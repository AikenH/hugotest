[{"content":"该文章会测试各种后续修改，包括基础字体，各种后续添加适配的shortcodes： 如 alert、视频、widget ，包括字体渲染，视频渲染，iframe渲染，以及相关的一些其他修改， 同时文章由于引入了大量的js，导致一些功能的渲染速度会下降，这也是我们需要测试的地方，包括找到加载的瓶颈；\nExtend ShortCodes encrypt 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\rhere is a long message.\nseems like we can only entrypt once in one markdown, if we encrypt multiplytimes, the function will make the password error.\nsidenote abc\nLorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. def Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.\nLorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.\nTimeline 2023-10-01 节日 国庆节 祖国生日快乐 2024-01-01 节日\u0026amp;计划 元旦节 上北京er Chat metisy\u0026nbsp;\u0026nbsp;\u0026nbsp;2024-11-25 19:31 这是左边的消息内容。 2024-11-25 19:32\u0026nbsp;\u0026nbsp;\u0026nbsp;aikenh 这是右边的消息内容，测试长长长长长长长长长长长长长长长长长长长长长长长长度。 quota-center 十里青山远，潮平路带沙\n数声啼鸟怨年华\n又是凄凉时候，在天涯\n白露收残月，清风散晓霞\n绿杨堤畔问荷花\n记得年时沽酒，那人家\nquota 十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\nsimple-notice 十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\nnotice 十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\ngithub widget Organic-Carbon-Estimating A program used in estimating organic carbon stocks in oceans. 计算指定海域的有机碳存量，包括颗粒有机碳与溶解有机碳，数据依赖于 NASA 中分辨率成像光谱仪 MODIS 遥感产品。 MATLAB align 文字居左\n文字居中\n文字居右\nVideo Function bilibili BV12NpBeYErP Markdown Function Expand Support pangujs 这是一段测试pangu之白的article，看看渲染出来的效果如何\nAlert Block 接下来测试各个关键词的渲染效果并进行调整， 首先就是 Note\nNote\rtest note block\u0026rsquo;s style.\n其次是：important\nImportant\r重要内容\n接着是：tip\nTip\r这是一些提示内容\n再次是 warning\nWarning\r这是一些告警内容\n最后是caution\nCaution\r重要内容\n然后测试一个自己添加的\nSummary\r总结\nmermaid mermaid 的跟随主题切换更改渲染的方式一直不work，暂时使用black theme加渲染的方式做处理。\nflowchart LR G[工作强度] G --\u0026gt; A G --\u0026gt; C G --\u0026gt; E A[\u0026#34;主动\u0026#34;策略] --\u0026gt; B[卷，按照表现辞退， 工作时间长，薪资构成=基本工资+基金表现*贡献Rate] C[\u0026#34;被动\u0026#34;跟踪] --\u0026gt; D[WLB, 固定工资，晋升-\u0026gt;管理] E[\u0026#34;混合\u0026#34;] --\u0026gt; F[介于两者之间，薪资与公司表现挂钩] 下面给出一个官方的不同实例来看不同的模式下的不同渲染情况\nsequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! 最后再来一个常规的流程图，或者说是概率图\n--- title: Action Distrubution based on Feature --- flowchart LR A[DragonBeenAtkBySomeone] --\u0026gt; B1[Value 1] B1 -- 60% --\u0026gt; C[Atk Target is Dragon] B1 -- 40% --\u0026gt; D[Other Action] A --\u0026gt; B2[Value 0] --\u0026gt; E[All Action Possible] Default ShortCodes gist https://www.andbible.com/post/hugo-content-management-shortcodes/ youtube twitter Owl bet you\u0026#39;ll lose this staring contest 🦉 pic.twitter.com/eJh4f2zncC\n\u0026mdash; San Diego Zoo Wildlife Alliance (@sandiegozoo) October 26, 2021 ins View this post on Instagram FI ","permalink":"https://metisy.cool/posts/shotcode_test/","summary":"\u003cp\u003e该文章会测试各种后续修改，包括基础字体，各种后续添加适配的shortcodes： 如 alert、视频、widget ，包括字体渲染，视频渲染，iframe渲染，以及相关的一些其他修改，\n同时文章由于引入了大量的js，导致一些功能的渲染速度会下降，这也是我们需要测试的地方，包括找到加载的瓶颈；\u003c/p\u003e\n\u003ch2 id=\"extend-shortcodes\"\u003eExtend ShortCodes\u003c/h2\u003e\n\u003ch3 id=\"encrypt\"\u003eencrypt\u003c/h3\u003e\n\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"password\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003cp\u003ehere is a long message.\u003c/p\u003e\n\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n\r\n\u003cscript\u003e\r\n    \r\n\r\n\r\nfunction sanitizeContent(content) {\r\n    \r\n    return content.replace(/[\\x00-\\x1F\\x7F]/g, '').trim(); \r\n}\r\n\r\nfunction encryptContent(password, content) {\r\n    const key = CryptoJS.MD5(password).toString();\r\n    const iv = key.substring(16); \r\n    const paddedContent = padContent(content);\r\n    const encrypted = CryptoJS.AES.encrypt(paddedContent, CryptoJS.enc.Utf8.parse(key), {\r\n        iv: CryptoJS.enc.Utf8.parse(iv),\r\n        mode: CryptoJS.mode.CBC,\r\n        padding: CryptoJS.pad.Pkcs7\r\n    });\r\n    return CryptoJS.enc.Base64.stringify(encrypted.ciphertext);\r\n}\r\n\r\nfunction padContent(content) {\r\n    const blockSize = 32; \r\n    const padlen = blockSize - (content.length % blockSize);\r\n    \r\n    \r\n    return content;\r\n}\r\n\r\nfunction processEncryptedBlocks() {\r\n    const blocks = document.querySelectorAll('.hugo-encryptor-cipher-text');\r\n    blocks.forEach(block =\u003e {\r\n        const password = block.getAttribute('data-password');\r\n        const content = block.innerHTML.trim(); \r\n        const sanitizedContent = sanitizeContent(content); \r\n        const encryptedContent = encryptContent(password, sanitizedContent);\r\n        block.innerHTML = encryptedContent;\r\n        block.removeAttribute('data-password');\r\n    });\r\n\r\n    \r\n    const script = document.createElement('script');\r\n    script.src = '/js/decrypt.js';\r\n    document.body.appendChild(script);\r\n}\r\n\r\n\r\ndocument.addEventListener('DOMContentLoaded', processEncryptedBlocks);\r\n\u003c/script\u003e\n\u003cp\u003eseems like we can only entrypt once in one markdown, if we encrypt multiplytimes, the function will make the password error.\u003c/p\u003e","title":"ShortCode Function Test"},{"content":"\rSummary\r如果页面的功能较为复杂，且涉及到了从服务端获取数据等操作，如果简单的使用同步编程，等待一个个任务按顺序执行，由于网络或者某些时间复杂度较高的操作，导致网页加载时间过长，或者使用逻辑不合理（加载某些资源的同时无法进行浏览等），因此异步编程的特性在 web 端是十分重要的。\n通过异步编程使一个长时间运行的任务运行的同时能够对网页做出其他的操作和对其他事件做出相应，而不需等待该任务完成，以下的这些功能就是最常见需要异步完成的；\nfetch 发起 http 请求 getUserMedia() 获取用户的摄像头和麦克风 showOpenFilePicker() 请求用户选择文件以供访问。 基于事件处理程序实现异步 事件处理的逻辑实际上也是一种接近异步编程的方式，对应的函数不是即时执行，而是等事件被触发后在进行调用。一些早期的异步 API 就是这样使用事件的。\n一些早期的异步 API 就是这样来使用事件，例如 XMLHttpRequest 可以使用 JS 向远程服务器发起 HTTP 请求，这类网络请求操作都会比较耗时，因此通常会使用异步，以下面的例子进行后续说明；\n1 2 3 4 5 6 7 8 9 10 11 12 const log = document.querySelector(\u0026#34;.event-log\u0026#34;); document.querySelector(\u0026#34;#xhr\u0026#34;).addEventListener）(\u0026#34;click\u0026#34;, () =\u0026gt; { log.textContent = \u0026#34;\u0026#34;; const xhr = new XMLHttpRequest(); xhr.addEvenetLister(\u0026#34;loadend\u0026#34;, () =\u0026gt; { log.textContent = `${log.textContent} 完成, 状态码: ${xhr.status}`; }); xhr.open(\u0026#34;GET\u0026#34;, \u0026#34;https://URL/dir/file.json\u0026#34;); xhr.send(): log.textContent = `${log.textContent} 请求已发起\\n`; }); xhr 按钮点击后，声明一个 XMLHttpRequest 对象，并监听其 loadend 事件，然后发送请求，并将字符串修改为请求已发起，该字符串会在触发了 loadend 加载完了请求事件后改为，已完成。\n事件处理程序本身是一种特殊类型的回调函数（函数作为参数传递到另一个函数），多层回调函数的嵌套会导致代码难以理解和 debug，因此后面大多数 API 不在使用回调函数去处理异步的情况。\nPromise 现代 JS 异步编程的基础 Promise 是现代 JavaScript 中异步编程的基础。它是一个由异步函数返回的对象，可以指示操作当前所处的状态。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象提供了方法来处理操作最终的成功或失败。\n一个基于 Promise 的 API，异步函数会启动操作并直接返回一个 Promise 对象，可以将后续的处理函数附加到该对象上，当操作完成时（成功、失败），执行对应的处理函数。\n以 fetch() 为例 1 2 3 4 5 6 7 8 9 10 const fetchPromise = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); console.log(fetchPromise); fetchPromise.then((response) =\u0026gt; { console.log(`已受到响应 ${response.status}`); }); console.log(\u0026#34;已发送请求...\u0026#34;); 1 Promise { \u0026lt;state\u0026gt;: \u0026#34;pending\u0026#34;} 调用 fetch() 将返回的 promise 存储到 fetchPromise 变量 Promise 的变量输出结果如下 将处理函数传递给 promise 变量的 then 函数，当 fetch 操作成功的时候，promise 就会调用对应的处理函数。 整体的处理逻辑还是比较清晰的，关键是使用 promise 变量的 then 函数去处理 fetch 的各种不同结果。\n链式使用 Promise 在前面通过 fetch 获取 response 对象的时候，我们需要使用对应的 json() 方法将其转换为 js 专属的对象，这里的 json 实际上也是一个异步方法，由此我们可以链式的实现异步如下：\n1 2 3 4 5 6 7 8 9 10 const fetchPromise = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); fetchPromisze.then((response) =\u0026gt; { const jsonPromise = response.json(); jsonPromise.then((json) =\u0026gt; { console.log(json[0].name); }); }); 这种情况在多层嵌套的时候也会堆叠得很难理解，但是相比于回调函数，每一级的回调都会有个 promise 的即时返回值来指示对应异步函数中的完成状态。\n由于 promise 是一个即时返回值，因此上述的代码可以简写为：\n1 2 3 4 5 fetchPromise .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; { console.log(data[0].name); }); 不必在第一个 then 中调用下一个 then，可以直接返回对应的 promise 对象，对对应的 promise 对象调用处理即可，这样可以避免多级缩进叠加；\n处理异常返回值 对 promise 中的状态值进行检查，如果状态码不是 ok 就需要对应的抛出错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const fetchPromise = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); fetchPromise .then((response) =\u0026gt; { if(!response.ok){ throw new Error(`HTTP 请求错误 ${response.status}`); } }) .then((json) =\u0026gt; { console.log(json[0].name); }); 此外由于这种异步的函数返回机制，如果要按照上面的方式逐个进行错误处理非常的困难，需要在每个嵌套层中进行处理，为了避免这种麻烦，Promise 对象提供了一个 catch() 方法（类似 then），当调用成功时触发的是 then 而调用失败了就会调用 catch 中定义的处理函数。\n将 catch 添加到 Promise 的末尾，他可以在任何异步函数失败的时候调用，下面是一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const fetchPromise = fetch( \u0026#34;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); fetchPromise .then((response) =\u0026gt; { if (!response.ok) { throw new Error(`HTTP 请求错误：${response.status}`); } return response.json(); }) .then((json) =\u0026gt; { console.log(json[0].name); }) .catch((error) =\u0026gt; { console.error(`无法获取产品列表：${error}`); }); Promise 的状态值 需要注意 promise 对应的成功和失败的含义随着 API 的不同而不同，例如 fetch 认为服务器返回一个错误如（404 not found）时请求成功，但如果网络错误阻止请求被发送，则认为请求失败。\nStatus Desc Pending 待定 还在请求中，尚未有确定的结果，也是初始状态 fulfilled 已兑现 操作成功的标准返回，后续进入调用 then 的逻辑 rejected 已拒绝 操作失败的标准返回，后续进入调用 catch 的逻辑 有时用**已敲定(settled)来同时表示已兑现和已拒绝；如果一个 Promise 已敲定，或者他被\u0026quot;锁定\u0026quot;以跟踪另一个 Promise 的状态，那么就是已解决(resolved)**的。\n组式使用 Promise (合并使用) 当操作由多个异步函数组成，如果需要串行完成那就需要 promise 链，如果需要组合使用多个 promise，相互之间不依赖但是需要所有 promise 都实现的情况，可以考虑合并多个异步函数的使用。\n使用 Promise.all() 接受一个 Promise 数组，并返回一个单一的 Promise，使用该操作通过合并来简化对一批 promise 的处理，由 promise.all() 返回的 promise 有以下的特性：\n什么时候调用 then？当数组中所有 promise 都兑现时; 传入 then 的形式式什么？提供一个包含所有响应的数组，顺序与传入 all 的顺序一致; 什么时候拒绝/调用catch？任何一个promise 没有兑现的时候，调用 catch，并提供被拒绝的 promise 抛出的错误; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const fetchPromise1 = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); const fetchPromise2 = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found\u0026#34;, ); const fetchPromise3 = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json\u0026#34;, ); //const fetchPromise3 = fetch( // \u0026#34;bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json\u0026#34;, //); Promise.all([fetchPromise1, fetchPromise2, fetchPromise3]) .then((responses) =\u0026gt; { for (const response of responses) { console.log(`${response.url}：${response.status}`); } }) .catch((error) =\u0026gt; { console.error(`获取失败：${error}`); }); 选择使用 Promise (任一) 如果需要一组Promise 中某一个实现即可，这种时候可以使用 promise.any(), 任意一个被兑现时便兑现，仅当所有 Promise 被拒绝的时候才拒绝。\nasync 和 await 在函数的开头添加 async 关键词可以使得一个函数成为一个异步函数：\n1 2 3 async function myFunction(){ ... } await 关键词则使得我们不再并行执行异步函数，而是在原地等待该异步函数执行完成，也就是讲异步函数当成同步函数来使用，直到其 Promise 相应彻底完成，如下可以将 fetch 改写成同步函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 async function fetchProducts() { try { // 在这一行之后，我们的函数将等待 `fetch()` 调用完成 // 调用 `fetch()` 将返回一个“响应”或抛出一个错误 const response = await fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); if (!response.ok) { throw new Error(`HTTP 请求错误：${response.status}`); } // 在这一行之后，我们的函数将等待 `response.json()` 的调用完成 // `response.json()` 调用将返回 JSON 对象或抛出一个错误 const json = await response.json(); console.log(json[0].name); } catch (error) { console.error(`无法获取产品列表：${error}`); } } fetchProducts(); 这个 fetchProducts() 还是一个异步函数，因此不能按照以下的方法调用：\n1 2 const promise = fetchProducts(); console.log(promise[0].name); // “promise”是一个 Promise 对象，因此这句代码无法正常工作 相反的，需要按照 promise 的方式去调用：\n1 2 const promise = fetchProducts(); promise.then((data) =\u0026gt; console.log(data[0].name)); 同样地，请注意你只能在 async 函数中使用 await，除非你的代码是 JavaScript 模块 。这意味着你不能在普通脚本中这样做：\n你可能会在需要使用 Promise 链地方使用 async 函数，这也使得 Promise 的工作更加直观。\n请记住，就像一个 Promise 链一样，await 强制异步操作以串联的方式完成。如果下一个操作的结果取决于上一个操作的结果，这是必要的，但如果不是这样，像 Promise.all() 这样的操作会有更好的性能。\nPromise 实战 前面讨论如何使用返回 promise 的 APIs，这一节研究如何实现返回 Promise 的 Apis，这与基于使用 promise 的 APIs 相比，是一个不太常见的任务。参考文献 mdn如何实现基于promise的api | 菜鸟教程JavaScript Promise | 廖雪峰JavaScript 以一个普通的回调转换为 Promise 的例子来说明：\n1 2 3 4 5 6 7 8 9 10 const output = document.querySelector(\u0026#34;#output\u0026#34;); const button = document.querySelector(\u0026#34;#set-alarm\u0026#34;); function setAlarm() { window.setTimeout(() =\u0026gt; { output.textContent = \u0026#34;Wake up!\u0026#34;; }, 1000); } button.addEventListener(\u0026#34;click\u0026#34;, setAlarm); 利用 Promise 来构造后会变成如下的实现：\n1 2 3 4 5 6 7 8 9 10 function alarm(person, delay) { return new Promise((resolve, reject) =\u0026gt; { if (delay \u0026lt; 0) { throw new Error(\u0026#34;Alarm delay must not be negative\u0026#34;); } window.setTimeout(() =\u0026gt; { resolve(`Wake up, ${person}!`); }, delay); }); } 该函数会创建并返回一个新的 Promise，其中需要说明的是，Promise 本身需要两个参数 resolve 和 reject，当执行成功了就会调用 resolve（类似 return），如果失败了，就会自动调用 reject，（throw error 的部分），两者都可以讲任何类型的单个参数传递，具体而言参考后续调用如下：\n1 2 3 4 5 button.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { alarm(name.value, delay.value) .then((message) =\u0026gt; (output.textContent = message)) .catch((error) =\u0026gt; (output.textContent = `Couldn\u0026#39;t set alarm: ${error}`)); }); 可以讲一个函数变成具备原生异步功能的 Promise？由此我们就可以对其使用 await 或者 async 来灵活的决定该 Function 要同步或者异步执行。\nWorkers 页面线程简介 Summary\rWorker 使页面能在单独执行的线程中运行一些任务，避免因为一个长期运行的同步任务使整个任务完全没有响应。\n一些多线程的 Principle，避免同时访问相同的变量带来的意外等：\n主代码和你的 worker 代码永远不能直接访问彼此的变量 Workers 和主代码运行在完全分离的环境中，只有通过相互发送消息来进行交互 这意味着 workers 不能访问 DOM（窗口、文档、页面元素等等） 有三种不同类型的 workers，不过该章节只会介绍第一个，其他两个简要的讨论。\ndedicated workers shared workers service workers 以页面中的质数生成器为例，如果作为同步任务执行，在计算过程中整个页面将会卡住，按照以下的方式来讲计算交付于另一个 worker。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 在 \u0026#34;generate.js\u0026#34; 中创建一个新的 worker const worker = new Worker(\u0026#34;./generate.js\u0026#34;); // 当用户点击 \u0026#34;Generate primes\u0026#34; 时，给 worker 发送一条消息。 // 消息中的 command 属性是 \u0026#34;generate\u0026#34;, 还包含另外一个属性 \u0026#34;quota\u0026#34;，即要生成的质数。 document.querySelector(\u0026#34;#generate\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { const quota = document.querySelector(\u0026#34;#quota\u0026#34;).value; worker.postMessage({ command: \u0026#34;generate\u0026#34;, quota: quota, }); }); // 当 worker 给主线程回发一条消息时，为用户更新 output 框，包含生成的质数（从 message 中获取）。 worker.addEventListener(\u0026#34;message\u0026#34;, (message) =\u0026gt; { document.querySelector(\u0026#34;#output\u0026#34;).textContent = `Finished generating ${message.data} primes!`; }); document.querySelector(\u0026#34;#reload\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { document.querySelector(\u0026#34;#user-input\u0026#34;).value = \u0026#39;Try typing in here immediately after pressing \u0026#34;Generate primes\u0026#34;\u0026#39;; document.location.reload(); }); 通过 worker.postMessage 来和对应的线程传递信息，在对应的 worker 中，可以按照以下的方式来接受和传递信息；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 监听主线程中的消息。 // 如果消息中的 command 是 \u0026#34;generate\u0026#34;，则调用 `generatePrimse()` addEventListener(\u0026#34;message\u0026#34;, (message) =\u0026gt; { if (message.data.command === \u0026#34;generate\u0026#34;) { generatePrimes(message.data.quota); } }); // 生成质数 (非常低效) function generatePrimes(quota) { function isPrime(n) { for (let c = 2; c \u0026lt;= Math.sqrt(n); ++c) { if (n % c === 0) { return false; } } return true; } const primes = []; const maximum = 1000000; while (primes.length \u0026lt; quota) { const candidate = Math.floor(Math.random() * (maximum + 1)); if (isPrime(candidate)) { primes.push(candidate); } } // 完成后给主线程发送一条包含我们生成的质数数量的消息消息。 postMessage(primes.length); } worker 要做的第一件事情就是开始监听来自主脚本的消息。这通过使用 addEventListener() 实现，它在 worker 中是一个全局函数。在 message 事件处理器内部，事件的 data 属性包含一个来自主脚本的参数的副本。\nNote\r**备注：**要运行此站点，你必须运行一个本地 web 服务器，因为 file:// URLs 不允许加载 workers。参考我们的设置一个本地测试服务器 的指导。完成后，你应该可以点击 \u0026ldquo;Generate primes\u0026rdquo; 并且使你的主页面保持响应。 如果你在创建和运行这个样例的过程中有疑问，你可以在 https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/finished 查看完成后的版本，并且在 https://mdn.github.io/learning-area/javascript/asynchronous/workers/finished 进行在线尝试。\n我们刚刚创建的 worker 被称为 dedicated worker。这意味着它由一个脚本实例使用。\n不过，还有其他类型的 worker：\nSharedWorker 可以由运行在不同窗口中的多个不同脚本共享。 Service worker 的行为就像代理服务器，缓存资源以便于 web 应用程序可以在用户离线时工作。他们是渐进式 Web 应用 的关键组件。 ","permalink":"https://metisy.cool/posts/learnweb21-js06-%E5%BC%82%E6%AD%A5js/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e如果页面的功能较为复杂，且涉及到了从服务端获取数据等操作，如果简单的使用同步编程，等待一个个任务按顺序执行，由于网络或者某些时间复杂度较高的操作，导致网页加载时间过长，或者使用逻辑不合理（加载某些资源的同时无法进行浏览等），因此异步编程的特性在 web 端是十分重要的。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e通过\u003cstrong\u003e异步编程\u003c/strong\u003e使一个长时间运行的任务运行的同时能够对网页做出其他的操作和对其他事件做出相应，而不需等待该任务完成，以下的这些功能就是最常见需要异步完成的；\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efetch\u003c/code\u003e 发起 http 请求\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egetUserMedia()\u003c/code\u003e 获取用户的摄像头和麦克风\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eshowOpenFilePicker()\u003c/code\u003e 请求用户选择文件以供访问。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"基于事件处理程序实现异步\"\u003e基于事件处理程序实现异步\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e事件处理的逻辑实际上也是一种接近异步编程的方式，对应的函数不是即时执行，而是等事件被触发后在进行调用。一些早期的异步 API 就是这样使用事件的。\u003c/p\u003e","title":"LearnWeb21-JS06-异步JS"},{"content":"\rSummary\r本文主要介绍笔者的家庭服务器设计方案 V1。该方案中中涵盖影视、图像、图书\u0026amp;文献、博客、智能家居管理、密码管理服务，以及公网上内容分发的初步设计和选择的考量。\n整体架构 整个服务中心在设计的时候主要考虑以下的几个方面：\n💻操作设备\u0026amp;系统(OS)和内容存储方案：如何经济实惠的选择合适的设备和系统 🌦️服务需求：需要搭建哪些服务，应该选择哪个服务进行自托管 🌍部署方案：如何保证在局域网+公网都能顺利且安全的访问 📱访问策略：各个平台上的访问方式的选择 此外，并非所有服务都需要在公网上进行部署，这里的部分服务可以仅用于局域网，由于仅开放了 Nginx 端口，因此从公网中访问不到未分发的内容，因此，部分存储与敏感信息相关的服务可以仅保留在局域网中进行访问。\nNote\r在这种情况下如果希望能够使用一致的域名访问方式，是否可以考虑使用 Nginx 鉴权限制访问 ip 为内网 ip，其他公网访问直接丢弃？\n初版家庭服务中心的架构图如下，(这里并非列出所有的服务组件)，该架构图中所有的应用都是为了方便日常生活中的各项活动，下面会对架构图自底向上的做一些简单的说明。\n设备和存储选择 存储和设备的选择主要来自以下的两个需求，首先是能够用作机顶盒，其次是尽量能省则省，综合考虑上述的两个需求，树莓派+网络云盘的策略有如下的几个优势，也是选择它的原因：\n设备和存储价格相对便宜，长时间在线电费消耗也几乎可以忽略不计 体积较小，作为机顶盒放置的方式较为简单 云盘的转存和资源收集的速度快，且可结合小雅和 Alist 进行网盘的集成，以及线上资源的整合。 劣势就在于非本地存储和对网络的要求相对较高一些，且在系统上需要折腾的时间会比成熟的 NAS 厂家的开箱即用要折腾一些，最后就是一些对性能要求较高的服务树莓派可能无法承担这个职责，因此这里使用自己的个人电脑用来部署一些对性能要求较高的服务。\n服务部署策略 docker 在服务部署的优势有：独立互不影响的环境和一键部署方便性，因此我们使用 docker 进行几乎所有的服务的部署，并使用 portainer 对其进行管理。\n图书\u0026amp;漫画：使用 Kavita+Calibre（进行资源的转换和元信息的不全）+ （Zlibray\u0026amp;漫自由）获取资源。 照片：使用 Immich 满足整个家庭备份手机照片并进行统一管理的需求，可完全代替 icloud 且只需要本地磁盘。 影视：使用 Alist 整合自己的网盘 + 线上的 xiaoya 的 alist 资源 + emby 做一个影视墙（可选）+ Kodi 进行电视端的播放（KORE，kodi 手机端的官方遥控器） 智能家居：使用 HomeAssistant 管理各种不同品牌的智能家居设备 服务分发和服务访问 这里使用 Nginx+腾讯云进行服务的分发，并通过 DDNSgo 动态更新域名解析的 IPV6 地址，之后就可以通过域名对相应服务进行访问。\n可用 Caddy 这个现在的后期之秀来代替 Nginx，Nginx 也可以安装对应的可视化设置界面。\n上述提到的是基于 ipv6 部署到公网后的分发情况，如果没有或者不想部署公网的话就使用如 Zerotier 和 Tailscale 的内网穿透服务来实现虚拟内网 ip+端口去访问服务。\n在各个终端上的服务访问可以通过浏览器的保存为应用/固定到桌面，以及各自对应的官方 APP 为主要的访问手段。\n后续计划 Note\r这里记录后续希望进行补充的服务和设计，最终希望能够作为一个比较全面且完整的方案，覆盖到生活的方方面面，为自己和朋友的生活提供便利。\n设计 StableDiffusionWEBui 的鉴权页面，方便部署到公网上使用，方便作图需求 现已涵盖视频图片和图书等服务，后续考虑是否有必要针对音乐添加相关页面 (eval) 菜谱管理中心，收藏各个不同的平台的菜谱 (eval) RSS Center 可能需要 RSS-HUB 创建自己关心的所有 RSS 源，然后通过 (eval) 使用 Ghost 尝试更新自己的 Blog (eval) 更新 Homepage 更新 CodeServer，是否要在网页上部署Vscode FI","permalink":"https://metisy.cool/posts/%E5%AE%B6%E5%BA%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B4%E4%BD%93%E6%96%B9%E6%A1%88/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e本文主要介绍笔者的家庭服务器设计方案 V1。该方案中中涵盖影视、图像、图书\u0026amp;文献、博客、智能家居管理、密码管理服务，以及公网上内容分发的初步设计和选择的考量。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"整体架构\"\u003e整体架构\u003c/h2\u003e\n\u003cp\u003e整个服务中心在设计的时候主要考虑以下的几个方面：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e💻操作设备\u0026amp;系统(OS)和内容存储方案：如何\u003cstrong\u003e经济实惠\u003c/strong\u003e的选择合适的设备和系统\u003c/li\u003e\n\u003cli\u003e🌦️服务需求：需要搭建\u003cstrong\u003e哪些服务\u003c/strong\u003e，应该选择\u003cstrong\u003e哪个服务\u003c/strong\u003e进行自托管\u003c/li\u003e\n\u003cli\u003e🌍部署方案：如何保证在局域网+\u003cstrong\u003e公网\u003c/strong\u003e都能顺利且\u003cstrong\u003e安全的访问\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e📱访问策略：各个平台上的访问方式的选择\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e此外，并非所有服务都需要在公网上进行部署，这里的部分服务可以仅用于局域网，由于仅开放了 Nginx 端口，因此从公网中访问不到未分发的内容，因此，部分存储与敏感信息相关的服务可以仅保留在局域网中进行访问。\u003c/p\u003e\n\r\n\r\n\r\n  \r\n  \r\n\r\n\u003cblockquote class=\"alert-blockquote alert-note\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eNote\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e在这种情况下如果希望能够使用一致的域名访问方式，是否可以考虑使用 Nginx 鉴权限制访问 ip 为内网 ip，其他公网访问直接丢弃？\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e初版家庭服务中心的架构图如下，(这里并非列出所有的服务组件)，该架构图中所有的应用都是为了方便日常生活中的各项活动，下面会对架构图自底向上的做一些简单的说明。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231209082421.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231209082421.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231209082421.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"家庭服务器整体方案"},{"content":" 该章节主要包括 Promot 生成和部分工作流的分析，旨在了解如何写出更好的关键词，如何生成更好的图片，当我们不知道怎么描述的时候也可以将该工作交给 ChatGPT，让其为我们攥写一般基础的提示词\nPrompt 编写范式 参考资料：【Stable Diffusion】Prompt 通常编写可以遵照以下的类别进行组织，主要有 \u0026lt;质量控制\u0026gt; + \u0026lt;前置\u0026gt; + \u0026lt;主体\u0026gt; + \u0026lt;场景词\u0026gt; 几类，其中分别包括以下的几类词：\n质量控制：画质、镜头效果、光照效果 前置词：画风、艺术家、风格 主体：人物\u0026amp;对象、姿势、服装、道具 场景：环境、背景、细节 Additional Network：载入额外模型 分割符号： 各个关键词之间用 , 分割，且对应的权重从前到后依次递减，因此在编写关键词的时候也要注意先后顺序。\n权重加权符号：各种括号代表各种不同的加权系数，这里建议用 (prompt: weight) 统一来编写提示词的权重规则，整体可读性会更好。\n这里的 weight 指的是权重变成原本的 weight 倍，就可以调整加强或减弱。\n各个括号的默认系数如下: () -\u0026gt; 1.1 ; {} -\u0026gt; 1.05 ; [] -\u0026gt; 0.952 可以通过(())进行叠加即 1.1*1.1\n额外模型调取：编写格式为 \u0026lt;lora:loramodelname:multiplier\u0026gt;，即载入 loramodelname 模型，权重为 multiplier，该权重不建议过大。\n关键词的切换： 语法如下 [key1:key2:step]，通过该语法可以实现在进行到不同步骤的时候使用不同的关键词进行渲染，其中 :key2 可以忽略，忽略后即可理解为 [\u0026quot;\u0026quot;:key1:step]，有一下的一些规则：\nStep 在大于 1 时表示具体的步骤，小于 1 时表示迭代步数的百分比 如果想要在某步之后忽略 key1，与上面忽略 key2 正好相反，可以写成 [key1::step] [key1|key2] 则表示两个关键词交替选择渲染 反向提示词：反向提示词就是让 AI 避免生成什么样的图片，使用得当可以帮助我们更好的生成想要的图片，后面再关键词的地方会介绍一些常见的反向关键词，例如低画质相关和一些容易变形身体部位的描述等\n这里介绍一个 easynegative 的 embedding 模型，其是通过大量的不好的图片训练出来的模型，通过在反向关键词部分调用 easynegative 调用该模型即可过滤。\n具体的使用方式如下：\n首先去 C 站下载模型， EasyNegative - EasyNegative | Stable Diffusion Textual Inversion | Civitai ; 然后将其放入 stable-diffuison-webui 资料夹下的 embeddings 文件夹；重启之后在负向关键词中填入 EasyNegative 即可生效（也可从额外网络中选择 Textual inversion/tembeding，然后将该模型填入 Negative 中）\n但是单独使用的话，效果可能还是没有那么好，所以最好还是结合着一些特定的负向关键词一起使用。\nKeyword 关键词 该部分主要来自参考资料，原文推荐 阅读，如果觉得有用，请给原文点赞。\n通过在文章前面添加画质关键词能提升生成图片的质感，质量，描述简单通用而有效\nprompt Desc HDR, UHD, 8 k 这样的质量词可以带来巨大的差异提升照片的质量 Best quality 最佳质量 masterpiece 杰作 Highly detailed 细节添加 Studio lighting 演播室灯光 ultra-fine painting 精细绘图 sharp focus 清晰聚焦 physically-based rendering 基于物理渲染 extreme detail description 详细刻画 Professional 改善图片的对比细节 Vivid Colors 色彩鲜艳 Bokeh 模糊背景，突出主题 (EOS R8, 50mm, F1.2, 8K, RAW photo:1.2) 相机设置 High resolution scan 年代感 Sketch 素描 Painting 绘画 还有一些诸如：depth of field 景深、wide angle 广角之类术语，也能帮助我们生成更好的或者更符合预期的图片。\n可以通过添加艺术家关键词来使得生成图片具备特定风格，常用于固定的风格模仿。\nprompt Artist 肖像画（Portraits） Derek Gores, Miles Aldridge, Jean Baptiste-Carpeaux, Anne-Louis Girodet 风景画（Landscape） Alejandro Bursido, Jacques-Laurent Agasse, Andreas Achenbach, Cuno Amiet 恐怖画（Horror） H.R.Giger, Tim Burton, Andy Fairhurst, Zdzislaw Beksinski 动漫画（Anime） Makoto Shinkai, Katsuhiro Otomo, Masashi Kishimoto, Kentaro Miura 科幻画（Sci-fi） Chesley Bonestell, Karel Thole, Jim Burns, Enki Bilal 摄影（Photography） Ansel Adams, Ray Earnes, Peter Kemp, Ruth Bernhard 概念艺术家（视频游戏）Concept artists video game Emerson Tung, Shaddy Safadi, Kentaro Miura 常用的反向 Prompt 常有如下的这些，实际上可以根据生成的情况放上去，或者根据需要的图片直接一股脑的放上去即可，希望 AI 画好一个元素，可以通过正 tag 结合反向的约束来实现。\nnegative prompt Desc mutated hands and fingers 变异的手和手指 deformed 变形的 bad anatomy 解剖不良 disfigured 毁容 poorly drawn face 脸画的不好 mutated 变异的 extra limb 多余的肢体 ugly 丑陋 poorly drawn hands 手画的不好 missing limb 缺少肢体 floating limb 漂浮的四肢 disconnected limbs 肢体不连贯 malformed hands 畸形的手 out of focus 脱离焦点 long neck 长脖子 long body 长身体 Sample一些简单成品 \u003c!DOCTYPE html\u003e\rexam 1\r参考资料 Stable Diffusion prompt: a definitive guide - Stable Diffusion Art (stable-diffusion-art.com) 繪圖AI - Stable Diffusion 相關教學與參考資源 202303 update - yoyojojo的創作 - 巴哈姆特 (gamer.com.tw) 魔咒百科词典 (aitag.top) AI繪圖魔導書 - Google 表格 https://majinai.art/zh-tw/index.php ","permalink":"https://metisy.cool/posts/stablediffusionprompt/","summary":"\u003cblockquote\u003e\n\u003cp\u003e该章节主要包括 Promot 生成和部分工作流的分析，旨在了解如何写出更好的关键词，如何生成更好的图片，当我们不知道怎么描述的时候也可以将该工作交给 ChatGPT，让其为我们攥写一般基础的提示词\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"prompt-编写范式\"\u003ePrompt 编写范式\u003c/h2\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://zhuanlan.zhihu.com/p/619247417?utm_id=0\" target=\"_blank\" rel=\"noopener\"\u003e【Stable Diffusion】Prompt\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e通常编写可以遵照以下的类别进行组织，主要有 \u003ccode\u003e\u0026lt;质量控制\u0026gt; + \u0026lt;前置\u0026gt; + \u0026lt;主体\u0026gt; + \u0026lt;场景词\u0026gt;\u003c/code\u003e 几类，其中分别包括以下的几类词：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e质量控制\u003c/strong\u003e：画质、镜头效果、光照效果\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e前置词\u003c/strong\u003e：画风、艺术家、风格\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e主体\u003c/strong\u003e：人物\u0026amp;对象、姿势、服装、道具\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e场景\u003c/strong\u003e：环境、背景、细节\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAdditional Network\u003c/strong\u003e：载入额外模型\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e分割符号：\u003c/strong\u003e 各个关键词之间用 \u003ccode\u003e,\u003c/code\u003e 分割，且对应的权重从前到后依次递减，因此在编写关键词的时候也要注意先后顺序。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e权重加权符号\u003c/strong\u003e：各种括号代表各种不同的加权系数，这里建议用 \u003ccode\u003e(prompt: weight)\u003c/code\u003e 统一来编写提示词的权重规则，整体可读性会更好。\u003c/p\u003e\n\u003cp\u003e这里的 weight 指的是权重变成原本的 weight 倍，就可以调整加强或减弱。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e各个括号的默认系数如下: () -\u0026gt; 1.1 ; {} -\u0026gt; 1.05 ; \u003ccode\u003e[]\u003c/code\u003e -\u0026gt; 0.952\n可以通过(())进行叠加即 1.1*1.1\u003c/p\u003e\n\u003c/blockquote\u003e","title":"AIGC04 Stable Diffusion Write Prompt Better"},{"content":"@AikenHong 2021\nCode of must of those methods We will analysis those tricks on LT situation, and Analysis why it works. 在进行LT矫正的任务中，有几种常见的trick在各种模型中被使用，我们会对这几种不同的trick进行介绍和分析。\n其实在数据量少这一方面LT和Few-Shot是有一定的OverLap的,可以参考以下那边的思路perhaps\nIntroduction 通常情况下这种严重的类别不平衡问题会使得模型严重过拟合于头部，而在尾部欠拟合\n首先介绍 bag of tricks 这篇论文中总结了一些常用的Trick，并组合出了最佳的一套trick\n经过该文实验总结，Trick组合应该是[1]`：\n在前几个epoch应用input mixup数据增强，然后后面fine-tuning; (基于CAM的)重采样来重新训练分类器; 实际上就是MixUp + Two-Stage的策略，后续对Mix-up这个策略带来的作用要进行补充了解一下\nRebalance 对于ReBalance的方法，实际上就是从 data和 update两个角度来缓解Unbalance本身，通过从数据量上达到重新均衡，或者基于Loss使得bp过程中赋予Tail更高的权重来达到优化过程的平衡。\n前者称为rebalance，后者则为reweight.\nreweighting 这一部分在实际设计上的体现主要是通过对Loss的重新构造而成，通过对Loss的构造来实现区分的BP权重.\n代价敏感softmax交叉熵损失CS_CE: 在ce前乘最小训练图像数目与每个类别图像数目的比值，相当于更注重少类样本 $$ \\mathcal{L}{CS_CE}(\\mathbf{z}, c)=-\\frac{n{\\min }}{n_{c}} \\log \\left(\\frac{\\exp \\left(z_{c}\\right)}{\\sum_{i=1}^{C} \\exp \\left(z_{i}\\right)}\\right) $$\nFocal Loss：设置$\\alpha$ 和 $\\beta$来控制少数类和难分类别对损失的贡献： $$\\mathcal{L}{\\text {Focal }}(\\mathbf{z}, c)=-\\sum{i=1}^{C}\\left(1-p_{i}^{t}\\right)^{\\gamma} \\log \\left(p_{i}^{t}\\right)$$\n类别平衡损失：就是在基本的损失（CE，FOCAL）前加入一个衡量权重，其中$\\beta$是一个超参数，来衡量有效的信息 $$\\mathcal{L}{CB_Focal}(\\mathbf{z}, c)=-\\frac{1-\\beta}{1-\\beta^{n{c}}} \\sum_{i=1}^{C}\\left(1-p_{i}^{t}\\right)^{\\gamma} \\log \\left(p_{i}^{t}\\right)$$\nLogit Abjustment[3]: $$\\ell(y, f(x))=\\alpha_{y} \\cdot \\log \\left[1+\\sum_{y^{\\prime} \\neq y} e^{\\Delta_{y y^{\\prime}}} \\cdot e^{\\left(f_{y^{\\prime}}(x)-f_{y}(x)\\right)}\\right]$$\nrebalance 实际上就是对少类或者多类的数据重新做均衡，方法的本质差别一般都不是特别大\n随机过采样：随即重复少数类别的样本来使得样本均衡 随机降采样：随机删除多数类别的样本使得样本均衡 样本平衡采样：应该值得就是1-2 IB-Sampling 类别平均采样: 对类别进行统一采样，每个类别被采样的概率都一样(Q=0)，然后从每个类别中有放回的随机采样实例，从而构建平衡的数据集 $$p_j = \\frac{n_j^q}{\\sum_{i=1}^C n_i^q}$$ 平方根采样(Q=0.5) 逐步平衡采样：先对多个epoch进行实例平衡采样（上式q=1，也就是没有任何平衡操作的采样），然后再剩下的epoches中进行类别平衡采样。这种采样方式需要设置一个超参数来调整从哪一个epoch开始变换采样方式。也可以使用更软的阈值，即随着epoch的增加来逐渐调整实例平衡采样（IB）和类别平衡采样所占的比例，如下面公式所示。 $$ P_j^{PB} (t) = (1-\\frac{t}{T})P_j^{IB} + \\frac{t}{T}P_j^{CB} $$\ntwo-stage 在Unbalanced的Data上Pretrain一个特征提取器，然后再rebalance（IB，CB）的数据集上对Classifier进行重新训练（调整），（and | or）对齐，校准（disalign，causal）来提升LT的性能的方法\nmotivation 但是这些rebalance的方法通常会带来以下两个问题[2]：\nrebalance之后分类器会倾向于分类正确的尾部样本，导致对于头部有一定的bad influence（欠拟合），对尾部过拟合 rebalance方法会显著的促进分类器的学习，但是会损害深度特征的表示能力，如上图所示，分类器学到的分界面更好，但是特征的表示却更加的松散了 我认为rebalance的策略确实会使得Clf学的更好的分界面，减少偏向性，但是不至于在尾部过拟合，这一部分分析最重要的应该是rebalance对于特征空间的Bad Influence，这可能就是Two Stage的来源。\n于是作者为其设计了一些消融实验：CE指的是长尾，RW，RS指的是使用的rebalance的数据。\n可以发现在Backbone上使用Unbalance的数据而在Clf上使用Resampler的数据效果是最好的，这种two-stage的解耦两阶段的训练策略展现了一个有希望的结果。\n这种两阶段的方式，我认为在第二阶段的时候也要对特征进行微调来适应当前的分布，不过很多的方法都是直接只对分类器进行调整，我们可以对两种方式进行测试\n下图显示了fix-two-stage和baseline对比[5] 下图展示了理想的two-stage结果与显示方法之间的距离[5] cls-bound是再fix特征后，用完全均衡的数据集训练分类器得到的结果，由此带入第二张图的绿色的线，可以知道，现有长尾方法的性能瓶颈（未使用two-stage），仍然在特征空间中的有偏差的决策边界。 基于这些分析,我们认为，在得到一个强有力的特征表示后，我们可以将问题归化到分类器上，基于这点假设，我们可以结合我们的自监督模块来对该方法进行归化。\nBBN structure Share Weight of Backbone，Using diff dataset to get diff feature. Then we using $\\alpha$ to Combine the logits and calculate the loss.\n$$ z = \\alpha * W_c^T * f_c + (1-\\alpha) * W_\\gamma^T * f_\\gamma $$\n$$ L = \\alpha * l(softmax(z),y_c) + (1-\\alpha) *l(softmax(z),y_\\gamma) $$\n在上述的流程图中W代表的是两个不一样的数据优化器，基于这样的设置最终就能区分两部分的优化。\n但是这个方法为我们带来的最大的启发还是在于区分两阶段中学习的重点，backbone需要在一个unblance的条件下学习一个更为通用的表征，而Cls需要矫正偏差。不平衡的情况下可能能学到一个很好的通用表征，这一点就是我们使用自监督的一个重要原因。\nDecoupling ==Train BB and Fixed then Train CLF== 此外坐着发现全连接的weight和norm和对应类别的样本数正相关，所以在第二部最后将分类器改为归一化的分类器，文中的两种设计是：\n$\\overline{W_i}=\\frac{w_i}{\\lVert W_i \\rVert^T}$ $\\overline{W_i}=\\frac{w_i}{f_i}$ 其中2利用fixed第一步分类权重$w_i$,对每个类学习了一个加权参数$f_i$\nbetter-calibration 但是这种两阶段的方式也不是没有代价的，他会带来比较严重的校准错误(Calibration)，也就是我们预测的概率和实际的相似度之间的一致性。\n（BTW评估校准错误的指标 $ECE=\\sum_{b=1}^B\\frac{|S_b|}{N} |acc(S_b) - conf(S_b)|$，将数据分为b组，S_b是落入b区间的样本集合)\n本文主要测试了MixUP在两阶段训练中的作用，以及提出了：\n标签感知平滑损失，实际上就是cb_ce的半泛化形式： $$\\begin{gathered} l(\\boldsymbol{q}, \\boldsymbol{p})=-\\sum_{i=1}^{K} \\boldsymbol{q}{i} \\log \\boldsymbol{p}{i} \\ \\boldsymbol{q}{i}= \\begin{cases}1-\\epsilon{y}=1-f\\left(N_{y}\\right), \u0026amp; i=y \\ \\frac{\\epsilon_{y}}{K-1}=\\frac{f\\left(N_{y}\\right)}{K-1}, \u0026amp; \\text { Otherwise }\\end{cases} \\end{gathered}$$\n$\\epsilon_y$是y(gt)的一个小平滑因子,数目与类别的样本数有关，并提出了几种函数形式，来优化这个损失\nBN的移位学习，由于两阶段的数据集不一致，所以normalize的参数是需要学习变化的（均值和方差）\n具体的数学分析和推导，后续根据论文理解了再来补充\nDisAlign 基于上述对于方法的分析，该文章着重于对于分类器进行校准，具体的思路是基于利于平衡预测的类别分布来对分类器的输出进行匹配，矫正；简单的说利用类别先验和输入数据学习类别的决策边界。 具体由两部分构成(重构预测的概率输出，建立理想分布，使用KL散度计算损失)\n自适应配准函数 $$\\begin{gathered} s_{j}=\\alpha_{j} \\cdot z_{j}^{o}+\\beta_{j}, \\quad \\forall j \\in \\mathcal{C} \\ \\hat{z}{j}=\\sigma(\\mathbf{x}) \\cdot s{j}+(1-\\sigma(\\mathbf{x})) \\cdot z_{j}^{o} \\ =\\left(1+\\sigma(\\mathbf{x}) \\alpha_{j}\\right) \\cdot z_{j}^{o}+\\sigma(\\mathbf{x}) \\cdot \\beta_{j} \\ p_{m}(y=j \\mid \\mathbf{x})=\\frac{\\exp \\left(\\hat{z}{j}\\right)}{\\sum{k=1}^{C} \\exp \\left(\\hat{z}_{k}\\right)} \\end{gathered}$$\n广义重加权校准 理想的分布的计算方法如下，定义说的不是很好，最好还是参考一下代码 $$\\begin{gathered} p_{r}\\left(y=c \\mid \\mathbf{x}{i}\\right)=w{c} \\cdot \\delta_{c}\\left(y_{i}\\right), \\quad \\forall c \\in \\mathcal{C} \\ w_{c}=\\frac{\\left(1 / r_{c}\\right)^{\\rho}}{\\sum_{k=1}^{K}\\left(1 / r_{k}\\right)^{\\rho}}, \\quad \\forall c \\in \\mathcal{C} \\end{gathered}$$\n最终的损失计算方程如下： $$ \\begin{aligned} \\mathcal{L} \u0026amp;=\\mathbb{E}{\\mathcal{D}{t r}}\\left[\\mathcal{K} \\mathcal{L}\\left(p_{r}(y \\mid \\mathbf{x}) | p_{m}(y \\mid \\mathbf{x})\\right)\\right] \\ \u0026amp; \\approx-\\frac{1}{N} \\sum_{i=1}^{N}\\left[\\sum_{y \\in \\mathcal{C}} p_{r}\\left(y \\mid \\mathbf{x}{i}\\right) \\log \\left(p{m}\\left(y \\mid \\mathbf{x}_{i}\\right)\\right)\\right]+C \\end{aligned} $$\n==训练的具体策略== 1）在第一阶段，在不平衡数据集上使用实例平衡 ( instance-balanced ) 采样策略实现特征提取器和原始分类头的联合学习。此时由于不平衡的数据分布，学习到的原始分类头是严重有偏的。\n2）在第二阶段，我们在特征提取器参数固定不变的情况下关注分类头以调整决策边界，引入了自适应配准函数 ( adaptive calibration function ) 和广义重加权 ( generalized re-weight ) 策略来配准各类概率。\nCaucal Analysis 基于two-stage的这种现象，然后分析机器和人学习的区别，认为带来偏差的元凶在于Optim优化算法，为此，该文章构建因果图，从而去除在模型更新过程中由动量带来的偏差效应。\n\"keep good and remove bad momentum\"[7]\r$v_t = \\mu · v_{t-1} + g_t$, $\\theta = \\theta_{t-1} - lr · v_t$\n要调用这个方法的话，我们就需要\n将训练的CLF修改成Multi-Head并Normlize，参考Decouple. 训练过程中统计移动平局特征$\\overline{x}$，将其单位方向看成头部倾向. 测试的过程中修正logits即可 具体公式参考对应的解析和代码实现;\n和自监督结合的话，只需要在微调的阶段进行统计和修正即可，毕竟是一个一阶段的方式。\nContrastive 这一部分考虑一些和对比学习，或者说自监督学习耦合的方法来进行分析。\n为何将这两者放到同一个章节中？ 因为这两者企图从表征的层面，为LT任务，带来增益，得到一个可分的特征空间基于良好的特征表达，进而解耦的来训练一个更好的CLF。\n如果我们假设我们能得到一个高维线性可分的特征空间，对于长尾的样本带来的训练偏差（决策面偏差）是否可以通过对于特定类别的Margin-Like的Loss设置，达到一个类似Balance的效果，这一点上实际上可能和Align和校正的思想有点相似。但是我们是为了让分类器空间中的分界面在小样本的束缚下变得更加的合理。\n从分界面的角度看LT的情况：（上面是普通CE，下面是Contrastive Learning） 在数据量出现较大的差异的情况下，由于蓝色的数目更多更杂，所以实际上分界面可能会沿着蓝色数据的边界做切分（overfit），在这种Class-Level的过拟合下，就会导致对于少数类别的分类结果很差。\n而下方的对比学习就是一样的解决方案，他试图将同一类的数据聚拢在一起，将不同类的距离尽可能的拉远，这样会使得在空间中的决策面更加的鲁棒也已于区分，虽然可能会一定程度上减少蓝色的表现，但是红色的表现会因此大大的提升。\nhybird contrastive 该文章[9]的基本架构上实际上参考的就是BBN的epoch-params在two-stage中集成 supervised contrasive Loss，具体框架可以看下面这图： 他的设计思想很容易从这张图中领会，损失函数的表达显然如下\n$$ L_{hybird} = \\alpha · L_{SCL}(B_{SC}) + (1-\\alpha) · L_{ce}(B_{CE}) $$\n在这里要注意SC和自监督中使用的区别在于，自监督学习的过程中没有标签，所以只能将自己作为Positive，而在SC的时候，同类的样本之间应该都作为Positive $$ \\mathcal{L}{S C L}\\left(\\mathbf{z}{i}\\right)=\\frac{-1}{\\left|\\left{\\mathbf{z}{i}^{+}\\right}\\right|} \\sum{\\mathbf{z}{j} \\in\\left{\\mathbf{z}{i}^{+}\\right}} \\log \\frac{\\exp \\left(\\mathbf{z}{i} \\cdot \\mathbf{z}{j} / \\tau\\right)}{\\sum_{\\mathbf{z}{k}, k \\neq i} \\exp \\left(\\mathbf{z}{i} \\cdot \\mathbf{z}_{k} / \\tau\\right)} $$\n鉴于SC的计算复杂度要和整个Epoch的数据进行对比，需要大量的显存空间，在这方面作者将其改进为PSC，其实也就是将每个class计算一个prototype，然后基于原型去计算这个相似性损失 $$ \\mathcal{L}{P S C}\\left(\\mathbf{z}{i}\\right)=-\\log \\frac{\\exp \\left(\\mathbf{z}{i} \\cdot \\mathbf{p}{y_{i}} / \\tau\\right)}{\\sum_{j=1, j \\neq y_{i}}^{C} \\exp \\left(\\mathbf{z}{i} \\cdot \\mathbf{p}{j} / \\tau\\right)} $$ 在这里这个Prototypical需要正则化到单位元中，这样能快速计算相似性损失，也不会需要大量的现存。\n可以参考的点主要就在于损失的设计和框架上的这种分epoch机制了，但是基于自监督的方式的话，可能不是很用的上这一点，但是我们可以考虑怎么结合这个loss去做对应的分类器。\nThe value of labels 这一篇文章是将自监督学习和半监督学习应用到长尾分布的问题上，文章对应的仓库中可以get预训练模型和很多对应的数据，同时验证了下面两种策略都可以大大提升模型的效果，包括和之前的各种策略进行耦合。\n半监督：利用更多的无标注数据 自监督：不利用任何其他数据，使用长尾分布的数据进行自监督训练 后续的实验过程中我可能也会遵循该设计，或者使用的是全数据的自监督预训练。\n考虑尾部标签本身的意义，想要利用尾部的标签信息，又不受偏差的影响，实际上就是使用自监督进行预训练，然后后面使用各种方法兼容的一个策略。 MixUp in LT 将MixUP应用在LT中，试图\u0026quot;以使其具有更高的泛化性，以及降低模型本身的置信度\u0026quot;[4], 经过实验表明，仅在Stage1使用MixUP，在Stage2的第二阶段使用几个epoch的Mixup的效果可能会更好。\n在这里可能也要考虑一下CutMix方法\nConclusion 实验结果汇总 基于BackBone对这些方法的实验结果($Top1 Acc$)进行汇总，作为我们后续研究的参照：在进行实验的时候，我们需要首先调整好BenchMark，基于Benchmark做的改进才能和对应的方法进行对比。\n整理原则：\n对应的论文则由该论文本身为主，后续和LT的仓库进行对比分析； 最主要需要对比的应该是ce情况下的指标，这是我们最重要的，当这个指标对齐后，我们就可以和这些方法同台竞技了。 Dataset -\u0026gt; LT-Cifar-100 \u0026lt;- -\u0026gt; LT-CIfar10 \u0026lt;- Backbone Factor(Exp) 100 50 10 100 50 10 ResNet32 RESULT - - - - - - CE 38.32 43.85 55.71 70.36 74.81 86.39 - Focal Loss 38.4 44.3 56.8 70.4 76.7 86.7 - MixUp 39.5 45.0 58.0 73.1 77.8 87.1 - CB Loss 39.6 45.2 58.0 74.6 79.3 87.1 - BAGS-After 47.83 51.69 - 73.59 79.03 - - SSL-Uniform 40.40 45.04 57.07 73.50 78.20 87.72 SSL-Balanced 43.06 47.09 58.06 76.53 80.4 87.72 LDAM 42.0 46.6 58.7 77.0 81.0 88.2 - BBN 42.56 47.07 59.12 79.82 82.18 88.32 - Causal 44.1 50.3 59.6 80.6 83.6 88.5 - Reference 阅读过程中还看到一些什么BAGS，进行数据分组的方法，这个方法肯定不会在我们的框架中使用，但是我们可以分析一下这种分组训练为什么会对长尾的场景存在差异。\n⭐\u0026ldquo;Bag of Tricks for LT Visual Recognition with Deep Convolutional Neural Network\u0026rdquo; ZHIHU ⭐\u0026ldquo;BBN: Bilateral-Branch Network with Cumulative Learning for Long-Tailed Visual Recognition\u0026rdquo; ZHIHU CVPR20 ❓\u0026ldquo;Long-Tail Learning via Logit Abjustment\u0026rdquo; ICLR 20 zhihu1 | zhihu2 \u0026ldquo;Improving Calibration for Long-Tailed Recognition\u0026rdquo; CVPR21 zhihu ⭐\u0026ldquo;Distribution Alignment: A Unified Framework for Long-tail Visual Recognition\u0026rdquo; CVPR21 zhihu | zhihu2 \u0026ldquo;Decoupling Representation and Classifier for Long-Tailed Recognition\u0026rdquo; ICLR20 \u0026ldquo;Long-Tailed Classification by Keeping the Good and Removing the Bad Momentum Causal Effect\u0026rdquo; NIPS20 | zhihu \u0026ldquo;Rethinking the Value of Labels for Improving Class-Imbalanced Learning\u0026rdquo; NIPS20| zhihu \u0026ldquo;Contrastive Learning based Hybrid Networks for Long-Tailed Image Classification\u0026rdquo; CVPR21 zhihu 总结性串讲：\nLT-Classification ","permalink":"https://metisy.cool/posts/lt-collection/","summary":"\u003cp\u003e@AikenHong 2021\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/mitming/OpenLT\" target=\"_blank\" rel=\"noopener\"\u003eCode of must of those methods\u003c/a\u003e\n\nWe will analysis those tricks on LT situation, and Analysis why it works.\n在进行LT矫正的任务中，有几种常见的trick在各种模型中被使用，我们会对这几种不同的trick进行介绍和分析。\u003c/p\u003e\n\u003cp\u003e其实在数据量少这一方面LT和Few-Shot是有一定的OverLap的,可以参考以下那边的思路perhaps\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211217165531.png\"\u003e\r\n    \u003cimg alt=\"LT\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211217165531.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211217165531.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"LT\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\n通常情况下这种严重的类别不平衡问题会使得模型严重过拟合于头部，而在尾部欠拟合\u003c/p\u003e\n\u003cp\u003e首先介绍 \u003ca href=\"https://zhuanlan.zhihu.com/p/416315017\" target=\"_blank\" rel=\"noopener\"\u003ebag of tricks\u003c/a\u003e\n 这篇论文中总结了一些常用的Trick，并组合出了最佳的一套trick\u003c/p\u003e\n\u003cp\u003e经过该文实验总结，Trick组合应该是\u003csub\u003e[1]`\u003c/sub\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在前几个epoch应用input mixup数据增强，然后后面fine-tuning;\u003c/li\u003e\n\u003cli\u003e(基于CAM的)重采样来重新训练分类器;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e实际上就是MixUp + Two-Stage的策略，后续对\u003cstrong\u003eMix-up\u003c/strong\u003e这个策略带来的作用要进行补充了解一下\u003c/p\u003e\n\u003ch2 id=\"rebalance\"\u003eRebalance\u003c/h2\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e对于ReBalance的方法，实际上就是从 \u003ccode\u003edata\u003c/code\u003e和 \u003ccode\u003eupdate\u003c/code\u003e两个角度来缓解Unbalance本身，通过从数据量上达到重新均衡，或者基于Loss使得bp过程中赋予Tail更高的权重来达到优化过程的平衡。\u003c/p\u003e","title":"LT Collection"},{"content":"\r👋 Hi there! I'm AikenHong.\r🚀 About Me I am a Machine Learning Engineer and passionate software developer, specializing in AI research, with a strong commitment to exploring the endless possibilities within the IT industry. I hold a master\u0026rsquo;s degree from Xi\u0026rsquo;an Jiaotong University.\nI am currently focused on AI and machine learning projects while diligently working to become a full-stack developer. My enthusiasm for exploring new worlds and concepts is fueled by my love for travel and immersive video games, which inspire my creativity and drive my eagerness to learn and try new things.\n🛠️ Skills \u0026amp; Tools Development Languages:\nMain: Python, C++, Bash Learning: JavaScript (HTML \u0026amp; CSS) Future Plans: Rust \u0026amp; Go Development Tools:\nOperating Systems: Mac, Windows, Linux IDEs: VSCode \u0026amp; Vim (Neovim) Terminal Emulators: Windows Terminal, WezTerm, iTerm 🎮 Fun Fact The strategy and perseverance needed in Souls-like games are traits I carry into my coding and research work. Just like in gaming, patience and creativity are key!\nFeel free to explore my repositories and connect with me for any collaboration. Let\u0026rsquo;s learn and innovate together!\n🔗 Connect with Me Fi. ","permalink":"https://metisy.cool/about/","summary":"\u003cp align=\"center\"\u003e\r\n  \u003cimg src=\" https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/DSCF4104_%E5%89%AF%E6%9C%AC.JPG\" width=100%\u003e\r\n\u003c/p\u003e\r\n\u003cp align=\"center\"\u003e\r\n  👋 Hi there! I'm AikenHong.\r\n\u003c/p\u003e\r\n\u003ch3 id=\"-about-me\"\u003e🚀 About Me\u003c/h3\u003e\n\u003cp\u003eI am a Machine Learning Engineer and passionate software developer, specializing in AI research, with a strong commitment to exploring the endless possibilities within the IT industry. I hold a master\u0026rsquo;s degree from Xi\u0026rsquo;an Jiaotong University.\u003c/p\u003e\n\u003cp\u003eI am currently focused on AI and machine learning projects while diligently working to become a full-stack developer. My enthusiasm for exploring new worlds and concepts is fueled by my love for travel and immersive video games, which inspire my creativity and drive my eagerness to learn and try new things.\u003c/p\u003e","title":"About Me"},{"content":"该文档主要目的是用于测试Latex语法对应前端的渲染能力，主要用于测试Hexo站点是否能正常渲染Latex。\nExample1: 2 inline in one sentence.\nWhen $a \\ne 0$, there are two solutions to $(ax^2 + bx + c = 0)$ and they are $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$ Example2: Matrix Example\n$$ \\begin{bmatrix} 1\u0026amp;x\u0026amp;x^2\\ 1\u0026amp;y\u0026amp;y^2\\ 1\u0026amp;z\u0026amp;z^2 \\end{bmatrix} \\ \\begin{bmatrix} 1\u0026amp;x\u0026amp;x^2\\\\ 1\u0026amp;y\u0026amp;y^2\\\\ 1\u0026amp;z\u0026amp;z^2 \\end{bmatrix} \\ vmatrix ||、Bmatrix{}、pmatrix() $$\nExample3: the Conditional Formula\n$$ f(x)= \\begin{cases} 0\u0026amp; \\text{x=0}\\\\ 1\u0026amp; \\text{x!=0} \\end{cases} $$\nExample4: Sprcial Symboy\n$$ \\lim_{\\alpha \\rightarrow +\\infty} \\frac{1}{\\alpha(\\beta+1)} $$\nExample5: Complex Function Which Occurs Error in Much Situation\n$$\r\\begin{gathered}\r\\mathcal{L}_{POD-final} = \\frac{\\lambda_c}{L-1}\\sum_{l=1}^{L-1} \\mathcal{L}_{POD-spatial}(f_l^{t-1}(x),f_l^t(x)) + \\\\\r\\lambda_f \\mathcal{L}_{POD-flat}(f_l^{t-1}(x),f_l^t(x))\r\\end{gathered}\r$$\rExample6：Mathbb、Text、etc\u0026hellip;\n$$\r\\mathcal{L}_{\\text {POD-pixel }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C} \\sum_{w=1}^{W} \\sum_{h=1}^{H}\\left\\|\\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2}\r$$\rExample7: Multiple Lines of Loss in Incremental Learning\n$$\r\\begin{gathered}\r\\mathcal{L}_{\\text {POD-channel }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{w=1}^{W} \\sum_{h=1}^{H}\\left\\|\\sum_{c=1}^{C} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{c=1}^{C} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2} \\\\\r\\mathcal{L}_{\\text {POD-gap }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C}\\left\\|\\sum_{w=1}^{W} \\sum_{h=1}^{H} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{w=1}^{W} \\sum_{h=1}^{H} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2} \\\\\r\\mathcal{L}_{\\text {POD-width }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C} \\sum_{h=1}^{H}\\left\\|\\sum_{w=1}^{W} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{w=1}^{W} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2}\r\\end{gathered}\r$$\r如果这些都能正确渲染的话，基本整个文档中的Latex基本渲染应该都没问题，用该文档能验证当前本地渲染的版本是否是正确的。\n","permalink":"https://metisy.cool/posts/latex_test/","summary":"\u003cp\u003e该文档主要目的是用于测试Latex语法对应前端的渲染能力，主要用于测试Hexo站点是否能正常渲染Latex。\u003c/p\u003e\n\u003cp\u003eExample1: 2 inline in one sentence.\u003c/p\u003e\n\u003cp\u003eWhen $a \\ne 0$, there are two solutions to $(ax^2 + bx + c = 0)$ and they are $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$\nExample2: Matrix Example\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{bmatrix} 1\u0026amp;x\u0026amp;x^2\\ 1\u0026amp;y\u0026amp;y^2\\ 1\u0026amp;z\u0026amp;z^2 \\end{bmatrix}\n\\\n\\begin{bmatrix} 1\u0026amp;x\u0026amp;x^2\\\\ 1\u0026amp;y\u0026amp;y^2\\\\ 1\u0026amp;z\u0026amp;z^2 \\end{bmatrix}\n\\\nvmatrix ||、Bmatrix{}、pmatrix()\n$$\u003c/p\u003e\n\u003cp\u003eExample3: the Conditional Formula\u003c/p\u003e\n\u003cp\u003e$$\nf(x)=\n\\begin{cases}\n0\u0026amp; \\text{x=0}\\\\\n1\u0026amp; \\text{x!=0}\n\\end{cases}\n$$\u003c/p\u003e\n\u003cp\u003eExample4: Sprcial Symboy\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e$$\n\\lim_{\\alpha \\rightarrow +\\infty} \\frac{1}{\\alpha(\\beta+1)}\n$$\u003c/p\u003e","title":"Latex Function Test"}]