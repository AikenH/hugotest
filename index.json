[{"content":"该文章会测试各种后续修改，包括基础字体，各种后续添加适配的shortcodes： 如 alert、视频、widget ，包括字体渲染，视频渲染，iframe渲染，以及相关的一些其他修改， 同时文章由于引入了大量的js，导致一些功能的渲染速度会下降，这也是我们需要测试的地方，包括找到加载的瓶颈；\nExtend ShortCodes encrypt 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\rhere is a long message.\nseems like we can only entrypt once in one markdown, if we encrypt multiplytimes, the function will make the password error.\nsidenote abc\nLorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. def Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.\nLorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.\nTimeline 2023-10-01 节日 国庆节 祖国生日快乐 2024-01-01 节日\u0026amp;计划 元旦节 上北京er Chat metisy\u0026nbsp;\u0026nbsp;\u0026nbsp;2024-11-25 19:31 这是左边的消息内容。 2024-11-25 19:32\u0026nbsp;\u0026nbsp;\u0026nbsp;aikenh 这是右边的消息内容，测试长长长长长长长长长长长长长长长长长长长长长长长长度。 quota-center 十里青山远，潮平路带沙\n数声啼鸟怨年华\n又是凄凉时候，在天涯\n白露收残月，清风散晓霞\n绿杨堤畔问荷花\n记得年时沽酒，那人家\nquota 十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\nsimple-notice 十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\nnotice 十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\ngithub widget Organic-Carbon-Estimating A program used in estimating organic carbon stocks in oceans. 计算指定海域的有机碳存量，包括颗粒有机碳与溶解有机碳，数据依赖于 NASA 中分辨率成像光谱仪 MODIS 遥感产品。 MATLAB align 文字居左\n文字居中\n文字居右\nVideo Function bilibili BV12NpBeYErP Markdown Function Expand Support pangujs 这是一段测试pangu之白的article，看看渲染出来的效果如何\nAlert Block 接下来测试各个关键词的渲染效果并进行调整， 首先就是 Note\nNote\rtest note block\u0026rsquo;s style.\n其次是：important\nImportant\r重要内容\n接着是：tip\nTip\r这是一些提示内容\n再次是 warning\nWarning\r这是一些告警内容\n最后是caution\nCaution\r重要内容\n然后测试一个自己添加的\nSummary\r总结\nmermaid mermaid 的跟随主题切换更改渲染的方式一直不work，暂时使用black theme加渲染的方式做处理。\nflowchart LR G[工作强度] G --\u0026gt; A G --\u0026gt; C G --\u0026gt; E A[\u0026#34;主动\u0026#34;策略] --\u0026gt; B[卷，按照表现辞退， 工作时间长，薪资构成=基本工资+基金表现*贡献Rate] C[\u0026#34;被动\u0026#34;跟踪] --\u0026gt; D[WLB, 固定工资，晋升-\u0026gt;管理] E[\u0026#34;混合\u0026#34;] --\u0026gt; F[介于两者之间，薪资与公司表现挂钩] 下面给出一个官方的不同实例来看不同的模式下的不同渲染情况\nsequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! 最后再来一个常规的流程图，或者说是概率图\n--- title: Action Distrubution based on Feature --- flowchart LR A[DragonBeenAtkBySomeone] --\u0026gt; B1[Value 1] B1 -- 60% --\u0026gt; C[Atk Target is Dragon] B1 -- 40% --\u0026gt; D[Other Action] A --\u0026gt; B2[Value 0] --\u0026gt; E[All Action Possible] Default ShortCodes gist https://www.andbible.com/post/hugo-content-management-shortcodes/ youtube twitter Owl bet you\u0026#39;ll lose this staring contest 🦉 pic.twitter.com/eJh4f2zncC\n\u0026mdash; San Diego Zoo Wildlife Alliance (@sandiegozoo) October 26, 2021 ins View this post on Instagram FI ","permalink":"https://hugotest-phi.vercel.app/posts/shotcode_test/","summary":"\u003cp\u003e该文章会测试各种后续修改，包括基础字体，各种后续添加适配的shortcodes： 如 alert、视频、widget ，包括字体渲染，视频渲染，iframe渲染，以及相关的一些其他修改，\n同时文章由于引入了大量的js，导致一些功能的渲染速度会下降，这也是我们需要测试的地方，包括找到加载的瓶颈；\u003c/p\u003e\n\u003ch2 id=\"extend-shortcodes\"\u003eExtend ShortCodes\u003c/h2\u003e\n\u003ch3 id=\"encrypt\"\u003eencrypt\u003c/h3\u003e\n\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"password\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003cp\u003ehere is a long message.\u003c/p\u003e\n\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n\r\n\u003cscript\u003e\r\n    \r\n\r\n\r\nfunction sanitizeContent(content) {\r\n    \r\n    return content.replace(/[\\x00-\\x1F\\x7F]/g, '').trim(); \r\n}\r\n\r\nfunction encryptContent(password, content) {\r\n    const key = CryptoJS.MD5(password).toString();\r\n    const iv = key.substring(16); \r\n    const paddedContent = padContent(content);\r\n    const encrypted = CryptoJS.AES.encrypt(paddedContent, CryptoJS.enc.Utf8.parse(key), {\r\n        iv: CryptoJS.enc.Utf8.parse(iv),\r\n        mode: CryptoJS.mode.CBC,\r\n        padding: CryptoJS.pad.Pkcs7\r\n    });\r\n    return CryptoJS.enc.Base64.stringify(encrypted.ciphertext);\r\n}\r\n\r\nfunction padContent(content) {\r\n    const blockSize = 32; \r\n    const padlen = blockSize - (content.length % blockSize);\r\n    \r\n    \r\n    return content;\r\n}\r\n\r\nfunction processEncryptedBlocks() {\r\n    const blocks = document.querySelectorAll('.hugo-encryptor-cipher-text');\r\n    blocks.forEach(block =\u003e {\r\n        const password = block.getAttribute('data-password');\r\n        const content = block.innerHTML.trim(); \r\n        const sanitizedContent = sanitizeContent(content); \r\n        const encryptedContent = encryptContent(password, sanitizedContent);\r\n        block.innerHTML = encryptedContent;\r\n        block.removeAttribute('data-password');\r\n    });\r\n\r\n    \r\n    const script = document.createElement('script');\r\n    script.src = '/js/decrypt.js';\r\n    document.body.appendChild(script);\r\n}\r\n\r\n\r\ndocument.addEventListener('DOMContentLoaded', processEncryptedBlocks);\r\n\u003c/script\u003e\n\u003cp\u003eseems like we can only entrypt once in one markdown, if we encrypt multiplytimes, the function will make the password error.\u003c/p\u003e","title":"ShortCode Function Test"},{"content":"test 该文档主要目的是用于测试Latex语法对应前端的渲染能力，主要用于测试Hexo站点是否能正常渲染Latex。\nExample1: 2 inline in one sentence.\nWhen $a \\ne 0$ , there are two solutions to $(ax^2 + bx + c = 0)$ and they are\n$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. $$\rExample2: Matrix Example\n$$ \\begin{bmatrix} 1\u0026x\u0026x^2\\\\ 1\u0026y\u0026y^2\\\\ 1\u0026z\u0026z^2 \\end{bmatrix}\r\\\\\r\\begin{bmatrix} 1\u0026x\u0026x^2\\\\\\\\ 1\u0026y\u0026y^2\\\\\\\\ 1\u0026z\u0026z^2 \\end{bmatrix}\r\\\\\rvmatrix ||、Bmatrix{}、pmatrix()\r$$\rExample3: the Conditional Formula\n$$ f(x)=\r\\begin{cases}\r0\u0026 \\text{x=0}\\\\\\\\\r1\u0026 \\text{x!=0}\r\\end{cases}\r$$\rExample4: Sprcial Symboy\n$$ \\lim_{\\alpha \\rightarrow +\\infty} \\frac{1}{\\alpha(\\beta+1)}\r$$\rExample5: Complex Function Which Occurs Error in Much Situation\n$$ \\begin{gathered}\r\\mathcal{L}_{POD-final} = \\frac{\\lambda_c}{L-1}\\sum_{l=1}^{L-1} \\mathcal{L}_{POD-spatial}(f_l^{t-1}(x),f_l^t(x)) + \\\\\r\\lambda_f \\mathcal{L}_{POD-flat}(f_l^{t-1}(x),f_l^t(x))\r\\end{gathered}\r$$\rExample6：Mathbb、Text、etc\u0026hellip;\n$$ \\mathcal{L}_{\\text {POD-pixel }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C} \\sum_{w=1}^{W} \\sum_{h=1}^{H}\\left\\|\\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2}\r$$\rExample7: Multiple Lines of Loss in Incremental Learning\n$$ \\begin{gathered}\r\\mathcal{L}_{\\text {POD-channel }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{w=1}^{W} \\sum_{h=1}^{H}\\left\\|\\sum_{c=1}^{C} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{c=1}^{C} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2} \\\\\r\\mathcal{L}_{\\text {POD-gap }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C}\\left\\|\\sum_{w=1}^{W} \\sum_{h=1}^{H} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{w=1}^{W} \\sum_{h=1}^{H} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2} \\\\\r\\mathcal{L}_{\\text {POD-width }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C} \\sum_{h=1}^{H}\\left\\|\\sum_{w=1}^{W} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{w=1}^{W} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2}\r\\end{gathered}\r$$\r如果这些都能正确渲染的话，基本整个文档中的Latex基本渲染应该都没问题，用该文档能验证当前本地渲染的版本是否是正确的。\n","permalink":"https://hugotest-phi.vercel.app/posts/latextest2/","summary":"\u003cp\u003etest\n该文档主要目的是用于测试Latex语法对应前端的渲染能力，主要用于测试Hexo站点是否能正常渲染Latex。\u003c/p\u003e\n\u003cp\u003eExample1: 2 inline in one sentence.\u003c/p\u003e\n\u003cp\u003eWhen $a \\ne 0$ , there are two solutions to $(ax^2 + bx + c = 0)$ and they are\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. $$\r\n\u003c/div\u003e\r\n\u003cp\u003eExample2: Matrix Example\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\n\\begin{bmatrix} 1\u0026x\u0026x^2\\\\ 1\u0026y\u0026y^2\\\\ 1\u0026z\u0026z^2 \\end{bmatrix}\r\n\\\\\r\n\\begin{bmatrix} 1\u0026x\u0026x^2\\\\\\\\ 1\u0026y\u0026y^2\\\\\\\\ 1\u0026z\u0026z^2 \\end{bmatrix}\r\n\\\\\r\nvmatrix ||、Bmatrix{}、pmatrix()\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003eExample3: the Conditional Formula\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\nf(x)=\r\n\\begin{cases}\r\n0\u0026 \\text{x=0}\\\\\\\\\r\n1\u0026 \\text{x!=0}\r\n\\end{cases}\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003eExample4: Sprcial Symboy\u003c/p\u003e","title":"latextest2"},{"content":"\rError\r编写 C++ 代码时偶尔会遇到两个类需要相互引用的情况，如果在 h 文件中相互包含会导致 \u0026ldquo;has not been declared\u0026rdquo; 等声明问题，此时需要使用前置声明的方式来解决该问题\nCode Example 以一个实际场景为例：假设有工具类 Search Helper 提供一系列搜索功能，还有另一个 ObjectAttr 定义一系列操作对象的属性，在 ObjectAttr 中需要引用 SearchHelper 提供的某个基础函数，而 SearchHelper 中部分针对 ObjectAttr 设计的某些功能则需要将 ObjectAttr 中的类作为入参，此时我们可能会在 h 文件中相互引用；\n在 obj_definition.h 中有 GetSelfNearObj 函数，其过程中需要调用 search_helper 中的 GetDistObj 函数进行辅助运算\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026#34;util/search_helper.h\u0026#34; namespace object_info{ class ObjectAttr{ public: LocationType location; int ObjId; int NearObjId; private: void GetSelfNearObj(); }; } 在 search_helper.h 中有以下函数定义\n1 2 3 4 5 6 7 #include \u0026#34;base/obj_definition.h\u0026#34; namespace search_helper{ class SearchHelper{ public: int GetDistObj(const object_info::ObjectAttr \u0026amp; obj1, const object_info::ObjectAttr \u0026amp; obj2); }; } 这种情况下编译会出现未定义，未声明，not a type 之类缺少类型说明符的错误。\nerror: ... has not been declared Fix \u0026amp; Analysis 上述错误是由于两个文件构成了循环依赖，类 SearchHelper 依赖于 ObjectAttr，ObjectAttr 又依赖于 SearchHelper；因此编译器会报错导致无法通过编译；\n在这种情况下，可以通过前向声明的方式来解决这种问题，即不去进行循环引用，在search_helper 中不 #include obj_definition.h，但是对需要的 ObjectAttr 进行一个空声明，然后在 .cpp 中 #include obj_definition.h 具体如下，将 H 文件修改为；\n1 2 3 4 5 6 7 8 9 10 namespace objct_info{ class ObjectAttr; } namespace search_helper{ class SearchHelper{ public: int GetDistObj(const object_info::ObjectAttr \u0026amp; obj1, const object_info::ObjectAttr \u0026amp; obj2); }; } 在对应的 .cpp 文件中添加对 obj_definition 的包含，这样在编译过程中，ObjectAttr 会被自动链接到正确的定义；\n1 2 3 4 #include \u0026#34;base/obj_definition.h\u0026#34; // origin cpp file below... // ... 上述例子展示了不同命名空间下的情况，这里秉持的原则就是不同文件中对类的前置声明要保持一致，无论是命名空间、参数、类型等，在同一个命名空间中的情况要更简单，可以以此类推，这里不再赘述；\nReference c++ 头文件互相包含问题 c++ 类声明 类前置声明范例 ","permalink":"https://hugotest-phi.vercel.app/posts/ts1_%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%8C%85%E5%90%AB/","summary":"\u003cblockquote class=\"alert-blockquote alert-error\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eError\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e编写 C++ 代码时偶尔会遇到两个类需要相互引用的情况，如果在 h 文件中相互包含会导致 \u0026ldquo;has not been declared\u0026rdquo; 等声明问题，此时需要使用前置声明的方式来解决该问题\u003c/p\u003e","title":"CPP_头文件互相包含"},{"content":"\rSummary\r如果页面的功能较为复杂，且涉及到了从服务端获取数据等操作，如果简单的使用同步编程，等待一个个任务按顺序执行，由于网络或者某些时间复杂度较高的操作，导致网页加载时间过长，或者使用逻辑不合理（加载某些资源的同时无法进行浏览等），因此异步编程的特性在 web 端是十分重要的。\n通过异步编程使一个长时间运行的任务运行的同时能够对网页做出其他的操作和对其他事件做出相应，而不需等待该任务完成，以下的这些功能就是最常见需要异步完成的；\nfetch 发起 http 请求 getUserMedia() 获取用户的摄像头和麦克风 showOpenFilePicker() 请求用户选择文件以供访问。 基于事件处理程序实现异步 事件处理的逻辑实际上也是一种接近异步编程的方式，对应的函数不是即时执行，而是等事件被触发后在进行调用。一些早期的异步 API 就是这样使用事件的。\n一些早期的异步 API 就是这样来使用事件，例如 XMLHttpRequest 可以使用 JS 向远程服务器发起 HTTP 请求，这类网络请求操作都会比较耗时，因此通常会使用异步，以下面的例子进行后续说明；\n1 2 3 4 5 6 7 8 9 10 11 12 const log = document.querySelector(\u0026#34;.event-log\u0026#34;); document.querySelector(\u0026#34;#xhr\u0026#34;).addEventListener）(\u0026#34;click\u0026#34;, () =\u0026gt; { log.textContent = \u0026#34;\u0026#34;; const xhr = new XMLHttpRequest(); xhr.addEvenetLister(\u0026#34;loadend\u0026#34;, () =\u0026gt; { log.textContent = `${log.textContent} 完成, 状态码: ${xhr.status}`; }); xhr.open(\u0026#34;GET\u0026#34;, \u0026#34;https://URL/dir/file.json\u0026#34;); xhr.send(): log.textContent = `${log.textContent} 请求已发起\\n`; }); xhr 按钮点击后，声明一个 XMLHttpRequest 对象，并监听其 loadend 事件，然后发送请求，并将字符串修改为请求已发起，该字符串会在触发了 loadend 加载完了请求事件后改为，已完成。\n事件处理程序本身是一种特殊类型的回调函数（函数作为参数传递到另一个函数），多层回调函数的嵌套会导致代码难以理解和 debug，因此后面大多数 API 不在使用回调函数去处理异步的情况。\nPromise 现代 JS 异步编程的基础 Promise 是现代 JavaScript 中异步编程的基础。它是一个由异步函数返回的对象，可以指示操作当前所处的状态。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象提供了方法来处理操作最终的成功或失败。\n一个基于 Promise 的 API，异步函数会启动操作并直接返回一个 Promise 对象，可以将后续的处理函数附加到该对象上，当操作完成时（成功、失败），执行对应的处理函数。\n以 fetch() 为例 1 2 3 4 5 6 7 8 9 10 const fetchPromise = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); console.log(fetchPromise); fetchPromise.then((response) =\u0026gt; { console.log(`已受到响应 ${response.status}`); }); console.log(\u0026#34;已发送请求...\u0026#34;); 1 Promise { \u0026lt;state\u0026gt;: \u0026#34;pending\u0026#34;} 调用 fetch() 将返回的 promise 存储到 fetchPromise 变量 Promise 的变量输出结果如下 将处理函数传递给 promise 变量的 then 函数，当 fetch 操作成功的时候，promise 就会调用对应的处理函数。 整体的处理逻辑还是比较清晰的，关键是使用 promise 变量的 then 函数去处理 fetch 的各种不同结果。\n链式使用 Promise 在前面通过 fetch 获取 response 对象的时候，我们需要使用对应的 json() 方法将其转换为 js 专属的对象，这里的 json 实际上也是一个异步方法，由此我们可以链式的实现异步如下：\n1 2 3 4 5 6 7 8 9 10 const fetchPromise = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); fetchPromisze.then((response) =\u0026gt; { const jsonPromise = response.json(); jsonPromise.then((json) =\u0026gt; { console.log(json[0].name); }); }); 这种情况在多层嵌套的时候也会堆叠得很难理解，但是相比于回调函数，每一级的回调都会有个 promise 的即时返回值来指示对应异步函数中的完成状态。\n由于 promise 是一个即时返回值，因此上述的代码可以简写为：\n1 2 3 4 5 fetchPromise .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; { console.log(data[0].name); }); 不必在第一个 then 中调用下一个 then，可以直接返回对应的 promise 对象，对对应的 promise 对象调用处理即可，这样可以避免多级缩进叠加；\n处理异常返回值 对 promise 中的状态值进行检查，如果状态码不是 ok 就需要对应的抛出错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const fetchPromise = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); fetchPromise .then((response) =\u0026gt; { if(!response.ok){ throw new Error(`HTTP 请求错误 ${response.status}`); } }) .then((json) =\u0026gt; { console.log(json[0].name); }); 此外由于这种异步的函数返回机制，如果要按照上面的方式逐个进行错误处理非常的困难，需要在每个嵌套层中进行处理，为了避免这种麻烦，Promise 对象提供了一个 catch() 方法（类似 then），当调用成功时触发的是 then 而调用失败了就会调用 catch 中定义的处理函数。\n将 catch 添加到 Promise 的末尾，他可以在任何异步函数失败的时候调用，下面是一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const fetchPromise = fetch( \u0026#34;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); fetchPromise .then((response) =\u0026gt; { if (!response.ok) { throw new Error(`HTTP 请求错误：${response.status}`); } return response.json(); }) .then((json) =\u0026gt; { console.log(json[0].name); }) .catch((error) =\u0026gt; { console.error(`无法获取产品列表：${error}`); }); Promise 的状态值 需要注意 promise 对应的成功和失败的含义随着 API 的不同而不同，例如 fetch 认为服务器返回一个错误如（404 not found）时请求成功，但如果网络错误阻止请求被发送，则认为请求失败。\nStatus Desc Pending 待定 还在请求中，尚未有确定的结果，也是初始状态 fulfilled 已兑现 操作成功的标准返回，后续进入调用 then 的逻辑 rejected 已拒绝 操作失败的标准返回，后续进入调用 catch 的逻辑 有时用**已敲定(settled)来同时表示已兑现和已拒绝；如果一个 Promise 已敲定，或者他被\u0026quot;锁定\u0026quot;以跟踪另一个 Promise 的状态，那么就是已解决(resolved)**的。\n组式使用 Promise (合并使用) 当操作由多个异步函数组成，如果需要串行完成那就需要 promise 链，如果需要组合使用多个 promise，相互之间不依赖但是需要所有 promise 都实现的情况，可以考虑合并多个异步函数的使用。\n使用 Promise.all() 接受一个 Promise 数组，并返回一个单一的 Promise，使用该操作通过合并来简化对一批 promise 的处理，由 promise.all() 返回的 promise 有以下的特性：\n什么时候调用 then？当数组中所有 promise 都兑现时; 传入 then 的形式式什么？提供一个包含所有响应的数组，顺序与传入 all 的顺序一致; 什么时候拒绝/调用catch？任何一个promise 没有兑现的时候，调用 catch，并提供被拒绝的 promise 抛出的错误; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const fetchPromise1 = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); const fetchPromise2 = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found\u0026#34;, ); const fetchPromise3 = fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json\u0026#34;, ); //const fetchPromise3 = fetch( // \u0026#34;bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json\u0026#34;, //); Promise.all([fetchPromise1, fetchPromise2, fetchPromise3]) .then((responses) =\u0026gt; { for (const response of responses) { console.log(`${response.url}：${response.status}`); } }) .catch((error) =\u0026gt; { console.error(`获取失败：${error}`); }); 选择使用 Promise (任一) 如果需要一组Promise 中某一个实现即可，这种时候可以使用 promise.any(), 任意一个被兑现时便兑现，仅当所有 Promise 被拒绝的时候才拒绝。\nasync 和 await 在函数的开头添加 async 关键词可以使得一个函数成为一个异步函数：\n1 2 3 async function myFunction(){ ... } await 关键词则使得我们不再并行执行异步函数，而是在原地等待该异步函数执行完成，也就是讲异步函数当成同步函数来使用，直到其 Promise 相应彻底完成，如下可以将 fetch 改写成同步函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 async function fetchProducts() { try { // 在这一行之后，我们的函数将等待 `fetch()` 调用完成 // 调用 `fetch()` 将返回一个“响应”或抛出一个错误 const response = await fetch( \u0026#34;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\u0026#34;, ); if (!response.ok) { throw new Error(`HTTP 请求错误：${response.status}`); } // 在这一行之后，我们的函数将等待 `response.json()` 的调用完成 // `response.json()` 调用将返回 JSON 对象或抛出一个错误 const json = await response.json(); console.log(json[0].name); } catch (error) { console.error(`无法获取产品列表：${error}`); } } fetchProducts(); 这个 fetchProducts() 还是一个异步函数，因此不能按照以下的方法调用：\n1 2 const promise = fetchProducts(); console.log(promise[0].name); // “promise”是一个 Promise 对象，因此这句代码无法正常工作 相反的，需要按照 promise 的方式去调用：\n1 2 const promise = fetchProducts(); promise.then((data) =\u0026gt; console.log(data[0].name)); 同样地，请注意你只能在 async 函数中使用 await，除非你的代码是 JavaScript 模块 。这意味着你不能在普通脚本中这样做：\n你可能会在需要使用 Promise 链地方使用 async 函数，这也使得 Promise 的工作更加直观。\n请记住，就像一个 Promise 链一样，await 强制异步操作以串联的方式完成。如果下一个操作的结果取决于上一个操作的结果，这是必要的，但如果不是这样，像 Promise.all() 这样的操作会有更好的性能。\nPromise 实战 前面讨论如何使用返回 promise 的 APIs，这一节研究如何实现返回 Promise 的 Apis，这与基于使用 promise 的 APIs 相比，是一个不太常见的任务。参考文献 mdn如何实现基于promise的api | 菜鸟教程JavaScript Promise | 廖雪峰JavaScript 以一个普通的回调转换为 Promise 的例子来说明：\n1 2 3 4 5 6 7 8 9 10 const output = document.querySelector(\u0026#34;#output\u0026#34;); const button = document.querySelector(\u0026#34;#set-alarm\u0026#34;); function setAlarm() { window.setTimeout(() =\u0026gt; { output.textContent = \u0026#34;Wake up!\u0026#34;; }, 1000); } button.addEventListener(\u0026#34;click\u0026#34;, setAlarm); 利用 Promise 来构造后会变成如下的实现：\n1 2 3 4 5 6 7 8 9 10 function alarm(person, delay) { return new Promise((resolve, reject) =\u0026gt; { if (delay \u0026lt; 0) { throw new Error(\u0026#34;Alarm delay must not be negative\u0026#34;); } window.setTimeout(() =\u0026gt; { resolve(`Wake up, ${person}!`); }, delay); }); } 该函数会创建并返回一个新的 Promise，其中需要说明的是，Promise 本身需要两个参数 resolve 和 reject，当执行成功了就会调用 resolve（类似 return），如果失败了，就会自动调用 reject，（throw error 的部分），两者都可以讲任何类型的单个参数传递，具体而言参考后续调用如下：\n1 2 3 4 5 button.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { alarm(name.value, delay.value) .then((message) =\u0026gt; (output.textContent = message)) .catch((error) =\u0026gt; (output.textContent = `Couldn\u0026#39;t set alarm: ${error}`)); }); 可以讲一个函数变成具备原生异步功能的 Promise？由此我们就可以对其使用 await 或者 async 来灵活的决定该 Function 要同步或者异步执行。\nWorkers 页面线程简介 Summary\rWorker 使页面能在单独执行的线程中运行一些任务，避免因为一个长期运行的同步任务使整个任务完全没有响应。\n一些多线程的 Principle，避免同时访问相同的变量带来的意外等：\n主代码和你的 worker 代码永远不能直接访问彼此的变量 Workers 和主代码运行在完全分离的环境中，只有通过相互发送消息来进行交互 这意味着 workers 不能访问 DOM（窗口、文档、页面元素等等） 有三种不同类型的 workers，不过该章节只会介绍第一个，其他两个简要的讨论。\ndedicated workers shared workers service workers 以页面中的质数生成器为例，如果作为同步任务执行，在计算过程中整个页面将会卡住，按照以下的方式来讲计算交付于另一个 worker。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 在 \u0026#34;generate.js\u0026#34; 中创建一个新的 worker const worker = new Worker(\u0026#34;./generate.js\u0026#34;); // 当用户点击 \u0026#34;Generate primes\u0026#34; 时，给 worker 发送一条消息。 // 消息中的 command 属性是 \u0026#34;generate\u0026#34;, 还包含另外一个属性 \u0026#34;quota\u0026#34;，即要生成的质数。 document.querySelector(\u0026#34;#generate\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { const quota = document.querySelector(\u0026#34;#quota\u0026#34;).value; worker.postMessage({ command: \u0026#34;generate\u0026#34;, quota: quota, }); }); // 当 worker 给主线程回发一条消息时，为用户更新 output 框，包含生成的质数（从 message 中获取）。 worker.addEventListener(\u0026#34;message\u0026#34;, (message) =\u0026gt; { document.querySelector(\u0026#34;#output\u0026#34;).textContent = `Finished generating ${message.data} primes!`; }); document.querySelector(\u0026#34;#reload\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { document.querySelector(\u0026#34;#user-input\u0026#34;).value = \u0026#39;Try typing in here immediately after pressing \u0026#34;Generate primes\u0026#34;\u0026#39;; document.location.reload(); }); 通过 worker.postMessage 来和对应的线程传递信息，在对应的 worker 中，可以按照以下的方式来接受和传递信息；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 监听主线程中的消息。 // 如果消息中的 command 是 \u0026#34;generate\u0026#34;，则调用 `generatePrimse()` addEventListener(\u0026#34;message\u0026#34;, (message) =\u0026gt; { if (message.data.command === \u0026#34;generate\u0026#34;) { generatePrimes(message.data.quota); } }); // 生成质数 (非常低效) function generatePrimes(quota) { function isPrime(n) { for (let c = 2; c \u0026lt;= Math.sqrt(n); ++c) { if (n % c === 0) { return false; } } return true; } const primes = []; const maximum = 1000000; while (primes.length \u0026lt; quota) { const candidate = Math.floor(Math.random() * (maximum + 1)); if (isPrime(candidate)) { primes.push(candidate); } } // 完成后给主线程发送一条包含我们生成的质数数量的消息消息。 postMessage(primes.length); } worker 要做的第一件事情就是开始监听来自主脚本的消息。这通过使用 addEventListener() 实现，它在 worker 中是一个全局函数。在 message 事件处理器内部，事件的 data 属性包含一个来自主脚本的参数的副本。\nNote\r**备注：**要运行此站点，你必须运行一个本地 web 服务器，因为 file:// URLs 不允许加载 workers。参考我们的设置一个本地测试服务器 的指导。完成后，你应该可以点击 \u0026ldquo;Generate primes\u0026rdquo; 并且使你的主页面保持响应。 如果你在创建和运行这个样例的过程中有疑问，你可以在 https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/finished 查看完成后的版本，并且在 https://mdn.github.io/learning-area/javascript/asynchronous/workers/finished 进行在线尝试。\n我们刚刚创建的 worker 被称为 dedicated worker。这意味着它由一个脚本实例使用。\n不过，还有其他类型的 worker：\nSharedWorker 可以由运行在不同窗口中的多个不同脚本共享。 Service worker 的行为就像代理服务器，缓存资源以便于 web 应用程序可以在用户离线时工作。他们是渐进式 Web 应用 的关键组件。 ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb21-js06-%E5%BC%82%E6%AD%A5js/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e如果页面的功能较为复杂，且涉及到了从服务端获取数据等操作，如果简单的使用同步编程，等待一个个任务按顺序执行，由于网络或者某些时间复杂度较高的操作，导致网页加载时间过长，或者使用逻辑不合理（加载某些资源的同时无法进行浏览等），因此异步编程的特性在 web 端是十分重要的。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e通过\u003cstrong\u003e异步编程\u003c/strong\u003e使一个长时间运行的任务运行的同时能够对网页做出其他的操作和对其他事件做出相应，而不需等待该任务完成，以下的这些功能就是最常见需要异步完成的；\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efetch\u003c/code\u003e 发起 http 请求\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egetUserMedia()\u003c/code\u003e 获取用户的摄像头和麦克风\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eshowOpenFilePicker()\u003c/code\u003e 请求用户选择文件以供访问。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"基于事件处理程序实现异步\"\u003e基于事件处理程序实现异步\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e事件处理的逻辑实际上也是一种接近异步编程的方式，对应的函数不是即时执行，而是等事件被触发后在进行调用。一些早期的异步 API 就是这样使用事件的。\u003c/p\u003e","title":"LearnWeb21-JS06-异步JS"},{"content":"\rSummary\r本篇是 Mdn 使用 JSON 一文的阅读笔记，对 web 开发中的 JSON 进行了介绍\nJSON 简介 JavaScript Object Notation(JSON)是将结构化数据表示为 JavaScript 对象的标准格式，通常用于网页上的表示和传输数据（服务端，客户端），熟悉 JSON 对象的创建，传输，解析，对于 JS 来说也是一门基本功了。\nJSON 可以存在单独的文件中，后缀为 .json，同时在进行网络传输时，MIME 类型 为 application/json\n基本操作介绍 对 JSON 这类标记语言进行的操作通常就是下面的两种：\n将字符串转换为原生对象的过程称为反序列化(deserialization) 将原生对象转换为字符串进行网络传输的字符串的过程则成为序列化(serialization) 因此可以理解为这就是一个 object-string 的相互转换过程，因此在一个语言中如何使用 json 这种标记语言，最核心的就是上述的这两个操作，随着后续的发展，JSON 在除了 js 的其他语言中也被广泛的使用到。\nJSON 结构和“语法” 整个 JSON 是一个字符串，其非常类似于 JS 对象字面量的写法（无需命名对象名），且其中仅包含要传输的数据（属性）而不包含方法；\n一般而言有两种方法来编写 JSON 文件，一种是类似对象字面量（字典），存储一个单体对象的方式；另一种则是 JSON 数组，最外层用数组的形式，在数组里面可以存储多个单独对象。下面分别给出示例：\n单对象形式，对象字面量（like 字典），js 中反序列化获取之后就会得到一个对象，使用对象的方法去调用其中的属性即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;squadName\u0026#34;: \u0026#34;Super hero squad\u0026#34;, \u0026#34;homeTown\u0026#34;: \u0026#34;Metro City\u0026#34;, \u0026#34;formed\u0026#34;: 2016, \u0026#34;menbers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Molecule Man\u0026#34;, \u0026#34;age\u0026#34;: 29, \u0026#34;secretIdentity\u0026#34;: \u0026#34;Dan Jukes\u0026#34;, \u0026#34;powers\u0026#34;: [ \u0026#34;Radiation resistance\u0026#34;, \u0026#34;Turning tiny\u0026#34;, \u0026#34;Radiation blast\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;Madame Uppercut\u0026#34;, \u0026#34;age\u0026#34;: 39, \u0026#34;secretIdentity\u0026#34;: \u0026#34;Jane Wilson\u0026#34;, \u0026#34;powers\u0026#34;: [ \u0026#34;Million tonne punch\u0026#34;,\u0026#34;Damage resistance\u0026#34;, \u0026#34;Superhuman reflexes\u0026#34; ] } ] } 数组多对象形式,下面这种写法也是一种合法的 JSON，js 中反序列化获取后则会得到一个数组对象，使用下标去索引即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [ { \u0026#34;name\u0026#34;: \u0026#34;Molecule Man\u0026#34;, \u0026#34;age\u0026#34;: 29, \u0026#34;secretIdentity\u0026#34;: \u0026#34;Dan Jukes\u0026#34;, \u0026#34;powers\u0026#34;: [\u0026#34;Radiation resistance\u0026#34;, \u0026#34;Turning tiny\u0026#34;, \u0026#34;Radiation blast\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;Madame Uppercut\u0026#34;, \u0026#34;age\u0026#34;: 39, \u0026#34;secretIdentity\u0026#34;: \u0026#34;Jane Wilson\u0026#34;, \u0026#34;powers\u0026#34;: [ \u0026#34;Million tonne punch\u0026#34;, \u0026#34;Damage resistance\u0026#34;, \u0026#34;Superhuman reflexes\u0026#34; ] } ] 同时 JSON 还有以下的一些编写规范：\n纯数据，只包含属性不包含方法； 要求字符串和属性名称使用双引号，单引号无效； 错位的 , 和 ; 都可能导致 json 文件出错，要做好检查，可以使用JSONLint 这样的程序来验证； JSON 实际上可以使任何可以有效包含在 JSON 中的数据类型的形式，例如，单个字符串或者单个数字也是一个有效的 JSON 对象； 序列化\u0026amp;反序列化 由于序列化和反序列化的操作在 web 环境中的普遍性，因此浏览器都有一个内建的 api JSON 来支持这些操作，主要是下面的两个方法\nparse(string) 以字符串形式接收 JSON 对象，并返回 js 的内建对象。 stringify(obj) 以对象作为参数，返回对应的 JSON 字符串。 Deserialization 反序列化 获取 JSON 数据进行反序列化通常会有两种情况：传输格式为 JSON 是已知 \u0026amp;\u0026amp; 接收到字符串，需要将其按照 JSON 的方式转换为对象；\n第一种情况下可以直接使用 response.json() 直接将获取到的数据转换为对象：\n1 const superHeros = await response.json(); 第二种情况下使用浏览器的 JSON api 来实现转换：\n1 const superHeros = JSON.parse(superHerostext); Serialization 序列化 和反序列化正好相反，序列化也很简单，使用下面 stringify() 方法：\n1 2 3 let myObj = {name: \u0026#34;aikenhong\u0026#34;, age: \u0026#34;26\u0026#34;}; let myString = JSON.stringify(myObj); myString; 可以将上述代码在控制台输入试试，序列化后就可以进行数据传输\n数据传输 Process with Fetch Date 序列化和反序列化过程避不开数据的获取和传输，因此这里会简单介绍一下 JSON 数据的获取和传输的方法。\n这一部分给出一个典型的获取函数来进行说明整个数据获取流程的组成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 async function getJsonData(){ const requestURL = \u0026#34;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json\u0026#34;; const request = new Request(requestURL); const response = await fetch(request); const superHeros = await response.json(); // deserialization2 example. // const superHerosText = await response.text(); // const superHeros = JSON.parse(superHerosText); methodUseObjReceived(superHeros); } 通过 requestURL 初始化一个新的 Request 对象（一个请求体）； 使用 fetch() 方法对这个 Request 对象发起请求，返回一个 response 对象； 使用 response 对象的 json() 以 JSON 的方式获取内容并返回对应的对象； fetch() API 是异步的，这个再后续的章节中会介绍异步函数的知识，目前仅需知道，调用了异步 api 的函数名称前要加入 async 关键字，并在异步 api 的调用之前添加 await 关键字。\nReference FetchAPI 使用Fetch HTTP请求方法 JSON官网 上面这些资料有一些现在就可以看看，有一些在对相关知识了解的更全面之后可以进一步的学习一下。\n","permalink":"https://hugotest-phi.vercel.app/posts/learnweb20-js05-json%E4%BD%BF%E7%94%A8/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e本篇是 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/JSON\" target=\"_blank\" rel=\"noopener\"\u003eMdn 使用 JSON\u003c/a\u003e\n 一文的阅读笔记，对 web 开发中的 JSON 进行了介绍\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"json-简介\"\u003eJSON 简介\u003c/h2\u003e\n\u003cp\u003eJavaScript Object Notation(JSON)是将结构化数据表示为 JavaScript 对象的标准格式，通常用于网页上的表示和传输数据（服务端，客户端），熟悉 JSON 对象的创建，传输，解析，对于 JS 来说也是一门基本功了。\u003c/p\u003e\n\u003cp\u003eJSON 可以存在单独的文件中，后缀为 \u003ccode\u003e.json\u003c/code\u003e，同时在进行网络传输时，\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/MIME_type\" target=\"_blank\" rel=\"noopener\"\u003eMIME 类型\u003c/a\u003e\n为 \u003ccode\u003eapplication/json\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"基本操作介绍\"\u003e基本操作介绍\u003c/h3\u003e\n\u003cp\u003e对 JSON 这类标记语言进行的操作通常就是下面的两种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将字符串转换为原生对象的过程称为反序列化(deserialization)\u003c/li\u003e\n\u003cli\u003e将原生对象转换为字符串进行网络传输的字符串的过程则成为序列化(serialization)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因此可以理解为这就是一个 object-string 的相互转换过程，因此在一个语言中如何使用 json 这种标记语言，最核心的就是上述的这两个操作，随着后续的发展，JSON 在除了 js 的其他语言中也被广泛的使用到。\u003c/p\u003e\n\u003ch3 id=\"json-结构和语法\"\u003eJSON 结构和“语法”\u003c/h3\u003e\n\u003cp\u003e整个 JSON 是一个字符串，其非常类似于 JS 对象字面量的写法（无需命名对象名），且其中\u003cstrong\u003e仅包含要传输的数据（属性）而不包含方法\u003c/strong\u003e；\u003c/p\u003e\n\u003cp\u003e一般而言有两种方法来编写 JSON 文件，一种是类似对象字面量（字典），存储一个单体对象的方式；另一种则是 JSON 数组，最外层用数组的形式，在数组里面可以存储多个单独对象。下面分别给出示例：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e单对象形式\u003c/strong\u003e，对象字面量（like 字典），js 中反序列化获取之后就会得到一个对象，使用对象的方法去调用其中的属性即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026#34;squadName\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Super hero squad\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \t\u003cspan class=\"nt\"\u003e\u0026#34;homeTown\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Metro City\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \t\u003cspan class=\"nt\"\u003e\u0026#34;formed\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e2016\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \t\u003cspan class=\"nt\"\u003e\u0026#34;menbers\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t \t\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t \t\t\u003cspan class=\"nt\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Molecule Man\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t      \t\u003cspan class=\"nt\"\u003e\u0026#34;age\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e29\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t      \t\u003cspan class=\"nt\"\u003e\u0026#34;secretIdentity\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Dan Jukes\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t      \t\u003cspan class=\"nt\"\u003e\u0026#34;powers\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t      \t\t\u003cspan class=\"s2\"\u003e\u0026#34;Radiation resistance\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Turning tiny\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Radiation blast\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t      \t\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t \t\u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t \t\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t \t\t\u003cspan class=\"nt\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Madame Uppercut\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \t\t\u003cspan class=\"nt\"\u003e\u0026#34;age\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e39\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \t\t\u003cspan class=\"nt\"\u003e\u0026#34;secretIdentity\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Jane Wilson\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \t\t\u003cspan class=\"nt\"\u003e\u0026#34;powers\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t     \t\t\u003cspan class=\"s2\"\u003e\u0026#34;Million tonne punch\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Damage resistance\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Superhuman reflexes\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t  \t\t\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t \t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \t\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e数组多对象形式\u003c/strong\u003e,下面这种写法也是一种合法的 JSON，js 中反序列化获取后则会得到一个数组对象，使用下标去索引即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \u003cspan class=\"nt\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Molecule Man\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \u003cspan class=\"nt\"\u003e\u0026#34;age\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e29\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \u003cspan class=\"nt\"\u003e\u0026#34;secretIdentity\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Dan Jukes\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \u003cspan class=\"nt\"\u003e\u0026#34;powers\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Radiation resistance\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Turning tiny\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Radiation blast\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \u003cspan class=\"nt\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Madame Uppercut\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \u003cspan class=\"nt\"\u003e\u0026#34;age\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e39\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \u003cspan class=\"nt\"\u003e\u0026#34;secretIdentity\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Jane Wilson\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \u003cspan class=\"nt\"\u003e\u0026#34;powers\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t     \u003cspan class=\"s2\"\u003e\u0026#34;Million tonne punch\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t     \u003cspan class=\"s2\"\u003e\u0026#34;Damage resistance\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t     \u003cspan class=\"s2\"\u003e\u0026#34;Superhuman reflexes\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t   \u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e同时 JSON 还有以下的一些编写规范：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e纯数据，只包含属性不包含方法；\u003c/li\u003e\n\u003cli\u003e要求字符串和属性名称使用双引号，单引号无效；\u003c/li\u003e\n\u003cli\u003e错位的 \u003ccode\u003e,\u003c/code\u003e 和 \u003ccode\u003e;\u003c/code\u003e 都可能导致 json 文件出错，要做好检查，可以使用\u003ca href=\"https://jsonlint.com/\" target=\"_blank\" rel=\"noopener\"\u003eJSONLint\u003c/a\u003e\n  这样的程序来验证；\u003c/li\u003e\n\u003cli\u003eJSON 实际上可以使任何可以有效包含在 JSON 中的数据类型的形式，例如，单个字符串或者单个数字也是一个有效的 JSON 对象；\u003c/li\u003e\n\u003c/ol\u003e","title":"LearnWeb20-JS05-JSON使用"},{"content":"\rSummary\rJS 中的一切变量皆为对象，可以将对象理解为一个包含相关数据和方法的集合（变量 \u0026amp; 函数）我们也将其称之为属性和方法，就像我们在 python 里做的那样，本篇为 mdn_JS对象基础 ，mdn_JS对象原型 的阅读笔记\n如果 面向对象编程基本概念 不太清楚的话，可以看一下这个链接，了解一下下面这些基本概念：derive 派生 | oriented 面向 | polymorphism 多态 | override 重写/重载 | encapsulation 封装 | private 私有 | delegation 委派 |\n从声明对象开始 手动声明对象（字面量） 在 JS 中声明一个对象实际上和声明一个字典一样，使用 {} 就可以声明一个对象，{}中可以包含属性甚至函数，下面给出一个例子：\n1 2 3 4 5 6 7 8 9 10 const person = { name: [\u0026#34;aiken\u0026#34;, \u0026#34;metis\u0026#34;], age: 26, bio: function () { console.log(`${this.name[0]} ${this.name[1]} now is ${this.age} years old`); } introduce() { console.log(`hello! i\u0026#39;m ${this.name[0]}.`); } } 可以看出该声明的对象中，不仅包含属性: name, age, 还包含方法 bio, introduce,可以看出方法存在两种不同的写法，更常用的是第二种简写。\n这种手动写出对象的内容来创建的特定对象叫做对象字面量(object literal)，与从定义好的类实例化出来的对象不同。\n基于函数来批量声明对象 当我们需要批量创建多个同类对象的时候，按照上面的方法来定义就会显得十分麻烦，这个时候我们可以使用函数来批量声明对象。\n1 2 3 4 5 6 7 8 9 10 11 12 function createPerson(name, age) { const obj = {}; obj.name = name; obj.age = age; obj.bio = function(){ console.log(`${this.name} now is ${this.age} years old`); }; return obj; } const aiken = createPerson(\u0026#39;aiken\u0026#39;,\u0026#39;26\u0026#39;); const metisy = createPerson(\u0026#39;metis\u0026#39;, \u0026#39;25\u0026#39;); 通过函数来声明对象的时候：用首先定义一个空对象，然后去修改对象属性和对象的方法，实现批量处理。\n\u0026ldquo;this\u0026rdquo; 使用和含义 this 指代代码运行时调用 this 的对象本身，这在定义单个对象字面量的时候可能没什么用，但是当我们有多个对象，这样这种时候通过使用 this，就可以使得函数定义是更通用的，就像上面的例子中，aiken.bio 和 metisy.bio 都能正确的打印出其年纪和名称。\n使用类(构造函数)来声明对象 使用类来声明对象是各种编程语言中最通用的一种声明对象的方式，JS 一切皆为对象的设计思想，使得 JS 中定义类的方式和定义函数的方式实际上是十分相似的，这里主要的区分在于用构造函数声明新对象的时候，我们使用 new 关键字。下面给出一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 function Person(name, age) { // 命名类的时候和其他语言一样，使用大写字母开头。 this.name = name; this.age = age; this.bio = function(){ console.log(`${this.name} now is ${this.age} years old`); }; } const aiken = new Person(\u0026#39;aiken\u0026#39;, 26); const metis = new Person(\u0026#39;metis\u0026#39;, 25); 可以看出，使用构造函数的方式的时候，我们无需指定返回值，但需要使用 new 关键词去声明新的对象。\n对象属性和方法的访问和修改 Summary\r调用对象的属性和方法主要有两种方式：点访问法和括号访问法；两种方式在大多数情况下是通用的，但是诸如希望遍历其中的属性，或者说要访问的属性是一个不确定的变量的时候，这种时候只能使用括号访问法。\n访问对象成员 这里我们以上文的 Person 类构造出来的对象 aiken 为例，当我们需要访问其中的属性值或者方法的时候：\n点表示法：console.log(aiken.name) 这里的对象可以按照一个命名空间去理解，选择 aiken 命名空间中的 name 变量； 括号表示法：console.log(aiken['name']) 就像字典/数组一样去访问其中的属性； 通常而言但就对象属性访问而言，点表示法是更通用优雅的一种，而括号表示法主要在我们希望访问一个不确定的属性的时候，使用变量存储要访问的字段的情况；\n1 2 3 4 5 6 function classFactor(attrName) { console.log(aiken[attrName]); } classFactor(\u0026#34;name\u0026#34;); // 访问aiken的name classFactor(\u0026#34;age\u0026#34;); // 访问aiken的age 这种情况也经常用于交互场景，通过 UI 设置对应的属性名称和属性值；\n1 2 3 let myDataName = nameInput.value; let myDataValue = nameInput.value; aiken[myDataName] = myDataValue; 对象成员设置 通过上述的访问对象成员的方法，我们可以获取到一个对象的任一成员（属性、方法），可以通过简单的赋值符号 = 去修改（更新）改成员。\n1 2 aiken.age = \u0026#39;27\u0026#39;; aiken[\u0026#39;age\u0026#39;] = \u0026#39;28\u0026#39;; 也可以用同样的操作去创建新的成员（属性、方法）\n原型与继承 Summary\r原型实际上就是别的语言中所说的\u0026quot;基类\u0026quot;或者\u0026quot;父类\u0026quot;，js 的继承方法和其他语言中我们熟悉的方法有所不同，这里需要注意区分。\nJS 中的继承和其他语言一样，会继承父类中的属性和方法，当我们在调用的时候还是沿着继承的链条逐渐查询的（先子，后父），这里就不在赘言。\n一些基础特性 开始学习原型与继承 之前，这里要介绍两个后面会比较常用到的小特性：\n第一个特性是，使用 Object.getPrototypeOf 函数可以获取到对应对象的原型，这个时候结合一个 do\u0026hellip;while 循环我们就可以打印出整条原型链。\n1 2 3 4 5 6 7 8 9 function getPrototypeLink(object) { do{ object = Object.getPrototypeOf(object); console.log(object); }while(object); } // 当找不到原型的时候就会返回unll终止循环 // 通常而言最基础的原型是Object.prototype,所有的对象都会默认拥有它，再往前就是null 第二个特性是，定义完一个对象，例如 Person,这个时候在控制台键入\n1 person. 控制台会将对象可用的一系列属性列出，该特性可以用来检查继承的发生与否，以及情况；同时可以发现，除了我们定义的各种属性之外，还有一些隐式继承至默认原型的属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 __defineGetter__ __defineSetter__ __lookupGetter__ __lookupSetter__ __proto__ city constructor greet hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf 其中像是 toString 或者 valueOf 这些方法，可以适当的去了解下，后面用到的情况可能会比较多。\n可以发现 JS 中所有的对象都有一个内置属性 __proto__ ，该属性指向我们对象的原型（父类），通常用 Object.getPrototypeOf 去获取对应的对象，同样如果修改/指定该属性的值，在 js 中，就是继承操作，这个后续进行讲解。\n属性遮蔽 当对象和其原型同时定义了同名的属性，在访问该属性的时候，首先会在对象本身的命名空间中进行搜索，当搜索不到的时候才会去搜索父类，因此这个时候对象的这个属性就对原型中的对应属性出现了遮蔽；\n设置原型（类似继承） JS 中设置原型有几种不同的方式，包括使用 Object.create() 和使用构造函数的方式；\nObject.Create Object.create(ptorotype-object) 方法可以创建一个新的对象，并允许指定一个用作新对象原型的对象。\n1 2 3 4 5 6 7 8 const personPrototype = { greet(){ console.log(\u0026#34;hello!\u0026#34;); } } const aiken = Object.create(personPrototype); aiken.greet(); // hello! 使用构造函数 JS 中，所有的函数都有一个 prototype 属性，当调用一个函数作为构造函数时（即使用 new）这个属性本身会被设置为新构造对象的原型（按照惯例会存在 __proto__ 的属性中），因此，如果设置构造函数的 prototype 属性到某个原型上，就能确定构造出来的新的对象都会继承该原型。\n具体的操作如下, 这里沿用上述的 personPrototype 来做说明。\n1 2 3 4 5 6 7 function Person(name){ this.name = name; } Object.assign(Person.prototype, personPrototype); const aiken = new Person(\u0026#39;aiken\u0026#39;); aiken.greet(); 这也解释了为什么我们查找原型的时候，总会在原型的名称后面加上 .prototype，在上述的对象 aiken 中，自身特有的属性叫做自有属性，可以使用 Object.hasOwn(obj, attr) 检查 attr 是不是 obj 的自有属性。\n1 2 Object.hasOwn(aiken, \u0026#34;name\u0026#34;); // true Object.hasOwn(aiken, \u0026#34;greet\u0026#34;); // false; JS 面向对象编程的特点 面向对象编程基本概念 这一文中除了对整个面向对象编程的基本概念有讲解，也说明了 JS 的面向对象编程的特点，建议阅读，简单一点：\n其他大多语言都是基于类的面向对象编程，对象必须有类创建出来，两者是不同的概念，定义类和实例化对象的方法是不同的，而 js 从创建对象字面量的方式就可以知道，JS 无需类就可以创建对象（类本身也会是一个对象）. 基于(类本身也是一个对象)这个假定，就可以发现，原型链和继承有一样的层级结构，但是本质上是不一样的，原型链实际上是一个链表，一个对象的原型实际上是另一个对象，之间通过 _proto_ 属性进行连接，这是一种委派。 但是整体在使用上，原型和 js 的构造函数可以基本上实现面向对象的编程特性，但是可能还不太够用，因此 JS 还提供了一些别的特性：参见下一节。\nJavaScript 中的类 Summary\r这里介绍的类实际上底层使用的仍然是原型，这是通过引入 class 的关键字来使创建原型链更加的便捷以及和其他语言对齐。\n1 2 3 4 5 6 7 8 9 10 11 12 class Person{ name; constructor(name){ this.name = name; } introduceSelf(){ console.log(`hi! I\u0026#39;m ${this.name}`); } } const aikenhong = new Person(\u0026#34;aikenhong\u0026#34;); aikenhong.introduceSelf(); 上面这个 JS 中的类的声明中有以下的几点：\n声明有 name 属性（可选，构造函数中使用 this 那行会在初始化 name 属性前自动创建它，但是列出来可以方便阅读） 一个需要 name 参数的构造函数 一个成员方法 也可以初始化默认值，就像 name = \u0026quot;\u0026quot;; ,构造函数使用 constructor 关键字来声明，这里的 new 创建新的对象的时候，就会创建新的对象，将 this 绑定到新的对象,执行 constructor 函数，返回新的对象。\n省略构造函数 如果不需要初始化什么变量，只需要提供基准方法，那就可以省略构造函数，这个会自动生成。\n继承 使用 extends 指定基类，实现继承，并用 super 调用父类的构造函数，然后覆盖父类的方法，并新增一个新的方法，例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Professor extends Person{ teaches; constructor(name, teaches){ super(name); this.teaches = teaches; } introduceSelf(){ console.log( `My name is ${this.name}, and i will be your ${this.teaches} profesor.` ); } grade(paper){ const grades = Math.floor(Math.random() * (5-1)+1); console.log(grades); } } const aiken = new Professor(\u0026#34;Aiken\u0026#34;, \u0026#34;CS\u0026#34;); 封装（私有变量和私有方法） 这一节主要就介绍一下怎么将对象和方法变成私有的，在命名之前添加 #\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Person { #name; constructor(name){ this.name = name; } introduceSelf(){ console.log(`my name is ${name}`); } #privateLogHead(){ console.log(\u0026#34;log head\u0026#34;); } publicLogHead(){ privateLogHead(); } } const examplePerson = new Person(); examplePerson.#name; // syntax error examplePerson.introduceSelf(); examplePerson.#privateLogHead(); // syntax error examplePerson.publicLogHead(); ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb19-js04-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003eJS 中的一切变量皆为对象，可以将对象理解为一个包含相关数据和方法的集合（变量 \u0026amp; 函数）我们也将其称之为属性和方法，就像我们在 python 里做的那样，本篇为 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Basics\" target=\"_blank\" rel=\"noopener\"\u003emdn_JS对象基础\u003c/a\u003e\n，\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes\" target=\"_blank\" rel=\"noopener\"\u003emdn_JS对象原型\u003c/a\u003e\n 的阅读笔记\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e如果 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_programming\" target=\"_blank\" rel=\"noopener\"\u003e面向对象编程基本概念\u003c/a\u003e\n 不太清楚的话，可以看一下这个链接，了解一下下面这些基本概念：derive 派生 | oriented 面向 | polymorphism 多态 | override 重写/重载 | encapsulation 封装 | private 私有 | delegation 委派 |\u003c/p\u003e\n\u003ch2 id=\"从声明对象开始\"\u003e从声明对象开始\u003c/h2\u003e\n\u003ch3 id=\"手动声明对象字面量\"\u003e手动声明对象（字面量）\u003c/h3\u003e\n\u003cp\u003e在 JS 中声明一个对象实际上和声明一个字典一样，使用 \u003ccode\u003e{}\u003c/code\u003e 就可以声明一个对象，{}中可以包含属性甚至函数，下面给出一个例子：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003eperson\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;aiken\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;metis\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eage\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e26\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ebio\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e \u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e now is \u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eage\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e years old`\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eintroduce\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"sb\"\u003e`hello! i\u0026#39;m \u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e.`\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e可以看出该声明的对象中，不仅包含属性: name, age, 还包含方法 bio, introduce,可以看出方法存在两种不同的写法，更常用的是第二种简写。\u003c/p\u003e\n\u003cp\u003e这种手动写出对象的内容来创建的特定对象叫做对象字面量(object literal)，与从定义好的类实例化出来的对象不同。\u003c/p\u003e\n\u003ch3 id=\"基于函数来批量声明对象\"\u003e基于函数来批量声明对象\u003c/h3\u003e\n\u003cp\u003e当我们需要批量创建多个同类对象的时候，按照上面的方法来定义就会显得十分麻烦，这个时候我们可以使用函数来批量声明对象。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ecreatePerson\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eage\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003eobj\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eage\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eage\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ebio\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kd\"\u003efunction\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e now is \u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eage\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e years old`\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003eaiken\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecreatePerson\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;aiken\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;26\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003emetisy\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecreatePerson\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;metis\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;25\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e通过函数来声明对象的时候：用首先定义一个空对象，然后去修改对象属性和对象的方法，实现批量处理。\u003c/p\u003e\n\u003ch3 id=\"this-使用和含义\"\u003e\u0026ldquo;this\u0026rdquo; 使用和含义\u003c/h3\u003e\n\u003cp\u003ethis 指代代码运行时调用 this 的对象本身，这在定义单个对象字面量的时候可能没什么用，但是当我们有多个对象，这样这种时候通过使用 this，就可以使得函数定义是更通用的，就像上面的例子中，\u003ccode\u003eaiken.bio\u003c/code\u003e 和 \u003ccode\u003emetisy.bio\u003c/code\u003e 都能正确的打印出其年纪和名称。\u003c/p\u003e\n\u003ch3 id=\"使用类构造函数来声明对象\"\u003e使用类(构造函数)来声明对象\u003c/h3\u003e\n\u003cp\u003e使用类来声明对象是各种编程语言中最通用的一种声明对象的方式，JS 一切皆为对象的设计思想，使得 JS 中定义类的方式和定义函数的方式实际上是十分相似的，这里主要的区分在于用构造函数声明新对象的时候，我们使用 \u003ccode\u003enew\u003c/code\u003e 关键字。下面给出一个例子：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ePerson\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eage\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"c1\"\u003e// 命名类的时候和其他语言一样，使用大写字母开头。\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eage\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eage\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ebio\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kd\"\u003efunction\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e now is \u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eage\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e years old`\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003eaiken\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003ePerson\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;aiken\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e26\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003emetis\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003ePerson\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;metis\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e25\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e可以看出，使用构造函数的方式的时候，我们无需指定返回值，但需要使用 new 关键词去声明新的对象。\u003c/p\u003e","title":"LearnWeb19-JS04-类与对象"},{"content":"\rSummary\rweb-js 中主要的编程方式就是需要结合browser 的事件和属性来实现对页面的动态控制，事件章节可以说是web 动态编程中的核心部分了，了解主要存在和需要被控制的事件是相当重要的。\n常见的浏览器事件 下面列出一些常见的事件类型和具体事件，更多的事件可以参考Mdn ，在设计页面的时候可以考虑我们希望获得什么效果来找寻是否有对应的事件来构建对应的动态响应。\n事件类型 具体事件 鼠标事件 点击、选择、悬停、拖拽、滚轮、焦点(focus, blur) 键盘事件 按键、剪切板、文本输入 窗口事件 调整大小、窗口关闭 页面事件 加载结束、错误发生、CSS 变换、DOM 事件 自定义事件 点击按钮，表单提交 多媒体事件 视频播放、暂停、结束 在确定了事件之后，就需要对事件附加一个事件处理器（监听器），当事件触发的时候，运行指定的js 代码对该事件做出相应。\n事件处理器 Summary\r通常而言，我们使用特定的 element 调用 addEventListener(event, function) 添加一个事件监听器，当参数中指定的事件 event 在对应元素上发生，就调用对应的 function 执行相应的变动，如果不是通用的函数，这里经常可以看到使用匿名函数去定义对应的操作。\n添加事件处理器 因此对于一个事件而言，实际上包含的操作有以下的几个：找到 DOM 中要操作的对应元素、添加事件监听器、选择对应的事件、定义对应的操作函数；\n1 const btn = document.querySelector(\u0026#34;button\u0026#34;); 1 2 3 4 5 6 7 8 function random(number) { return Math.floor(Math.random() * (number + 1)); } function changeBackground() { const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`; document.body.style.backgroundColor = rndCol; } 1 btn.addEventListener(\u0026#34;click\u0026#34;, changeBackground); 可以为同一个事件设置多个处理器，也就是添加多个 function，对于添加事件来说其中 addEventListener 是最为通用的，可以绑定多种事件，不过除了 addEventListener 之外，还有一些特殊事件的添加监听的方法，例如 click 事件有一个内联的监听器：onclick。\n1 btn.onlick = changeBackground; 虽然有一些示例在 html 中绑定事件内联，但是最好还是分开在 js 中绑定更好。\n移除监听器 如果使用 addEventListener 添加了一个事件处理器，可以使用 removeEventListener(event, function) 方法将该监听器删除，同样要使用对应的 element ，event，function。\n也可以对元素调用 abort 移除与该元素相关的所有事件处理器：\n1 element.abort(); 事件对象 有时候在事件处理函数内部，有时候会看到一些固定名称的参数，例如 event，evt，e 这些是事件对象，它会自动传递给事件处理函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 const btn = document.querySelector(\u0026#34;button\u0026#34;); function random(number) { return Math.floor(Math.random() * (number + 1)); } function bgChange(e) { const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`; e.target.style.backgroundColor = rndCol; console.log(e); } btn.addEventListener(\u0026#34;click\u0026#34;, bgChange); 例如上文中的 e 指的是事件对象，e.target 指的是这个按钮本身，类似的大多数事件对象都会有一些额外的属性和方法可供使用，这个可以参考 event-object ，找到对应 event 的事件对象的属性。\n阻止默认行为 最常见的是 web 表单，当用户输入的内容不符合 format 的时候，我们希望直接阻止默认提交行为，不将其提交到服务器去处理。\n1 2 3 4 5 6 form.addEventListener(\u0026#34;submit\u0026#34;, (e) =\u0026gt; { if (fname.value === \u0026#34;\u0026#34; || lname.value === \u0026#34;\u0026#34;) { e.preventDefault(); para.textContent = \u0026#34;You need to fill in both names!\u0026#34;; } }); 事件行为/传播逻辑 事件冒泡 1 2 3 \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;button\u0026gt;点我！\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 以上述 DOM 为例，当我们点击 btn 的时候，btn、div、body 会依次冒泡触发 click 事件；\n这种冒泡有时候会因为函数之间的冲突导致一些不希望出现的问题，这种时候我们可以对事件传递一个阻止冒泡的元素方法 stopPropagation，防止其继续向父级冒泡。\n1 2 3 4 video.addEventListener(\u0026#34;click\u0026#34;, (event) =\u0026gt; { event.stopPropagation(); video.play(); }); 事件捕获 事件传播的另一种形式是事件捕获，这个就像事件冒泡，但是顺序是相反的，也就是从最外层逐渐到最里层的形式，但是需要在 addEventListener() 的 capture 选项中启用它，这样的顺序就会是完全相反的。\n1 2 3 4 5 6 7 8 9 10 11 const output = document.querySelector(\u0026#34;#output\u0026#34;); function handleClick(e) { output.textContent += `你在 ${e.currentTarget.tagName} 元素上进行了点击\\n`; } const container = document.querySelector(\u0026#34;#container\u0026#34;); const button = document.querySelector(\u0026#34;button\u0026#34;); document.body.addEventListener(\u0026#34;click\u0026#34;, handleClick, { capture: true }); container.addEventListener(\u0026#34;click\u0026#34;, handleClick, { capture: true }); button.addEventListener(\u0026#34;click\u0026#34;, handleClick); 例如上面的这串代码，有capture 和没有的顺序是完全相反的。\n事件委托 上述的事件冒泡和事件捕获的一个应用，例如，我们将页面划分成n 个区域，希望每个区域都支持在点击后随机设置其背景颜色，\n1 2 3 4 5 6 \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 但我们显然不希望对每个子元素都进行一次绑定，尤其是子元素的数量多起来以后，因此，更简单的是我们对父元素设置事件处理器，然后基于事件冒泡来确认用户点击每个区域时函数被执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function random(number) { return Math.floor(Math.random() * number); } function bgChange() { const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`; return rndCol; } const container = document.querySelector(\u0026#34;#container\u0026#34;); container.addEventListener(\u0026#34;click\u0026#34;, (event) =\u0026gt; { event.target.style.backgroundColor = bgChange(); }); 备注： 在这个例子中，我们使用 event.target 来获取事件的目标元素（也就是最里面的元素）。如果我们想访问处理这个事件的元素（在这个例子中是容器），我们可以使用 event.currentTarget。\n可以去这里 link 查看对应效果，理解以下这个事件是怎么发生的，其实最关键的是 target 和currentTarget 的区分 ，简单的讲：\ntarget 是实际触发事件的元素 currentTarget 始终是绑定监听器的元素。 ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb18-js03-%E4%BA%8B%E4%BB%B6/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003eweb-js 中主要的编程方式就是需要结合browser 的事件和属性来实现对页面的动态控制，事件章节可以说是web 动态编程中的核心部分了，了解主要存在和需要被控制的事件是相当重要的。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"常见的浏览器事件\"\u003e常见的浏览器事件\u003c/h2\u003e\n\u003cp\u003e下面列出一些常见的事件类型和具体事件，更多的事件可以\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/Events\" target=\"_blank\" rel=\"noopener\"\u003e参考Mdn\u003c/a\u003e\n，在设计页面的时候可以考虑我们希望获得什么效果来找寻是否有对应的事件来构建对应的动态响应。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e事件类型\u003c/th\u003e\n          \u003cth\u003e具体事件\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e鼠标事件\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e点击、选择、悬停、拖拽、滚轮、焦点(focus, blur)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e键盘事件\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e按键、剪切板、文本输入\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e窗口事件\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e调整大小、窗口关闭\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e页面事件\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e加载结束、错误发生、CSS 变换、DOM 事件\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e自定义事件\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e点击按钮，表单提交\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e多媒体事件\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e视频播放、暂停、结束\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e在确定了事件之后，就需要对事件附加一个\u003cstrong\u003e事件处理器（监听器）\u003c/strong\u003e，当事件触发的时候，运行指定的js 代码对该事件做出相应。\u003c/p\u003e\n\u003ch2 id=\"事件处理器\"\u003e事件处理器\u003c/h2\u003e\n\r\n\r\n\r\n  \r\n  \r\n\r\n\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e通常而言，我们使用特定的 \u003ccode\u003eelement\u003c/code\u003e 调用 \u003ccode\u003eaddEventListener(event, function)\u003c/code\u003e 添加一个事件监听器，当参数中指定的事件 \u003ccode\u003eevent\u003c/code\u003e 在对应元素上发生，就调用对应的 \u003ccode\u003efunction\u003c/code\u003e 执行相应的变动，如果不是通用的函数，这里经常可以看到使用匿名函数去定义对应的操作。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch3 id=\"添加事件处理器\"\u003e添加事件处理器\u003c/h3\u003e\n\u003cp\u003e因此对于一个事件而言，实际上包含的操作有以下的几个：找到 DOM 中要操作的对应元素、添加事件监听器、选择对应的事件、定义对应的操作函数；\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ebtn\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003equerySelector\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;button\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003erandom\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003enumber\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003eMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003efloor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003erandom\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003enumber\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003echangeBackground\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003erndCol\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"sb\"\u003e`rgb(\u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nx\"\u003erandom\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e255\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e, \u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nx\"\u003erandom\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e255\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e, \u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nx\"\u003erandom\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e255\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"sb\"\u003e)`\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nb\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ebody\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003estyle\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ebackgroundColor\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003erndCol\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ebtn\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eaddEventListener\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;click\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003echangeBackground\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e可以为同一个事件设置多个处理器，也就是添加多个 function，对于添加事件来说其中 \u003ccode\u003eaddEventListener\u003c/code\u003e 是最为通用的，可以绑定多种事件，不过除了 \u003ccode\u003eaddEventListener\u003c/code\u003e 之外，还有一些特殊事件的添加监听的方法，例如 click 事件有一个内联的监听器：\u003ccode\u003eonclick\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ebtn\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eonlick\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003echangeBackground\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e虽然有一些示例在 html 中绑定事件内联，但是最好还是分开在 js 中绑定更好。\u003c/p\u003e","title":"LearnWeb18-JS03-事件"},{"content":"JS 基础语法 该部分的学习除了 MDN 的相关知识，会结合数据结构的内容来进行学。\n语言的第一印象和 python 有许多相似的地方。语法上可能大差不差，在循环和其他一些变量上又有一些和 C#,CPP 相似的地方。\nBasic Rules 基础规则简介 首先介绍基本的编写规则:如注释、缩进规则、变量规则等\u0026hellip;\n注释：CPP 相同使用 // 和 /* */ 进行行/块注释。 句尾 ; ：单行单条语句结束可以无需 ; (但为了规范和明确可以加上)，同行多个语句可以用 ; 进行语句的区分。 变量 声明变量使用：var , let , const 三个关键词；其中 let 和 const 是相似的，用于声明块级作用域的局部变量，只有在声明的位置之后才能使用，唯一的区别在于 const 声明的常量不能用赋值运算符直接更改，（但如果是个对象，它的属性可以被添加、更新、删除）\n变量定义：(另起一个 Paragraph 表示尊重) JS 为非强类型语言(即类似 python 而非 cpp)，为动态类型语言，变量声明无需指定类型。但有以下几个注意的事项：\n（不推荐）不带关键字的变量声明会默认为全局变量。 （推荐）可以使用 let 或 var 关键字定义变量。 （最推荐）最推荐使用 let 进行变量的声明，var 对变量定义位置的要求更低，使用 var 编写可能会方便，但是在后续维护和阅读中可能会体验很差。使用 let 然后和别的语言一样声明和使用变量。 可以使用 typeof 来检查变量类型 其中对于变量的定义上，Var 和 let 的详细差别可以参考 var与let的区别 ，var变量提升 ，简单的讲 var 的定义会先于所有的语句执行，声明一个全局的变量。下面简单介绍一下各种不同的数据类型：\n对象：JavaScript 里一切皆对象，一切皆可储存在变量里。这一点要牢记于心，字典也是一种对象，定义方式和 Python 一致：\n1 2 let dog = { name: \u0026#34;Spot\u0026#34;, breed: \u0026#34;Dalmatian\u0026#34; }; dog.name // 访问name属性。 数值： JS 只有一种数值类型 Number，不需要像 cpp 执行 int 和 float 之类的转换，说到数值类型，就需要对基本的运算符进行说明，这里简单列一下支持的一些运算符类型\nIdx Col1 Col2 Col3 Col4 Col5 Colo6 基础 + - * / % ** 自增自减 *= (var)++ (var)\u0026ndash; += -= /= 比较 !== === \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 基本运算符：和大多数语言的基本运算符保持一致，这里需要特殊说明的只有相等的判断符，区别于其他语言，JS 中使用三个等号来判断相等；\n1 2 if a == b: print(\u0026#34;a is equal to b\u0026#34;) 1 2 3 4 if (a === b) { console.log(\u0026#34;a is equal to b\u0026#34;); } 这里的函数定义和条件判断都更接近 cpp，使用{}将代码块来区分，而非单纯使用缩进。\n字符串：JS 中字符串的定义方式支持使用 \u0026quot;\u0026quot;、'' ，这和其他语言的支持是类似的，如果字符串中需要使用引号，也可以使用 \\ 进行转义，同时字符串支持 + 进行拼接。\n此外，JS 还支持使用 ``反引号来包裹字符串，使用反引号的时候就可以很容易的在字符串中包含引号；而这不是反引号字符串最重要的特性，该反引号字符串的使用更类似于 shell 语言：\n使用反引号的字符串时，可以利用 ${} 符号来包装变量和表达式。 1 2 3 const output = `我喜欢歌曲《${song}》。我给它打了 ${ (score / highestScore) * 100 } 分。`; 上面这是一个很典型的嵌入了表达式的情况，这种方式能够很方便的进行变量之间的交互，也具备比较好的可读性（如果变量命名的比较科学的话），此外反引号还具备以下的特性：\n多行表达可以直接换行，无需如 \u0026quot;\u0026quot; 等方式定义的字符串，需要嵌入 \\n 转义的换行符 使用 ${sub}:$ {value}:${pos} 进行字符串拼接的可读性通常\u0026gt;= 使用 + 进行字符串拼接 介绍完了字符串的定义，介绍一下字符串的相关操作：\n首先，字符串可以使用 string[idx] 去获取字符串中 idx 的字符； 其次，字符串本身实际上也是一个对象类型，我们可以使用 obj.method 调用对应的字符串方法，这点和其他语言是一致的，无需多言，下面列出一些常用的字符串函数。 IDX Col 1 Col 2 Col3 1 .length .indexOf() 找到对应字符(串)的下标 .slice(start, end) 2 .toLowerCase() .toUpperCase() .replace(old, new) 可以看出，字符串实际上和数组类型避不开亲属关系，下面就介绍一下数组 数组：Python 一样可以存储多种类型在一个 Array 中，同样使用 array[idx] 访问对应 idx 的元素，使用 .length 获取数组的长度，通常用于循环中。\n支持 push , pop 在数组末尾增加或删除元素，pop 会返回刚删除的元素； 支持 unshift，shift 在数组前面添加和删除元素； 数组和字符串转换: 使用 split 从 string 到 array，使用 joint(\u0026lsquo;符号\u0026rsquo;) 从 array 到指定符号链接的字符串，或者使用 toString()使用默认符号链接成字符串\n1 2 3 4 let myStringData = \u0026#34;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\u0026#34;; let myArrayString = myStringDate.split(\u0026#34;,\u0026#34;); let StringAgain = myArrayString.join(\u0026#34;-\u0026#34;); StringAgain = myArrayString.toString(); Function 函数 JS 的函数关键字和 Shell 的一样只需要使用 function 即可，实际上和 CPP 也是一样的只是无需指定类型。\n1 2 3 4 5 6 7 8 function multipy(a, b) { let result = a + b; return reuslt; } let res = multipy(3, 5); console.log(res); 有趣的地方在于 JS 的类也是用 function 定义的，这可能是由于一切皆为对象这个特性，所谓函数可能实际上是一个只有单个调用结构的类。并没有作区分。\n定义默认参数：默认参数和可选参数是息息相关的，当我们定义了默认的参数，这个参数就可以选择性的不赋值，通过默认参数去赋值。\n1 2 3 4 5 6 function hello(name=\u0026#34;aiken\u0026#34;){ console.log(`hello ${name}!`); } hello(\u0026#39;aikenhong\u0026#39;); hello(); 匿名函数和箭头函数 当有些函数我们并不打算复用，或者当一些函数希望接受另一个函数作为参数时，我们经常会看到匿名函数的使用，匿名函数经常用于这种函数作为参数的场景，这种场景下也经常使用箭头函数的写法来定义这个匿名函数。\n匿名函数的基本定义方法如下：\n1 2 3 textBox.addEventListener(\u0026#34;keydown\u0026#34;, function (event) { console.log(`You pressed \u0026#34;${event.key}\u0026#34;.`); }); 通常使用箭头函数的写法去实现这样的匿名函数\n1 2 3 textBox.addEventListener(\u0026#34;keydown\u0026#34;, (event) =\u0026gt; { console.log(`You pressed \u0026#34;${event.key}\u0026#34;.`); }); 如果只给匿名函数传入一个参数的时候，该参数两侧的圆括号可以省略\n1 2 3 textBox.addEventListener(\u0026#34;keydown\u0026#34;, event =\u0026gt; { console.log(`You pressed \u0026#34;${event.key}\u0026#34;.`); }); 甚至如果只有一个 return 的时候还能省略外层的大括号\n1 2 3 textBox.addEventListener(\u0026#34;keydown\u0026#34;, event =\u0026gt; console.log(`You pressed \u0026#34;${event.key}\u0026#34;.`), ); 函数本身的作用域仅存在于内部，函数外面的都是全局作用域，\nEvent 事件 接下来我把用于 web 开发的 javascript 用 web-js 代称用来区分服务端的 js，服务端的 js 我直接用 nodejs 代称好了。\n在 web-js 中，与事件的交互应该是最为关键的一个环节了，通过浏览器和用户触发的各种事件（如点击，页面滚动，页面跳转）来触发 js 中编写的一个个行为，正是所谓赋予网页动态交互特性。\n可以复习 LearnWeb00-Web入门 中 How JavaScript Works 中讲到的原生异步处理机制，此处有使用 windows 监听的。\n下面引一个 MDN 中的例子做一些简单的说明：\n1 2 3 document.querySelector(\u0026#34;html\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { alert(\u0026#34;别戳我，我怕疼。\u0026#34;); }); 👍 这里有个有趣的匿名函数写法，使用 () =\u0026gt; {} 定义一个匿名函数，实际上也可以用下面这个完整的表达方式：\n1 2 3 document.querySelector(\u0026#39;html\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { alert(\u0026#34;别戳我\u0026#34;); }) 此处的例子可解释为：使用 document（DOM）接口中的 querySelector 选择 html 元素添加对于 click 时间的监听，并在监听到点击行为的时候弹出别戳我的弹窗。\nSelector 可以参考 HTML 部分选择器的含义去理解，具体可选择可能还是要参考 DOM API 中的说明，但是理论上应该会和 HTML 中的定义方式保持一致。\n例子 2 监听图片点击事件，切换背景图片，这里有两种写法和重要的 API 函数 getAttribute 和 setAttribute。\n写法一：使用图片变量的 OnClick 事件（这里说明了变量本身是会携带一些事件定义，并非只有 AddListner 一种监听）\n1 2 3 4 5 6 7 8 9 10 11 ele_img.onclick = function() { let src = ele_img.getAttribute(\u0026#34;src\u0026#34;); if (src === \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/80a5366f89dfbd27ec46f669e0eac84.jpg\u0026#34;) { ele_img.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005005911.png\u0026#34;); } else { ele_img.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/80a5366f89dfbd27ec46f669e0eac84.jpg\u0026#34;); } }; 写法二：使用原本的事件监听方法：\n1 2 3 4 5 6 7 8 9 10 11 ele_img.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { let src = ele_img.getAttribute(\u0026#34;src\u0026#34;); if (ele_img.src === \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/80a5366f89dfbd27ec46f669e0eac84.jpg\u0026#34;) { ele_img.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005005911.png\u0026#34;); } else { ele_img.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/80a5366f89dfbd27ec46f669e0eac84.jpg\u0026#34;); } }); 写法三：将具体函数内容独立出去为 ImgSwitch，这里直接调用函数名\n1 ele_img.addEventListener(\u0026#34;click\u0026#34;, ImgSwitch); 也可放在匿名函数或者函数里：\n1 2 3 ele_img.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { ImgSwitch(); ); 例子三 HTML 中添加 Button，CSS 对 Button 简单渲染，然后 JS 中添加输入事件，HTML 和 CSS 部分不在赘述。\nbutton 同样可以使用 onclick 事件来监听点击。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let ele_button = document.querySelector(\u0026#34;button\u0026#34;); ele_button.onclick = () =\u0026gt; { addUserName(); } function addUserName() { let name = prompt(\u0026#34;请输入您的姓名：\u0026#34;); let message = \u0026#34;欢迎您，\u0026#34; + name + \u0026#34;/\u0026#34;; localStorage.setItem(\u0026#34;name\u0026#34;, name); Heading.textContent = message; } if (!localStorage.getItem(\u0026#34;name\u0026#34;)) { Heading.textContent = \u0026#34;欢迎您！\u0026#34;; } else { Heading.textContent = \u0026#34;欢迎您，\u0026#34; + localStorage.getItem(\u0026#34;name\u0026#34;) + \u0026#34;/\u0026#34;; } 这里主要是 prompt 可以唤出一个输入框，将信息输入 name 中 LocalStorage 将信息存到本地的浏览器中 然后最后的判断做一个初始化，如果浏览器中缓存有相关信息就直接输出，否则输入一个 default 值。 如何写入浏览器的缓存也是后续很重要的一个事情，有存储对于多次页面交互来说十分关键。\n后续章节 [[LearnWeb18-JS03-事件]] 会更详细的讲解事件相关的 JS 代码。\nLoop 循环 TYPE A B C 循环范式 for while do\u0026hellip;while 常见关键词 break continue For 循环 FOR 循环的方式和 cpp 比较相似，可以对列表直接进行循环，列表元素可以是 Obj 和 Dom 元素等。\n普通的 FOR 循环方式：\n1 2 3 4 const fruits = [\u0026#34;apples\u0026#34;, \u0026#34;bananas\u0026#34;, \u0026#34;cherries\u0026#34;]; for (let i = 0; i \u0026lt; fruits.length; i++){ console.log(fruit); } 类似 auto 的循环变体：\n1 2 3 4 const fruits = [\u0026#34;apples\u0026#34;, \u0026#34;bananas\u0026#34;, \u0026#34;cherries\u0026#34;]; for (const fruit of fruits) { console.log(fruit); } 例如下面的方式对 Dom 进行循环清空内容\n1 2 3 4 const resetParas = document.querySelectorAll(\u0026#34;.resultParas p\u0026#34;); for (const resetPara of resetParas) { resetPara.textContent = \u0026#34;\u0026#34;; } 这里的 querySelectorALL 是 querySelect 的延伸，找出.resultParas 中所有的 p 元素，并将其放于列表之中。\nfocus 是 input 的一个可用属性函数，可以将光标聚焦于输入框中，方便控制和减少用户的操作，善用 focus 切换关注的输入框能提升交互体验。\nJS 中 Continue 和 Break 的用法也和其他的语言一致，分别是跳过单词循环和跳出当前循环。\nWhile 循环 1 2 3 4 5 6 7 8 initializer while(condition) { // code run in while. // condition change statement. eg: i++; } do\u0026hellip;while 循环 1 2 3 4 5 6 7 initializer do { // code run in do ... while // condition change statement. eg: i++; } while(condition) 两种形式的 while 的区别就是在执行循环之前还是之后，判断当前是否满足条件。\nCondition 条件语句 JS 条件语句的语法和 CPP 基本一致，下面是 JS 的条件语句单元\n1 2 3 if (condition) {} else if (condition) {} else {} JS 中的与或非运算符如下：\nTitle 与 或 非 Operator \u0026amp;\u0026amp; || ! 条件语句中往往还会涉及到 switch 语句，对于需要很多个 if else 的场景，可能会更方便一些，switch 的模板如下：\n1 2 3 4 5 6 7 8 9 10 11 12 switch(expression){ case value1: LOGIC1 break; case value2: LOGIC2 break; default: LOGIC3 } default 不需要使用 break 跳出，如果没有hit 任何的value，就执行默认的逻辑块，switch 很多时候用于选择页面的选择框情况。\n1 2 3 4 5 6 7 \u0026lt;label for=\u0026#34;weather\u0026#34;\u0026gt;选择今天的天气：\u0026lt;/label\u0026gt; \u0026lt;select id=\u0026#34;weather\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;--作出选择--\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;sunny\u0026#34;\u0026gt;晴天\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;rainy\u0026#34;\u0026gt;雨天\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const select = document.querySelector(\u0026#34;select\u0026#34;); const para = document.querySelector(\u0026#34;p\u0026#34;); select.addEventListener(\u0026#34;change\u0026#34;, setWeather); function setWeather() { const choice = select.value; switch (choice) { case \u0026#34;sunny\u0026#34;: para.textContent = \u0026#34;阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\u0026#34;; break; case \u0026#34;rainy\u0026#34;: para.textContent = \u0026#34;外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\u0026#34;; break; default: para.textContent = \u0026#34;\u0026#34;; } } 对于一些简单的选择和条件判断的情况，也可以使用三元运算符来实现，和 CPP 一样是问号冒号表达式吧，从下面的 case 可以看出三元表达式非常时候在类似明亮和暗黑主题切换的场景中。\n1 2 3 4 5 select.addEventListener(\u0026#34;change\u0026#34;, () =\u0026gt; select.value === \u0026#34;black\u0026#34; ? update(\u0026#34;black\u0026#34;, \u0026#34;white\u0026#34;) : update(\u0026#34;white\u0026#34;, \u0026#34;black\u0026#34;), ); ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb17-js02-intro/","summary":"\u003ch2 id=\"js-基础语法\"\u003eJS 基础语法\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e该部分的学习除了 MDN 的相关知识，会结合数据结构的内容来进行学。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e语言的第一印象和 python 有许多相似的地方。语法上可能大差不差，在循环和其他一些变量上又有一些和 C#,CPP 相似的地方。\u003c/p\u003e\n\u003ch3 id=\"basic-rules-基础规则简介\"\u003eBasic Rules 基础规则简介\u003c/h3\u003e\n\u003cp\u003e首先介绍基本的编写规则:如注释、缩进规则、变量规则等\u0026hellip;\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e注释\u003c/strong\u003e：CPP 相同使用 \u003ccode\u003e//\u003c/code\u003e 和 \u003ccode\u003e/*  */\u003c/code\u003e 进行行/块注释。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e句尾\u003c/strong\u003e \u003ccode\u003e;\u003c/code\u003e ：单行单条语句结束可以无需 \u003ccode\u003e;\u003c/code\u003e (但为了规范和明确可以加上)，同行多个语句可以用 \u003ccode\u003e;\u003c/code\u003e 进行语句的区分。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"变量\"\u003e变量\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e声明变量使用：\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003evar\u003c/code\u003e\u003c/a\u003e\n, \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003elet\u003c/code\u003e\u003c/a\u003e\n, \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e\n 三个关键词；其中 \u003ccode\u003elet\u003c/code\u003e 和 \u003ccode\u003econst\u003c/code\u003e 是相似的，用于声明块级作用域的局部变量，只有在声明的位置之后才能使用，唯一的区别在于 \u003ccode\u003econst\u003c/code\u003e 声明的常量不能用赋值运算符直接更改，（但如果是个对象，它的属性可以被添加、更新、删除）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e变量定义：\u003c/strong\u003e(另起一个 Paragraph 表示尊重) JS 为非强类型语言(即类似 python 而非 cpp)，为\u003cstrong\u003e动态类型语言\u003c/strong\u003e，变量声明\u003cstrong\u003e无需指定类型\u003c/strong\u003e。但有以下几个注意的事项：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e（不推荐）不带关键字的变量声明会默认为全局变量。\u003c/li\u003e\n\u003cli\u003e（推荐）可以使用 \u003ccode\u003elet\u003c/code\u003e 或 \u003ccode\u003evar\u003c/code\u003e 关键字定义变量。\u003c/li\u003e\n\u003cli\u003e（最推荐）最推荐使用 \u003ccode\u003elet\u003c/code\u003e 进行变量的声明，var 对变量定义位置的要求更低，使用 var 编写可能会方便，但是在后续维护和阅读中可能会体验很差。使用 \u003ccode\u003elet\u003c/code\u003e 然后和别的语言一样声明和使用变量。\u003c/li\u003e\n\u003cli\u003e可以使用 \u003ccode\u003etypeof\u003c/code\u003e 来检查变量类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其中对于变量的定义上，Var 和 let 的详细差别可以参考 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Variables#var_%E4%B8%8E_let_%E7%9A%84%E5%8C%BA%E5%88%AB\" target=\"_blank\" rel=\"noopener\"\u003evar与let的区别\u003c/a\u003e\n，\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87\" target=\"_blank\" rel=\"noopener\"\u003evar变量提升\u003c/a\u003e\n，简单的讲 var 的定义会先于所有的语句执行，声明一个全局的变量。下面简单介绍一下各种不同的数据类型：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对象\u003c/strong\u003e：JavaScript 里一切皆对象，一切皆可储存在变量里。这一点要牢记于心，字典也是一种对象，定义方式和 Python 一致：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003edog\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Spot\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ebreed\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Dalmatian\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003edog\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ename\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 访问name属性。\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e数值：\u003c/strong\u003e JS 只有一种数值类型 Number，不需要像 cpp 执行 int 和 float 之类的转换，说到数值类型，就需要对基本的运算符进行说明，这里简单列一下支持的一些运算符类型\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003eIdx\u003c/th\u003e\n          \u003cth\u003eCol1\u003c/th\u003e\n          \u003cth\u003eCol2\u003c/th\u003e\n          \u003cth\u003eCol3\u003c/th\u003e\n          \u003cth\u003eCol4\u003c/th\u003e\n          \u003cth\u003eCol5\u003c/th\u003e\n          \u003cth\u003eColo6\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e基础\u003c/td\u003e\n          \u003ctd\u003e+\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n          \u003ctd\u003e*\u003c/td\u003e\n          \u003ctd\u003e/\u003c/td\u003e\n          \u003ctd\u003e%\u003c/td\u003e\n          \u003ctd\u003e**\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e自增自减\u003c/td\u003e\n          \u003ctd\u003e*=\u003c/td\u003e\n          \u003ctd\u003e(var)++\u003c/td\u003e\n          \u003ctd\u003e(var)\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e+=\u003c/td\u003e\n          \u003ctd\u003e-=\u003c/td\u003e\n          \u003ctd\u003e/=\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e比较\u003c/td\u003e\n          \u003ctd\u003e!==\u003c/td\u003e\n          \u003ctd\u003e===\u003c/td\u003e\n          \u003ctd\u003e\u0026lt;\u003c/td\u003e\n          \u003ctd\u003e\u0026gt;\u003c/td\u003e\n          \u003ctd\u003e\u0026lt;=\u003c/td\u003e\n          \u003ctd\u003e\u0026gt;=\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e基本运算符\u003c/strong\u003e：和大多数语言的基本运算符保持一致，这里需要特殊说明的只有\u003cstrong\u003e相等的判断符\u003c/strong\u003e，区别于其他语言，JS 中使用三个等号来判断相等；\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;a is equal to b\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e===\u003c/span\u003e \u003cspan class=\"nx\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;a is equal to b\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e这里的函数定义和条件判断都更接近 cpp，使用{}将代码块来区分，而非单纯使用缩进。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"LearnWeb17-JS02-Intro"},{"content":"\rSummary\r本篇读书笔记主要记录书中一些投资理财相关的概念、一些思维方式、一些典型的策略等等，用于自己后续理财的基础。\n“投资理财越早开始越好，无需拘泥于启动资金的多少，时间才是投资理财中最重要的增长因子”。\n财务自由 需要多少钱才能财富自由 4%法则（William Bengen）：通过投资一组资产，每年从退休金中提取不超过 4%的金额用来支付自己的生活所需，那么直到自己趋势，退休金都花不完。\n因此如果每年需要 40w 的开销，那么就需要超过 1000w 的资产来实现一个比较稳定的财富自由，按照自己每年的消费可以进行简单的换算。\n如何避免财富缩水 Summary\r财富缩水主要的原因就在于通货膨胀，对通货膨胀有所了解才能更好的从通货膨胀中保护自己的财富。\n很多时候通货膨胀看的是 CPI(居民消费价格指数)，最近几年国内的 CPI 同比增长一年为 2%~3%，也就是说物价每年上涨 2%~3%，但是实际上只看 CPI 是不够的，这是因为 CPI 实际上仅包含了必需消费，而如果要保证生活质量的水平不变，需要跑赢的是\u0026quot;可选消费通货膨胀率\u0026quot;。\n这是因为任何一个社会，优质的教育和医疗资源的价格增长速度是比较显著的高于 CPI 的，因此可选消费指数才是我们要跑赢的目标。而这个增长速度则通常和 M2 的增长速度相关。\nM2 是广义货币的量，代表社会广义货币的增长速度，最近三年的同比大概在 8%~9%，但是该指数并非完全和可选消费指数相等同。\n综合而言，我们通常需要考虑的膨胀指数应该介于 CPI 和 M2 增速之间，因此资产增值的速度应该在 3%~9%之间，才能避免财富缩水，如果考虑一些不稳定时局的原因，可能还要存一些避险资产例如黄金。\n通常来说，只要长期投资债券基金（包括相关的理财产品）是可以跑赢 CPI 的，债券通常的长期平均收益都在 6%上下，但若想要获得更高的收益可能就得上股票这种高风险高收益的了。\n定投 巴菲特：“通过定投指数基金，一个什么都不懂的业余投资者，往往能够战胜大部分的专业投资者”\n这里涉及到的两个概念：定投、指数基金后面均会有所解释，首先简单解释定投：\nSummary\r定投实际上就是定期投入的意思，定期的将资金转入某个能产生现金流的金融资产，五险一金实际上就是一种定投，每一个周期按照一定的规则投入一定的资金进行投资。\n定投能起到的一些小的作用是（这两点上我个人并不认为是什么作用）：①强制储蓄，克制穷人思维。②保值增值，避免人力资产贬值的风险。\n定投还有另外一个特性，是我认为定投最重要的一点：定投是一种被动投资理念，其希望我们不要去预测市场，因此坚持定投与我而言，我认为其最大的作用在于能够摒弃人的主观判断，抛弃自己能够准确判断短期市场涨跌的想法，来选择一种更稳妥的方式进行投资。\n定投要投资什么 Summary\r定投要投能带来现金流的资产\n这里我觉得资产这个说法还是比较容易混淆的，应该说定投要做能够带来现金流的投资，不过为了统一说法，后面还是用资产来进行说明；能够带来现金流则指的是，能够产生收益，产生额外的金钱，这就是现金流，比较拗口举个例子（以资产：现金流的形式）：\n债券：每年产生的利息，利息 房地产：租金 工作（我们这个人力）：工资 无法产生现金流的产品也是有的，例如：珠宝、艺术品、古董、甚至黄金（避险资产，特指经济和市局稳定下的黄金）\n有什么可以选择的投资项目 普通投资者在日常生活中能投资的产品按照性质通常可以分为：货币、债券、股票三类，可以选择直接投资这些资产，但是不同的品种的投资门槛有较大的差别，例如货币市场可能需要 500w 以上才能进入，部分股票一股的金额也比较高，部分债券的门槛也比较高。\n所以通常而言普通投资者这都会通过一些间接的金融产品来接触这三类金融产品，即：银行理财产品、股票基金；\n基金大部分只需要几十几百元即可投资，银行理财可能略高一些，但是大多都是普通投资者可以接受的。简单说明一下两者的特点\n银行的产品分为典型的储蓄，和理财：\n储蓄：活期/定期存储产品，利率较低，但是风险极低，长远来看也算是定存 理财：类似定期存储（周月年）但是有一些不一样的特点，①门槛相对较高②在特殊时点收益高（考核）③小银行的收益一般比大银行高（吸引用户） 收益：国有\u0026lt;商业\u0026lt;城商、农商行\u0026lt;信用社 风险与收益相反 城商级别就有一定的风险了（大城市除外） 一般期限越长收益率越高 通常而言，银行理财产品主要投资的为债券类品种，本身长期收益率在 4%~6%之间，比储蓄相对较高，但是不会高太多。\n基金则是我们最常接触到的投资工具，实际上就是基金公司给出一种投资方案，大家一起集资进行投资，通过拼团的方式，使得众多普通人能够以较低的门槛一起参加哪些门槛较高的投资活动，并基于该方案一损俱损一荣俱荣。\n基金投资有以下的特点：\n有基金经理专门管理（实际上理财产品发行商都会有），因此无需频繁操作 可以分散风险（资金池庞大，足够实现多种配比，实现个体户难以实现的分散投资） 降低投资门槛 接下来我们先对基金，也就是我们即将投资的内容要有更清楚的认知后才能更好的去选择和投资。\n基金 基金的交易方式 Summary\r对于普通投资者来说，常见的交易基金的方式主要有两种：申购赎回和买入卖出\n申购基金：向基金公司购买基金份额（也就是用钱入场） 赎回基金：基金公司用钱购回我们手上的基金份额（也就是拿钱走人）\n这种申购\u0026amp;赎回的流程，这里的交易对象是基金公司。而买入卖出就像是“二手交易市场”，该二手交易市场是由政府专门成立和监管的，任何人不想要的基金或者想要购买特定基金的也可以从该市场中购买，并不一定要从基金公司手上购买，这里的交易对象是个人。因此申购\u0026amp;赎回会导致基金的份额发生变化，而买入\u0026amp;卖出则不会；\n这里的二手交易市场也就是上海证券交易所 \u0026amp; 深圳证券交易所等地方，很多基金可以在此处交易和买卖。\n这也就衍生出了场内基金和场外基金的概念：\n场内基金: 只能从基金公司申购基金 场外基金: 除了从基金公司申购，还能去证券交易所进行买入卖出 基金的分类和基本概念 基金的类别较为广广泛，常见的有：公募，私募，养老，社保等，普通投资者和我们后续进行分析的都是公募基金。\n按照投资的方向也可以对基金做一个分类：\n股票基金：\u0026gt;80% 股票，通常的指数基金也属于股票基金，分级基金/母基金大多是指数基金。 债券基金：\u0026gt;80%债券 混合基金：股票债券货币的组成较为灵活，大多保本基金为混合基金 货币基金：类似活期储蓄 如果按照投资的理念，则分为：主动型基金和被动型基金：主动型基则是基金经理自己选择调整构成，而被动型基金是根据某个指数或者规则来被动确定和调整基金的构成，指数基金即为一个典型的被动基金，按照事先规定的指数规则来选股。\n因为规则的一致，同一个指数的不同基金的表现都会大差不差的。\n按照销售的渠道，则分为：场内基金和场外基金；\n按照募集对象，可以分为公募基金和私募基金：\n公募和私募的区别就在于是否公开招募，私募一般门槛都要大几百万，公募，公开招募大多门槛较低。\n按照基金是否开放，可以分为：开放式基金和封闭式基金：\n开放基金持续接受申购赎回，基金的份额会发生变化； 封闭基金设置好确定的基金份额，不会过多变化，在结束了募资进入封闭期后，不会接受申购和赎回，如果想要只能去证券交易所购买\n早期的时候大多都是封闭式基金，现在\u0026amp;我们将要考虑的也主要都是开放式基金了，介绍完了交易方式和基金种类后，我们就可以考虑如何去选择基金做投资了，在选择中我们主要按照投资的方向去做决策，接下来就介绍三类基金的一些特点。\n基金的选择 下面这些基础知识后面可以去《指数基金投资指南》中补充，这里主要是一些简单的基本概念介绍。\n货币基金 货币基金是专门投资那些安全又具有很高流动性的货币市场工具的基金，其主要包括：期限小于1年的短期国库券、政府公债、大额可转让定期存单、商业本票、银行承兑汇票。\n其主要针对大资金的投资者开放，且大多具备高安全性和流动性的特点，因此非常适用于短期资金的打理。\n如何挑选货币基金？\n货币基金没有申购赎回费，但是货币基金会收取销售服务费、管理费、托管费，很直观的在购买货币基金的时候需要注意该费率之间的不同，越低越划算，一般而言，各类货币基金中，B 类货币基金的费率是相对较低的，以往是因为门槛高没有普及开，现在也有一些降低了门槛的 B 类货币基金。\nSummary\r货币基金的主要特点是：几乎不会亏损，买卖方便，长期收益较低，适合打理短期零钱。因此购买货币基金的时候，主要注意费率之间的不同。\n债券基金 债券基金是以债券为主要投资对象的基金，主要投资的对象为：国债、金融债、企业债等固定收益类金融产品。虽然货币基金也可以投资债券，但是一般都需要剩余期限在 397 天以内，而债券基金没有上述的限制，两者实际上有所类似，可以认为货币基金更针对的是短期的品种，而债券基金会考虑稍微长期一些的场景。\n债券基金有申购赎回费用，其又可称为“固定收益品种”，债券基金追求的是更加固定的收入，其周期相较货币基金更长，当时收益也略高于货币基金，风险系数也较小。可以作为一种定期存款的替代品，但是相比定期存款，其利息高些，但是不保证\u0026amp;不承诺收益。\n考虑纯债基金，主要可以分为两类：短期债基（相比货币基金投资范围更广，但是近几年短期的债基都被货币基金取代因而品种少），中长期债基（场内场外都有）主要追踪的都是国债和城投债指数，各家基金公司通常都有历史业绩好表现稳定的长期债基，其同质化也相对较高，不像股基的收益方差很大。\n==债券基金的风险来源==\n债券基金收益既然比货币基金要高一些，风险确实也是相对要高的，其风险来源主要是市场利率的变化，因为债券的价格和市场利率是负相关的：利率下降，债券的价格就会上升，回报就会更好。\n可以理解为，市场的利息上去了，那么人们会倾向于存款而不会购买债券，供需关系变化后就会导致价格的下跌，那么相对专业一点：\nQuota\r一般来说：加息周期，利率上升，债券基金表现不会太好；降息周期，利率下降，债券基金则会表现不错。假如利率变动 1%，比起短期债基，长期债基受到的影响要更大，跌幅或涨幅都要更高\n如何购买和选择债券基金？主要的 tips 就以下的两点：\n利率低位选短期债基，利率高位选长期债基 选好品种后，出现浮亏可以加仓拉低成本 但是更为重要的是要判断长期利率的走势：\u0026ldquo;如果利率处于历史走势的底部，那未来的下降空间就不大，但有较大的上升空间。如果利率处于历史走势的顶部，则有很大的下降空间。\u0026rdquo;\n👍 可以使用历史平均周期的利率来进行估算：\u0026ldquo;过去十几年，十年期国债利率的中位数是 3%~3.5%。以这个作为标准，当利率低于 3%的时候，也就是利率处于低位的时候，建议大家选择短期债券基金，或者干脆直接选择货币基金。当利率高于 3.5%的时候，建议大家选择长期债券基金。\u0026rdquo;\n一般来说，债券基金的投资风险不高，但在持有过程中收益也是很有可能下跌的。市场利率变化是有周期性的，不会一直上升或下降，波动周期也是比较短的，3~4 年一轮。如果我们持有的债券基金出现了账面浮亏的情况，可以通过加仓把成本降下来。用这种方式，投资债券基金就很容易赚到钱了。\n股票基金 股票基金顾名思义是以股票为主的基金，其收益率和风险都是最大的，根据股价的走势，可能大赚特赚也可能一亏到底，但是股票基金的长期收益通常是三种基金中最高的(如果选择正确的话)。\n一般选择定投的就是股票基金，而且定投的主力是其中的指数基金（被动型基金，上述有提到），指数基金也是巴菲特建议普通投资者选择的基金，（他自己最经常推荐的就是低成本的标普 500）\n指数基金的优势？\n基于市场指数进行变化，有新陈代谢的活性 能够长期上涨：\u0026ldquo;巴菲特也提到，买指数基金就是买国运。只要相信国家能继续发展，指数基金就能长期上涨，我们就能分享国家经济增长的收益。\u0026rdquo; 费用低廉：指数基金的托管费和管理费相比主动基金明显更低 同时其能够规避：\n市场黑天鹅风险，因为指数基金投资通常几十上百只股票，不会因为个体崩盘，并会定期调整 本金永久损失的风险，指数通常下跌也有极限 制度风险，确定的规则，开放的选股，不会阴沟里被人坑 总结 短期存储的工具（货币类工具）：银行储蓄和货币基金中货币基金相对更合适，收益也会更高一些，其基本上长期稳定的小幅度上涨。 中长期保障性存储工具：银行理财产品和债券基金。这两类的投资收益不相上下，但大部分银行理财产品在持有的时候看不到波动浮亏，投资者可能会更心安一些，其中银行理财产品的底层大多就是债权类基金，其收益相对货币更高，但是存在波动风险，严重时甚至高达 1x%，但只要战线够长基本都能盈利。 激进类资产（股票类工具）：高风险高收益产品，也是唯一在获得收益后能够对抗通胀的产品（if 通胀进行中），波动大。 指数基金 指数的命名，名称中的数字通常代表其会挑选多少只股票。\n不限制投资行业的指数就是宽基指数，而有的指数在投资的时候会限制行业，例如消费行业指数，这种就是行业指数，行业指数受到行业影响比较大，初学者优先还是选择宽基指数。\n指数基金的配置方式：市值加权和策略加权；\n市值加权即股票的市值越高在指数中的占比就越高，策略加权则是按照别的方式来决定个股权重（smart-beta）指数，由于策略加权的策略多样性，导致在不同市场（牛/熊）中各个基金也能有不同的表现，因此结合多种不同策略的特点，就能在不同的市场环境下更好的投资。\n选择对应的基金时，遵循以下的两个思路：①寻找费用最低、误差最小的品种；②寻找有特色的增强型指数基金，不过如何增强相对不透明，相比于普通基金更具风险。常见的宽基指数有以下这些：\nA 股：沪深 300（最具规模和代表性）、中证 500（最容易获得超额收益的指数）（利用其不理性的涨跌）、创业板指数（整体盈利较低、不稳定）（容易暴涨暴跌）；\n港股：\n恒生指数（最具代表性，代表的是港股的蓝筹股）-\u0026gt; 盈富基金（恒生指数基金的最佳选择）、H 股指数（内地注册，香港上市，用港币交易的股票） 香港中小指数（主要投资的是 H 股和红筹股，）-\u0026gt; LOF(上市型开放式基金) 风险：老千股 美股：主要的有以下两个著名指数\n纳斯达克指数（NDX）（纳斯达克规模最大的 100 家企业） 标普 500 指数（带主观判断的蓝筹股指数）：大公司 90%，中型公司 10%，入选标准为：行业领导者，ROE（净资产收益率）更好的入选。 更宽、更稳，以消费、医药、科技等周期性产业的占比更高。 能够代表美股市场的基准收益， 属于美元资产，可以分散风险 策略加权指数基金 上面这些指数主要都是基础的市值加权的宽基指数基金，这类品种具备长期的，与国家经济发展相关的半稳定性，故而其通常是各个股票市场上的主力品种。除了这些基于市值加权指数基金外，通常还有两类基金比较小众且长期投资收益更好。\n策略加权指数基金：采取某种投资策略来挑选股票 长期优秀的行业指数基金：有的行业本身的盈利能力相对出色，如当下的 IT 所有的策略指数中，最常见最有影响力的主要是：红利指数、基本面指数、价值指数、低波动指数。\n红利指数：持股收息的最佳选择 Quota\r股票是会发放股息的，也就是现金分红，业绩比较好的公司，每年会从净利润拿出来一部分，以现金分红的形式回馈股东。\n红利指数，按照股息率来决定个股的权重，因为公司能持续发放股息，也就说明其财务和盈利状况较好，因此，能分红的股票往往也是一个好的选择。\n四个主要的红利指数：上证红利指数、中证红利指数、深证红利指数、红利机会指数，他们分别有着不同的特点，但是红利指数通常有一些共同的优点：\n高股息率：在熊市更有优势，在熊市中是非常不错的优势； 波动较低：由于企业的经营情况要好才能发出股息，因此相对而言比较稳定； 提供分红现金流：有的红利指数基金会将基金分红的形式发放给基金持有者 也有一些共同的缺点：有一些股票会因为短期的大幅盈利而大比例分红，就可能会入选红利指数，但是这种短期大涨并不会持续，就会影响指数的长期分红能力，影响其稳定性，但整体瑕不掩瑜。\n基本面指数 基本面指数属于质量指数，从上市公司的经营质量的角度去挑选股票，其不看市值，只看基本面指标：营业收入（过去 5 年的营业收入平均值）、现金流（过去 5 年现金流的平均值）、净资产（定时调整的净资产）、分红（过去 5 年分红的总额）。\n而国内最出名的基本面指数为：中证基本面 50 指数；\n基本面指数相比普通的指数，最大的好处是收益会相对更高一些，但是基本面指数在不同时间段的表现显示其在熊市跑赢市场更多一些，在各国的熊市中，基本面都能跑赢标普 5.8%，在牛市中跑赢标普 0.7%左右，平均下来多出了 2%~3%的年华收益率。\n基本面指数对应的指数基金有：基本面 50、深证基本面 60/120 基本面 400 等，不过大部分规模都太小，不适合投资。\n红利指数和基本面指数，在熊市相对更抗跌一些，一方面其现金流吸引大家长期持有股票，另一方面，熊市下跌过程中分红投入，也可以托底股价，所以这也是熊市中更好的选择，这两类都是长期不错的指数。\n价值指数 基本面指数使用 4 个基本面指标的规模大小来加权，价值指数相似使用四个估值指标来进行筛选：市盈率、市净率、市现率、股息率。\n市盈率=公司市值/公司盈利 市净率=公司市值/公司净资产 市现率=公司市值/现金流量 股息率=现金分红/公司市值 通常对于同一个股票品种来说，市盈率、市净率、市现率越低，股息率越高，这个品种的投资价值也会越高，价值指数就是用的这种策略。\n其走势，特征，收益和上述的红利和基本面指数也差不多，不过前两年在国内的数量不多，目前主要就沪深 300 指数。\n低波动指数 低波动指数是挑选市面上波动率最低的一批股票。这里的波动率，说的是股票每天涨跌幅的标准差，有点龟兔赛跑的味道了，该指数有以下特点\n波动率最低的 150 只股票 波动率加权 避免集中于某个行业，对行业股票数量进行限制 选择策略加权指数基金 策略加权指数基金是很不错的，因为其收益往往由于基本的宽基指数基金，以有效加权指数基金为定投品种，可以帮助我们在定投的过程中提高收益，但是策略加权指数基金也有一些缺点：\n资金容量不大：容纳不了太多基金（相对，影响不了个人) 行业指数基金 Summary\r实际上就是选择一个行业方向去进行投资，相比于宽基指数而言，行业的难度和风险就会更高一些，因为单独国家的发展可能是向前的，但某个行业却不一定，不过行业指数能够较好的丰富投资的品类，作为宽基指数的补充。\n股票的涨跌主要有两个方面构成，一个是企业发展情况的事实，第二个则是投资者的信心和共识，事实作为信心的来源，信心和共识则是股票涨跌的原因。因此在做这种选择判断的时候，要基于事实、舆论、发展趋势去做基本的判断。\n从供需关系和长期发展的关系来看，可以脱离时代背景，长盛不衰的行业（更容易赚钱）主要集中在：消费和医药行业，因为无论处于什么时局，健康和日常消费都是作为一个人类不可或缺的，这里的供需关系是长期稳定和健康的。\n消费行业主要包括：饮料、酒、农副食品等，其中主力为食品饮料行业，这也是巴菲特比较推崇的一类，如可乐，稳定且可长期发展不会有太大的变化。\nA 股中代表性的消费指数主要是：上证消费指数、上证消费 80 指数、中证消费指数、全指消费指数；也有一些食品饮料的指数。\n医药行业的两大优点：长牛\u0026amp;避险，和消费行业一样，人都离不开生老病死，因此这个需求是比较稳定的，不过医药行业会有政策的风险，比如政府会限制医药行业的收益，来降低国民的医疗支出，和政府医保的财政支出，但是仍然瑕不掩瑜是一个比较优秀的行业。\nA 股中相关的医药指数还是比较多的，300 医药指数，500 医药指数，中证医药指数，全指医药指数，中证医药 100 行业指数，投资的时候要选择规模大一些的，上面的指数不是都适合投资。同时要考虑规避\u0026amp;承担黑天鹅风险的。\n可选消费行业：高档手机、汽车、大家电等；其特点为：①需求弱于必需消费、有一定的周期性 ②收益于人口红利，特别是人均消费金额的提升；③具备更新换代的特性\n那么怎么去选择行业指数呢？\n⭐🌟相比于宽基指数，这些行业指数会有额外的风险，推荐是定投的时候可以以宽基策略加权指数基金为主，然后以优秀行业指数基金为辅去做组合，稳健的基金作为投资主力，然后使用一些优秀的行业基金来博取超额收益。\n挑选过程中记得：规模合适、费用低廉、追踪误差小，下面会详细的将讲一下具体的标准和选择方式。\n基金的投资和选择 这里首先讲一个最重要的问题：指数基金会不会跑路（捐款逃跑）、暴雷（类似 P2P 钱无法周转，导致无法支付投资者的本金和利息）\n指数基金不会跑路，原因如下\n公募基金公司的门槛很高（实缴注册资本\u0026gt;1e，股东资产达标，3 年内无任何不良信用） 公募基金都有托管人，（资金托管于第三方银行或者券商），基金公司没有卷款潜逃的权利和能力 证监会和基金协会严格监管，包括投资和风险控制流程。 暴雷的可能性也极小，原因如下：\n公募基金可以投资的对象受到了严格的限制，不得投资这种非标准的金融产品 鸡蛋不是放在一个篮子里，通常会有多个产品和股票的分散投资。 但是存在大涨大跌的风险。 基金销售平台倒闭了怎么办 这里的基金销售平台指：蚂蚁财富、天天基金、蛋卷基金之类的，其注册成本和资金相对都比较庞大，倒闭的风险较小，这里不再赘述。\n😀核心是：基金销售平台并不会持有我们的基金，其只负责销售基金，基金最终是到了基金公司的托管账户中，平台与我们的资金是分割的，即使平台倒闭了，也可以在基金公司找到我们购入的基金份额。\n作为平台而言，其运作成本并不高，通常并不会出现这种倒闭的情况。\n基金公司倒闭了怎么办 像风险和成本就不再说了，和平台一样是低成本运作的公司，如果真的倒闭了，会提前走入清盘流程，\n基金规模太小的不要选 一个基金所持有的股票、债券、现金的总市值，就是这个基金的规模，最好选择规模在 2e 元以上的\n如果一个基金的指数规模比较小，一个是有可能会有清盘的风险，且难以运作和保证收益的稳定性；清盘指的是，基金公司按照某个基金净值强制赎回（通常是基金亏本情况下停止运作），这可能会导致我们在亏损的状态下就中断了投资。清盘通常会留出一定的处理时间，但是对于我们长期投资的规划来说并不划算和方便。\n另一个是固定费用的相对占比会比较高，以及资金的灵活性和流动性比较差，赎回的流程可能会更长。\n优先选择费用较低的基金 事实上基金的收取费率对我们投资的收益的影响是很明显的，费率包含透明费率和不透明费率两种。下面会简单介绍一下：\n透明的费率主要是： 申购费、赎回费、管理费、托管费，下面给出一些基准参考\n申购费：通常在 1%1.5%左右，如果在银行购买就是这个价格，但是如果通过那些基金销售平台购买，通常会打一折。也就是在 0.10.15%，这对整体收益的影响就比较小了 赎回费：赎回费在 7 天之内会有一个惩罚费率，1.5%，超过 7 天后通常在 0.5%左右，也还算比较合理，如果持有长期（1~2 年）赎回的费率会越来越低甚至免费 管理费（每年扣除）：通常在基金报告中，大多数在 0.5%~0.8% 托管费（每年扣除）：一般在 0.1%~0.2% 后两者可能量化基金这种频繁操作的费率会相对高一些，其他的应该都得比较低才行，我们看到的基金净值通常都是扣除了管理费和托管费之后的。\n不透明的费率则有：分红税、印花税、交易佣金\n分红和印花税不是向我们个人收取的，而是国家和券商向基金机构收取的，但是调仓频率是固定的，所以相对换手率低一些，一般个人投资者不太考虑 交易佣金在基金的年报中也会有计算，基于不同换手率会有不同的交易佣金，指数基金的交易佣金大多在 0.1%~0.4%。 不透明的这些费率通常是在取得整体收益之后，从基金的总额中扣除的，因此对于个人来说可能会看不到这部分的费率以及也不太考虑到这一块。\n因此最主要的是要考虑管理费+托管费，申购赎回费，交易佣金（不好知道），购买的时候要注意这一块。\n优先选择追踪误差较小的基金 最终误差：指数基金特有的指标，是否能复刻，追踪好指数的表现（或者超过）这就能评估这个基金是否是我们想要追踪的指数效果。\n怎么看：基金报告里面需要定期披露的指标，报告里可以看，也可以直接对比以下指数的数据就行。这个要看主要看两个方面：\n（一般更看重这个）基金份额净值增长率与业绩比较基准收益率的差值。 基金份额净值增长率标准差与业绩比较基准收益率标准差的差值。 🔥结合估值进行投资选择 为什么指数基金长期的收益不错，但是投资者通常都不赚钱，因此有\u0026quot;七亏二平一赚\u0026quot;的说法，这是因为投资者很多 \u0026ldquo;追涨杀跌\u0026rdquo; ，很多投资者，特别是新手投资者，往往都是在牛市入局的，在股票已经涨起来之后入场，在便宜的时候没有买入，后续的上涨空间就小了，反而更加容易下跌。指数基金也是一样的道理；\n因此需要结合估值来判断指数基金是否是一个适合定投的状态，其存在自己的投资价值，我们要在其值得投资的阶段买入，如果在牛市大涨后再买入，就容易亏损，其实通常来说，在熊市反而更加值得坚持定投指数基金，短期大涨之后入局反而不适合。\n因此我们要结合估值来判断当前是当前是否值得投资和入局，是熊市还是牛市。\n估值的基本理念 “估”是其第一个特点，鉴于股市是一个共识驱动的市场，就像我们无法计算出心理阴影面积一样，我们也无法为一个股票得出一个准确的股市价值，每个人对一个股票的心理预期是不同的。\n结合估值，对一个股票的价值进行估计，通过估值和当前市场价格的偏离，进行正确的策略选择，实现不同策略的价值投资是一个更为推崇的投资方法。\n但是由于无法得到一个准确的估值，推荐结合格雷厄姆的“安全边际”理论来使用估值去做判断，也就是为估值留一个保守空间，再对该估值进行利用，这样的估值用起来就会更为安全。\n估值的方法 现在市场上流行的估值方法有几十中，但是通常分为：相对估值法和绝对估值法两类，这里我认为量化的核心可能就是结合深度学习算法来对股票做一个快速且短期的估值，并基于该估值计算出来的价格偏差进行短期且快速的偏差计算。\n相对估值法：例如确定房价的时候和小区均价对比，核心在于参照物的选择，通过比较确定当前单位的估值。\n绝对估值法：一个投资品种在它生命周期内所能产生的现金流的折现值之和，就是这个品种的绝对估值。如果一个资产的现金流越明确，其越精准。\n通常使用的时候会结合着来，绝对估值法这边的概念还不是很清楚，但是两者应该相互对照，最好是能得出一致的结论。\n估值过程中的要素选择 人类估值可以遵循\u0026quot;奥卡姆剃刀原则\u0026quot;，如无必要勿增实体，而如果打算使用 AI 进行估值，可以使用权重去做因子控制，然后根据学习出来的权重表来对因子做进一步的过滤选择。\nQuota\r上市公司的盈利、国家的政策法规、经济环境、企业的竞争、管理层的好坏、投资者的心理情况、资金面、汇率波动……每一个因素都有可能在短期里影响指数的走势。\n但是基于“约翰伯格”的总结，对指数基金影响最大的三个因素为市盈率、盈利、分红。+1 考虑企业的净资产。这几个是最常见的几个因素。要避免引入过多干扰要素来混淆估值过程。除了这几个以外，还有一些：市销率、市现率等指标，后续在做量化的时候要去了解这些个股投资指标。\n指数基金作为股票的集合，相比于单个股票而言具备更高的稳定性和内在的指数规律联系，因此估值起来会更容易一些、成功率也更高。\n市盈率：Top1 🔴 首先抛出缺点：其不适合用于盈利变化大的品种上，也不适合强周期性品种，遇到金融危机和经济周期的底部会失效等。\nThink\r市值率的缺点给了我们启发，再进行模型设计的时候，可以考虑结合 CrossAttention，对市场的情况（经济周期、熊/牛）、行业的特性，对不同的因子做不同的权重再控制，避免指标在不同的场景下的作用不一致。\n静态市盈率：市值/上一年度财报的净利润 滚动市盈率：市值/最近四个季度财报的净利润，时效性更高一些，更推荐 动态市盈率：市值/预测未来一年的净利润，大多不用 席勒市盈率（CAPE）：市值/过去十年的净利润平均值，通常用于衡量一个股票市场的整体情况（需要历史更为悠久） 中位数市盈率：指数基金才有的指标，个股中没有；取 Set 中中位数的市盈率。 其中中位数市盈率的作用可以额外的讲解一下：其可以避免市盈率计算中部分成分股被大多数绑架的情况（例如其他股票已经大涨，但是权重股票还没有大涨，使得指数处于低位，导致指数失真的情况），相对于普通的市盈率对于市场的变化更敏感。\n中位数市盈率适用于：成分股的平均市值规模差别较大的情况，其作用会更明显，例如牛市时，如果中位数市盈率率先进入高估区域，说明大多数都已经涨起来了，这个时候要警惕后续下跌的风险。\n市净率：Top2 市净率：每股股价/每股净资产 == 账面价值，具体计算的时候使用如下公式：\n$$ PB=P/B\r$$\r其中 P 是公司市值，B 是公司净资产（资产-负债）具体可以在上市公司的年报中找到，相比于市盈率，市净率更稳定一些，因为盈利是一个短时指标，而净资产则是一个累计指标。\n当一家公司还没产生亏损，大多数时候净资产都是增长的时候，市净率就可以作为一个比较好的参考（亏损也可以作为负面的参考要素）\n市净率主要有以下的几个方面影响：\n净资产收益率 ROE：每单位资产的变现能力，企业对资产的利用率，螺丝钉和查理芒格都认为其是一个较为关键的指标，该指标与股票的长期收益率十分相关，相当于他们对我们贡献的这一笔股票投资的变相能力，所以长期下来会和股票的收益十分类似。\n$$ ROE = 净利润/净资产\r$$\r市净率的有效范围：\n① 资产的稳定性，有的资产能够随着时间增值，例如酒，有的则会随着时间贬值（周期性产品没有及时销售），资产的稳定性越高，市净率的有效性更高。 ② 不适用于无形资产：如果企业的收益主要来源是其中的人才，专利，影响力，话语权，那么市净率的参考价值就比较低（例如律师或者 openai） ③ 整个行业大规模亏损的情况下不适合参考市净率； ④ 短期经济危机，盈利短期不稳定，可以参考市净率作为辅助判断 股息率：衡量现金分红收益率 股息率和分红率要记得区分，定义上有一些类似，但是含义和功能就完全不一样了：\n股息率： $现金分红/公司市值$ ，股价越低，股息率越高，相同分红的情况下 分红率： $现金分红/总净利率$ ，通常是一个事先定义的值，大多数情况下不会改变 股息率的作用是能将公司的净利润增长映射到股价上（投资者的现金收益），同时股息是无需我们出售股权的时候也能获取到的现金流，这也是国家分享国有企业收益的方式，通过持有高股息的股票资产组合，就可以在无需关注股价涨跌的情况下，获取越来越高的现金分红。\n分红和盈利挂钩却不与股价挂钩，所以一般企业不出现大问题的情况下，分红都会逐年上涨，（偶尔盈利下降也会下降），因为上述特点，针对高股息的品种进行投资也是一种投资方式，这也是很多人选择投资的方式：选择分红高、估值偏低的股票。\n这里贴两个使用高股息率投资组合的典型案例：\n如何利用估值去做投资 按照盈利的趋势的分类去分析基金，主要可以分为 5 个品种：盈利保持不变、盈利长期稳定增长、盈利快速增长、盈利大起大落、盈利衰退。\n其中大起大落和衰退的品种投资难度太高，不适合普通投资者的投资主力，所以主要对前三种进行分析。\n盈利保持不变：看现金流收益率高低 实际上就是一个债权类的资产，就和国债一样确定的稳定收益，对这类品种的估值，主要看现金收益率的高低，如果现金流收益率满意就可以考虑，但是要考虑这类品种的安全性，不能中途倒闭或暴雷。\n投资这类产品中有以下的Tips：\n这类品种的话可以参考债券类的收益，如果收益和债权类相似接近，是正常的，如果稳定的收益远高于债券基金的平均收益，背后可能有坑或者风险。 这类品种的现金流收益率必须要高于国债的收益率，因为国债安全性最高，股票类的安全性没有那么高，因此如果现金流收益率没有更高的话，就没有考虑的必要。 $$ 现金流收益率=现金流/市值\r$$\r牛市中很多品种的市值大涨，导致其实际的收益很低，如果投资者看重这种中短期的赚钱效应去哄抢，导致异常上涨，这是非常不明智的。\n❓盈利稳定增长：盈利收益率法 $$ 盈利收益率=公司盈利/公司市值\r$$\r可以发现其为市盈率的倒数，其是一种绝对估值法，通常使用这种估值进行投资的时候遵循以下三个原则：\n当指数基金的盈利收益率\u0026gt;10%且\u0026gt;国债收益率两倍以上的时候投资 当盈利收益率小于债券基金预期收益率(19 年的时候为 6.4%)的时候卖出 怎么去计算和看到一个基金的这些数据，这是后面急需解决的问题。\n借由盈利收益率，我们说明以下绝对估值法：其将一个品种未来的现金流折现到当前，计算当前的理论值，如果当前股价低于该现值，说明当前股价被低估了，如果低估了很多，就可以考虑投资。\n这里的折现可以简单理解为：按照一个百分比，将未来的现金折算到当前为多少钱，例如 2 年后的 100 元，按照折现率 10%,到现在就相当于为 $100/(1.1)^2=86.2$ ，即当前的估值就是 86.2，这里的折现率就是我们想要的年复合收益率 。\n但是收益当然是越高越好，大家期望的收益都不同，那么用于估计价值的时候，往往会使用国家的社会平均折现率，（前两年我国公布的为 8%），当然为了规避风险，股票计算的时候往往会使用更大的数字，10%~12%去计算。市盈率的第一条法则实际上就是该估值法的简单应用。\n$$ 永续年金的现金流的现值=每年的现金流/折现率\r$$\r$$ 市值 = 盈利/盈利收益率\r$$\r所以只有当盈利收益率\u0026gt;折现率的时候，市值现金流才会实现正向的增长，因此才有投资的价值，否则实际上该企业的发展并赶不上时代的变化。\n上述这种计算方法，是适合未来现金流固定不变的品种，但是实际上投资的指数基金的盈利会稳定增长，因此应该使用永续增长年金模型\n$$ 永续增长型年金的现金流现值（市值） = 每年现金流（盈利）/ （折现率（盈利收益率）- 增长率）\r$$\r例如一个公司一年赚 100w，按 10%算折现率，5%算增长率，则算出来其市值估值分别为 1000w 和 2000w。\n而格雷厄姆考虑到安全边际效应，不使用增长型模型，因为就算增长率保持在 10%不再继续上涨，也是一个可观的投资。\n盈利收益率法的原理。它本质上是一个折现率为 10%的绝对估值法，在这种情况下的定投策略如下：\n当盈利收益率大于10%时，分批投资（即继续定投） 盈利收益率小于10%，但大于6.4%时，坚定持有已经买入的基金份额。 当盈利收益率小于6.4%时，卖出基金。 🔥局限性：只适合于流通性比较好、盈利比较稳定的品种。如果是盈利增长速度较快或者盈利波动比较大的指数基金，则不适合使用盈利收益率法\nQuota\r目前国内适合盈利收益率法的品种，主要是上证红利、中证红利、上证 50、基本面 50、上证 50AH 优选、央视 50、恒生、恒生中国企业等指数的指数基金。这几个品种的投资很简单，当盈利收益率大于 10%时就可以投资，小于 6.4%时就可以卖出。\n盈利快速增长：博格公式法 如果一个品种长期盈利的增长速度远远高于 10%，那么不适合用盈利收益率法，而因该用博格公式法；其主要针对的是盈利高速增长的品种和盈利呈周期性变化的品种。\n$$ 指数基金净值=市盈率*盈利+分红\r$$\r也就是说影响我们股民收益的一个是股息率决定了分红收成，另一个是市盈率，决定了一个公司将盈利转化为市值的能力，股息通常而言是确定的，一般而言，当价格被低估的时候，股息率就更高，最需要考虑的其实是市盈率的变化和未来盈利的增长。\n复习一下市盈率： $市盈率=公司市值/公司盈利$ 市值由股价计算而来。\n对于一个宽基指数来说，市盈率通常是在一个范围内来回波动，不会太高也不会太低，例如沪深，历史上最低是 8，最高时 48，熊市中在 811，牛市中在 1748，其他时候都在 8~17 来回波动，那么也就是说当我们买入的如果市盈率低的话，那么我们就可以从中获取显著的收益，如果在高点买入，那只能看下跌的空间了。\n需要注意：短期内，指数基金的涨跌，主要是由估值的变化决定的。但是时间拉长后，指数基金的上涨，是由背后公司的盈利增长和分红积累推动的。这个因果关系要搞清楚。\n👍因此如果给估值和盈利增长排优先级的话：盈利增长良好为先，第二个是在估值处于低位的时候买入；因此改良后的定投方法为：\n挑选长期盈利增长率良好的品种 在估值处于低位的时候买入：一个是自身历史估值处于低位，另一个是估值要和自身的盈利增长速度匹配。 高估时候卖出 估值和增长速度匹配的意思是什么呢？ 比如说美国股票市场的指数，长期盈利增长率大约是 10%，美国股市过去百年的市盈率平均值，大约是 15 倍。这就是一个对应关系。\n只有匹配正常的，能避免一些炒作的股票，提高一些置信度。\n从全世界范围来看，成熟国家的股票市场，长期盈利增长率在8%~10%，市盈率平均值在 15 倍左右。这是一个可以参考的估值区间。如果盈利增长率更高，那可以享受的市盈率平均值也会更高。但是很少有品种能长期保持 30%以上的盈利增长速度，所以对市盈率数值超过30 倍的指数基金，一定要慎之又慎。\n计算是否匹配的时候也可以使用 PEG 指标\n$$ PEG=市盈率数值/长期盈利增长速度数值\r$$\rPEG 的正常范围在 1~2 之间，\u0026lt;1 的话还是比较好的，可能是一种被低估了的情况，\u0026gt;2 的话就要小心了，宁可不投资都。\n结合上述的所有，博格公式法总结如下：\n长期盈利增长速度大幅高于 10%的品种，适合使用博格公式法。 使用 PEG 规避风险, 避免投资市盈率长期保持很高数值的产品 考虑市盈率的历史数据，如果市盈率处于历史低位，那么大概率该产品被低估，可以考虑买入 如果市盈率处于高位，或者 PEG\u0026gt;2 那么大概率被高估，需要慎重。 （补充）低估买入，高估卖出 数据的查找和计算并不方便，而且也没有准确的估值，螺丝钉自己会公布一些，可以去看。\n🧰定投的具体操作方式选择 Summary\r上述的文章讲的是，买什么（长期收益优秀的策略加权指数基金），什么时候买（低估时），现在还有一个问题就是什么时候买。\n主要是以下的几种：定期定额、定期不定额、慧定投（基于均线的定期不定额）、价值平均策略（基于市值的定期不定额）、估值定投策略（基于估值的定期不定额），这些策略的大概意思从名字也能看出来，这里就不作太基本的介绍。\n首先是定期定额基本但有缺陷，一般不推荐：A 股中不推荐：收入增长速度变化、通货膨胀变化、钝化、以及不够灵活。通常会采取定期不定额的方法。\n定期不定额：除了收入的变化，指数基金本身的涨跌，也会导致当前定投周期，投资价值的变化，如果我们在低估周期定投，且短期内指数基金下跌了，实际上他的投资价值反而提高了，实际上我们的策略应该是，在指数基金处于低估区域的时候去投资，而由于其本身的波动大，区间内可能会出现低估和高估的情况，我们应该再低估的时候买入更多，拉低整体均价，在高估的时候不投乃至卖出。\n这种策略也叫“定投收益放大器”，有种越跌越买的感觉，在这个基础上，因为指数基金上涨是长期的，下跌时短期的，这样，如果我们在短期下跌的时候拉低均价，我们的收益会进一步增加。\n慧定投：参考均线来做的定期不定额，均线（过去一段时间的平均价格），支付宝通常是 500 日均线，如果高于均线就少投一些，随着幅度越大投的越少。如果低于过去 500 个交易日的均线就多投一些，少得越多，投的越多。这个可以查看支付宝中的说明。\n慧定投的缺陷：①支付宝这边并非参考的单个产品对应指数的均线，其只有个别几种产品指数的均线；②无法帮助区分基金，任何基金都可以使用该慧定投策略。\n价值平均策略：又称为市值恒定策略，给手里的指数基金设定一个市值增长速度，比如说，计划每个月投 1k，到第二个月的时候，由于基金的波动，原本的 1k 可能不止 1k 或者少于 1k 了，无论是多了还是少了，我们就将其补充到 2k，这也是一种方式。思想上也是一样的，这个增长速度可以是绝对值也可以是比例。\n价值平均的缺陷：在波动比较大的股市，可能遇到大跌的时候慧需要拿出较多金额进行补仓，但是我们也可以手动为其设定每个月的上线。\n估值定投策略：上面两种投资方式都是简单有效的，但是他们都没有考虑指数基金本身的投资价值，上述对基金的选择中，我们提到了在基金被低估的时候进行投资，才能取得最好的长期收益。因此我们结合两件事：\n在熊市，指数基金被低估的时候开始投资 配合估值，在估值较低的时候买入更多。 🌟具体而言，每个月定投的金额计算公式如下,公式中的 n 就是定投放大器，n 越大，放大的收益越大，但是相应的可能需要的金额也会更多。\n$$ 每月定投的金额=首次低估时的定投资金*(\\frac{当月的盈利收益}{首次的盈利收益率})^n\r$$\r按照螺丝钉的经验，假如说初始定投金额是 1000 元，n 设置为 2，当遇到 A 股极端下跌，指数基金到了历史最低估值的阶段，定投金额可能就会变成 2400 元2600 元。大多数时间里，定投金额会在 1000 元1500 元。这是一个大致的参考区间。\n估值定投的缺点：① 只适合指数基金，不适合主动基金，要存在事先确定/公开透明的股票，比例，才能进行后续的计算和估值。② 估值有时候不太稳定，可能会由于盈利下滑等原因导致失效，例如金融危机的时候。市盈率也应该降低，但是标普 500 指数因为背后公司盈利下滑，导致市盈率反而被动提升到了八九十倍（市盈率=市值/盈利）\n金融危机的 case 在做量化的时候，时很典型的反例，需要结合起来考虑怎么优化。\n如果估值失效的时候：\n沿用盈利大幅下滑之前的盈利数据，或者多年平均盈利数据。 用其他的估值指标：例如净资产。 😀止盈策略：什么时候卖出 常见的止盈策略有三种，三种方式都有道理，但是适用的范围有区别。\n从自身收益角度考虑止盈 从投资品种的价值角度考虑止盈 不止盈，在低估的时候买入，长期持有，依靠基金的分红来获得现金流 自身收益止盈 第一种就是最简单的，当我们账面收益达到了我们设定的收益率的时候，我们就直接赎回，不管后续的发展了，这种方法需要注意的就两点：\n不能太频繁止盈 止盈率的设定非常重要，通常设置为 30%，和可转债相关，可以去补充了解以下相关的知识。 其有以下缺点/特点：\n投资开始阶段不同，会出现有人出场有人入场 牛市的疯狂涨幅会更高，投资者会损失部分利益 适合波动大的品种，因为赚 30%就直接止盈，按照定投低估指数基金，30%收益率就止盈，在 2~3 年内实现止盈获利是大概率的。 按照估值止盈 就是前文中反复提及的，在价格大幅低于其估值的时候买入，在价格大幅高于其估值的时候卖出，这种方式的投资周期通常会比 30% 止盈的方式的周期更长，因为一般得到大牛市的中后期，才会到高估区域，如果使用这种止盈方式的话需要耐心持有。\n其优点：\n在牛市收益高，通常从低估到正常估值，从正常估值到高估，每个区域都会有 30%~40% 的涨幅。 投资者可以比较长的享受到投资品种本身盈利上涨带来的收益，由于盈利始终上涨，市值也会稳步增长。 缺点：\n需要耐心 对策略指数基金的品种有要求，需要快速增长盈利：一般是优秀的策略加权宽基基金，或者优秀的行业基金指数 通过估值进行止盈的策略可以按照定期不定额的策略进行卖出，结合起来就是：\nImportant\r指数基金被低估的越多，我们买入越多；当指数基金进入高估区域，我们把手里的基金分成多份，估值高出越多，我们卖出的比例越高，进行分批止盈，也叫做梯度止盈。\n这种方式可以避免我们在牛市的时候完全错过后面的收益，不过风险就是可能牛市结束还没卖完，算是一个权衡，避免过多损失和过多亏损。\n具体操作示例：例如在 20 倍市盈率的时候进入了高估区域，我们有 1w 份基金，我们卖出 10%,当达到 24 倍市盈率的时候卖出：\n$$ 10\\%* (24/20) ^n $$\r这里的 20 是假设，10% 可以自由调整\n不止盈 不止盈，在明显低估的时候买入，长期持有，依靠分红来获取日常消费的现金流，如果日常收入需求完全可以靠股息分红来支撑，那么这个就是最好的投资策略了。\n为什么可以长期持有？因为指数基金本身的迭代特性只要其背后的公司正常运营，其盈利是长期上涨的，现金分红作为盈利的一部分也会长期上涨，因此将指数基金转换为一个利息收益不断上涨的超长期理财产品。\n但是这种策略有以下的条件：\n需要选择股息率较高，分红较多的指数基金 长期分红的收益和初始买入的股息率关系很大 一定要在初期股息率很高的时候投资，一般 4%以上是还不错，5%以上是少见的好机会，2%都不到的话就要很小心。\n通常股息率比较高的时候，往往也是大熊市指数基金处于低估的时候，也暗含了低估值投资的理念。所以如果打算长期持有获取分红收益，一定要在股息率比较高的时候再买入.\nA 股中较为适合的主要是大盘宽基指数基金：如上证 50、沪深 300、恒生、H 股、中证红利、红利机会等。\n止盈策略选择 第一种止盈：适合波动很大，暴涨暴跌的产品，分红不多，周期性很强，这种止盈策略效率更高。\n第二种止盈：按照估值止盈，通常是 7~10 年止盈一次，这种方式适用于长期稳定的指数基金，最终收益是叠加多个牛市的收益，如果能在熊市入场，收益会更好。\n第三种止盈：适用于红利、股息率高，且长期经营和收益状况都比较稳定的指数基金。\n通常如果不急着用钱可以考虑使用第二种止盈方式，一般会在牛市的中后期才进行止盈，一般 710 年一次。否则可以按照 30%的方式，一般 23 年就会有卖出的机会。\n制定完整的定投计划 根据收入和开支，指定合理的定投额度: 通常 3 年为期，牛市缩短，(收入-开支)/2 筛选投资的品种: 被低估的指数基金； 设定好买卖区间：软件上设置定投计划； 定期根据行情进行优化，定时不定额的买入\u0026amp;卖出； 养老投资计划 稳健为主，以 100-年龄的方式来决定配置指数基金的比例，例如 70 岁，使用 30%的现金来配置指数基金，然后将该部分基金分成 20 份，按月分配，建议是红利类；其他的以银行理财产品、货币这种稳健的方式为主。\n👍可以参考 CPPI 策略来指定保本投资组合：\n即大部分资金配置货币基金、理财产品、债券，少部分资金配置低估指数基金。比如说 100 万元，用 90 万元配置年收益率为 5%的理财产品，剩下的 10 万元配置低估指数基金。一年后，如果股市下跌，低估指数基金跌幅最高为 20%左右，那 10 万元还剩下 8 万元，但是理财产品可以获得 4.5 万元的收益，合计就是 90+4.5+8=102.5 万元，还是保本的。\n教育定投 特点在于，要用钱的时间是固定的，这种香港有很多类似的投资组合，可以参考我妹的那种，距离用钱的时间越远，选择低估指数约值得考虑，卖出点可以放高，时间越近，越要考虑稳妥。\n常见问题 基金净值的高低，对收益有影响吗？ $$ 基金净值=基金规模/基金总份额数量\r$$\r答：无，追踪同一个指数的基金，净值高低对投资收益影响不大。\nABC 类的区别 ABC 指的是收费的方式：\nA：前端收费，收取申购和赎回费，现在第三方平台打折，申购几乎免除，因此 AB 同质化，且有时候赎回费率更低。 B：后端收费，收取赎回费，免除申购费 C：不收取申购赎回费，收取服务费。 C 类通常是给短期投资者提供的，长期起来 A 类反而更有优势，因为服务费较高； \u0026amp;\u0026amp; 一般 7 天之内赎回会有惩罚性费率 1.5%，一般长期 A(B)，短期 C。\n场内基金和场外基金哪个更划算 场内（证券交易所内）一般是散户之间交易，人心更加勾心斗角，这里暂不介绍，主要在互联网上用场外交易即可（和官方申购赎回），如果有的已经封盘了，倒是可以在开通股票账户后，去对应的证券交易软件上，购买那些已经封闭的。\n场内的优势在于交易更加实时一些，后续也可以利用这个来操作\n🔥已经有一笔资金，要分批投入吗 这实际上是和自己的预测相关的，如果你认为不会再低了，就一次性投入，如果你想分批，说明你认为现在不是最低点，或者略高。\n如果判断对了当然好，如果错了就可能会亏损，因此建议使用分批来排除自己的主观臆断，减少损失的风险，所以推荐还是越跌越买：\n通常是把资金分成 20 份，进入低估区域后，投入 1 份，也就是 5%。这里的 5%，有点类似前面介绍定期不定额定投时的初始定投金额，之后每个月投入一份，如果市场下跌了，可以提高投入的比例和金额。用这种方式，可以在 10~20 个月里，把一笔资金分批配置成低估指数基金\n20 个月是一个经验数字，一般低估区域的平均时间长度为 1~2 年，最长也不过三年，因此方便在熊市建仓。\n日定投、周定投、还是月定投 日定投的周期太短了，首先排除日投的策略，一般都是周或者月（每个月的金额差不多），当周期拉长以后，实际上实际收益差距不大，主要看自己是否看到下跌以后会忍不住，如果会的话就直接周投，不然就月投更省心。\n定投一定能降低成本吗 钝化效应：当定投的资金在持有的资金的 5% 以下后，增加的资金占比太小了，因此对原有资金的影响不大，这就是钝化效应，这个时候想要在下跌的时候降低成本就不行了。所以还是要定期不定额，下跌的时候多买点，才能更有效的降低成本。\n此外当进入高估区域的时候，我们进行分批卖出的操作，然后等下跌再分批投入被低估的指数基金，这样流动性就起来了，也会减少钝化效应的情况。\n定投多久才能开始盈利（指数） 1~3 年，通常 1 年多，耐心是最好的品德\n看点数来买基金靠谱吗？ 短期来看可能会有一定的效果，长期迟早会失效。 点数本质上是从指数开始计算的 100 开始增长的，因为市盈率的变化，和市场一直在发展（盈利一直在增长，故而市值会增长，点数也就一直增长） 所以点数其实是一个短期波动长期上升的模型（同行业、国家的运势和发展） 是否有完美的高抛低吸的投资方法 无，但是长期走势是有迹可循的，原因是股市的复利效应，股票资产是有复利的，公司会把盈利的一部分再投入生产来产生更多的盈利\u0026amp;分红发放，都会推动股市上涨。\n估值低不代表短期会上涨，但是估值低在 3~5 年的收益就会越高，\n定投低估的指数基金，最大的浮亏是多少 我们以 2018 年的熊市为例。2018 年，是 A 股历史上的第二大熊市，沪深 300 指数跌幅大约为25%，代表了主流指数的平均跌幅。不过虽然指数下跌 25%，但如果定投的话，在微笑曲线的作用下，浮亏会大大减少。通常只有 1/3~1/2 的浮亏，也就是浮亏在 10%~15%。\n上述是宽基在大熊市的浮亏情况，使用合适的定投方法，浮亏也会更小。\n","permalink":"https://hugotest-phi.vercel.app/posts/%E5%AE%9A%E6%8A%95%E5%8D%81%E5%B9%B4%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e本篇读书笔记主要记录书中一些投资理财相关的概念、一些思维方式、一些典型的策略等等，用于自己后续理财的基础。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e“投资理财越早开始越好，无需拘泥于启动资金的多少，时间才是投资理财中最重要的增长因子”。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"财务自由\"\u003e财务自由\u003c/h2\u003e\n\u003ch3 id=\"需要多少钱才能财富自由\"\u003e需要多少钱才能财富自由\u003c/h3\u003e\n\u003cp\u003e4%法则（William Bengen）：通过投资一组资产，每年从退休金中提取不超过 4%的金额用来支付自己的生活所需，那么直到自己趋势，退休金都花不完。\u003c/p\u003e\n\u003cp\u003e因此如果每年需要 40w 的开销，那么就需要超过 1000w 的资产来实现一个比较稳定的财富自由，按照自己每年的消费可以进行简单的换算。\u003c/p\u003e\n\u003ch3 id=\"如何避免财富缩水\"\u003e如何避免财富缩水\u003c/h3\u003e\n\r\n\r\n\r\n  \r\n  \r\n\r\n\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e财富缩水主要的原因就在于通货膨胀，对通货膨胀有所了解才能更好的从通货膨胀中保护自己的财富。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e很多时候通货膨胀看的是 CPI(居民消费价格指数)，最近几年国内的 CPI 同比增长一年为 2%~3%，也就是说物价每年上涨 2%~3%，但是实际上只看 CPI 是不够的，这是因为 CPI 实际上仅包含了必需消费，而如果要保证生活质量的水平不变，需要跑赢的是\u0026quot;可选消费通货膨胀率\u0026quot;。\u003c/p\u003e\n\u003cp\u003e这是因为任何一个社会，优质的教育和医疗资源的价格增长速度是比较显著的高于 CPI 的，因此可选消费指数才是我们要跑赢的目标。而这个增长速度则通常和 M2 的增长速度相关。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eM2 是广义货币的量，代表社会广义货币的增长速度，最近三年的同比大概在 8%~9%，但是该指数并非完全和可选消费指数相等同。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e综合而言，我们通常需要考虑的膨胀指数应该介于 CPI 和 M2 增速之间，因此资产增值的速度应该在 3%~9%之间，才能避免财富缩水，如果考虑一些不稳定时局的原因，可能还要存一些避险资产例如黄金。\u003c/p\u003e\n\u003cp\u003e通常来说，只要长期投资债券基金（包括相关的理财产品）是可以跑赢 CPI 的，债券通常的长期平均收益都在 6%上下，但若想要获得更高的收益可能就得上股票这种高风险高收益的了。\u003c/p\u003e","title":"《定投十年财务自由》读书笔记"},{"content":"\rSummary\r设计个人首页作为 HTML 和 CSS 的实战，主要设计以下的几个部分，导航栏，侧边栏，logo，页脚，背景，以及一个简单的个人介绍页面，首先不考虑使用框架和库，仅对整体流程做熟悉，使用纯 HTML 和 CSS 进行基础实现。后续考虑使用框架和组件库进行重写。\nCheckList for Web Design : Using this website to checkout those element u missed in your design. Prepare for those elements. Get Ready and Start.\nNav-Bar 页眉的导航栏设计 Buger 下拉菜单(侧边菜单) https://alvarotrigo.com/blog/hamburger-menu-css/ flex 布局设计 使用 html css 进行布局时，如果计划使用 flex 等布局，避免无谓的划分子集的 div 等 box，避免多余的额外对齐工作，原型和草稿确认布局是很重要的。例如上述的导航栏，分成左右两个 div 即可，如果将搜索框等独立出来，在后续对齐和确认间距的时候会多出很多麻烦。\n可以缩减为仅使用一个 div，使用 flex 的布局技巧来使得元素一半左对齐一半右对齐即可，下面时具体说明。可以参考文献 1 的《使用自动的外边距在主轴上对齐》章节。\n如果希望让 flex 子元素靠右显示，可以在子元素中定义 margin-left: auto; (auto 也可使用其他数值单位替代)，参考 👍MDN弹性盒子容器中的对齐方式 | flex子元素靠右 | Flex的最后一个元素靠右 | Flexbox align-items 如果没有设置正确的话，所有的元素会按照撑满 flex 容器的高度去对齐。 使用 margin:auto 可以实现元素的居中 使用 align-self 可以实现单个 flex 子项的不同对齐方式。 可能接着阅读更多布局相关的资料，加深对布局的认识，以及正确选择合适的布局：Mdn Layout Cookbook Search Bar 搜索框 搜索框设计：使用 logo 和 input 的形式来实现一个搜索框的样式，如下图所示，由三个 box 的组合而成：form 包裹内部的 svg 和 input 两个 box。\n具体的 HTML 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;form class=\u0026#34;search-tool\u0026#34;\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=\u0026#34;17\u0026#34; height=\u0026#34;17\u0026#34; viewBox=\u0026#34;0 0 17 17\u0026#34; fill=\u0026#34;none\u0026#34; role=\u0026#34;img\u0026#34; class=\u0026#34;icon nav-v2-search__icon\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M1.5 7.75C1.5 9.4076 2.15848 10.9973 3.33058 12.1694C4.50269 13.3415 6.0924 14 7.75 14C9.4076 14 10.9973 13.3415 12.1694 12.1694C13.3415 10.9973 14 9.4076 14 7.75C14 6.0924 13.3415 4.50269 12.1694 3.33058C10.9973 2.15848 9.4076 1.5 7.75 1.5C6.0924 1.5 4.50269 2.15848 3.33058 3.33058C2.15848 4.50269 1.5 6.0924 1.5 7.75V7.75Z\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;1.5\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34;\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M12.814 12.8132L15.5 15.4999\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;1.5\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Search...\u0026#34; value=\u0026#34;\u0026#34; autocapitalize=\u0026#34;off\u0026#34; class=\u0026#34;search-form\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 为了美观我们去除 input 原本的边框和底色，同时避免内容溢出，css 可参考如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 .nav-func .search-tool { margin-top: 5px; background-color: rgba(14, 82, 30, 0.28); border-radius: 5000px; max-width: 180px; } .nav-func .nav-v2-search__icon { padding-left: 10px; /* position: relative; */ display: inline-block; /* left: 15px; */ } .nav-func .search-tool input { background: transparent; color: black; border: none; outline: 0; overflow: hidden; } 最好结合其父元素来限制搜索框的最大最小 width 以及 logo 的位置，同时为了小窗口的响应式设计可以结合媒体查询来控制搜索框的显示与否。\n1 2 3 4 5 6 7 @media screen and (max-width: 850px) { .nav-func .search-tool input { visibility: hidden; display: none; width: 0; } } 这里介绍一下 display: none; 和 visibility: hidden; 的区别：\n如果使用 visibility: hidden; 那么其结构，如在 flex 中的占位会仍然存在，只是元素并不显示，有时候我们需要使用它 如果使用 display: none; 那么其内容和结构都会完全小时，我们在计算的时候就仿佛 html 中没有这个元素一般，在一些响应式的场景会需要用到 Switch 主题切换按钮/亮暗色主题切换 给 body 添加 darktheme class 属性来为页面的基本元素设置亮暗的双主题切换，使用一下的选择器前缀来为不同主题下的页面添加不同背景颜色的属性：\n1 2 3 4 5 6 7 body.dark-mode { background-color: #232946; /* background: url(../images/background-dark.jpeg); */ background-size: cover; background-repeat: no-repeat; background-attachment: fixed; } 建议使用预先定义好的不同主题的色彩变量来实现无需多重定义各个单元的元素：\n1 2 3 4 5 6 7 8 :root { --clr: #141e15; --bga: #004643; --btm-color: #f9bc60; --para-color: #abd1c6; --font-color: #fffffe; --stroct-color: #001e1d; } 按照自己想要的设计亮暗切换按钮：\n1 2 3 4 \u0026lt;div class=\u0026#34;theme-toggle\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;sun\u0026#34;\u0026gt; \u0026lt;ion-icon name=\u0026#34;sunny-outline\u0026#34;\u0026gt;\u0026lt;/ion-icon\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;moon\u0026#34;\u0026gt; \u0026lt;ion-icon name=\u0026#34;moon\u0026#34;\u0026gt;\u0026lt;/ion-icon\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* theme switcher here */ header .theme-toggle { position: absolute; top: 20px; right: 20px; z-index: 2; } header .theme-toggle button { background: transparent; border: none; font-size: 1.5em; } header .theme-toggle .sun, header .theme-toggle .moon { display: none; cursor: pointer; } body:not(.dark-mode) header .theme-toggle .moon { display: inline-block; } body.dark-mode header .theme-toggle .sun { display: inline-block; } 使用以下的 js 代码来修改 body 的 classlist，实现类别标签的切换\n1 2 3 4 5 6 7 function changeTheme() { let body = document.querySelector(\u0026#39;body\u0026#39;) const isDarkMode = body.classList.toggle(\u0026#34;dark-mode\u0026#34;); localStorage.setItem(\u0026#39;darkMode\u0026#39;, isDarkMode); } document.querySelector(\u0026#34;.theme-toggle\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, changeTheme); Login/Regiest 登录和注册按钮 简单的两个 Span，使用不同的背景颜色来做区分会使得显示的效果更加的优雅美观，如果设计了这两个按钮，就可能还需要设计登出以及用户 Avater 标签来切换状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 .nav-func .login { /* border: 1px solid #1fb870; */ font-size: 0.9em; border-radius: 29999px; padding: 5px 5px; min-width: 60px; text-align: center; } .nav-func .login:hover { background-color: rgba(11, 29, 6, 0.2); font-weight: bold; } .nav-func .regiest { font-size: 0.9em; border-radius: 29999px; padding: 5px 5px; min-width: 67px; text-align: center; background-color: rgba(0, 0, 0); color: white; } .nav-func .regiest:hover { background-color: rgba(0, 0, 0, 0.6); font-weight: bold; } Background 背景设计 用于美观的背景界面在 CSS 中进行编写，如何在页面上放置你的背景，使其较好的展现\nREF：FreeCodeCamp 1 2 3 4 5 6 7 8 body { /* Set up the background image which fix to the widows view*/ background-image: url(\u0026#34;/images/background.jpg\u0026#34;); /* background-image: linear-gradient(-20deg, #2b5876 0%, #4e4376 100%); */ background-size: cover; background-repeat: no-repeat; background-attachment: fixed; } 为了使得图片适应各种 size 的显示窗口，需要以下的几个关键设置：\nbackground-repeat: no-repeat; 避免图片小于窗口时出现的复制图片来填满窗口的情况； background-size: cover; 使用 Cover 参数来缩放图片，使得图片得以充满整个窗口； background-attachment: fixed; 确保图片的位置时固定的，避免滚动页面使得图像的位置发生不恰当的变化。 设计注意事项： 一个现实拍摄的背景图片，往往存在比较复杂的色彩分布和细节，而作为背景而言，这样繁杂的色块和元素会给页面布局和色彩设计带来很多困扰，这里推荐的方式是：\n将背景添加模糊效果，这样能够突出表面的页面元素，包括字体等。 尽量使用大色块的合适图片 图片仅作为类似 Banner 的效果，页面布局整体还是以纯色为主。 模糊背景设置 为了设置模糊的背景，主要涉及到的思想为：使用 after 伪元素，在 Background 元素后面添加一层模糊遮罩，并通过 z-index=-1 避免其遮盖住其他元素。\n可以使用两种写法，一种使用 filter，直接复制一层元素到原本的元素之上，同时多定义一层背景避免百变。第二种为使用 backdrop-filter，直接对底层背景进行模糊：\n使用 filter：\n1 2 3 4 5 6 7 8 9 10 11 12 body:after{ background: inherit; filter: blur(10px); content:\u0026#39;\u0026#39;; position:absolute; top:0; left:0; width: 100%; height: 100%; background-size: cover; z-index: -1; } 使用 backdrop-filter：\n1 2 3 4 5 6 7 8 9 10 body:after{ content: \u0026#34;\u0026#34;; position: absolute; top: 0; left: 0; width: 100%; height: 100%; backdrop-filter: blur(10px); z-index: -1; } Meterial 素材准备和设计 Tools 形状和背景等 Meterial: 形状，背景，元素生成\nCSS Generators ：大合集，有诸多 CSS 生成的元素可供参考，丰富自己的页面元素。 作为前端开发，你应该知道的这十几个在线免费工具 Gradient Color BG using color as your background CSS Gradient — Generator, Maker, and Background Upload Image – remove.bg : 去除背景，用来做人物剪影等功能 Logo/Post Design By Canva : 使用其中的模板来设计自己的 logo 或者海报 YourWave : 生成浪花分割线，用来做背景等页面元素 Blobmaker :生成水滴 Smooth Shadow : 投影/阴影生成 Clippy - CSS clip-path maker : 生成将图像放在特定形状后面的 CSS 代码 Fancy Border Radius Generator : 圆角生成器，MDN 中也有一个 HaiKei : Sharp Provider, 提供各种生成的形状 Ribbon Shapes : 生成各种飘带 Picography ： upslash 的备胎，免费开源的图片。 Space ： 3d js 范例 calendar.js 开源日历 js 组件 Character：角色，插画生成\nPeepsLab ：简单一些插图头像生成，主要是肤色、发色、配饰面部等。 Charts：图表生成\nSVG Chart Generator : 生成 Svg 图表，可以根据自己的数据进行定制 Observable Plot ：JS 库，类似 matplotlib 用来画图表 Color 颜色选择和搭配 Color：主题颜色和颜色搭配选择，结合背景进行页面设计\ncolorhunter ：简单的调色板组合 colors.lol ：简单的调色板组合 happyhues ：一个模板应用各种组合颜色以后的效果展示，非常实用，本身也是一个很美的页面 Color Palette Generator ：调色板组合以及部分样例 zhihu-色彩搭配网站分享 ：一个调色网站分享的汇总帖子，也是该部分的主要来源 Accessible color palette generator : 基于提供的颜色提供调色盘 Windows 可以结合 PowerToy 中的取色器来获取壁纸中的主要色彩，进而进行进一步的色彩搭配，功能开启后的快捷键为：win+shift+c\nIcons 图标文件 一个一个图标素材去找显然是一件不现实的事情，图标框架就是为此而生的。\n较为主流常见的图标框架主要有：\nfontawesome ： ionicons Free Icons : 下载或者复制 svg 代码 Iconhunt ：icon 的搜索引擎，可以搜索到很多开源免费的 svg element-ui：与框架相关的这里暂时不做研究。 其中 fontawesome 的使用可以参考菜鸟教程 ：可以去官网下载、直接复制 svg，或者使用 stylesheet 引入（推荐）来使用对应的图标。\n通常使用 \u0026lt;i\u0026gt; 和 \u0026lt;span\u0026gt; 等内联元素进行调用，其中 \u0026lt;i\u0026gt; 尤为，且更为推荐，如：\n1 2 3 4 5 6 7 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;i class=\u0026#34;fa fa-car\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/body\u0026gt; ionicons 的用法则主要就是使用 style 参考：官网 引入的方式，或者 stylesheet 引入的方式，参考：菜鸟教程 ，图标列表可以查看 Icons 。\n使用 defer 或者添加于页面末尾，body 结束之前：\n1 2 \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script nomodule src=\u0026#34;https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 然后再需要图标的地方添加即可：\n1 \u0026lt;ion-icon name=\u0026#34;heart\u0026#34;\u0026gt;\u0026lt;/ion-icon\u0026gt; Template 模板 Loader : CSS Loaders 用于占位的加载动画，只需要赋值粘贴到自己的页面中即可。\nFonts 字体文件 这里介绍两种，在线引入字体的资源和本地引入字体的具体操作。\n亚克力材质生成和原理 ref: DIY: A Web Version of the Fluent Design System’s Acrylic Material 1 2 backdrop-filter: blur(20px); background-color: rgba(255,255,255,.3); 这里的 backgrop-filter 是一个新的 css 特性，能够对元素底下的内容添加模糊效果，也就是一个 filter（为当前元素提供模糊效果）的变体。\n简单的响应式设计思路 实现简单的响应式设计实际上就是：\n确定一些元素的显示与否，简化显示界面，或者将其使用额外弹出界面显示； 结合 overflow 后的行为，避免异常溢出； 确定一些最小最大尺寸和确保定位方式 Work Well，避免在视窗大小发生改变的时候导致元素偏移； 更多的还要用百分比和计算等更多的要素来实现 ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb16-web%E5%AE%9E%E6%88%9801-%E9%A6%96%E9%A1%B5%E8%AE%BE%E8%AE%A1/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e设计个人首页作为 HTML 和 CSS 的实战，主要设计以下的几个部分，导航栏，侧边栏，logo，页脚，背景，以及一个简单的个人介绍页面，首先不考虑使用框架和库，仅对整体流程做熟悉，使用纯 HTML 和 CSS 进行基础实现。后续考虑使用框架和组件库进行重写。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e\u003ca href=\"https://www.checklist.design/\" target=\"_blank\" rel=\"noopener\"\u003eCheckList for Web Design\u003c/a\u003e\n : Using this website to checkout those element u missed in your design. Prepare for those elements. Get Ready and Start.\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240219134111.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240219134111.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240219134111.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"nav-bar-页眉的导航栏设计\"\u003eNav-Bar 页眉的导航栏设计\u003c/h2\u003e\n\u003ch3 id=\"buger-下拉菜单侧边菜单\"\u003eBuger 下拉菜单(侧边菜单)\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://alvarotrigo.com/blog/hamburger-menu-css/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://alvarotrigo.com/blog/hamburger-menu-css/\u003c/a\u003e\n\u003c/p\u003e\n\u003ch3 id=\"flex-布局设计\"\u003eflex 布局设计\u003c/h3\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240221035525.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240221035525.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240221035525.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e使用 html css 进行布局时，如果计划使用 flex 等布局，避免无谓的划分子集的 div 等 box，避免多余的额外对齐工作，原型和草稿确认布局是很重要的。例如上述的导航栏，分成左右两个 div 即可，如果将搜索框等独立出来，在后续对齐和确认间距的时候会多出很多麻烦。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e可以缩减为仅使用一个 div，使用 flex 的布局技巧来使得元素一半左对齐一半右对齐即可，下面时具体说明。可以参考文献 1 的《使用自动的外边距在主轴上对齐》章节。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e如果希望让 flex 子元素靠右显示，可以在子元素中定义 \u003ccode\u003emargin-left: auto;\u003c/code\u003e (auto 也可使用其他数值单位替代)，参考 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Aligning_items_in_a_flex_container\" target=\"_blank\" rel=\"noopener\"\u003e👍MDN弹性盒子容器中的对齐方式\u003c/a\u003e\n |  \u003ca href=\"http://m.tnblog.net/notebook/article/details/7906\" target=\"_blank\" rel=\"noopener\"\u003eflex子元素靠右\u003c/a\u003e\n | \u003ca href=\"https://blog.51cto.com/mouday/4373479\" target=\"_blank\" rel=\"noopener\"\u003eFlex的最后一个元素靠右\u003c/a\u003e\n | \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Flexbox\" target=\"_blank\" rel=\"noopener\"\u003eFlexbox\u003c/a\u003e\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ealign-items 如果没有设置正确的话，所有的元素会按照撑满 flex 容器的高度去对齐。\u003c/li\u003e\n\u003cli\u003e使用 margin:auto 可以实现元素的居中\u003c/li\u003e\n\u003cli\u003e使用 align-self 可以实现单个 flex 子项的不同对齐方式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e可能接着阅读更多布局相关的资料，加深对布局的认识，以及正确选择合适的布局：\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook\" target=\"_blank\" rel=\"noopener\"\u003eMdn Layout Cookbook\u003c/a\u003e\n\u003c/p\u003e","title":"LearnWeb15-Web实战01-首页设计"},{"content":" 响应式设计的历史和思路： 媒介查询的入门 与或非等语句 传统的布局方法 尽可能使用现代的布局方法，我们可能不需要媒介查询的方式去实现响应式设计了，当然我们也可以结合媒介查询去对现代布局方式做优化。\n","permalink":"https://hugotest-phi.vercel.app/posts/learnweb15-css09-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Responsive_Design\" target=\"_blank\" rel=\"noopener\"\u003e响应式设计的历史和思路：\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Media_queries\" target=\"_blank\" rel=\"noopener\"\u003e媒介查询的入门 与或非等语句\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods\" target=\"_blank\" rel=\"noopener\"\u003e传统的布局方法\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e尽可能使用现代的布局方法，我们可能不需要媒介查询的方式去实现响应式设计了，当然我们也可以结合媒介查询去对现代布局方式做优化。\u003c/p\u003e","title":"LearnWeb15-CSS09-媒体查询与响应式设计"},{"content":"\rSummary\r这里 CSS 的布局指的是通过控制元素的属性：宽度，高度，块（不同类型），内联等来实现在 HTML 的基础上对整体页面的布局进行调整。将其排布在页面上。\nCSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口/窗口的位置。在这个模块中将涉及更多关于页面布局技术 的细节：\n布局模式介绍 正常布局流 ：指的是不对页面进行任何布局控制的时候，浏览器默认的 HTML 布局方式，实际上就是按照源码中的先后次序依次出现，在 HTML 布局的过程中，最为重要的就是元素的块和内联两种布局方式。这里需要注意的就是，块的方向和元素的书写方向的关系。\n而当我们希望使用 CSS 来改变正常的布局形式的时候，通常会使用以下的一些属性，或者说布局技术，来覆盖掉默认的 HTML 布局行为。\ndisplay 属性：改变元素在 HTML 中的渲染形式，如 block inline inline-block 还有 CSS 引入的 CSS Grid 和 Flexbox . float 属性：使用 float 属性能改变块级元素换行的特性，实现类似换行的效果，其值指定其他元素围绕块级元素的哪一边。 position 属性：利用 position 来设置盒子在盒子中的位置，在嵌套的情况下就可以产生多样的排布 表格布局：表格的布局方式可以用在非表格内容上，可以使用display: table和相关属性在非表元素上使用 多列布局： Multi-column layout 属性可以让块按列布局，比如报纸的内容就是一列一列排布的。 在讨论布局时，display 最多用到的属性为 flex 和 grid 属性，利用这两个属性值来改变布局。\nflex 弹性盒子 弹性盒子的出现为以下的几类问题有一个更好的解决方案：\n在父内容里面垂直居中一个块内容。 使容器的所有子项占用等量的可用宽度/高度，而不管有多少宽度/高度可用。 使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。 举个例子可能会更加直观，接下来用一个例子说明，flex 最直观的用法：\n1 2 3 .container { display: flex; } 1 2 3 4 5 \u0026lt;div class=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;box0\u0026#39;\u0026gt;One\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;box1\u0026#39;\u0026gt;Two\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;box2\u0026#39;\u0026gt;Three\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 如果没有 css 的话，会从上到下排列，但是在父容器上加上 flex 属性以后，就会变成 3 个并排的 box 如下（该控制的方向会随着文字方向）\n高度会随着最高的一个去设定，排成一行后留下剩下的空白 flex 中可以设置许多属性来改变 flex 项在 flex 布局中占用宽/高的方式，允许对块级元素进行拉伸处理，避免在尾部留下空白。例如在上面的例子中，修改 css 如下\n1 2 3 4 5 6 7 .container { display: flex; } .container \u0026gt; div { flex: 1; } 在这种情况下 flex 将会对元素进行拉伸，使其充满整个父容器空间如下：\nGrid 网格布局 当设置 display: grid 时，布局将会改成网格布局，此时还需要用两个辅助属性 grid-template-rows 和 grid-template-columns 分别定义行和列的轨道，从而描绘出理想的网格的情况。\n例如：\n1 2 3 4 5 6 .wrapper { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 100px 100px; grid-gap: 10px; } columns 定义了 3 个 1fr（fraction） 的列和两个 100px 的行，这样就定义出了如下的网格（2*3），且每个列都是均等的一份，可以简单的描述出将一行分为 3 等分，每个网格占据一份的情况。\n在获得了一个和这样的网格后，我们可能不希望使用所有的网格去放置元素，或者希望有的元素占据多个网格，除了让 html 自动进行排序，我们也可以显示的设置元素的位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 .wrapper { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 100px 100px; grid-gap: 10px; } .box1 { grid-column: 2 / 4; grid-row: 1; } .box2 { grid-column: 1; grid-row: 1 / 3; } .box3 { grid-row: 2; grid-column: 3; } grid-column 或者 grid-row 可以设置占据的行或列，以及从哪一行到哪一行 1/3 指的是第一到第三（前闭后开）即第一第二行。这种情况下就会呈现下面的效果：\nFloat 浮动 该属性主要是实现一种 word 文档中的环绕的效果，会改变元素身边的流向，其主要有四个取值上下左右：\nleft：将本身这个元素浮动到页面的左侧 以此类推 例如下述这个代码，及其呈现效果如下：\n1 2 3 4 5 6 .box { float: left; width: 150px; height: 150px; margin-right: 30px; } Table 表格布局 使用 display: table 和 display: table-cell 等将父容器和元素转换为格子元素去处理，沿用表格的 layout 来排布我们的元素，可以参考介绍 CSS 布局 的相关部分。\nmulti-column 多列布局 要把一个块转变成多列容器 (multicol container)，我们可以使用 column-count 属性来告诉浏览器我们需要多少列，也可以使用column-width (en-US) 来告诉浏览器以至少某个宽度的尽可能多的列来填充容器。\n例如以下的例子 multi-column-layout 将两个 div 均按照同样的宽度进行多列布局，类似报纸中常用的使用多列来呈现信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 body { max-width: 800px; margin: 0 auto; } .container { column-width: 300px; border: 5px solid black; } .container2 { column-count: 3; border: 5px dotted red; } Position 定位技术 定位 (positioning) 能够让我们把一个元素从它原本在正常布局流 (normal flow) 中应该在的位置移动到另一个位置。定位 (positioning) 并不是一种用来给你做主要页面布局的方式，它更像是让你去管理和微调页面中的一个特殊项的位置。\n定位 (positioning) 能够让我们把一个元素从它原本在正常布局流 (normal flow) 中应该在的位置移动到另一个位置。定位 (positioning) 并不是一种用来给你做主要页面布局的方式，它更像是让你去管理和微调页面中的一个特殊项的位置。\n静态定位（Static positioning）是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。 相对定位（Relative positioning）允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计（design pinpointing）非常有用。 绝对定位（Absolute positioning）将元素完全从页面的正常布局流（normal layout flow）中移出，类似将它单独放在一个图层中。我们可以将元素相对于页面的 \u0026lt;html\u0026gt; 元素边缘固定，或者相对于该元素的_最近被定位祖先元素_（nearest positioned ancestor element）。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。 固定定位（Fixed positioning）与绝对定位非常类似，但是它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。 粘性定位（Sticky positioning）是一种新的定位方式，它会让元素先保持和 position: static 一样的定位，当它的相对视口位置（offset from the viewport）达到某一个预设值时，它就会像 position: fixed 一样定位 各个定位的例子请参考对应的 MDN 列表，粘性定位和固定定位绝对是我们想要的东西。\n这里简单总结以下最重要的一些点：\n定位除了设置 position: 属性之外，还需要使用 top 和 left 来对位置进行解释。 相对定位时 top 和 left 相当于是于默认偏移相比要远离正常的 top 和 left 的距离 绝对定位的 top 和 left 则是距离页面左侧和顶侧的距离，即 html 元素 固定定位和绝对定位的一样，但是不会随着滚动移动 粘性定位将默认的静态定位 (static positioning) 和固定定位 (fixed positioning) 相混合。当一个元素被指定了 position: sticky 时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了 position: fixed 一样。 FLEX 弹性盒子详解 首先介绍 flex 的模型和一些基本的定义，能够对 flex 的布局调整有更清楚的认知：\n主轴（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 cross start 和 cross end。 设置了 display: flex 的父元素（在本例中是 \u0026lt;section\u0026gt; ）被称之为 flex 容器（flex container）。 在 flex 容器中表现为弹性的盒子的元素被称之为 flex 项（flex item）（本例中是 \u0026lt;article\u0026gt; 元素。 修改主轴方向 弹性盒子提供了 flex-direction 这样一个属性，它可以指定主轴的方向（弹性盒子子类放置的地方）——它默认值是 row，这使得它们在按你浏览器的默认语言方向排成一排\n换行设置 当你在布局中使用定宽或者定高的时候，可能会出现问题即处于容器中的弹性盒子子元素会溢出，可以通过添加换行声明属性，让其自动换行，同时我们也可以限定每个 flex 项的最小宽度，让其不必吧所有都排在同一行，可以多用几行。\n在 flex-container 中设置：\n1 flex-wrap: wrap; 在 flex-item 中设置：\n1 flex: 200px; flex-flow 缩写 可以将 flex-direction 和 flex-wrap 缩写为 flex-flow。\n1 flex-flow: row wrap; flex 项的动态尺寸 flex 计算空间的占用比例的时候使用的是一个无单位的比例值进行表示，例如设置每个 article 的 flex 值为 1，即每个元素占用的空间为 1：1：1 ，占用的空间是基于 padding 和 margin 之后剩余的空间计算。\n通过调整这个 flex 值可以调整每个值的相对比例，在指定相对值的同时还可以指定 flex-item 的最小值，避免为了并排多个元素导致元素宽度过大或者过小导致异常表现。\n1 2 3 article { flex: 1 200px; } 上述代码将首先为每个 flex 占据 200px 的空间，最后将剩余的空间按照比例分给各个 flex-item，flex 的灵活性就是他最大的优势，对于不同浏览器窗口都能有一个比较好的排布。\nflex 的缩写和全写 flex 作为一个简写可以按顺序替代一下的三个属性：\nflex-grow：实际上就是上述的无单位比例值， flex-shrink：是一个比较高级的功能，用于溢出容器的 flex 项，预防一些预防情景，一般不用 flex-basis：就是上述用到的最小值。 水平和垂直对齐 1 2 3 4 5 div{ display: flex; align-items: center; justify-content: space-around; } 上述代码的效果可以让 div 中的元素垂直水平居中，如下图所示：\n其中各个元素的作用如下（如果对名词不清晰的记得去看上述的 flex 模型图）：\nalign-items ：控制 flex-item 在 cross-axis 的位置（也就是垂直位置）。 默认是 stretch，也就是从顶开始延伸，然后和最大高度的 item 保持一致。 center 则会使得元素在垂直位置居中，高度和上述保持一致。 也可以设置 flex-start 或者 flex-end 使得元素在最高处或者最低处对齐。 在容器的子元素中可以使用 align-self 属性覆盖 align-iterms 的行为，对其中的特定元素选择特定的位置呈现。 justify-content ：控制 flex 项在主轴上的位置，默认书写位置的话即水平位置： 默认值是 flex-start，从主轴的开始处开始排列，也可以用 flex-end center 可以让 flex 项在主轴居中 space-around 会使得所有 flex 项沿着主轴均匀的分布，在任意一端留有一点空间 space-between 和上述相似，但是不会再两侧留下空间。 flex 项排序 可以使用 flex 的属性来改变容器中元素显示的顺序，对其中的元素使用 order ；\n1 2 3 button:first-child{ order: 1; } 所有的 flex 项的 order 默认为 0，order 值大的项在显示过程中的顺序更靠后，支持设置负值。\nflex 嵌套 flex 允许嵌套使用，当元素为 flex 的时候，其子袁术默认为 flex-item，但是我们可以手动修改 flex-item 项的 display 为 flex，这样其子节点也会变成 flex-item。\n支持实现如下的效果:\n这种情况下使用的代码为：\n1 2 3 4 5 article:nth-of-type(3) { flex: 3 200px; display: flex; flex-flow: column; } Grid 网格布局 网格布局是一种很经典且常用的布局模式，可以帮助我们更好的划分页面，获得一个更为统一的页面设计，一个网格通常包含很多行和列，行或者列中间的空隙都被成为沟槽 gutter。\n一般网页通常用 12-16 列的网格布局来构成，我们也可参考该布局思路和方式。\n定义网格的时候如果只设置 display: grid 页面不会发生变化因为默认只有一列，需要指定网格的行和列的属性和个数，页面才会相对应的改变。\n1 2 3 4 div{ display: grid; grid-template-columns: 200px 200px 200px; } 如上述 grid-template-columns 按照列的个数为每个列指定了宽度，这里的列值可以是绝对值也可以是各种百分比等任何值，而如果我们希望类似 flex 按照比例来设置的话可以使用 fr，同样还是看占几份 fr 来划分。\nfr 如何和其他值并用：例如和绝对值并用的话会在减掉了绝对值剩下的空间中按照 fr 中所占的比例来进行平等划分。\ngrid-网格间隙 使用 grid-column-gap (en-US) 属性来定义列间隙；使用 grid-row-gap (en-US) 来定义行间隙；使用 grid-gap (en-US) 可以同时设定两者。\n1 2 3 4 5 6 .container { display: grid; grid-template-columns: 2fr 1fr 1fr; grid-gap: 20px; gap: 20px; } 网格间隙可以使用 px 或者百分比，但是不能使用 fr 值。\n备注： gap属性曾经有一个grid-前缀，不过后来的标准进行了修改，目的是让他们能够在不同的布局方法中都能起作用。尽管现在这个前缀不会影响语义，但为了代码的健壮性，你可以把两个属性都写上。\n快速创建重复网格 假设要创建多个 1fr 的网格，没道理一个个编写，这样太慢且冗余了，可以使用repeat的函数来快速表达：\n1 2 3 4 5 .container{ display: grid; grid-template-columns: repeat(3, 1fr); grid-gap: 20px; } repeat(n, value)表示重复 value 多次，value 也可以是多个值。n 和 value 之间要用 , 隔开，值和值之间则不用。\n隐式创建的网格 可以显示定义行和列，也可以隐式的根据内容自动扩充行网格，这种弥补显式网格无法放下的内容而生成的网格就是隐式网格（或者说被隐式定义的网格），具体的方法如下：\n1 2 3 4 5 6 .container { display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: 100px; grid-gap: 20px; } 这里设置了行为自动的 100px，这种情况下，当网格内容装不下的时候，就会根据网格内容按照 100px 的高度来自动切分和增加新的网格。\n该 auto 属性只会适用于隐式定义出来的网格，如果存在显示定义的网格并不会受其影响。 可以使用 minmax 函数来约束隐式网格，minmax(minvalue, auto)，这样我们就约束了网格的最小高度，而没有限制最大高度，这样其会根据内容自动确定行高（且最多只有一行隐式网格） 自动多列填充 有时候我们希望能够自动生成很多列来填满容器，可以使用下述的代码：\n1 2 3 4 5 6 .container { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); grid-auto-rows: minmax(100px, auto); grid-gap: 20px; } 这里使用了关键字 auto-fill 来代替具体的次数，生成的列最小为 200px 宽。而且容器总会被列塞满。\n元素放置 需要注意的是格子的 index 和对应的文字书写顺序相关，如果使用了如阿拉伯语等非常规的文字书写顺序，需要注意你的 index 是否还适用。\n通常使用 grid-column 和 grid-row 来定义元素放置的开始格子和结束格子（或所在格子），当然也可以用诸如 grid-column-start 和 grid-column-end 来确定，但是没这个必要。具体的写法如下，开始和结束使用 // 分割。\n1 2 3 4 header { grid-column: 1 / 3; grid-row: 1; } 也可以使用类似 markdown 表格描述的方式来描述元素放置的位置如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 .container { display: grid; grid-template-areas: \u0026#34;header header\u0026#34; \u0026#34;sidebar content\u0026#34; \u0026#34;footer footer\u0026#34;; grid-template-columns: 1fr 3fr; gap: 20px; } header { grid-area: header; } article { grid-area: content; } aside { grid-area: sidebar; } footer { grid-area: footer; } 在 grid-template-areas 处定义好每个 var 所在的行列，然后在后续使用 grid-area 将元素放入这些定义好的 var，或者说 area 中即可。\nFLOAT 浮动布局 浮动布局这里的使用上文已经介绍过了，基本的使用就是按照这种方式，但是需要注意的是：\n浮动元素实际上是脱离了原本正常的文档布局流，所以无法使用别的元素的 margin 将浮动元素推开，只能使用浮动元素将其他元素的内容推开。 为浮动元素后的元素添加可视化的背景颜色，可以看到浮动实际上和后面的元素盒子是重合的，缩小的其实是盒子中的行内/内容盒子，才营造出了浮动的效果。 如果我们只希望环绕其中一段文本而非全部，可以为后续的元素添加浮动清除属性，这样后续的元素就会依旧换行在这个元素完全到这个元素之下： 1 2 3 4 .cleared { clear: left; } /* 这里的clear支持left right和both 分别用于取消某一侧的浮动*/ 如果我们将浮动和文本包裹在同一个 box 中，并添加背景的时候可能会存在下面这种现象：\r而我们希望背景的颜色能将浮动元素包裹，这就需要我们取消盒子的浮动，这种情况下比较现代的方法是实用属性：display: flow-root; 上面背景没覆盖的情况是因为我们在计算 box 背景的时候，由于浮动元素从正常的布局流中脱离出去了，因此计算元素高度的时候并不将其包裹在内，因此可以理解成，需要取消元素之后的盒子的浮动。 Position 定位 基本的知识上面已经介绍了，这里不在重复，只添加一些额外的信息和知识点，详细介绍参考 mdn ：\nZ-Index 该属性主要用于多个元素发生堆叠的时候谁在更上方，当存在多个绝对定位的元素的时候，这一点非常有用，可以为滚动的时候带来不同的效果。\n简单的讲，z 轴就是以屏幕到你眼睛的向量为正向，因此 z 轴越大会在最上面，未被设置的时候都默认为 0，设置的时候使用如下代码：\n1 2 3 4 5 6 7 p:nth-of-type(1) { position: absolute; background: lime; top: 10px; right: 30px; z-index: 1; } 绝对定位的父容器设置 默认是 html 页面的边缘，可以为父容器设置 relative 来实现绝对定位参考的边缘改为父容器。\n滚动粘性位置 每个后续的粘性会替换上一个, 这里目前好像只看到的 dd 和 dt 的方法，别的还没看到，后续值得研究一下。\n","permalink":"https://hugotest-phi.vercel.app/posts/learnweb14-css08-css%E5%B8%83%E5%B1%80/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e这里 CSS 的布局指的是通过控制元素的属性：宽度，高度，块（不同类型），内联等来实现在 HTML 的基础上对整体页面的布局进行调整。将其排布在页面上。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cblockquote\u003e\n\u003cp\u003eCSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口/窗口的位置。在这个模块中将涉及更多关于页面\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Layout_mode\" target=\"_blank\" rel=\"noopener\"\u003e布局技术\u003c/a\u003e\n的细节：\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"布局模式介绍\"\u003e布局模式介绍\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Normal_Flow\" target=\"_blank\" rel=\"noopener\"\u003e\u003cstrong\u003e正常布局流\u003c/strong\u003e\u003c/a\u003e\n：指的是不对页面进行任何布局控制的时候，浏览器默认的 HTML 布局方式，实际上就是按照源码中的先后次序依次出现，在 HTML 布局的过程中，最为重要的就是元素的块和内联两种布局方式。这里需要注意的就是，块的方向和元素的书写方向的关系。\u003c/p\u003e\n\u003cp\u003e而当我们希望使用 CSS 来改变正常的布局形式的时候，通常会使用以下的一些属性，或者说布局技术，来覆盖掉默认的 HTML 布局行为。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003edisplay\u003c/code\u003e\u003c/a\u003e\n\u003c/strong\u003e 属性：改变元素在 HTML 中的渲染形式，如 \u003ccode\u003eblock\u003c/code\u003e \u003ccode\u003einline\u003c/code\u003e \u003ccode\u003einline-block\u003c/code\u003e 还有 CSS 引入的 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids\" target=\"_blank\" rel=\"noopener\"\u003eCSS Grid\u003c/a\u003e\n 和 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox\" target=\"_blank\" rel=\"noopener\"\u003eFlexbox\u003c/a\u003e\n.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/float\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003efloat\u003c/code\u003e\u003c/a\u003e\n\u003c/strong\u003e 属性：使用 float 属性能改变块级元素换行的特性，实现类似换行的效果，其值指定其他元素围绕块级元素的哪一边。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003eposition\u003c/code\u003e\u003c/a\u003e\n\u003c/strong\u003e 属性：利用 position 来设置盒子在盒子中的位置，在嵌套的情况下就可以产生多样的排布\u003c/li\u003e\n\u003cli\u003e表格布局：表格的布局方式可以用在非表格内容上，可以使用\u003ccode\u003edisplay: table\u003c/code\u003e和相关属性在非表元素上使用\u003c/li\u003e\n\u003cli\u003e多列布局： \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_multicol_layout\" target=\"_blank\" rel=\"noopener\"\u003eMulti-column layout\u003c/a\u003e\n 属性可以让块按列布局，比如报纸的内容就是一列一列排布的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在讨论布局时，\u003ccode\u003edisplay\u003c/code\u003e 最多用到的属性为 \u003ccode\u003eflex\u003c/code\u003e 和 \u003ccode\u003egrid\u003c/code\u003e 属性，利用这两个属性值来改变布局。\u003c/p\u003e","title":"LearnWeb14-CSS08-CSS布局"},{"content":"\rSummary\r这一章节主要是涵盖开发 css 的各部分，有一些需要掌握的技能的 TODO 还有一些代码风格之类的东西\nTODO 后续如果初窥门路了可以研究整理一下如何去找参考文献的思路。 熟练使用使用开发者工具进行网站调试的方式。 DOC 查找 如何查阅 MDN 是一个很重要的技能（当今确实是可以使用 GPT 替代，但是也要掌握基础技能）：\n当希望知道一个模块有什么属性可以设置的时候应该在 Modules 中查找对应的模块内容，例如表格的相关属性 当希望属性用法的时候才去查看对应的属性 Debug 调试 尝试熟练去使用开发者模式去查看盒模型，调整颜色，布局，查看属性，添加属性等。\n编写规范 可以参考: MDN 的 CSS 代码规范的示例 的同时，遵循组织 CSS 的一些准则，来确定自己的编写规范。\n我的开发流程：\n使用 Layer 导入组件库 使用 Layer 设置默认层，包括表格预设，各种预设的东西 使用 Layer 设置主题层 定义 custom 内容，内容的组织可以参考： OOCSS 面向对象的 CSS 设计，或者基于文章结构的组织（基础如 body,h -\u0026gt; 组件，例如不带 index 的列表-\u0026gt; 站点 level 如导航栏 -\u0026gt; 特指内容） 编写过程中：\n保持命名方式统一 添加注释说明各部分内容 保持缩进和换行 为一些颜色之类的数值设置变量，避免重复修改多个地方 ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb13-css07-css%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e这一章节主要是涵盖开发 css 的各部分，有一些需要掌握的技能的 TODO 还有一些代码风格之类的东西\u003c/p\u003e","title":"LearnWeb13-CSS07-CSS开发流程"},{"content":"\rSummary\r表格的部分主要还是要实操，MDN 中给了一个例子，这里给我的启示是要更多的去阅读表格的相关属性 ，或者去阅读别人对表格设计中用到的元素，才能更好的掌握一些设计的思路，这里就给出本文中给出的一些常见的属性和设置方法，后续在具体实践中慢慢补充。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 table{ table-layout: fixed; width: 100%; border-collapse: collapse; border: 3px solid purple; } thead th:nth-child(1) { width: 30%; } thead th:nth-child(2) { width: 20%; } thead th:nth-child(3) { width: 15%; } thead th:nth-child(4) { width: 35%; } th, td { padding: 20px; } 当为表格设置初始样式的时候，使用 layout 为 fixed 会使得表格的行为更好预测，避免由于内容产生的畸变导致难以设置或者出现一些奇怪对齐情况，使用 fixed 然后设置每一列的宽度，在对内容进行处理可能更好。 使用 nth-child 设置每一列的宽度，最终相加为 100%，使得在不同分辨率下比较好控制。 border-collapse: collapse; 原本两个格子之间会有两条边线，这样的话可以合并重叠的边线，让表格更符合我们的预期。 使用 text-align 设置对齐方式 使用 thead，tfoot，tbody 来分别设置样式，可以做出类似三线表之类的东西 为标题 caption 设置对应的样式 后续可能会找一些比较常见的表之类的来整理，\u0026amp; 查看一下组件库。\n","permalink":"https://hugotest-phi.vercel.app/posts/learnweb12-css06-%E8%A1%A8%E6%A0%BC%E6%A0%B7%E5%BC%8F%E5%A4%84%E7%90%86/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e表格的部分主要还是要实操，\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Styling_tables\" target=\"_blank\" rel=\"noopener\"\u003eMDN\u003c/a\u003e\n 中给了一个例子，这里给我的启示是要更多的去阅读\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_table\" target=\"_blank\" rel=\"noopener\"\u003e表格的相关属性\u003c/a\u003e\n，或者去阅读别人对表格设计中用到的元素，才能更好的掌握一些设计的思路，这里就给出本文中给出的一些常见的属性和设置方法，后续在具体实践中慢慢补充。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-css\" data-lang=\"css\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003etable\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003etable-layout\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"kc\"\u003efixed\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ewidth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e100\u003c/span\u003e\u003cspan class=\"kt\"\u003e%\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eborder-collapse\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"kc\"\u003ecollapse\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eborder\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"kt\"\u003epx\u003c/span\u003e \u003cspan class=\"kc\"\u003esolid\u003c/span\u003e \u003cspan class=\"kc\"\u003epurple\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003ethead\u003c/span\u003e \u003cspan class=\"nt\"\u003eth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"nd\"\u003enth-child\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nt\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ewidth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e30\u003c/span\u003e\u003cspan class=\"kt\"\u003e%\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003ethead\u003c/span\u003e \u003cspan class=\"nt\"\u003eth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"nd\"\u003enth-child\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nt\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ewidth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e20\u003c/span\u003e\u003cspan class=\"kt\"\u003e%\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003ethead\u003c/span\u003e \u003cspan class=\"nt\"\u003eth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"nd\"\u003enth-child\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nt\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ewidth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e15\u003c/span\u003e\u003cspan class=\"kt\"\u003e%\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003ethead\u003c/span\u003e \u003cspan class=\"nt\"\u003eth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"nd\"\u003enth-child\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nt\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ewidth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e35\u003c/span\u003e\u003cspan class=\"kt\"\u003e%\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eth\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003etd\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003epadding\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e20\u003c/span\u003e\u003cspan class=\"kt\"\u003epx\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e当为表格设置初始样式的时候，使用 layout 为 fixed 会使得表格的行为更好预测，避免由于内容产生的畸变导致难以设置或者出现一些奇怪对齐情况，使用 fixed 然后设置每一列的宽度，在对内容进行处理可能更好。\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003enth-child\u003c/code\u003e 设置每一列的宽度，最终相加为 100%，使得在不同分辨率下比较好控制。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eborder-collapse: collapse;\u003c/code\u003e 原本两个格子之间会有两条边线，这样的话可以合并重叠的边线，让表格更符合我们的预期。\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003etext-align\u003c/code\u003e 设置对齐方式\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003ethead\u003c/code\u003e，\u003ccode\u003etfoot\u003c/code\u003e，\u003ccode\u003etbody\u003c/code\u003e 来分别设置样式，可以做出类似三线表之类的东西\u003c/li\u003e\n\u003cli\u003e为标题 \u003ccode\u003ecaption\u003c/code\u003e 设置对应的样式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e后续可能会找一些比较常见的表之类的来整理，\u0026amp; 查看一下组件库。\u003c/p\u003e","title":"LearnWeb12-CSS06-表格样式处理"},{"content":"\rSummary\r该篇章主要收集一些常见的样式设置的参考页和一些需要记住的重要设置内容，由于不可能记住所有的属性和设置，善用查询可能才是唯一的王道。\nCSS 中的值与单位 CSS 中的值与单位 这里介绍常见的一些值和单位，有一些新的可能会有所缺失，但是大部分都有了，这里可以列举几个常见但是之前不理解的。\nem 相对字体大小 vw 视窗宽度，值为百分比的含义 百分比：与父辈容器的百分比 rgba 或者 rgb 的第四个值代表透明度，十六进制想设置透明度的话，就在后面再加两位 16 进制表示透明度的百分比。 这里倒是提示我们需要有个比较好的取色器或者像 vscode 中的色盘来编写 css，颜色搭配网站在 css 中也是很重要的。\nCSS 调整大小 该章节内容来自 MDN 在 CSS 中调整大小 ，节选。\n原始尺寸\u0026amp;固有尺寸: 如图像等外部资源的固有尺寸；而 div 之类的空元素本身是没有尺寸的（0），其高度由其所含的内容高度决定，这就是元素的固有尺寸； 指定尺寸: 可以为元素指定 height 和 width，因此当使用绝对值和百分比进行设置尺寸时，如果和内容尺寸不匹配等可能会存在溢出等情况，需要谨慎使用； 一、使用百分比设置尺寸：在使用百分数时，需要知道我们指定的是什么的百分比：\n百分比通常指可用空间的百分比：在具体的语境中有，整个可视空间的百分比（没有父容器时），或者父容器宽度的百分比。 百分比用于内外边距时：其不会根据方向设置为宽或高的百分比，而是固定使用内联尺寸的百分比进行计算，即宽度的百分比。 二、使用最大最小值设定尺寸：min- \u0026amp; max- 尺寸，如果我们有一个内容变化的盒子，我们希望固定某个高度或者宽度的最大值或者最小值的情况使用。\n1 2 3 4 .box{ min-height: 150px; width: 200px; } 上述例子就拥有一个固定宽度，但是高度随着内容量变化的盒子，这也是一种处理内容溢出的方式；\n此外 max-width 还常用于限制图片的大小，避免图片过大导致的显示异常，例如以下用法：\n1 2 3 4 5 6 7 .box{ width: 200px; } .width{ max-width: 100%; } 1 2 3 \u0026lt;div class=box\u0026gt; \u0026lt;img src=\u0026#34;imgurl\u0026#34; alt=\u0026#34;big picture\u0026#34; class=\u0026#39;width\u0026#39; /\u0026gt; \u0026lt;/dib\u0026gt; 这种情况下图片会自动限制其表现比例，避免超出 box 的宽度，而无需去手动指定，通过这种方式可以使得图片可相应，避免在更小的设备上显示异常（但是还是应该处理多图片文件，避免过大的图片造成的流量浪费。）\n三、使用视口单位设置尺寸: vw 值的话会反应当前的窗口大小，1vw 指视窗宽度的 1%，直接基于视窗值设置可以获得更为灵活的一些设计，例如可以使用 100vw 来做对应的 banner 或者 nav 等。\nCSS 中常见样式 文本 基本文本和字体样式 web 字体获取和导入 text-align 属性可以实现文本居中显示 writing-mode 属性可以修改文字的竖排横排等，该模式也会影响块级元素的 box 的切分方向，参考：处理不同方向的文本 ，在文字修改为竖排的时候 width 和 heigh 也应该切换，为此 css 提供了一种映射属性来处理这种情况，如果需要的话再去了解。 列表 列表样式 ：包括列表符号，行高，间距，数字的开始和计算.. 链接 链接样式 ：设置各种状态下的连接表现，设置连接后面添加跳转图标等 边框 border 圆角设置使用 border-radius 属性进行设置，其通过指定两个值分别定义水平半径和垂直半径来实现，也可以只传入一个值（可为绝对值或者百分比）来设置两个值，其他的参见文档。\n背景 background 背景可定义诸多属性，是一个比较复杂的简写属性，这里介绍一些基本能设置的内容，以及简写的规则，背景主要被设置的有：\n颜色，可以使用 rgba(x,x,x,y) 前三位是颜色代码，最后一位代表透明度。 图片(链接和地址使用 url() 包裹)，可以指定多个图片 Background-repeat 设置小图片的平铺， 使用 Background-size 控制图片的大小，可以使用长度或者百分比，也可以使用 cover（保持比例完全覆盖 box，可能会只显示局部） 或者 contain（保持比例，图片完全在 box 中，可能会留白） 关键字 使用 -position 控制图片的左上角位置，一个水平值和垂直值，可以是值或者 top center 之类的关键字 可以使用 \u0026lt;gradient\u0026gt; 渐变函数来获得渐变背景 背景附加 background-attachment 控制图片在元素和页面滚动时候的表现 scroll：使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动 fixed：使元素的背景固定在视口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置 local：将背景固定在它所设置的元素上，所以当你滚动该元素时，背景也随之滚动。 简写属性的规则：\nbackground-color 只能在最后一个逗号之后指定。 background-size 值只能立即包含在 background-position 之后，用“/”字符分隔，例如：center/80%。 CSS 中的图像、媒体和表单 替换元素：css 中的图像和视频被称为替换元素，css 无法影响他们的内部布局。\n图像大小调整 前面已经有几种图像大小调整的方式了，这里回顾一下：如果使用 background 属性的处理，使用 max-width 的方式处理；\n1 2 3 4 5 6 7 8 .box{ ... background-size: cover; } img{ max-width: 100% } 这里介绍一下其他的处理方式，可以使用 object-fit 属性，可以设置多种将图像嵌入盒子的样式，这里的属性部分和 Background 是重叠的，例如 cover，contain，fill（不会保持比例）\n1 2 3 4 5 6 7 .cover{ object-fit: cover; } .contain{ object-fit: contain; } 替换元素的布局特殊性 替换元素在布局时有特殊表现：在对替换元素使用 CSS 布局时，例如使用 flex 或者 grid 布局时，默认元素会被拉伸到布满整块区域，但是替换元素不会被拉伸，而是对齐网格区域或者弹性容器的起始处；\n如果希望图像拉伸，我们可以利用下述 css 对 layout 的 image 元素强制拉伸。\n1 2 3 4 layout \u0026gt; img { height: 100%; width: 100%; } 表单 form 元素 用 CSS 格式化表单元素是一个需要技巧的工作，HTML 表单指南 包含了详细的格式化表单元素的指导，我不会在这里复述。本节需要介绍的是一些值得关注的关键基础内容。\n很多表单控件是通过 \u0026lt;input\u0026gt; 元素（html）添加到网页上的。该元素定义了简单的表单区域，例如文字输入。更进一步还有 HTML5 新加入的更加复杂的区域，例如颜色和日期撷取器。 表单元素默认不会继承字体样式，可以通过在最上面设置 textarea, input, button{font-family: inherit; font-size:100%} 来默认继承 使用 border-box 来设置表单，由于跨浏览器的 form 元素对于不同的挂件使用不同的盒子约束规则，所有我们可以使用 border-box 来保证统一，然后将内外边距都设置为 0，在设置具体样式的时候再分别添加 为 \u0026lt;textarea\u0026gt; 默认添加 overflow:auto 避免不需要的滚动条。 可以将上述作为我们的表单的默认设置，作为一个层或者最上方添加。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 button, input, select, textarea { font-family: inherit; font-size: 100%; box-sizing: border-box; padding: 0; margin: 0; } textarea { overflow: auto; } 可以使用下述代码的方式来调整表单的一些样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 input[type=\u0026#34;text\u0026#34;], input[type=\u0026#34;email\u0026#34;] { border: 3px solid #111; margin: 0 0 1em 0; padding: 10px; width: 100%; } input[type=\u0026#34;submit\u0026#34;] { border: 3px solid #333; background-color: #000; border-radius: 5px; padding: 10px 2em; font-weight: bold; color: #fff; } input[type=\u0026#34;submit\u0026#34;]:hover, input[type=\u0026#34;submit\u0026#34;]:focus { background-color: #333; } 1 2 3 4 5 6 7 8 \u0026lt;form\u0026gt; \u0026lt;div\u0026gt;\u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; 至于样式化表单的更加深入的信息，可以看下这些教程的 HTML 一节的这两篇文章：\nStyling HTML Forms Advanced Styling for HTML Forms ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb11-css05-%E9%83%A8%E5%88%86%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e该篇章主要收集一些常见的样式设置的参考页和一些需要记住的重要设置内容，由于不可能记住所有的属性和设置，善用查询可能才是唯一的王道。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003chr\u003e\n\u003ch2 id=\"css-中的值与单位\"\u003eCSS 中的值与单位\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units\" target=\"_blank\" rel=\"noopener\"\u003eCSS 中的值与单位\u003c/a\u003e\n 这里介绍常见的一些值和单位，有一些新的可能会有所缺失，但是大部分都有了，这里可以列举几个常见但是之前不理解的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eem\u003c/code\u003e 相对字体大小\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evw\u003c/code\u003e 视窗宽度，值为百分比的含义\u003c/li\u003e\n\u003cli\u003e百分比：与父辈容器的百分比\u003c/li\u003e\n\u003cli\u003ergba 或者 rgb 的第四个值代表透明度，十六进制想设置透明度的话，就在后面再加两位 16 进制表示透明度的百分比。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里倒是提示我们需要有个比较好的取色器或者像 vscode 中的色盘来编写 css，颜色搭配网站在 css 中也是很重要的。\u003c/p\u003e","title":"LearnWeb11-CSS05-部分常见样式设置"},{"content":"\rSummary\rHTML 和 CSS 中，所有的元素都是基于一个个的 Box 去渲染的，理解盒子模型的设计，才能知道如何进行布局，从而使的页面按照希望的样子呈现，该定义实际上和 HTML 的块级元素和内联元素使完全相对应的。需要注意两者之间的关联性。\n块级盒子(Block Box)和内联盒子(Inline Box) 块级盒子和 HTML 中的块级元素使相互对应的，例如 h 和 p 有以下的特点：\n与其他元素之间会换行 因为换行，在内联的方向上（也就是行）会占据所有可用空间，即绝大多数情况下和父容器一样宽。 width 和 height 属性均可发挥总用 内边距（padding）, 外边距（margin）和边框（border）会将其他元素从当前盒子周围“推开” 内联盒子和 HTML 中的内联元素相互对应，例如 span, em, strong 等，有以下的特点：\n不会换行 width 和 height 属性不起作用 垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。 水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。 如果希望切换元素的内联或者块级属性，可以通过对盒子的 display 属性设置进行切换，对应的属性值为 inline 和 block，而更有趣的，如果我们希望不换行，但是内联中的 width 和 height 属性起到作用，可以使用 inline-box 属性。\nInline-box 属性在导航栏/链接元素中很常见，我们通过增大内容区域来使得链接存在更大的命中区域，同时不影响别的元素的呈现。\n在这里还会看到片一个十分常见的盒子属性 flex 其通常会将外部的显示类型转换为 block，但是内部的显示类型设置为 flex，对其内部的各个子元素，都将转换为 flex 元素，并基于 flex 即弹性盒子的规则 进行布局，可以生成更灵活的界面，这个后面在排版部分针对性的了解，这里简单介绍如下：\nflex 会将内部的元素默认沿着行的方向均分切成几个 box，但是具体的切分可以根据后续的属性进行定义。 如果希望 flex 的外部为内联的，则使用 inline-flex 属性。 盒子模型 CSS 中一个块级标准盒子包括几个重要的定义，可以结合下面这张图查看，其中蓝色的同样也是可以调整的属性值, 可以很容易的通过浏览器的开发者工具去检查和查看 box 模型：\nContent Box 区域可以结合 Height 和 Width 属性定义区域大小 Padding Box 也就是内容区域和边界之间的空白； Border Box 边框的范围是在 Content 区域+四周 Padding 指定值得到，包含内容和 padding 区域 Margin Box 所在的虚线框则是我们的盒子和其他元素之间的空白区域，也可以理解为间隔，使用 Margin 属性定义 Border 和外界的距离 也可以使用替代模型去描述一个 box，如果是这种情况就使用 box-sizing: border-box; 处理一个盒子，这种情况下 width 和 height 指的是到 border 的长和宽，这里不多讲，如果希望全部使用原始盒模型可以使用以下的代码：\n1 2 3 4 5 6 7 8 html{ box-sizing: border-box; } *, *::before, *::after{ box-sizing: inherit; } Box 的属性设置详解 MARGIN：详情参考之前的属性简写部分，主要是上左下右四个 margin，这里需要注意的是，其 value 均可为正负值\n通过负值收缩空间，可以呈现元素相交和堆叠的效果。 通过正值推开空间，令 box 独立呈现。 如果有两个 BOX 相邻等类似的情况，这样两者之间的 Margin 会取 margin-top 和 margin-bottom 中较大的一个，而非相加，需要详解可参阅外边距重叠 Padding：和 Margin 一样，但是不可以为负值。\nBorder：边框 box 本身和 padding 做区分的原因是因为其主要描绘的是四条边框线，同样可以区分或者共同控制：\n分别设置每边的宽度、颜色和样式，可以使用：\nborder-top border-right border-bottom border-left 设置所有边的颜色、样式或宽度，请使用以下属性：\nborder-width border-style border-color 设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：\nborder-top-width border-top-style border-top-color border-right-width border-right-style border-right-color border-bottom-width border-bottom-style border-bottom-color border-left-width border-left-style border-left-color 参阅 MDN 文档。\n内容溢出处理 当往 box 塞入太多内容的时候可能会导致元素从 Box 边框中溢出，导致呈现效果一团答辩（但是也比消失了好，消失了可能会导致问题没有被发现），css 中通过 overflow 来控制这些溢出内容：\n1 2 3 4 .box{ ... overflow: hidden; } 默认为 visible 会溢出 设置为 hidden 则会直接截断， 设置为 scroll 浏览器会总是提供滚动条，避免内容的消失（但并不适合所有情况），如果我们仅需在一个方向上滚动，可以使用 overflow-y 仅对 y 轴方向设置溢出处理，不然有两个滚动条可能也不太美观。 设置为 auto 浏览器会仅在内容溢出的时候才会显示滚动条。 ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb10-css04-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003eHTML 和 CSS 中，所有的元素都是基于一个个的 Box 去渲染的，理解盒子模型的设计，才能知道如何进行布局，从而使的页面按照希望的样子呈现，该定义实际上和 HTML 的块级元素和内联元素使完全相对应的。需要注意两者之间的关联性。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"块级盒子block-box和内联盒子inline-box\"\u003e块级盒子(Block Box)和内联盒子(Inline Box)\u003c/h2\u003e\n\u003cp\u003e块级盒子和 HTML 中的块级元素使相互对应的，例如 \u003ccode\u003eh\u003c/code\u003e 和 \u003ccode\u003ep\u003c/code\u003e 有以下的特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e与其他元素之间会换行\u003c/li\u003e\n\u003cli\u003e因为换行，在内联的方向上（也就是行）会占据所有可用空间，即绝大多数情况下和父容器一样宽。\u003c/li\u003e\n\u003cli\u003ewidth 和 height 属性均可发挥总用\u003c/li\u003e\n\u003cli\u003e内边距（padding）, 外边距（margin）和边框（border）会将其他元素从当前盒子周围“推开”\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e内联盒子和 HTML 中的内联元素相互对应，例如 \u003ccode\u003espan\u003c/code\u003e, \u003ccode\u003eem\u003c/code\u003e, \u003ccode\u003estrong\u003c/code\u003e 等，有以下的特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不会换行\u003c/li\u003e\n\u003cli\u003ewidth 和 height 属性不起作用\u003c/li\u003e\n\u003cli\u003e垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 \u003ccode\u003einline\u003c/code\u003e 状态的盒子推开。\u003c/li\u003e\n\u003cli\u003e水平方向的内边距、外边距以及边框会被应用且会把其他处于 \u003ccode\u003einline\u003c/code\u003e 状态的盒子推开。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果希望切换元素的内联或者块级属性，可以通过对盒子的 display 属性设置进行切换，对应的属性值为 \u003ccode\u003einline\u003c/code\u003e 和 \u003ccode\u003eblock\u003c/code\u003e，而更有趣的，如果我们希望不换行，但是内联中的 \u003ccode\u003ewidth\u003c/code\u003e 和 \u003ccode\u003eheight\u003c/code\u003e 属性起到作用，可以使用 \u003ccode\u003einline-box\u003c/code\u003e 属性。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eInline-box 属性在导航栏/链接元素中很常见，我们通过增大内容区域来使得链接存在更大的命中区域，同时不影响别的元素的呈现。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在这里还会看到片一个十分常见的盒子属性 \u003ccode\u003eflex\u003c/code\u003e 其通常会将外部的显示类型转换为 block，但是内部的显示类型设置为 flex，对其内部的各个子元素，都将转换为 flex 元素，并基于 flex 即\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox\" target=\"_blank\" rel=\"noopener\"\u003e弹性盒子的规则\u003c/a\u003e\n进行布局，可以生成更灵活的界面，这个后面在排版部分针对性的了解，这里简单介绍如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eflex 会将内部的元素默认沿着行的方向均分切成几个 box，但是具体的切分可以根据后续的属性进行定义。\u003c/li\u003e\n\u003cli\u003e如果希望 flex 的外部为内联的，则使用 inline-flex 属性。\u003c/li\u003e\n\u003c/ul\u003e","title":"LearnWeb10-CSS04-盒子模型"},{"content":"\rSummary\r本章节是额外对于优先级的补充章节，在使用上可能会没有明显的感知，但是从概念上理解 CSS 的优先级和后续复杂项目的开发中还是起到了比较大的作用，该章节介绍层叠层的概念，在原先的优先级判定上添加了层的概念。\n层叠概念回顾 该 Section 内容完全摘录自 MDN CSS 教程，也算是对于整体重要性和优先级的一个很好的总结。\n相关声明：找到所有具有匹配每个元素的选择器的声明代码块。 重要性：根据规则是普通还是重要对规则进行排序。重要的样式是指设置了 !important (en-US) 标志的样式。 来源：在两个按重要性划分的分组内，按作者、用户或用户代理这几个来源对规则进行排序。 层：在六个按重要性和来源划分的分组内，按层叠层进行排序。普通声明的层顺序是从创建的第一个到最后一个，然后是未分层的普通样式。对于重要的样式，这个顺序是反转的，但保持未分层的重要样式优先权最低。 优先级：对于来源层中优先权相同的竞争样式，按优先级 对声明进行排序。 出现顺序：当两个来源层的优先权相同的选择器具有相同的优先级时，最后声明的具有最高优先级的选择器的属性值获胜。 CSS 渲染过程中会逐步往下选择，如果在中间已经决出了胜负就不会继续往下，例如对一个元素在每个来源中只有一个定义，那么在来源层就可以决出胜负，无需往下了，而若获胜的来源中有多个层定义了同个属性，那么就会对比各个层的优先级，诸如此类。\n其他的部分前文已经基本提到了，接下来补充来源和层的两个概念。\n![note]+ 三个来源中的：\u0026lsquo;用户代理\u0026rsquo;指的是浏览器，用户指的是网站访问者，作者指的是网站开发者，浏览器内部将来自这三个来源的样式表进行来源的排序。\n来源的优先级排序 有三种层叠来源类型 ：用户代理样式表、用户样式表和作者样式表。浏览器根据来源和重要性将每个声明分为六个来源分组。有八个优先权级别：六个来源分组、正在过渡的属性和正在动画的属性。优先权的顺序是从具有最低优先权的普通用户代理样式，到当前应用的动画中的样式，到具有最高优先权的重要用户代理样式，再到正在过渡的样式：\n用户代理普通样式 用户普通样式 作者普通样式 正在动画的样式 作者重要样式 用户重要样式 用户代理重要样式 正在过渡的样式 用 \u0026lt;style\u0026gt; 元素直接在元素上声明的样式是作者样式。不包括动画和过渡样式，用户代理普通样式具有最低优先权；用户代理重要样式具有最高优先权。\n层叠层的概念和作用 概念: 结合上述两个 section 的内容，我认为层叠层实际上就是引入一个 layer 的概念，在编写 CSS 的时候将规则放到不同的层中，用来更加方便的区分优先级，就想一层一层的给网页刷上样式一样，越往后的优先级默认越高；其中仅有一个例外就是限定了 !important 的规则，他就像是一个占位符，预先确定了某个元素的样式，基于该规则进行\u0026quot;拓展\u0026quot;，因此其越早出现优先级越高。\n作用:\n通过这种方式便于多人同时开发时的协作，复杂项目时的持续开发和维护等，也以一种类似分桶的方式便于 Debug 样式的问题，使得 CSS 的逻辑更加清晰。 层叠层中还允许创建嵌套层，例如每个人使用的组件库不同时，可以各自将组件库嵌入自己的层中，消除组件库的定义与其他人的样式冲突，同时也确保开发过程中能够方便的使用和调整组件库而无需考虑优先级。 因此具体使用的时候，我们可以使用嵌套层的方式，将默认样式、第三方组件、主题等等首先嵌入层中，然后在开始继续的开发，这样在处理优先级的时候我们就无需考虑也无需解决跨层的冲突。\n层叠层使用 使用 @layer 声明 at 规则，使用 @layer 后跟一个或者多个层的名称来声明层，这将创建一个没有任何样式的具名层； 使用 @layer 块 at 规则，在快中的所有样式都将添加到一个命名或者未命名的层中 使用具有 layer 关键字或 layer() 函数的 @import 规则，将导入文件的内容分配到该层中。 在尚未初始化具有相同名称的层的情况下，这三种方法中的任何一种都会创建一个层。如果在 @layer at 规则或带有 layer() 的 @import 中没有提供层名称，则将创建一个新的匿名层。\n1-2 的区别实际上就是先声明或者带初始值声明，例如以下的 cpp 代码\n1 2 3 4 5 // 第一种 std::vector\u0026lt;int\u0026gt; a_arr; a_arr.push_back({1,2,3}); // 第二种 std::vector\u0026lt;int\u0026gt; a_arr = {1, 2, 3}; 备注： 层的优先顺序是它们创建的顺序。不在层中的样式，或者称为“未分层样式”，会层叠到最终的隐式标签中。\n使用 @layer 声明 at 规则 1 @layer theme, components, default; 通常在 CSS 的第一行进行层的声明，避免有些规则漏掉导致没办法使用层完全控制样式的优先级，上述层的出现顺序即是声明的顺序，可以看到我们是先刷了一层主题，再往上刷组件，刷默认值，最后剩下的是我们最后自定义和调整的内容（未添加到具体名称里的会自动添加到匿名层中，且最后定义）。\n此外需要注意的是，如果上述三个层并非放在最上方，而且有一些层已经被定义了，那么被定义的层在这里不会再次声明，而只会被忽略，剩下的层将添加在已有的层之后，所以推荐还是在最前面定义。\n使用 @layer 块 at 规则添加具体的样式 1 2 3 4 5 @layer theme{ main { display: grid; } } 使用块 at 规则可以：创建层并将块内的样式初始化添加进该层。如果没有指定 theme 名称的话，则会创建匿名层，每次未命名都会创建一个新的匿名层，而不是共用同个匿名层，这些匿名层也没办法往里面添加样式了。\n使用媒体查询来创建层 同样考虑到不同的设备尺寸，让我们通过媒体查询来决定是否定义某些层，这样也可以用来做页面的响应式设计，在不同的设备上生效不同的层即可，具体的代码范例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @media (min-width: 50em) { @layer site; } @layer page { h1 { text-decoration: overline; color: red; } } @layer site { h1 { text-decoration: underline; color: green; } } 这样在宽屏上，事先定义的则是 site，否则为 page，这样就会使得样式发生变化，从而实现页面的响应式设计。\n使用 @import 将样式表导入层 这一部分直接节选自 MDN，描述得很清楚了。\n@import 规则允许用户直接从其他样式表导入样式规则到 CSS 文件或 \u0026lt;style\u0026gt; 元素中。\n导入样式表时，必须在样式表或 \u0026lt;style\u0026gt; 块中的任何 CSS 样式之前定义 @import 语句。@import 语句必须出现在最前面，在任何样式之前，但可以在创建一个或多个层而不向这些层分配任何样式的 @layer 规则之后（@import 也可以在 @charset 规则之后）。\n你可以将样式表导入具名层、嵌套具名层或匿名层。以下层分别将样式表导入 components 层、components 层中的嵌套 dialog 层和一个未命名层：\n1 2 3 @import url(\u0026#34;components-lib.css\u0026#34;) layer(components); @import url(\u0026#34;dialog.css\u0026#34;) layer(components.dialog); @import url(\u0026#34;marketing.css\u0026#34;) layer(); 这里注意层的嵌套使用的是 . 符号，无论是命名，引用，添加样式表到该嵌套层，都使用的这个符号，使用 import 导入的嵌套层会默认在该层的末尾，吧 但是在同层中，非嵌套的样式会优先于普通嵌套的样式，嵌套层之间的优先级则基于顺序决定。\n你可以将多个 CSS 文件导入到单个层中。以下声明将两个单独的文件导入到单个 social 层中：\n1 2 @import url(comments.css) layer(social); @import url(sm-icons.css) layer(social); 你可以使用媒体查询 和特性查询 根据特定条件导入样式并创建层。以下将样式表导入到 international 层，但前提是浏览器支持 display: ruby，而且被导入的文件取决于屏幕的宽度。\n1 2 3 4 @import url(\u0026#34;ruby-narrow.css\u0026#34;) layer(international) supports(display: ruby) and (width \u0026lt; 32rem); @import url(\u0026#34;ruby-wide.css\u0026#34;) layer(international) supports(display: ruby) and (width \u0026gt;= 32rem); 层的优先级 整体判断优先级的逻辑和之前整理的是一致的，这里就简单给一下 MDN 中提到的总结。\n层的优先权顺序是创建层的顺序。 一旦创建，就无法更改层顺序。 普通样式的层优先权是创建层的顺序。 未分层普通样式优先于有层普通样式。 重要样式的层优先权被反转，早期创建的层具有优先权。 所有有层的重要样式都优先于未分层的重要（和普通）样式。 普通内联样式优先于所有普通样式，无论是否分层。 重要内联样式优先于所有其他样式，正在过渡的样式除外。 作者样式无法覆盖重要内联样式（过渡除外，但这是临时的） 嵌套层的层叠优先权顺序与常规层类似，但包含在层内。优先权顺序基于嵌套层创建的顺序。层中的非嵌套样式优先于嵌套的普通样式，对于重要样式则相反。嵌套层之间的优先级权重并不重要，但它在嵌套层内的冲突样式中确实很重要。\n","permalink":"https://hugotest-phi.vercel.app/posts/learnweb09-css03-%E5%B1%82%E5%8F%A0%E5%B1%82/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e本章节是额外对于优先级的补充章节，在使用上可能会没有明显的感知，但是从概念上理解 CSS 的优先级和后续复杂项目的开发中还是起到了比较大的作用，该章节介绍层叠层的概念，在原先的优先级判定上添加了层的概念。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"层叠概念回顾\"\u003e层叠概念回顾\u003c/h2\u003e\n\u003cp\u003e该 Section 内容完全摘录自 MDN CSS 教程，也算是对于整体重要性和优先级的一个很好的总结。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e相关声明\u003c/strong\u003e：找到所有具有匹配每个元素的选择器的声明代码块。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e重要性\u003c/strong\u003e：根据规则是普通还是重要对规则进行排序。重要的样式是指设置了 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/important\" title=\"Currently only available in English (US)\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003e!important\u003c/code\u003e (en-US)\u003c/a\u003e\n 标志的样式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e来源\u003c/strong\u003e：在两个按重要性划分的分组内，按作者、用户或用户代理这几个来源对规则进行排序。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e层\u003c/strong\u003e：在六个按重要性和来源划分的分组内，按层叠层进行排序。普通声明的层顺序是从创建的第一个到最后一个，然后是未分层的普通样式。对于重要的样式，这个顺序是反转的，但保持未分层的重要样式优先权最低。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e优先级\u003c/strong\u003e：对于来源层中优先权相同的竞争样式，按\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity\" target=\"_blank\" rel=\"noopener\"\u003e优先级\u003c/a\u003e\n对声明进行排序。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e出现顺序\u003c/strong\u003e：当两个来源层的优先权相同的选择器具有相同的优先级时，最后声明的具有最高优先级的选择器的属性值获胜。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eCSS 渲染过程中会逐步往下选择，如果在中间已经决出了胜负就不会继续往下，例如对一个元素在每个来源中只有一个定义，那么在来源层就可以决出胜负，无需往下了，而若获胜的来源中有多个层定义了同个属性，那么就会对比各个层的优先级，诸如此类。\u003c/p\u003e\n\u003cp\u003e其他的部分前文已经基本提到了，接下来补充来源和层的两个概念。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e![note]+\n三个来源中的：\u0026lsquo;用户代理\u0026rsquo;指的是浏览器，用户指的是网站访问者，作者指的是网站开发者，浏览器内部将来自这三个来源的样式表进行来源的排序。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"来源的优先级排序\"\u003e来源的优先级排序\u003c/h3\u003e\n\u003cp\u003e有三种\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade#origin_types\" target=\"_blank\" rel=\"noopener\"\u003e层叠来源类型\u003c/a\u003e\n：用户代理样式表、用户样式表和作者样式表。浏览器根据来源和重要性将每个声明分为六个来源分组。有八个优先权级别：六个来源分组、正在过渡的属性和正在动画的属性。优先权的顺序是从具有最低优先权的普通用户代理样式，到当前应用的动画中的样式，到具有最高优先权的重要用户代理样式，再到正在过渡的样式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e用户代理普通样式\u003c/li\u003e\n\u003cli\u003e用户普通样式\u003c/li\u003e\n\u003cli\u003e作者普通样式\u003c/li\u003e\n\u003cli\u003e正在动画的样式\u003c/li\u003e\n\u003cli\u003e作者重要样式\u003c/li\u003e\n\u003cli\u003e用户重要样式\u003c/li\u003e\n\u003cli\u003e用户代理重要样式\u003c/li\u003e\n\u003cli\u003e正在过渡的样式\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e用 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/style\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003e\u0026lt;style\u0026gt;\u003c/code\u003e\u003c/a\u003e\n 元素直接在元素上声明的样式是作者样式。不包括动画和过渡样式，用户代理普通样式具有最低优先权；用户代理重要样式具有最高优先权。\u003c/p\u003e","title":"LearnWeb09-CSS03-层叠层"},{"content":"\rNote\r你永远无法记住所有的 CSS 属性，善用参考资料：MDN CSS reference 和 GPT 善用浏览器的开发者面板在页面上及时编辑 CSS。 CSS 运行逻辑 前面在 LearnWeb00-Web入门 中简单提及了浏览器以及 CSS 起了什么作用，这里则是对于 CSS 是如何具体参与进页面的渲染的讲解，包括早该知道的 DOM 的定义也会在这里介绍，是 CSS 是如何运行 的读书笔记。\n浏览器获取了 HTML 之后：\n会拉取其所依赖的所有 CSS，JS 和静态资源（Parser HTML） 解析 HTML 代码，根据其中的 Tag、Class、ID 和相互之间的关系将 HTML 解析成 DOM ，每个元素作为其中的一个节点放进相对应的桶中。（元素桶、ID 桶之类） 紧接着，在拉取完 CSS 之后，浏览器开始解析 CSS，基于 CSS 中的选择器找到每个样式所属的 DOM 节点，并将其添加进去。\n最后基于最终的 DOM(Document Object Model) 渲染出完整的页面，这里对 DOM 进行一个简单的解释：\n一个 DOM 有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点（Node/DOM 或 DOM node）。节点由节点本身和其他 DOM 节点的关系定义，有些节点有父节点，有些节点有兄弟节点（同级节点）。\n此外浏览器在渲染过程中如果遇到了位置的 CSS 会直接跳过相应的 CSS ，然后渲染下一个规则。\n@规则 @rules(at-rules)是一类特殊的规则，\u0026ldquo;提供了关于 CSS 应该执行什么或如何表现的指令\u0026rdquo;。具体而言主要有以下两类：\n第一类：引入别的样式文件\n1 @import \u0026#34;style/style2.css\u0026#34;; 第二类：引入媒体查询 ，按照媒体的样式（例如视窗的大小）来决定使用的样式，这一点也是为了响应式布局很重要的一点；\n1 2 3 4 5 6 7 8 9 body { background-color: pink; } @media (min-width: 30em) { body { background-color: blue; } } 当窗口（可以通过调整浏览器宽度来改变）宽度\u0026gt;30em 时使用另外的背景颜色。\n代码添加空白 Quota\r空白是指实际的空格、制表符和换行符。就像浏览器忽略了 HTML 中的空白一样，浏览器也忽略了 CSS 中的空白。空白的价值在于它可以提高可读性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 body { font: 1em/150% Helvetica, Arial, sans-serif; padding: 1em; margin: 0 auto; max-width: 33em; } @media (min-width: 70em) { body { font-size: 130%; } } 可以使用 format 插件来对代码进行重构，增强代码的可读性。但是记得空白也不是随便用的，比如简写属性中的空白就用来区分不同的属性值，对于名称中的空白切分也会导致异常。\n属性与值进阶 大多数情况下属性的值为关键词或者数值，但是也会有一些较为复杂的场景存在，例如简单的一些函数。\nCalc() 函数 1 2 3 4 5 6 7 8 9 10 .outer { border: 5px solid black; } .box { padding: 10px; width: calc(90% - 30px); background-color: rebeccapurple; color: white; } 1 \u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;内部盒子的宽度为 90% - 30px。\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; 上述的 width 使用 calc 将宽度表达为 90% - 30 像素，使用 Calc 可以执行一些简单的数值计算流程。\nTransform 函数 transform 属性通常用于图像变形，因此其取值通常为一些函数，这里以 rotate 为例。\n1 \u0026lt;div class:\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 .box { margin: 30px; width: 100px; height: 100px; background-color: rebeccapurple; transform=rotate(0.8turn) } 上述代码会得到一个旋转后的 box，诸如此类，Transform 还有一些别的常用函数，后续可能会比较频繁的遇到，同样可以在 MDN 查询。\n简写属性 Quota\r一些属性，如 font 、background 、padding 、border 和 margin 等属性称为简写属性。它们允许在一行中设置多个属性值，从而节省时间并使代码更整洁。\n典型的例子就是边框定义，需要定义四个方向的边框，如 padding-top 和 padding-bottom，可以使用 padding 直接定义四个值来节省时间，顺序为顺时针（上右下左）\n1 padding: 10px 15px 15px 5px; 更多的可以参考 MDN 的 CSS 参考页面 ，找到更多简写资源如：background 选择器进阶 基础 CSS 规则中介绍了一些基本的选择器类别，这里为选择器做相对进阶的介绍，包括一些选择器的组合和运算，一些其他的用法，还有一些特别的选择器。\n同时选择多个元素 如果要选择多个类型的元素并为他们添加同一种规则集，可以使用 ， 对不同元素进行分割如下。\n1 2 3 p,li,h1 { color: red; } 上述代码会将列表，大标题，普通段落都使用红色渲染。\n伪类选择器理解 参考伪类和伪元素 ，伪类选择器的名称可能会让人困惑，实际上可以理解为一些状态或者一些辅助类别，可能是选择在特定状态下的某些元素，举个例子，链接点击前后的不同颜色：\n1 2 3 4 5 6 7 a:link{ color: pink; } a:visited{ color: grey; } 或者一些父子节点关系，如选择元素的某一个部分而不是整个元素，下面的例子选择 article 中作为第一个 child 的 p 元素，通常为第一段\n1 2 article p:first-child{ } 或者用一些选择特定子节点的伪类 :nth-child(even)，括号内接 index 为特定的子元素，也可以用 even 和 odd 指定奇偶，有特殊需求的时候可以去查表或者查 Chatgpt。\n伪元素选择器 参考伪类和伪元素 有一些特殊的元素，描述了一些特别的状态，例如：\n::first-line:选中第一行的内容 ::before: 在所有内容之前添加，可以插入一些辅助图标等 ::after:在所有内容之后添加，可以插入一些辅助图表等 举个例子，选择 article 部分的第一段的第一行：\n1 2 article p:first-child::first-line{ } 选择器组合方法 元素和类选择器嵌套：如果使用了 p.my-class 作为选择器，含义是只选择 p 元素中类名为 my-class 的元素，这个时候 a 元素的 my-class 就会被忽略。 类选择器嵌套：如果使用了 .log.warning 作为选择器，则会选择出 log 类中的 warning 类的元素，这里补充一个知识，就是 HTML 一个元素定义多个类的方式 \u0026lt;p class=\u0026quot;log warning\u0026quot;\u0026gt; 使用空格分割 使用空格后代选择：下述代码的选择器会选中 list 中的所有 em 元素，不在 list 中的 em 元素会被忽略，使用方法是基于先后顺序，以及使用空格分开。 1 2 3 li em { color:red; } 使用 + 相邻选择符：下述代码会选中与 h1 相邻的 p 中的 span 元素 1 2 3 4 h1 + p span{ font-size: 200%; color: red; } 使用 \u0026gt; 子代关系选择符：只会选中子代，孙代及以上的不会被选中 使用 ~ 兄弟关系选择符：举个例子，下述代码会选中 h1 之后的所有 p 元素。 1 2 h1 ~ p { } 全局选择器 * * 全局选择器，选中文档中的所有内容（或者是父元素中的全部内容），通常用于和其他元素组合，避免一些选择器组合中的歧义，例如和伪类选择器组合，选择第一个子元素的情况。\n1 2 article :first-child { } 上述代码用来选择 article 中的第一个子元素，但是该写法容易和下述写法混淆\n1 2 article:first-child{ } 而该写法表示的则是任何作为第一个子元素的 article 元素，意义上完全不同，因此为了可读性和可维护性，建议引入全局变量如下：\n1 2 article *:first-child{ } 表达了作为 article 元素中第一个子元素的任何元素，则符合我们的需求，也不容易产生混淆。\n属性选择器 属性选择器引入了部分正则的语法，可以较为灵活的判断属性值是否（以某种形式）包含了某个 Value，基础的语法如下：\n1 2 [attr]{ } 该语句选择具有 [attr] 属性的所有元素，当然也可以和其他的选择器做组合，这里后续不在赘述。\n如果需要指定 attr 的值，有以下的多种方式：\n[attr=value]: 存在只有一个且正好相等 [attr^=value]: 存在至少一个以 value 开头的属性 [attr$=value]: 存在至少一个以 value 结尾的属性 [attr*=value]: 存在至少一个含有 value 的属性 [attr~=value]: 完全相等或者包含一个 value [attr|=value]: 匹配 value 或者以 value 加连字符开头的属性值 \u0026hellip; 如果希望属性值大小写不敏感，可以添加 i 如下：\n1 [attr i] 页面样式渲染逻辑 会有同个元素被多个选择器渲染的情况，这种情况下会基于层叠（cascade）和优先级（specificity）规则对元素进行渲染。\n样式渲染规则 规则一：后出现的规则会覆盖先出现的规则（即层叠规则）\n1 2 p { color: red; } p { color: blud; } 在同等优先级的情况下 css 后出现的会覆盖之前出现的，可以理解为按顺序声明的语句。\n规则二：更具体的选择器具备更高的优先级：\n1 2 .special { color: blue; } p { color: red; } 1 \u0026lt;p class=\u0026#34;special\u0026#34;\u0026gt;我是什么颜色的？\u0026lt;/p\u0026gt; 例如上述 Case 中，css 中 special 的定义是在段落的基础之前的，因此段落文本理论上首先被渲染为蓝色，后续被 p 的红色覆盖，但是由于 special 作为类，被认为是比基础标签 p 的优先级更高，因此最终会被渲染成蓝色；\n具体的权重计算规则：\n一个选择器的优先级可以说是由三个不同的值（或分量）相加，可以认为是百（ID）十（类）个（元素）——三位数的三个位数：\nID：选择器中包含 ID 选择器则百位得一分。 类：选择器中包含类选择器、属性选择器或者伪类则十位得一分。 元素：选择器中包含元素、伪元素选择器则个位得一分。 此外还有内联样式：总是最高优先级; 以及特殊的属性值 !important 也是默认为最高优先级\n因此，由于优先级的存在，有时候某个元素可能会不按照预期渲染，这种时候查看被多少个选择器选中并进行调整即可。且优先级计算的时，由于有 !important 特殊属性值的存在，因此并不总是按照组来整体应用和计算。@important 和其他的属性不同，是先定义的优先级更高。\n样式继承关系 子元素的例如颜色，字体等属性是会继承父元素的，而像是 box 相关的边框属性（边框边距等）是不会继承的，否则设置了一个相对 page 为 50%的 box，其中的子元素直接指数级缩小可还得了。\n🔥mdn YTB 视频教程：如何使用开发者工具来检查级联和优先级 ： 在 rule 面板会列出所有的规则，可以点击元素旁边的按钮来定位，也可以直接在页面上修改，且位于越上方的规则其权重越重。在规则页面的下方也会有继承的面板。\n当然也可以手动的调整和控制继承，CSS 定义了五个特殊的通用属性值，用来简化部分内容重写的工作：\ninherit 继承父元素的对应属性值，实际上就是开启集成 initial 将属性还原初始值 revert 还原为浏览器的默认样式，大多数情况下=unset revert-layer 将属性值还原为上一个层叠层中建立的值 unset 重置为自然值，如果属性是自然继承就是 inherited, 否则就是 initial。 可以结合 all 属性将所有属性重置。\n级联层顺序 级联层相当于是将 css 分成几个大组，同样还是后声明的优先级更高，同样 import 还是个例外是相反的。未包含在某个级联层的则会默认放在最后一个未命名的组中声明，因此会有最高的优先级。\n下面给个级联层的定义例子，这个特性暂时不需要掌握，后续再看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @layer firstLayer, secondLayer; p { /* 0-0-1 */ background-color: red; color: grey !important; border: 5px inset purple; } p#addSpecificity { /* 1-0-1 */ border-style: solid !important; } @layer firstLayer { #addSpecificity { /* 1-0-0 */ background-color: blue; color: white !important; border-width: 5px; border-style: dashed !important; } } @layer secondLayer { p#addSpecificity { /* 1-0-1 */ background-color: green; color: orange !important; border-width: 10px; border-style: dotted !important; } } ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb08-css02-css%E5%85%A5%E9%97%A8/","summary":"\u003cblockquote class=\"alert-blockquote alert-note\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eNote\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e\u003col\u003e\n\u003cli\u003e你永远无法记住所有的 CSS 属性，善用参考资料：\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference\" target=\"_blank\" rel=\"noopener\"\u003eMDN CSS reference\u003c/a\u003e\n 和 GPT\u003c/li\u003e\n\u003cli\u003e善用浏览器的开发者面板在页面上及时编辑 CSS。\u003c/li\u003e\n\u003c/ol\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"css-运行逻辑\"\u003eCSS 运行逻辑\u003c/h2\u003e\n\u003cp\u003e前面在 \u003ca href=\"LearnWeb00-Web%e5%85%a5%e9%97%a8.md\"\u003eLearnWeb00-Web入门\u003c/a\u003e\n 中简单提及了浏览器以及 CSS 起了什么作用，这里则是对于 CSS 是如何具体参与进页面的渲染的讲解，包括早该知道的 DOM 的定义也会在这里介绍，是 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works\" target=\"_blank\" rel=\"noopener\"\u003eCSS 是如何运行\u003c/a\u003e\n的读书笔记。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240205140358.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240205140358.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240205140358.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e浏览器获取了 HTML 之后：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e会拉取其所依赖的所有 CSS，JS 和静态资源（Parser HTML）\u003c/li\u003e\n\u003cli\u003e解析 HTML 代码，根据其中的 Tag、Class、ID 和相互之间的关系将 HTML 解析成 DOM ，每个元素作为其中的一个节点放进相对应的桶中。（元素桶、ID 桶之类）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e紧接着，在拉取完 CSS 之后，浏览器开始解析 CSS，基于 CSS 中的选择器找到每个样式所属的 DOM 节点，并将其添加进去。\u003c/p\u003e\n\u003cp\u003e最后基于最终的 DOM(Document Object Model) 渲染出完整的页面，这里对 DOM 进行一个简单的解释：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e一个 DOM 有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点（Node/DOM 或 DOM node）。节点由节点本身和其他 DOM 节点的关系定义，有些节点有父节点，有些节点有兄弟节点（同级节点）。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e此外浏览器在渲染过程中如果遇到了位置的 CSS 会直接跳过相应的 CSS ，然后渲染下一个规则。\u003c/p\u003e","title":"LearnWeb08-CSS02-CSS入门"},{"content":"\rSummary\rHTML 中需要使用 CSS 进行样式组合才能得到一个阅读体验较好的表格，目前还是先专注在 HTML 的部分，后面到 CSS 部分的时候再合起来一起看。\n本文主要是参考 MDN 范例 中的源码以及对应的文章 HTML 表格基础 的一篇阅读笔记。\n表格基础 从源码开始我们可以看到表格对应的 Tag 核心的一下几个：\n\u0026lt;Table\u0026gt; 包裹整个表格 \u0026lt;caption\u0026gt; 设置表格的标题 \u0026lt;tr\u0026gt; 一行一行的包裹表格，全称应该是 table row 可以看到 HTML 中编写表格是使用 \u0026lt;tr\u0026gt; 进行逐行编写的，逐行的描述整个表格：\n用 \u0026lt;td\u0026gt; 描述表格的内容语义，table data 用 \u0026lt;th\u0026gt; 描述表格的标题语义，即首行首列的标题元素 table header 主要的元素就是上面这些，但是复杂的表格包括：合并的单元格（纵向和横向）需要再 th 和 td 中使用额外的属性来定义：colspan 和 rowspan\ncolspan=\u0026quot;2\u0026quot; 属性定义占据两个单元格宽度（横向合并） rowspan=\u0026quot;3\u0026quot; 属性定义占据三个单元格的宽度（纵向合并） 然后每个 tr 中排除掉被合并的单元格还需要多少个 td 需要我们自己计算。\nHTML 的表格基础样式 可以使用 colgroup 和 col 为整列设置同样的样式，每个 col 元素代表一列，如果需要一条元素定义多列的样式的时候可以使用 span 属性，下述代码会将第二列背景设置为黄色。\n对单个单元格设置样式可以仿照使用 style 属性来嵌入对应的 css 样式，包括宽度什么的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;table\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col /\u0026gt; \u0026lt;col style=\u0026#34;background-color: yellow\u0026#34; /\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Data 1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Data 2\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Calcutta\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Orange\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Robots\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Jazz\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; HTML 表格结构化 Quota\r由于表格在结构上有点复杂，如果把它们定义得更加结构化，那会帮助我们更能了解结构。一个明确的方法是使用 \u0026lt;thead\u0026gt; 、\u0026lt;tfoot\u0026gt; 和 \u0026lt;tbody\u0026gt; ，这些元素允许你把表格中的部分标记为表头、表尾、表体三部分。\n这样的结构化实际上没有什么默认 style，主要是帮助我们后续定义各个部分的样式。\n其他 表格元素支持嵌套 使用 scope 属性 来支持视障人士来理解这个表格 ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb07-html04-%E8%A1%A8%E6%A0%BC%E5%9F%BA%E7%A1%80/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003eHTML 中需要使用 CSS 进行样式组合才能得到一个阅读体验较好的表格，目前还是先专注在 HTML 的部分，后面到 CSS 部分的时候再合起来一起看。\u003c/p\u003e","title":"LearnWeb07-HTML04-表格基础"},{"content":"\rSummary\r接下来主要探讨 HTML 中的多媒体元素，图片、视频、音频以及 iframe 等等。\n图片元素 Image 1 \u0026lt;img src=\u0026#34;\u0026lt;img_url or location\u0026gt;\u0026#34; /\u0026gt; src ：最基本的图片元素仅需一个 src 属性来指向图片资源，这样就可以将图片导入页面中，其中关于 Location 这里有一个 SEO Tips(Google Recommand)：\n本地存储推荐存储于 images 图片的命名更加具备描述性。 不要将自己的 SRC 属性指向他人网页上的照片（这种行为为\u0026quot;盗链\u0026quot;） 如图像元素和视频元素这类嵌入的元素，有时候也被成为替换元素：元素的内容和原始尺寸由外部资源所定义，而非元素本身。（可以使用属性或者 CSS 进行控制）\nalt：alt 为了视障，节省带宽，浏览器支持问题等原因设置的代替图片出现的描述性文本，推荐根据图片内容进行编写：\n装饰需求 : 使用空的 alt=\u0026quot;\u0026quot; 避免输出多余信息，同时推荐将装饰性图片在 CSS 文件中定义而非 html，下文会详细讲解 CSS 设置装饰图片 内容需求：如果正文中没有描述，则 alt 对图片进行描述，否则设置为空。 width 与 height ：上文中提到图片的 size 由外部资源决定，单位了适应页面的大小，可以使用 img 标签中的 width 和 height 属性来实现对图片的缩放，同时也会在页面尚未加载完成时预留空间，避免页面结构混乱。（因此无需缩放也建议，获取图片的 size 写入属性。）\ntitle：类似超链接中的 title 属性，可以给照片添加悬停提示，当空间不够时可以通过这种方式来添加部分信息，但不推荐。\nfigure 与 figcaption：创建一个容器（box），可以为图片在图片下方添加说明，像论文中的那种，对于无障碍用户来说起到和 alt 一样的作用。\n1 2 3 4 \u0026lt;figure\u0026gt; \u0026lt;img src= \u0026#34;https://the-network-photo\u0026#34; alt=\u0026#34;\u0026#34; title=\u0026#34;key img\u0026#34;, width=\u0026#34;400\u0026#34;, height=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;figcaption\u0026gt;通过为网络添加一个低纬嵌入来实现用最小的空间代价控制网路行为\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; figure 中可以存放几张图片、一段代码、音视频、方程、或者任何其他的内容，而不只是单张照片，类似的补充说明的场景都可以使用 figure 元素呈现。\n使用 CSS 添加背景图片 举个例子，为整个页面/任何标签/元素设置一个背景图片，可以使用 background-img 属性来指定图片，并使用 background-* 属性来指定图片的 size 等呈现方式。\n1 2 3 4 html { background-img: url(\u0026#34;images/dinosaur.jpg\u0026#34;); background-size: auto; } 音视频内容 Video \u0026amp; Audio 补充知识：早期的 HTML 无法支持音视频因此有了 FLash 等技术的兴起，由于安全性和其无法支持 HTML 和 CSS 特性，且后续 HTML5 中支持了 video 和 audio 标签，故而这些技术就被淘汰。\n音视频的插入方式主要有：\n（学习）HTML5 提供了 video 和 audio 标签支持以及相应的 JavaScript 中提供了 APIs 对这些音视频进行控制， （推荐）OVPs(Online Video Provide Server)在线视频/音频提供商，如 b 站和 youtube 等，会提供现成的代码在网页中嵌入其音视频资源，可以避免我们主机的带宽消耗等诸多难题 Video 元素 1 2 3 4 5 \u0026lt;video src=\u0026#34;your video location or url\u0026#34; controls\u0026gt; \u0026lt;p\u0026gt; 你的浏览器不支持HTML5视频,可点击\u0026lt;a href=\u0026#34;videosize\u0026#34;\u0026gt;此链接\u0026lt;/a\u0026gt;观看 \u0026lt;/p\u0026gt; \u0026lt;/video\u0026gt; 使用方式和 \u0026lt;img\u0026gt; 标签相似使用 src 定位资源，而其他的一些别的用法说明：\ncontrols：布尔属性，为视频包含浏览器提供的默认控件页面来控制视频的播放，同时也可以使用 JS Media API 来创建自己的页面 标签中包裹的内容：如 \u0026lt;img\u0026gt; 中的 alt 为视频提供后备方案，如果视频不被支持或者加载失败，可以显示其中内容。 由于浏览器/设备的对不同音视频编解码器的不同支持(相关编解码知识请参考 MDN 使用多个播放源以提高兼容性章节)，可能会需要提供多个备选资源来源，可以使用以下的方式：\n1 2 3 4 5 6 7 \u0026lt;video controls\u0026gt; \u0026lt;source src=\u0026#34;name.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;name.webm\u0026#34; type=\u0026#34;video/webm\u0026#34; /\u0026gt; \u0026lt;p\u0026gt; 你的浏览器不支持HTML5视频,可点击\u0026lt;a href=\u0026#34;videosize\u0026#34;\u0026gt;此链接\u0026lt;/a\u0026gt;观看 \u0026lt;/p\u0026gt; \u0026lt;/video\u0026gt; 还有一些其他的属性，需要的时候建议查看文档。\nwidth 和 height autoplay：自动开始播放；loop：自动循环播放 muted：默认静音 poster：指向一个图像的 url，通常用于预览或者广告 preload：提供缓冲选项，none，auto，metadata 三个选项。 可以使用 track 标签，基于 WebVTT 格式为视频提供字幕，具体例子如下：\n1 2 3 4 5 \u0026lt;video controls\u0026gt; \u0026lt;source src=\u0026#34;example.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;example.webm\u0026#34; type=\u0026#34;video/webm\u0026#34; /\u0026gt; \u0026lt;track kind=\u0026#34;subtitles\u0026#34; src=\u0026#34;subtitles_en.vtt\u0026#34; srclang=\u0026#34;en\u0026#34; /\u0026gt; \u0026lt;/video\u0026gt; 其中 king 中有 subtitle 翻译字幕，caption 同步字幕，timed description 将文字转换为音频，服务视觉障碍人士。\naudio 元素 音频元素和视频元素基本完全一致，区别由于占用的空间较小，因此没有视觉部件，如同 width, height 和 poster\nJS 控制举例 1 2 const mediaElem = document.getElementById(\u0026#34;my-media-element\u0026#34;); mediaElem.load(); 例如：使用上述 load 命令可以重置媒体元素，其他的控制等使用的时候再进行补充\n网页与其他对象的嵌入 Iframe\u0026amp;Object 可以上 Mdn 查看 Web 中各种嵌入元素的简史 ，这里主要记录 iframe 元素：提供了一种将整个 web 页面嵌入另一个网页中的方法，是现在 web 中经常被使用的元素。\n上文中提到的基于 OVPs 插入音视频的方法实际上就是基于 iframe 元素实现的，通常可以在 OVPs 页面的分享处找到，复制其嵌入代码即可。\n随便找了一个 B 站的例子，使用 \u0026lt;iframe\u0026gt; tag，以 src 指定嵌入来源，还有其他相关的诸多属性设置。\n1 \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=1750103776\u0026amp;bvid=BV1m4421w7a2\u0026amp;cid=1428891154\u0026amp;p=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 除了视频还可以嵌入：在线地图、广告、Disqus 评论系统等，接下来可以介绍一下一些常用的属性。\nwidth=“100%“ 与 height=\u0026quot;500\u0026quot; 支持百分比和像素控制两种，可以指定一个绝对值剩下百分比。 frameborder: 设置为 1 会绘制边框，0 会删除边框，建议设置为 0，不建议设置，可以在 css 中操作边框的表现，如 border: none; allowfullscreen：布尔属性，是否可以以全屏方式打开该 frame。 sandbox：无脑 100%添加，可以增加一些安全性，但是需要较新的浏览器版本。 \u0026lt;iframe\u0026gt; 可以如视频一样指定备选内容，如果无法加载的话就显示对应的备选内容，或者直接指向视频网站。\n废弃 embed \u0026amp; object 嵌入 这两个 Tag 可以嵌入 Flash，脚本和 PDF 等内容，但是并不推荐这么去做，详细请参考 MDN 说明 ，避免使用 Flash 这个过时的技术，像 PDF 这种最好直接指向其链接，而非将其添加为嵌入。\n部分安全设置 CSP 指令：部署网站的时候添加安全响应头，避免自己的网站被别人作为嵌入插入自己的页面，为自己带来没有必要的额外带宽消耗。 方法参考自 MDN ，配置 Nginx，将一下这行添加到 http,server,或者 location 的配置中。\nadd_header X-Frame-Options SAMEORIGIN always; 使用HTTPS 矢量图形 SVG 矢量图的定义这里不再重复，其用一组函数来定义图形，具体的编写方法这里也不再多说，最好使用第三方工具直接生成 SVG。这里只介绍一下如何插入和操作 SVG：\n插入 SVG 主要有两种方法：\n第一种可以使用 \u0026lt;img\u0026gt; 但是无法使用 JS 操作图像，且只有在 svg 内部的 css 才能操作其样式 第二种直接使用 \u0026lt;svg\u0026gt; 里面添加 svg 的定义代码，可以为其添加 class 和 id，可以使用外部 css 调整器样式 1 2 3 \u0026lt;svg width=\u0026#34;300\u0026#34; height=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;rect width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; fill=\u0026#34;green\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; 想要了解 SVG 还是从 MDN 原文 开始并补充更多绘图知识吧。\n🔥响应式图片 响应式照片：如何在不同的屏幕尺寸，分辨率设备上都显示良好的图片，从而提升阅读体验和性能，之所以在 HTML 就需要介绍响应式图片，是因为页面在刚开始加载的时候就会获取图片，会先于 JS 和 CSS 显示出来，等到 JS 检测再动态加载新的照片会有点缓慢/奇怪。\nNote\rCSS 是比 HTML 更好的响应式设计工具，本章节仅仅专注于 HTML，待到 CSS 部分再学习。\nTodo\r该部分肯定还要再深入研究的，这一点肯定不够用。\n针对不同分辨率提供不同尺寸的图片 使用 img 中额外的属性 scrset 和 sizes 来指定不同条件下是选择显示的照片如下：\n1 2 3 4 5 6 \u0026lt;img srcset=\u0026#34;elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w\u0026#34; sizes=\u0026#34;(max-width: 600px) 480px, 800px\u0026#34; src=\u0026#34;elva-fairy-800w.jpg\u0026#34; alt=\u0026#34;Elva dressed as a fairy\u0026#34; /\u0026gt; srcset 使用 , 分割多个图片 src sizes 使用类似三元表达式的形式做判断，(cond), res1, res2 例如这里 cond 为屏幕宽度\u0026lt;=600px，这样在小分辨率屏幕下就会选择原始尺寸更接近 480px 的图片（res1，res2 需要取图片的固有宽度曲线则）进行渲染。 html 文件的 head 中的 \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width-device-width\u0026quot;\u0026gt; 会强制让手机浏览器采用他们的真实可视窗口的宽度来加载网页，这样避免错误的尺寸（有的浏览器会虚报放大再缩小）为网页响应式渲染带来问题。\n这种情况下，图片的大小在不同分辨率的屏幕上是不同的，取决于照片本身。\n为不同分辨率提供相同尺寸的图片 希望在不同分辨率屏幕上看到的实际尺寸是相同的，可以使用 srcset 结合 x 语法来让浏览器选择合适的照片。\n1 2 3 4 \u0026lt;img srcset=\u0026#34;elva-fairy-320w.jpg, elva-fairy-480w.jpg 1.5x, elva-fairy-640w.jpg 2x\u0026#34; src=\u0026#34;elva-fairy-640w.jpg\u0026#34; alt=\u0026#34;Elva dressed as a fairy\u0026#34; /\u0026gt; 在这种情况下，会计算屏幕用多少个像素表示一个 css 像素，也就是说按照分辨率与标准分辨率的倍数来选择/缩放照片。\n美术设计（更为实际的需求） 同一张照片在手机上表示效果如果和桌面端保持一致，可能会导致图片中的元素过小等各种各样的问题，导致阅读起来非常不便，这里建议使用 \u0026lt;picture\u0026gt; 属性替换 img 属性。\n1 2 3 4 5 \u0026lt;picture\u0026gt; \u0026lt;source media=\u0026#34;(max-width: 799px)\u0026#34; srcset=\u0026#34;elva-480w-close-portrait.jpg\u0026#34; /\u0026gt; \u0026lt;source media=\u0026#34;(min-width: 800px)\u0026#34; srcset=\u0026#34;elva-800w.jpg\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;elva-800w.jpg\u0026#34; alt=\u0026#34;Chris standing up holding his daughter Elva\u0026#34; /\u0026gt; \u0026lt;/picture\u0026gt; 同样在 media 选择条件，scrset 设置将会加载的图像。这种情况下我们可以对多张照片分别指定 size，来满足更为灵活的多样定制英雄，切记里面至少要有一个默认图像元素 img。\n使用新图像格式 WebP 和 AVIF 都可以在高质量的时候保持较小的文件大小。\n总结 FI 音视频方面：建议还是尽量使用视频提供商来嵌入多媒体内容，这些方式带来的带宽消耗和各种问题都相对棘手。 网页部署的时候需要注意 iframe 安全，同时可以使用 iframe 嵌入有趣的内容，但是切记仅在必要的时候嵌入 SVG 相比 img 有诸多优势，但是最好还是使用第三方软件生成。 使用响应式图片来适应多种屏幕，不打算使用美术设计的时候不要用 media 属性。 ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb06-html03-%E5%A4%9A%E5%AA%92%E4%BD%93%E5%85%83%E7%B4%A0/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e接下来主要探讨 HTML 中的多媒体元素，图片、视频、音频以及 iframe 等等。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"图片元素-image\"\u003e图片元素 Image\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003eimg\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u0026lt;img_url or location\u0026gt;\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003ccode\u003esrc \u003c/code\u003e：最基本的图片元素仅需一个 \u003cstrong\u003esrc\u003c/strong\u003e 属性来指向图片资源，这样就可以将图片导入页面中，其中关于 Location 这里有一个 SEO Tips(Google Recommand)：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e本地存储推荐存储于 \u003ccode\u003eimages\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e图片的命名更加具备描述性。\u003c/li\u003e\n\u003cli\u003e不要将自己的 SRC 属性指向他人网页上的照片（这种行为为\u0026quot;盗链\u0026quot;）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如图像元素和视频元素这类嵌入的元素，有时候也被成为\u003cstrong\u003e替换元素\u003c/strong\u003e：元素的内容和原始尺寸由外部资源所定义，而非元素本身。（可以使用属性或者 CSS 进行控制）\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ealt\u003c/code\u003e：alt 为了视障，节省带宽，浏览器支持问题等原因设置的代替图片出现的描述性文本，推荐根据图片内容进行编写：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e装饰需求 \u003c/code\u003e: 使用空的 \u003ccode\u003ealt=\u0026quot;\u0026quot;\u003c/code\u003e 避免输出多余信息，同时推荐将装饰性图片在 CSS 文件中定义而非 html，下文会详细讲解 CSS 设置装饰图片\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e内容需求\u003c/code\u003e：如果正文中没有描述，则 alt 对图片进行描述，否则设置为空。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ewidth\u003c/code\u003e 与 \u003ccode\u003eheight\u003c/code\u003e ：上文中提到图片的 size 由外部资源决定，单位了适应页面的大小，可以使用 img 标签中的 width 和 height 属性来实现对图片的缩放，同时也会\u003cstrong\u003e在页面尚未加载完成时预留空间，避免页面结构混乱\u003c/strong\u003e。（因此无需缩放也建议，获取图片的 size 写入属性。）\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etitle\u003c/code\u003e：类似超链接中的 title 属性，可以给照片添加悬停提示，当空间不够时可以通过这种方式来添加部分信息，但不推荐。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efigure\u003c/code\u003e 与 \u003ccode\u003efigcaption\u003c/code\u003e：创建一个容器（box），可以为图片在图片下方添加说明，像论文中的那种，对于无障碍用户来说起到和 alt 一样的作用。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003efigure\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003eimg\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;https://the-network-photo\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003ealt\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003etitle\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;key img\u0026#34;\u003c/span\u003e\u003cspan class=\"err\"\u003e,\u003c/span\u003e \u003cspan class=\"na\"\u003ewidth\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;400\u0026#34;\u003c/span\u003e\u003cspan class=\"err\"\u003e,\u003c/span\u003e \u003cspan class=\"na\"\u003eheight\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;200\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003efigcaption\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e通过为网络添加一个低纬嵌入来实现用最小的空间代价控制网路行为\u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003efigcaption\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003efigure\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003efigure 中可以存放几张图片、一段代码、音视频、方程、或者任何其他的内容，而不只是单张照片，类似的补充说明的场景都可以使用 figure 元素呈现。\u003c/p\u003e","title":"LearnWeb06-HTML03-多媒体元素"},{"content":"\rSummary\r本章节在 HTML01 的基础上加深对于一些基础概念，标签等的认知，还是以 HTML 编写的基础知识为主。\n块级元素和内联元素 块级元素和内联元素就像 Markdown 的内联代码和代码块两种写法，一个需要另起一行且会占据行，下一个元素必须另起一行，如 \u0026lt;p\u0026gt; 段落等。而内联元素就是可以嵌入行内，内联元素前后都无需换行，一般如强调，高亮，超链接一类。\n正是由于这种结构，块级元素在使用的时候除了内容，往往还承担着网页的结构相关的工作，如页眉，页脚, 列表，导航栏等等； 块级元素不会嵌套在内联元素中，但是可能嵌套在另一个块级元素中。 内联元素则通常在块级元素中和文本一起使用。 需要注意的是这类元素分类是过时的，HTML 定义了更加详细具体的分类，为了便于理解暂时使用旧的定义来做简单的区分。\n布尔属性 前文提到过，属性通常以 k-v 键值对的形式呈现，但是有部分属性是没有值的，其 key 通常与值有着相同的含义，如 disabled，该布尔属性本身就代表着禁用，例如输入框 \u0026lt;input\u0026gt; 禁用就会阻止用户的输入。\n1 \u0026lt;input type=\u0026#34;text\u0026#34; disabled /\u0026gt; 这样就会创建一个无法输入的输入框，通常会以灰色呈现，type 则限制了输入框的输入类型。\nHTML 头部 html01 中已经简单介绍过一些在 HTML Head 中的元素，这里主要为其中的元素添加更为详细的说明\n添加页面图标 页面添加网页图标的方式有：\n将其保存在与网站的索引页面相同的目录中，以 .ico 格式保存（大多数浏览器支持更通用的格式，如 .gif 或 .png） 将以下行添加到 HTML 的 \u0026lt;head\u0026gt; 块中以引用它，可能会看到很多其他针对不同设备保存不同图标的代码，也会用类似的语句写在这里。 1 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34; type=\u0026#34;image/x-icon\u0026#34; /\u0026gt; 设置主语言 例如在 \u0026lt;html lang='zh-CN'\u0026gt; HTMl 标签中加入 lang 属性为整个页面设置中文标签，这是为了搜索引擎的\u0026quot;搜索特定语言的页面\u0026quot;等功能提供支持。\n也可以分段添加语言信息（可能为了视障人士设计，阅读时候切换语言）\n1 \u0026lt;p\u0026gt;Japanese example: \u0026lt;span lang=\u0026#34;ja\u0026#34;\u0026gt;ご飯が熱い。\u0026lt;/span\u0026gt;.\u0026lt;/p\u0026gt; Meta 元数据 元数据就是描述数据的数据，实际上所有在 Head 部分的数据都能称之为元数据，包括 JS，CSS 引用等等。而 HTML 有一个“官方的”方式来为一个文档添加元数据—— \u0026lt;meta\u0026gt; 元素。用来指定网页编码的如下代码就是使用的 meta tag\n1 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; 正确的使用需要的编码能避免渲染时出现乱码，Meta 除了设置字符编码的元数据，还有以下的其他用法，大多是用于各个网站的专有元数据：\nMeta 标签中包含的name和content属性，分别对应元素的说明，和元素的具体的值，可用来添加作者信息，详细描述，联系方式等额外信息，这些字段有如下的用处：\n用于爬虫或者一些自动化处理的工作 SEO 优化，使得网页在搜索引擎上出现的更多，例如 description 中的信息也会被搜索引擎用于搜索结果。 在谷歌搜索里，在主页面链接下面，你将看到一些相关子页面——这些是站点链接，可以在 Google\u0026rsquo;s webmaster tools 配置——这是一种可以使你的站点对搜索引擎更友好的方式。\n许多 \u0026lt;meta\u0026gt; 特性已经不再使用。例如，keyword \u0026lt;meta\u0026gt; 元素（\u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;fill, in, your, keywords, here\u0026quot;\u0026gt;，为搜索引擎提供关键词，用于确定该页面与不同搜索词的相关性）已经被搜索引擎忽略了，因为作弊者填充了大量关键词到 keyword，错误地引导搜索结果。\n不同的网站（如 Facebook 之类的社交平台），涉及到网站分享，可能会有一些特有的元信息协议，让我们的网站可以为其提供更多额外的信息，如 logo 之类的，在分享的时候就能呈现出来。\nBODY 主体 无语义标签 除了 HTML01 中介绍的一些涵盖语义的标签（如 h1 等标题语义可能会在 web 的各种延伸应用中被使用，如阅读或搜索），还有一些不含语义的元素如\n块级的 \u0026lt;div\u0026gt; 内联级的 \u0026lt;span\u0026gt; 这些元素是为了标记部分内容，便于开发者对其实现样式或者动态规则等的设置出现的，举个例子\n1 2 \u0026lt;span style=\u0026#34;font-size: 32px; margin: 21px 0; display: block;\u0026#34;\u0026gt;这是顶级标题吗？\u0026lt;/span \u0026gt; span 没有含义和任何样式，该标签可以提供 class,id 等属性，使其可以用 css（如果是统一格式最好使用外嵌 css 文件的方式）进行控制。\nThe \u0026lt;span\u0026gt; element is a very generic inline container that doesn\u0026rsquo;t inherently represent anything. It can be easily styled with CSS or manipulated with JavaScript, making it a versatile tool for web developers to create specific styles or behaviors on parts of their content.【CHATGPT】\n这些元素最好在找不到合适的语义描述的时候再进行使用，避免滥用导致代码可读性降低。\nem \u0026amp; Strong 强调 \u0026lt;strong\u0026gt; 强烈（语义），显示未粗体，如果只是为了展现斜体而非强调，建议使用 span 和 css 样式，或者 \u0026lt;b\u0026gt;，不要使用该含语义的标签。 \u0026lt;em\u0026gt; 强调（语义），显示为斜体，如果只是为了展现斜体而非强调，建议使用 span 和 css 样式，不要使用该含语义的标签。 a 超链接 基础用法这里不再过多描述，下面给出一个简单的例子，然后就补充一些详细的描述。\n1 \u0026lt;a href=\u0026#39;https://www.google.com\u0026#39;\u0026gt;google\u0026lt;/a\u0026gt; 超链接可以包裹几乎一切其他的 tag，图片的也行\n除了 href 属性，还可以使用 target=\u0026quot;_blank\u0026quot; 属性使得页面在新标签页中打开， 使用 title 属性，添加即将跳转的页面的提示信息，悬停提示。 使用 download 属性，为下载链接下载的文件提供默认名称。 电子邮件地址可以在 href 中写为 href=mailto:youremail@mail.com 的话，打开的邮件会自动填充收件人 除了跳转链接还可以跳转到文档的特定部分，但是这要求给文档的各个部分添加 id 属性用于标识，一般用于标题 hn\n1 2 \u0026lt;h2 id=\u0026#39;h2\u0026#39;\u0026gt;Title2\u0026lt;/h2\u0026gt; 参见\u0026lt;a href=\u0026#34;some.html#h2\u0026#34;\u0026gt;第二章\u0026lt;/a\u0026gt;的内容 如果是同个文件的话文件路径/文件名可以省略，在 # 后面添加对应 id 即可。\ndl 描述列表 描述列表对应的是一种独特的列表，其主要用于一些类似术语说明的场景，用来标注一组：术语\u0026amp;释义或者问题\u0026amp;答案。其基本使用方式为 \u0026lt;dl\u0026gt; description list 包裹整个组，列表中的每一项术语/问题用 \u0026lt;dt\u0026gt; description term 标记，回答/释义用 \u0026lt;dd\u0026gt; description definition 包裹，下面给出一个例子：\n1 2 3 4 5 6 7 \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;谁是电影奥本海默的导演\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;诺兰\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;奥本海默的男主角扮演的角色是什么职业\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;物理学家\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; blockquota 引用块和行内引用 块级内容的引用使用 \u0026lt;blockquota\u0026gt; 包裹，里面使用 \u0026lt;cite\u0026gt; 属性来描述引用的地方（实际上 cite 属性在大多数浏览器等地方都没有很好的利用，如果要显示要自己编写） 行内引用使用 \u0026lt;q\u0026gt; 包裹对应的部分，同样建议添加 \u0026lt;cite\u0026gt; 属性。 Code 代码块 \u0026lt;code\u0026gt; ：用于标记计算机通用代码。 \u0026lt;pre\u0026gt; ：用于保留空白字符（通常用于代码块）——如果文本中使用了缩进或多余的空白，浏览器将忽略它，你将不会在呈现的页面上看到它。但是，如果你将文本包含在 \u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt; 标签中，那么空白将会以与你在文本编辑器中看到的相同的方式渲染出来。 \u0026lt;var\u0026gt; ：用于标记具体变量名。 \u0026lt;kbd\u0026gt; ：用于标记输入电脑的键盘（或其他类型）输入。 \u0026lt;samp\u0026gt; ：用于标记计算机程序的输出 主要的应该就是 pre 和 code 标记代码块内容，然后在正文编写的时候可以使用 var 标记变量。后面额外的这些标签主要应该是为了方便代码渲染，包括输入输出的区分等。\n其他 \u0026lt;abbr title=\u0026quot;全名\u0026quot;\u0026gt; 来包裹一个缩写，使得鼠标浮动的时候显示全称 \u0026lt;address\u0026gt; 标记联系方式，不知道有啥用 \u0026lt;sup\u0026gt; 上标，\u0026lt;sub\u0026gt; 下标 \u0026lt;time datetime=\u0026quot;2024-02-02\u0026quot;\u0026gt; 2024 年 2 月 2 日 \u0026lt;/time\u0026gt; 标记时间，主要是为了给计算机或者脚本提供一个更好解析的时间，避免很多不同种类的时间描述带来处理上的麻烦。 \u0026lt;br\u0026gt; 提供换行 \u0026lt;hr\u0026gt; 提供分割线 Layout 页面布局 对 HTML 这些元素的合理应用能够从 HTML 就很好的\u0026quot;描述\u0026quot;整个页面的布局，也会给视障用户带来便利。为其清楚的了解页面的布局。\n一个标注的页面通常包含以下的元素：（该部分直接摘录自 MDN ），对应的 html 标记元素\n页眉 \u0026lt;header\u0026gt; ：通常横跨于整个页面顶部有一个大标题和/或一个标志。这是网站的主要一般信息，通常存在于所有网页。\n导航栏 \u0026lt;nav\u0026gt; ：指向网站各个主要区段的超链接。通常用菜单按钮、链接或标签页表示。类似于标题栏，导航栏通常应在所有网页之间保持一致，否则会让用户感到疑惑，甚至无所适从。许多 web 设计人员认为导航栏是标题栏的一部分，而不是独立的组件，但这并非绝对；还有人认为，两者独立可以提供更好的 无障碍访问特性 ，因为屏幕阅读器可以更清晰地分辨二者。\n主内容 \u0026lt;main\u0026gt; ：中心的大部分区域是当前网页大多数的独有内容，例如视频、文章、地图、新闻等。这些内容是网站的一部分，且会因页面而异。\n侧边栏 \u0026lt;aside\u0026gt; ：一些外围信息、链接、引用、广告等。通常与主内容相关（例如一个新闻页面上，侧边栏可能包含作者信息或相关文章链接），还可能存在其他的重复元素，如辅助导航系统。\n页脚 \u0026lt;footer\u0026gt; ：横跨页面底部的狭长区域。和标题一样，页脚是放置公共信息（比如版权声明或联系方式）的，一般使用较小字体，且通常为次要内容。还可以通过提供快速访问链接来进行 SEO 。\n针对上述这些标签，有以下的一些其他说明\n\u0026lt;main\u0026gt; ：主内容。主内容中还可以有各种子内容区段，可用\u0026lt;article\u0026gt; 、\u0026lt;section\u0026gt; 和 \u0026lt;div\u0026gt; 等元素表示。 \u0026lt;aside\u0026gt; ：侧边栏，经常嵌套在 \u0026lt;main\u0026gt; 中。 理解所有 HTML 区段元素具体含义是很有益处的，这一点将随着个人 web 开发经验的逐渐丰富日趋显现。更多细节请查阅 HTML 元素参考 。现在，你只需要理解以下主要元素的意义：\n\u0026lt;main\u0026gt; 存放每个页面独有的内容。每个页面上只能用一次 \u0026lt;main\u0026gt;，且直接位于 \u0026lt;body\u0026gt; 中。最好不要把它嵌套进其他元素。 \u0026lt;article\u0026gt; 包围的内容即一篇文章，与页面其他部分无关（比如一篇博文）。 \u0026lt;section\u0026gt; 与 \u0026lt;article\u0026gt; 类似，但 \u0026lt;section\u0026gt; 更适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块。一般的最佳用法是：以 标题 作为开头；也可以把一篇 \u0026lt;article\u0026gt; 分成若干部分并分别置于不同的 \u0026lt;section\u0026gt; 中，也可以把一个区段 \u0026lt;section\u0026gt; 分成若干部分并分别置于不同的 \u0026lt;article\u0026gt; 中，取决于上下文。 \u0026lt;aside\u0026gt; 包含一些间接信息（术语条目、作者简介、相关链接，等等）。 \u0026lt;header\u0026gt; 是简介形式的内容。如果它是 \u0026lt;body\u0026gt; 的子元素，那么就是网站的全局页眉。如果它是 \u0026lt;article\u0026gt; 或\u0026lt;section\u0026gt; 的子元素，那么它是这些部分特有的页眉（此 \u0026lt;header\u0026gt; 非彼 标题 ）。 \u0026lt;nav\u0026gt; 包含页面主导航功能。其中不应包含二级链接等内容。 \u0026lt;footer\u0026gt; 包含了页面的页脚部分。 Example 举个例子 例子来自 MDN 官网的作业，按照这种结构结合 css 去划分各个区块。\ncss 可以上示例网站 按 F12 查看\nExtra 额外信息 注释 HTML 中的注释需要使用如下的方式实现注释： \u0026lt;!--注释的内容--\u0026gt;\n特殊字符\u0026quot;转义\u0026quot; 我们必须使用字符引用——表示字符的特殊编码，它们可以在那些情况下使用。每个字符引用以符号 \u0026amp; 开始，以分号（;）结束。\n原义字符 等价字符引用 \u0026lt; \u0026amp;lt; \u0026gt; \u0026amp;gt; \u0026quot; \u0026amp;quot; ' \u0026amp;apos; \u0026amp; \u0026amp;amp; 等价字符引用可以很容易记住，因为它使用的文本可以被看作是小于“\u0026lt;”，引号是“\u0026quot;”，其他的也是如此。要找到更多关于实体引用的信息，请参见 XML 和 HTML 字符实体引用列表 （维基百科）\n页面调试和校验 除了使用 VsCode 和浏览器预览做调试，还可以将 html 的代码放到 Makeup Validation Service 做校验。\n","permalink":"https://hugotest-phi.vercel.app/posts/learnweb05-html02-%E8%A6%81%E7%B4%A0%E5%AF%9F%E8%A7%89/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e本章节在 HTML01 的基础上加深对于一些基础概念，标签等的认知，还是以 HTML 编写的基础知识为主。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"块级元素和内联元素\"\u003e块级元素和内联元素\u003c/h2\u003e\n\u003cp\u003e块级元素和内联元素就像 Markdown 的内联代码和代码块两种写法，一个需要另起一行且会占据行，下一个元素必须另起一行，如 \u003ccode\u003e\u0026lt;p\u0026gt;\u003c/code\u003e 段落等。而内联元素就是可以嵌入行内，内联元素前后都无需换行，一般如强调，高亮，超链接一类。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e正是由于这种结构，\u003cstrong\u003e块级元素\u003c/strong\u003e在使用的时候除了内容，往往还承担着\u003cstrong\u003e网页的结构\u003c/strong\u003e相关的工作，如页眉，页脚, 列表，导航栏等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e块级元素\u003c/strong\u003e不会嵌套在内联元素中，但是可能嵌套在另一个块级元素中。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e内联元素\u003c/strong\u003e则通常在块级元素中和文本一起使用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e需要注意的是这类元素分类是过时的，HTML 定义了更加详细具体的分类，为了便于理解暂时使用旧的定义来做简单的区分。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"布尔属性\"\u003e布尔属性\u003c/h2\u003e\n\u003cp\u003e前文提到过，属性通常以 k-v 键值对的形式呈现，但是有部分属性是没有值的，其 key 通常与值有着相同的含义，如 \u003ccode\u003edisabled\u003c/code\u003e，该布尔属性本身就代表着禁用，例如输入框 \u003ccode\u003e\u0026lt;input\u0026gt;\u003c/code\u003e 禁用就会阻止用户的输入。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003einput\u003c/span\u003e \u003cspan class=\"na\"\u003etype\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;text\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003edisabled\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这样就会创建一个无法输入的输入框，通常会以灰色呈现，type 则限制了输入框的输入类型。\u003c/p\u003e","title":"LearnWeb05-HTML02-要素察觉"},{"content":"\rSummary\rJS 除了 WEB 在现代还有很多 NodeJS 的应用也会使用 JS，这里只介绍 web 相关的 JS 代码编写的部分。\nref: mdn JS 快速入门 | 《数据结构与算法 JavaScript 描述》\nIntro JavaScript 是一门完备的动态编程语言，可以借由诸多开发者编写的大量工具，为网站提供动态交互的特性（结合浏览器应用程序接口 API）主要用到的包括：\n浏览器应用程序接口（API）：浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成 3D 图像与音频样本等等。 第三方 API：让开发者可以在自己的站点中整合其他内容提供者（Twitter、Facebook 等）提供的功能。 第三方框架和库：用来快速构建网站和应用。 HTML 引入 JS 代码 为了使得代码更清晰且好组织，本文依然使用引入外部 JS 的办法进行代码结构组织，HTML 中引入相关 JS 的方法和 CSS 的方法类似但略有不同。具体代码如下：\n1 \u0026lt;script src=\u0026#34;scripts/main.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; 这一段代码可以加在 Head 部分，其中的 defer 属性，及 deferred 延迟，是为了让元素都加载完成后再加载 JS 部分代码，否则最好将 JS 的引入放在 HTML 快要结束的部分 （\u0026lt;/body\u0026gt; 的前一行）。避免 JS 元素对 HTML 提前进行修改导致 HTML 加载失效。\n参考资料：async-defer | Medium 调试 JS 代码 JS 有几种调试 debug 的方式，按照个人现阶段的理解，可以分为两类：一是主要针对 NodeJS 类的JavaScript on the server的调试，配置起来相对简单，只需要安装好 Node 在 Vsocde 中使用 Nodejs 进行调试即可。\n使用 NodeJS + VsCode 进行本地调试，也可以直接使用 node \u0026lt;yourjsfile\u0026gt;.js 执行，如果是在 Vscode 的终端中执行也会触发调试界面，非常方便。 【废弃】SpiderMonkey 中下载 JavaScript Shell 直接执行 JS 文件或者进入可交互终端。 【不常用】浏览器开发者环境中的控制台进行调试。 二则主要用于JaveScript inside the browser的调试，最常见的是：\n浏览器 F12 进入开发者环境中的控制台进行调试 VsCode + 以下两个插件：LiveServer+JavaScript Debugger（原 Debugger for Chrome） 进行调试。 顺带一提这里的JavaScript Debugger建议使用预览版本，官方插件中有指引。具体如下：\nQuota\rOpen the extensions view (ctrl+shift+x) and search for @builtin @id:ms-vscode.js-debug Right click on the JavaScript Debugger extension and Disable it. Search for @id:ms-vscode%% %%.js-debug-nightly in the extensions view. Install that extension. LiveServer 可以直接启动对应端口的进程，查看对应的最终效果，使用很简单这里不过多介绍，假设其启动的服务在 3000 端口，JavaScript Debugger 可以做以下配置。\n而JavaScript Debugger使用的时候需要新建 Lauch.json，使用 launch 模式进行 debug，具体配置如下（使用 edge 进行调试）该部分参考资料：在VsCode中使用JavaScript Debugger 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026#34;configurations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;msedge\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;launch vuejs: chrome\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://localhost:3000/\u0026#34;, \u0026#34;webRoot\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, // \u0026#34;breakOnLoad\u0026#34;: true, \u0026#34;sourceMaps\u0026#34;: true, \u0026#34;sourceMapPathOverrides\u0026#34;: { \u0026#34;webpack:///src/*\u0026#34;: \u0026#34;${webRoot}/*\u0026#34; } } ] url 为本地需要调试的项目地址 sourceMaps: true 开启源码映射功能，从而更好的调试源码 设置源码映射路径 sourceMapPathOverrides ，上面映射了 webpack 打包后的源码文件夹到项目的 src 目录；其他需要映射的目录，可以自行添加。 替换为自己对应的路径后即可开始调试，在 Js 中打下的断点就会生效了，这里暂时没使用 Attach 模式，后续用到在研究。\n了解代码调试和运行是学习语言的基础，对这些有所熟悉之后就可以开始学习和尝试编写 JS 代码了。\nJS 基础语法 该部分的学习除了 MDN 的相关知识，会结合数据结构的内容来进行学。\n语言的第一印象和 python 有许多相似的地方。语法上可能大差不差，在循环和其他一些变量上又有一些和 C#,CPP 相似的地方，Let\u0026rsquo;s Go\nBasic Rules 基础规则 首先介绍基本的编写规则:如注释、缩进规则、变量规则等\u0026hellip;\n注释：CPP 相同使用 // 和 /* */ 进行行/块注释。 句尾 ; ：单行单条语句结束可以无需 ; (但为了规范和明确可以加上)，同行多个语句可以用 ; 进行语句的区分。 变量定义：(另起一个 Paragraph 表示尊重)JS 为非强类型语言(即类似 python 而非 cpp)，为动态类型语言，变量声明无需指定类型。但有以下几个注意的事项：\n（不推荐）不带关键字的变量声明会默认为全局变量。 （推荐）可以使用 let 或 var 关键字定义变量。 （最推荐）最推荐使用 let 进行变量的声明，var 对变量定义位置的要求更低，使用 var 编写可能会方便，但是在后续维护和阅读中可能会体验很差。使用 let 然后和别的语言一样声明和使用变量。 Var 和 let 的详细差别可以参考 var与let的区别 。\n对象：JavaScript 里一切皆对象，一切皆可储存在变量里。这一点要牢记于心。\nARRAY 和 Python 一样可以存储多种类型在一个 Array 中，这点无需担心。\n基本运算符：和大多数语言的基本运算符保持一致，这里需要特殊说明的只有相等的判断符，区别于其他语言，JS 中使用三个等号来判断相等；\n1 2 if a == b: print(\u0026#34;a is equal to b\u0026#34;) 1 2 3 4 if (a === b) { console.log(\u0026#34;a is equal to b\u0026#34;); } 这里的函数定义和条件判断都更接近 cpp，使用{}将代码块来区分，而非单纯使用缩进。\nFunction 函数定义 JS 的函数关键字和 Shell 的一样只需要使用 function 即可，实际上和 CPP 也是一样的只是无需指定类型。\n1 2 3 4 5 6 7 8 function multipy(a, b) { let result = a + b; return reuslt; } let res = multipy(3, 5); console.log(res); 有趣的地方在于 JS 的类也是用 function 定义的，这可能是由于一切皆为对象这个特性，所谓函数可能实际上是一个只有单个调用结构的类。并没有作区分。\n为了不混淆，类的部分还是在后面单独进行描述。\nEvent 事件 接下来我把用于 web 开发的 javascript 用 web-js 代称用来区分服务端的 js，服务端的 js 我直接用 nodejs 代称好了。\n在 web-js 中，与事件的交互应该是最为关键的一个环节了，通过浏览器和用户触发的各种事件（如点击，页面滚动，页面跳转）来触发 js 中编写的一个个行为，正是所谓赋予网页动态交互特性。\n可以复习 LearnWeb00-Web入门 中 How JavaScript Works 中讲到的原生异步处理机制，此处有使用 windows 监听的。\n下面引一个 MDN 中的例子做一些简单的说明：\n1 2 3 document.querySelector(\u0026#34;html\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { alert(\u0026#34;别戳我，我怕疼。\u0026#34;); }); 👍 这里有个有趣的匿名函数写法，使用 () =\u0026gt; {} 定义一个匿名函数，实际上也可以用下面这个完整的表达方式：\n1 2 3 document.querySelector(\u0026#39;html\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { alert(\u0026#34;别戳我\u0026#34;); }) 此处的例子可解释为：使用 document（DOM）接口中的 querySelector 选择 html 元素添加对于 click 时间的监听，并在监听到点击行为的时候弹出别戳我的弹窗。\nSelector 可以参考 HTML 部分选择器的含义去理解，具体可选择可能还是要参考 DOM API 中的说明，但是理论上应该会和 HTML 中的定义方式保持一致。\n例子 2 监听图片点击事件，切换背景图片，这里有两种写法和重要的 API 函数 getAttribute 和 setAttribute。\n写法一：使用图片变量的 OnClick 事件（这里说明了变量本身是会携带一些事件定义，并非只有 AddListner 一种监听）\n1 2 3 4 5 6 7 8 9 10 11 ele_img.onclick = function() { let src = ele_img.getAttribute(\u0026#34;src\u0026#34;); if (src === \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/80a5366f89dfbd27ec46f669e0eac84.jpg\u0026#34;) { ele_img.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005005911.png\u0026#34;); } else { ele_img.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/80a5366f89dfbd27ec46f669e0eac84.jpg\u0026#34;); } }; 写法二：使用原本的事件监听方法：\n1 2 3 4 5 6 7 8 9 10 11 ele_img.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { let src = ele_img.getAttribute(\u0026#34;src\u0026#34;); if (ele_img.src === \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/80a5366f89dfbd27ec46f669e0eac84.jpg\u0026#34;) { ele_img.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005005911.png\u0026#34;); } else { ele_img.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/80a5366f89dfbd27ec46f669e0eac84.jpg\u0026#34;); } }); 写法三：将具体函数内容独立出去为ImgSwitch，这里直接调用函数名\n1 ele_img.addEventListener(\u0026#34;click\u0026#34;, ImgSwitch); 也可放在匿名函数或者函数里：\n1 2 3 ele_img.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { ImgSwitch(); ); 例子三 HTML 中添加 Button，CSS 对 Button 简单渲染，然后 JS 中添加输入事件，HTML 和 CSS 部分不在赘述。\nbutton 同样可以使用 onclick 事件来监听点击。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let ele_button = document.querySelector(\u0026#34;button\u0026#34;); ele_button.onclick = () =\u0026gt; { addUserName(); } function addUserName() { let name = prompt(\u0026#34;请输入您的姓名：\u0026#34;); let message = \u0026#34;欢迎您，\u0026#34; + name + \u0026#34;/\u0026#34;; localStorage.setItem(\u0026#34;name\u0026#34;, name); Heading.textContent = message; } if (!localStorage.getItem(\u0026#34;name\u0026#34;)) { Heading.textContent = \u0026#34;欢迎您！\u0026#34;; } else { Heading.textContent = \u0026#34;欢迎您，\u0026#34; + localStorage.getItem(\u0026#34;name\u0026#34;) + \u0026#34;/\u0026#34;; } 这里主要是 prompt 可以唤出一个输入框，将信息输入 name 中 LocalStorage 将信息存到本地的浏览器中 然后最后的判断做一个初始化，如果浏览器中缓存有相关信息就直接输出，否则输入一个 default 值。 如何写入浏览器的缓存也是后续很重要的一个事情，有存储对于多次页面交互来说十分关键。\n","permalink":"https://hugotest-phi.vercel.app/posts/learnweb04-js01-%E5%9F%BA%E7%A1%80webjs%E7%BC%96%E5%86%99/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003eJS 除了 WEB 在现代还有很多 NodeJS 的应用也会使用 JS，这里只介绍 web 相关的 JS 代码编写的部分。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e\u003cstrong\u003eref:\u003c/strong\u003e \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basics\" target=\"_blank\" rel=\"noopener\"\u003emdn JS 快速入门\u003c/a\u003e\n | 《数据结构与算法 JavaScript 描述》\u003c/p\u003e\n\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cp\u003eJavaScript 是一门完备的动态编程语言，可以借由诸多开发者编写的大量工具，为网站提供动态交互的特性（结合浏览器应用程序接口 API）主要用到的包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e浏览器应用程序接口（API）\u003c/strong\u003e：浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成 3D 图像与音频样本等等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e第三方 API\u003c/strong\u003e：让开发者可以在自己的站点中整合其他内容提供者（Twitter、Facebook 等）提供的功能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e第三方框架和库\u003c/strong\u003e：用来快速构建网站和应用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"html-引入-js-代码\"\u003eHTML 引入 JS 代码\u003c/h3\u003e\n\u003cp\u003e为了使得代码更清晰且好组织，本文依然使用引入外部 JS 的办法进行代码结构组织，HTML 中引入相关 JS 的方法和 CSS 的方法类似但略有不同。具体代码如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;scripts/main.js\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003edefer\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这一段代码可以加在 Head 部分，其中的 defer 属性，及 deferred 延迟，是为了让元素都加载完成后再加载 JS 部分代码，否则最好将 JS 的引入放在 \u003ca href=\"https://www.freecodecamp.org/chinese/news/link-javascript-to-html-with-the-src/\" target=\"_blank\" rel=\"noopener\"\u003eHTML 快要结束的部分\u003c/a\u003e\n（\u003ccode\u003e\u0026lt;/body\u0026gt;\u003c/code\u003e 的前一行）。避免 JS 元素对 HTML 提前进行修改导致 HTML 加载失效。\u003c/p\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://juejin.cn/post/6992371218481414152\" target=\"_blank\" rel=\"noopener\"\u003easync-defer\u003c/a\u003e\n | \u003ca href=\"https://realdennis.medium.com/html-script-%E4%B8%ADdefer%E8%B7%9Fasync%E6%98%AF%E4%BB%80%E9%BA%BC-1166ee88d18\" target=\"_blank\" rel=\"noopener\"\u003eMedium\u003c/a\u003e\n\u003c/p\u003e","title":"LearnWeb04-JS01-基础webJS编写"},{"content":"\rSummary\r在前文 web 入门中已经简单介绍了 CSS 是如何起作用，如何与 HTML 进行相互合作的，本篇主要简单介绍如何编写 CSS 文件中的各种样式。\nref: mdn css入门 | MDN css属性大全 在本文及后续的尝试中，都使用单独 CSS 文件外挂的格式，该种格式的结构会更清晰，即将下述代码放入 HTML 文件的 Head 部分。\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/style.css\u0026#34; /\u0026gt; href 部分需要替换为自己实际存放 css 文件的地址即可，此外也简单重复一下剩下的两种使用 CSS 的方式：内部样式表和内联样式表\n内部样式表即在 HTML 的 Head 部分添加 \u0026lt;style\u0026gt;your css code\u0026lt;/style\u0026gt; 将 CSS 代码都包裹起来 内联样式表即在特定元素中定义 style 属性，\u0026lt;p style=\u0026quot;your css code\u0026quot;\u0026gt; 在 style 属性中填充需要的 CSS 代码。 接下来进入正文，讲解 css 部分的组成和编写规则。\nPattern 基础范式 The Principle to Write Css.\n这是一个最基本的 CSS 结构，更为专业的名称是 CSS 规则集（简称为规则），其组成分成一下几个部分：\n选择器 Selector：类似表格中的筛选，筛选这个规则使用的范围，针对 Class、ID、Tag 等不同类型有不同的选择器写法 属性 Property: 选择要修改的属性，如颜色，大小，位置灯多重类型。 属性值 Property value: 各种对应属性的取值，如具体的哪个颜色，字体多大等。 声明 Declaration：由属性和属性值组成的一条单独的规则，指定一种特定的样式。 上述结构称为规则集，因为其可以同时包含多个规则（即声明），编写时有以下约定：\n每个规则使用 ; 作为结尾的分割 同一个规则集的规则需要编写在 {} 之中 属性和属性值为 K-V 对，声明时使用 : 作为分割符，且属性和值均不区分大小写 注释方法 1 2 3 /* all between those two symbol is comment. */ 选择器使用基础 该部分主要介绍如何使用选择器选中、多选不同的元素，更好更灵活的使用选择器来构建出各种不同的效果。\n不同类型选择器定义 除了使用标签名称进行选择，大多数时候会希望使用更加 specific 的 Class 等去选择需要渲染的内容，才能使得风格更加多样可定制。下面列出一些常见的选择器定义方法，更多的还是参阅MDN 选择器名称 选择的内容 示例 元素选择器（也称作标签或类型选择器） 所有指定类型的 HTML 元素 p 选择 \u0026lt;p\u0026gt; ID 选择器 具有特定 ID 的元素。单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID #my-id 选择 \u0026lt;p id=\u0026quot;my-id\u0026quot;\u0026gt; 或 \u0026lt;a id=\u0026quot;my-id\u0026quot;\u0026gt; 类选择器 具有特定类的元素。单一页面中，一个类可以有多个实例 .my-class 选择 \u0026lt;p class=\u0026quot;my-class\u0026quot;\u0026gt; 和 \u0026lt;a class=\u0026quot;my-class\u0026quot;\u0026gt; 属性选择器 拥有特定属性的元素 img[src] 选择 \u0026lt;img src=\u0026quot;myimage.png\u0026quot;\u0026gt; 但不是 \u0026lt;img\u0026gt; 伪类选择器 特定状态下的特定元素（比如鼠标指针悬停于链接之上） a:hover 选择仅在鼠标指针悬停在链接上时的 \u0026lt;a\u0026gt; 元素 引入字体文件 如果需要修改/导入字体文件，可以类似导入 css 文件一般，导入字体文件，一般有两种方式，一种是导入在线字体（不推荐，访问 google 字体库时可能会导致用户的 IP 泄漏），或者导入本地字体（推荐）。\n导入字体的例子如下：\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://fonts.googleapis.com/css?family=Open+Sans\u0026#34; /\u0026gt; 然后在 CSS 文件中全局\b/局部定义字体，这里给一个全局定义的例子，后面可以通过局部的规则对其进行覆盖：\n1 2 3 html { font_family: \u0026#34;Open Sans\u0026#34;, sans-serif /* 这应该是从Google Fonts能得到的其余输出*/ } 获取字体的手段：GoogleFonts ，Github，推荐将字体下载到本地之后再进行挂载，或者使用安全的 web通用字体 如：Arial、Times New Roman、Courier New。\n导入本地字体的指引可以参考 css 字体嵌入方法 ，实际上没有导入在线字体方便，需要考虑加载时间，导入支持各种浏览器的字体，优先加载用户本地字体等。\nCSS 的一切皆盒子 COPY FROM MDN\nCSS 布局主要是基于盒子模型。在你的页面上占用空间的每个盒子都有类似的属性：\npadding（内边距）：是指内容周围的空间。在下面的例子中，它是段落文本周围的空间。 border（边框）：是紧接着内边距的线。 margin（外边距）：是围绕元素边界外侧的空间。 创建一个这样的文本块还会需要用到一下的这些规则集：\nwidth：元素的宽度 background-color：元素内容和内边距底下的颜色 color：元素内容（通常是文本）的颜色 text-shadow：为元素内的文本设置阴影 display：设置元素的显示模式 设置整个 \u0026lt;body\u0026gt; 内容块的实例：\n1 2 3 4 5 6 7 body { width: 600px; margin: 0 auto; background-color: #ff9500; padding: 0 20px 20px 20px; border: 5px solid black; } width 限制了整个 body 的宽度一直为 600 个像素 margin: 0 auto; 当你在 margin 或 padding 这样的属性上设置两个值时，第一个值影响元素的上下方向（在这个例子中设置为 0）；第二个值影响左右方向。(这里，auto 是一个特殊的值，它将可用的水平空间平均分配给左和右）。如 Margin 语法 中所记载的那样，你也可以使用一个、两个、三个或四个值 padding: 0 20px 20px 20px; 我们给内边距设置了四个值来让内容四周产生一点空间。这一次我们不设置上方的内边距，设置右边，下方，左边的内边距为 20 像素。值以上、右、下、左的顺序排列。与 margin 一样，你也可以像 Padding 语法 中所记载的那样，使用一个、两个、三个或四个值。 border: 5px solid black; 这是为边框的宽度、样式和颜色设置的值。在本例中，它是一个在主体的所有侧面的 5 像素宽的纯黑色边框。 默认的标题样式并不美观，可以按照以下方式做一些简单的改善：\n1 2 3 4 5 6 h1 { margin: 0; padding: 20px 0; color: #00539f; text-shadow: 3px 3px 1px black; } padding：标题的顶部和底部内边距设置为 20 像素。 text-shadow： 第一个像素值设置阴影与文本的水平偏移量：它横移的距离。 第二个像素值设置阴影与文本的垂直偏移量：它向下移动的距离。 第三个像素值设置阴影的模糊半径。一个更大的值会产生一个更模糊的阴影。 第四个值设置阴影的基色。 最后，我们把图像居中来使页面更美观。可以复用 body 的 margin: 0 auto，但有一些差异，需要额外的设置来使 CSS 发挥作用。\n\u0026lt;body\u0026gt; 元素是块级元素，意味着它占据了页面的空间并且能够赋予外边距和其他改变间距的值。而图片是行级元素，不具备块级元素的一些功能。所以为了使图像有外边距，我们必须使用 display: block 给予其块级行为。\nCallout\r备注： 以上说明假定所选图片小于页面宽度（600 像素）。更大的图片会溢出 body 并占据页面的其他位置。要解决这个问题，可以： 1）使用图片编辑器 来减小图片宽度； 2）用 CSS 限制图片大小，即减小 \u0026lt;img\u0026gt; 元素 width 属性的值。\nCallout\r备注： 如果你暂时不能理解 display: block 和块级元素与行级元素的差别也没关系；随着你对 CSS 学习的深入，你将明白这个问题。display 属性的更多信息请查看 display 属性参考页面 。\n1 2 3 4 5 6 img { width: 400px; align-self: center; margin: 0 auto; display: block; } Example 最终效果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 html { font-family: \u0026#34;Open Sans\u0026#34;, sans-serif; font-size: 20px; } /* h1 { font-size: 50px; text-align: center; } */ h1 { margin: 0; padding: 20px 0; color: #00539f; text-shadow: 3px 3px 1px black; } p,li { font-size: 16px; line-height: 2; letter-spacing: 1px; } html { background-color: #2050b8; } body { width: 600px; margin: 0 auto; background-color: #ff9500; padding: 0 20px 20px 20px; border: 5px solid black; } img { width: 400px; align-self: center; margin: 0 auto; display: block; } ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb03-css01-%E5%9F%BA%E7%A1%80css%E8%A7%84%E5%88%99/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e在前文 web 入门中已经简单介绍了 CSS 是如何起作用，如何与 HTML 进行相互合作的，本篇主要简单介绍如何编写 CSS 文件中的各种样式。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003eref: \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/CSS_basics\" target=\"_blank\" rel=\"noopener\"\u003emdn css入门\u003c/a\u003e\n | \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference\" target=\"_blank\" rel=\"noopener\"\u003eMDN css属性大全\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e在本文及后续的尝试中，都使用单独 CSS 文件外挂的格式，该种格式的结构会更清晰，即将下述代码放入 HTML 文件的 Head 部分。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003elink\u003c/span\u003e \u003cspan class=\"na\"\u003erel\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;stylesheet\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003ehref\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;styles/style.css\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003ehref 部分需要替换为自己实际存放 css 文件的地址即可，此外也简单重复一下剩下的两种使用 CSS 的方式：内部样式表和内联样式表\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e内部样式表\u003c/strong\u003e即在 HTML 的 Head 部分添加 \u003ccode\u003e\u0026lt;style\u0026gt;your css code\u0026lt;/style\u0026gt;\u003c/code\u003e 将 CSS 代码都包裹起来\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e内联样式表\u003c/strong\u003e即在特定元素中定义 style 属性，\u003ccode\u003e\u0026lt;p style=\u0026quot;your css code\u0026quot;\u0026gt;\u003c/code\u003e 在 style 属性中填充需要的 CSS 代码。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e接下来进入正文，讲解 css 部分的组成和编写规则。\u003c/p\u003e\n\u003ch2 id=\"pattern-基础范式\"\u003ePattern 基础范式\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe Principle to Write Css.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240131161211.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240131161211.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240131161211.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e这是一个最基本的 CSS 结构，更为专业的名称是 \u003cstrong\u003eCSS 规则集\u003c/strong\u003e（简称为规则），其组成分成一下几个部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e选择器 Selector\u003c/strong\u003e：类似表格中的筛选，筛选这个规则使用的范围，针对 Class、ID、Tag 等不同类型有不同的选择器写法\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e属性 Property\u003c/strong\u003e: 选择要修改的属性，如颜色，大小，位置灯多重类型。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e属性值 Property value\u003c/strong\u003e: 各种对应属性的取值，如具体的哪个颜色，字体多大等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e声明 Declaration\u003c/strong\u003e：由属性和属性值组成的一条单独的规则，指定一种特定的样式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e上述结构称为规则\u003cstrong\u003e集\u003c/strong\u003e，因为其可以同时包含多个规则（即声明），编写时有以下约定：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e每个规则使用 \u003ccode\u003e;\u003c/code\u003e 作为结尾的分割\u003c/li\u003e\n\u003cli\u003e同一个规则集的规则需要编写在 \u003ccode\u003e{}\u003c/code\u003e 之中\u003c/li\u003e\n\u003cli\u003e属性和属性值为 K-V 对，声明时使用 \u003ccode\u003e:\u003c/code\u003e 作为分割符，且属性和值均不区分大小写\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"注释方法\"\u003e注释方法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-css\" data-lang=\"css\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003eall between those two symbol is comment.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"LearnWeb03-CSS01-基础CSS规则"},{"content":"\rIntro\r在 Web 入门，How HTML Work 部分已经简单介绍过，HTML 是一种定义内容结构的标记语言，通过一系列标记（确定其表现形式）和对应内容组成的元素，嵌套，排列，构成完整的页面。本文主要是整理和熟悉一下基础的标记元素\nREF: HTML 入门 从上述图像可以看到一个基本的 HTML 元素的构成，元素的 Tag 可以包含属性，多个属性之间用空格隔开，Class 属性可以为元素标识名称，进而为其指定 Style 等。\n属性通常为 K-V 键值对，attr=\u0026ldquo;value\u0026rdquo; 的形式呈现，这里引号可以是单或者双，甚至可以没有，但是没有引号有时候会导致问题，所以建议保持使用引号的风格去编写。\nHead/Overview 部分 参考网站中的范例如下，一个基本的 HTML 文件有以下这些可以注意的地方：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en-US\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;My test page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;images/firefox-icon.png\u0026#34; alt=\u0026#34;My test image\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;head\u0026gt; 就如 cpp 中的 head 文件，定义一些不用于向用户显示的内容，给浏览器的关键词，字符集声明，页面描述等内容 \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; 定义文档使用的字符串编码类型，utf-8 支持世界上大部分语言的渲染，避免因为中文等出现乱码的情况。 \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width\u0026quot;\u0026gt; 视口元素，可以确保页面以视口宽度进行渲染，避免移动端浏览器上因页面过宽导致缩放。 \u0026lt;title\u0026gt; 对当前网页的描述和注解，显示在标签栏中，以及收藏时显示的文字 \u0026lt;body\u0026gt; 部分则是包含网站的全部需要显示的内容。 Body 部分常见元素 标题：例如 markdown 中的 ## 定义各级标题，Html 中使用 \u0026lt;hn\u0026gt; n 从 1-6 定义网页的各级标题，一般最多用到 3-4 级；\n段落：按照 word 中的段落来理解，基本为常规的文本内容，段落间和段落内的间距会有所区别，使用标签 \u0026lt;p\u0026gt; 来定义段落；\n列表：分为无序列表 \u0026lt;ul\u0026gt; 和有序列表 \u0026lt;ol\u0026gt; 两种，无论是那种列表，具体的每一个列表项使用 \u0026lt;li\u0026gt; 定义，具体例子如下(列表中也可以嵌套别的列表)\n1 2 3 4 5 6 7 8 \u0026lt;p\u0026gt;here is a example for list\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;item1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;item2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;if u want ordered list, change ul to ol.\u0026lt;/p\u0026gt; 此外还存在空元素（图像元素），即不需要 Content 内容部分的元素，如图像元素，这是因为图像元素本身就是内容，具体的元素例子如下：\n1 \u0026lt;img src=\u0026#34;https://\u0026lt;img-url-\u0026gt;\u0026#34; alt=\u0026#34;the alias of this img\u0026#34; /\u0026gt; 图像元素的 tag 即 img, src 定义了图像的来源，可以是网站或者文件路径，alt 为图像的注解，为视障人士或者图像加载过程中，显示的图像元素的占位或注解。\n空元素无需再末尾添加/但是加上也没问题，加上也能使其作为有效的 XML 格式\n超链接：例如 markdown 中的 [](), Html 使用 Anchor 标签 \u0026lt;a\u0026gt; 和指定属性 href 即 () 以及显示的内容(content)也即 [] 来共同完成一个超链接, 以跳转到 google 为例：\n1 [google](https://www.google.com) 1 \u0026lt;a href=\u0026#39;https://www.google.com\u0026#39;\u0026gt;google\u0026lt;/a\u0026gt; Example 尝试 尝试一个 Dashboard 界面，加载一张基础图片，然后使用各个元素来列出一些服务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Aikenhong Dashboard for Home Sevices\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; Welcome to Aikenhong Dashboard for Home Services\u0026lt;/h1\u0026gt; \u0026lt;img src=\u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/80a5366f89dfbd27ec46f669e0eac84.jpg\u0026#34; alt=\u0026#34;Aikenhong Logo\u0026#34;\u0026gt; \u0026lt;H3\u0026gt; Intro: \u0026lt;p\u0026gt; 网站对中文提供支持，希望大家有一个友好的访问体验。\u0026lt;/p\u0026gt; \u0026lt;H3\u0026gt; Links \u0026lt;/H3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;https://www.aikenh.cn/\u0026#34;\u0026gt;myBlog\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;https://www.aikenh.cn/about/\u0026#34;\u0026gt;About Us\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;https://metisy.cool/\u0026#34;\u0026gt;Metisy\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; FI","permalink":"https://hugotest-phi.vercel.app/posts/learnweb02-html01-%E5%9F%BA%E7%A1%80%E7%9A%84%E6%A0%87%E7%AD%BE/","summary":"\u003cblockquote class=\"alert-blockquote alert-intro\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eIntro\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e在 Web 入门，How HTML Work 部分已经简单介绍过，HTML 是一种定义内容结构的标记语言，通过一系列标记（确定其表现形式）和对应内容组成的元素，嵌套，排列，构成完整的页面。本文主要是整理和熟悉一下基础的标记元素\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240131110224.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240131110224.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240131110224.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003eREF: \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/HTML_basics\" target=\"_blank\" rel=\"noopener\"\u003eHTML 入门\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e从上述图像可以看到一个基本的 HTML 元素的构成，元素的 Tag 可以包含属性，\u003cstrong\u003e多个属性之间用空格隔开\u003c/strong\u003e，Class 属性可以为元素标识名称，进而为其指定 Style 等。\u003c/p\u003e\n\u003cp\u003e属性通常为 K-V 键值对，attr=\u0026ldquo;value\u0026rdquo; 的形式呈现，这里引号可以是单或者双，甚至可以没有，但是没有引号有时候会导致问题，所以建议保持使用引号的风格去编写。\u003c/p\u003e\n\u003ch2 id=\"headoverview-部分\"\u003eHead/Overview 部分\u003c/h2\u003e\n\u003cp\u003e参考网站中的范例如下，一个基本的 HTML 文件有以下这些可以注意的地方：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u0026lt;!doctype html\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003ehtml\u003c/span\u003e \u003cspan class=\"na\"\u003elang\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;en-US\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003emeta\u003c/span\u003e \u003cspan class=\"na\"\u003echarset\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;utf-8\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003emeta\u003c/span\u003e \u003cspan class=\"na\"\u003ename\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;viewport\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003econtent\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;width=device-width\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003etitle\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003eMy test page\u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003etitle\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003ebody\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003eimg\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;images/firefox-icon.png\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003ealt\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;My test image\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003ebody\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003ehtml\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e 就如 cpp 中的 head 文件，定义一些不用于向用户显示的内容，给浏览器的关键词，字符集声明，页面描述等内容\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\u003c/code\u003e 定义文档使用的字符串编码类型，utf-8 支持世界上大部分语言的渲染，避免因为中文等出现乱码的情况。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width\u0026quot;\u0026gt;\u003c/code\u003e 视口元素，可以确保页面以视口宽度进行渲染，避免移动端浏览器上因页面过宽导致缩放。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;title\u0026gt;\u003c/code\u003e 对当前网页的描述和注解，显示在标签栏中，以及收藏时显示的文字\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e 部分则是包含网站的全部需要显示的内容。\u003c/li\u003e\n\u003c/ul\u003e","title":"LearnWeb02-HTML01-基础的标签"},{"content":"\rSummary\rFamiliar with the pipeline of how to build a website, how to organize the files, etc\u0026hellip;\nStart Design 开始设计一个网站的时候，可以从以下三个方面入手来启动整个开发设计过程：网站的主题-\u0026gt;基础的一些内容-\u0026gt;整体的外观设计（草稿）\n更具体一些：确定完要制作的网页，可以绘制草图有一个粗浅的整体效果，然后指定文本、图像、色彩、字体等资源，就可以开始制作了。\nFile Structure 关于项目中的文件命名，需要注意的是以下的三点，建议养成这样的规范去建立网页文件夹。\n建议使用完全小写来命名文件，webserver 是大小写敏感的，所以复杂的大小写关系容易导致访问不到文件。 尽量不要使用空格，空格可能会破坏链接被视为两个文件等，如果没有被区分很多服务器也需要使用 %20 对空格进行替换 尽量使用连字符代替下划线进行文件命名，google 搜索引擎将连字符作为单词的分割符，而不会识别下划线 而文件存储结构部分，通常而言，有以下的关键文件和文件夹结构，在很多场景下也会将 image 等文件夹放到 static 文件夹中。\nindex.html styles: 存放 css 文件 images: 存放图片等媒体资源文件 scripts: 存放 js 等脚本代码文件 资源的文件路径一般而言以 html 为 Basepath，然后根据上下级关系确认索引地址即可。\nDevelop Online 一些 web 的在线开发和预览网站，可以通过编写 html,css,js 直接获取预览效果，对于一些简单的 web 应用可以直接在线开发，但是无法实现资源的存储和托管等。\nJSFiddle Glitch JSBin CodePen 这些线上集成开发环境还是比较方便好用的，可以尝试自己更喜欢哪一个。\nPublish 这里在家庭服务器中已经有过相关的介绍就不在赘述，简单描述一下流程\n从域名服务商获取域名 获取 SSL 证书(https) 具有公网 IP 的服务器部署服务到指定端口/ GITHUB Page 等托管网站 使用 Nginx/Candy 之类的实现本地端口转发和域名解析 服务商实现 DNS 解析，将域名解析到对应的 IP 地址（托管网站无需处理） ","permalink":"https://hugotest-phi.vercel.app/posts/learnweb01-devpipeline/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003eFamiliar with the pipeline of how to build a website, how to organize the files, etc\u0026hellip;\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"start-design\"\u003eStart Design\u003c/h2\u003e\n\u003cp\u003e开始设计一个网站的时候，可以从以下三个方面入手来启动整个开发设计过程：网站的主题-\u0026gt;基础的一些内容-\u0026gt;整体的外观设计（草稿）\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240130115132.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240130115132.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240130115132.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e更具体一些：确定完要制作的网页，可以绘制草图有一个粗浅的整体效果，然后指定文本、图像、色彩、字体等资源，就可以开始制作了。\u003c/p\u003e\n\u003ch2 id=\"file-structure\"\u003eFile Structure\u003c/h2\u003e\n\u003cp\u003e关于项目中的文件命名，需要注意的是以下的三点，建议养成这样的规范去建立网页文件夹。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e建议使用完全小写来命名文件\u003c/strong\u003e，webserver 是大小写敏感的，所以复杂的大小写关系容易导致访问不到文件。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e尽量不要使用空格\u003c/strong\u003e，空格可能会破坏链接被视为两个文件等，如果没有被区分很多服务器也需要使用 %20 对空格进行替换\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e尽量使用连字符代替下划线进行文件命名\u003c/strong\u003e，google 搜索引擎将连字符作为单词的分割符，而不会识别下划线\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e而文件存储结构部分，通常而言，有以下的关键文件和文件夹结构，在很多场景下也会将 image 等文件夹放到 static 文件夹中。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eindex.html\u003c/li\u003e\n\u003cli\u003estyles: 存放 css 文件\u003c/li\u003e\n\u003cli\u003eimages: 存放图片等媒体资源文件\u003c/li\u003e\n\u003cli\u003escripts: 存放 js 等脚本代码文件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e资源的文件路径一般而言以 html 为 Basepath，然后根据上下级关系确认索引地址即可。\u003c/p\u003e","title":"LearnWeb01-DevPipeline"},{"content":"\rSummary\rWeb 前端开发者路线学习，基本的目的是能够为自己想做的项目搭建前端界面，从 web 开始再到各个移动设备的前端 UI，基于 Mdn 课程，Roadmap 具体项目逐步推进对各个知识点的学习。\n根据下面的课程、Roadmap、搭建自己的知识架构，在搭建过程中结合具体的项目，包括自己部署的界面去逐步实践，完善和熟悉整个知识体系和技术栈，并通过和现代 AI 辅助工具的合作，建立自己独立的前端开发流。\nRoadmap For Beginner Roadmap For All Mdn Web Tutor Be Ready 准备以及基础了解 基础：开发环境准备、页面设计、文件架构规划（由于网站需要包含多种代码、文本、素材、因此如何组织文件是相当重要的） 语言：HTML 、CSS、JS 三驾马车为一个网页必不可少的要素，通过结合各自不同的功能来实现多样化的页面设计。 What\u0026rsquo;s WEB What\u0026rsquo;s WEB? 通过 URL 统一资源定位符向服务器请求 HTML，HTML 通过包含的信息告诉 Browse 需要额外的信息来呈现该页面，因此基于 HTML 提供的信息 web browser 继续请求资源、CSS、JS 等文件，并将这些文件按照 HTML 的描述进行组合最终呈现完整的页面。\nHow HTML Work How HTML(Hyper Text Markup Language) Work? HTML 提供了一个标准（告诉 browser）用特定标签来描述一些纯文本，这些标签就对应特定的文本渲染方式。\nQuota\rHTML is a descriptive language that allow us to tell a web browser how to handle text content. HTML 是一个描述性语言，允许告知网页浏览器如何去处理这些文本内容并进行对应的渲染。\n更具体一点可以说以下面这个例子来说：\nQuota\rHTML 不是一门编程语言，而是一种用于定义内容结构的标记语言。HTML 由一系列的元素 组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。一对标签 可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。\nHTML 标签：\n用 \u0026lt;\u0026gt; 包裹标签名称这里是 p -\u0026gt; \u0026lt;p\u0026gt;， 可以在其之上通过更多的属性来提供更多的信息 \u0026lt;p lang='en'\u0026gt; ，这里的 lang 为属性名称，‘en’为属性值，值得一提的是 class 属性可以为元素提供一个标识名称，用于后续 css 中为元素定义各种样式。 将标签和对应的结束标签将文本段落，即内容，包围起来，就形成了HTML 元素（段落）：\u0026lt;p\u0026gt; some text \u0026lt;/p\u0026gt; 通过嵌套组合各种元素，就可以创建一个 HTML 文档了。 基础的架构如下 ：\n\u0026lt;html\u0026gt; \u0026lt;/html\u0026gt; 包裹文件中 HTMl 的部分（文件中可以包含其他的 css，js 等内容） \u0026lt;!DOCTYPE html\u0026gt; 如 head body title 之类的元素/标签的制定由 W3C(world wide web consortium) 确定和维护，可以在 MDN web 文档中查看所有 Tag 的文档，相对基本文档更加易于理解。 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;!-- 告诉Browser这是一个标准的HTML文档 --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt; My cat have not eat yet. \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; My cat is \u0026lt;strong\u0026gt;very\u0026lt;/strong\u0026gt; cute \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HyperText 只是一个花哨的词语，意味着 HTML 可以创建一个到另一个 HTML 文件的连接，类似超链接，实现页面的跳转。\n页面的跳转对应的为 a 元素，可以通过如下的超文本实现页面跳转功能（也就是超链接）\n1 \u0026lt;a herf=\u0026#34; https://aikenh.cn/\u0026#34;\u0026gt;Homepage\u0026lt;/a\u0026gt; 总结一下，也就是 HTML 是为了 Browser 理解文本的一种语言，通过 W3C 指定的各种标签/元素规则来理解\u0026amp;实现 Browser 对页面的渲染。\nHow CSS work What\u0026rsquo;s CSS \u0026amp; How it Style the web pages ? CSS 也是一种描述性语言，但描述的不是文本的“语义”，而是对每一种 HTML 元素的外观和感觉进行描述，例如描述 \u0026lt;head\u0026gt;content\u0026lt;/head\u0026gt; Head,strong 这类元素应该如何呈现，就像是一种 HTML 的化妆（样式补充）\nCSS (Cascading Style Sheets) 层叠样式表\nCSS 描述的是文本的 Presentation 表现形式，而 HTML 描述的是文本的 Semantics 语义（将表现从 HTML 分离出来避免最终页面代码混杂导致的混乱）。\nHow it works? 通常使用 CSS 有三种方法：\n（尽量避免，缺乏灵活性且难以维护）在 HTML 标记中使用 style 属性如 \u0026lt;strong style=\u0026quot;...\u0026quot;\u0026gt; （只适用于单个 HTML 文档，通常网站由多个 HTML 组成）将 CSS 声明添加到 HTML 文档中，用 \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 包围，上述代码中用 \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt; 标签将 HTML 的代码块包裹起来就是为了和其他类型的代码区分。 （首选）创建单独的 CSS 文件，然后在多个 HTML 中连接特定的样式表，从而维持一致的样式特征，如： 1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; herf=\u0026#34;style.css\u0026#34; /\u0026gt; How to defined CSS？ Starts with selector to indicate which HTML element we want to style. Then using {} to defind all the property.\n例如我们定义上述提到的 strong 和 head 的样式就可以按照下面的方式：\n1 2 3 4 5 6 7 8 9 strong { color: red; display: flex; } head { align-items: center; display: flex; } CSS 有 300 多个属性，可以定义任何方式的页面，最好了解常见的一些属性，属性的组合常常出乎你的意料，\nCSS 的另一个重要特性就是 Cascading 级联，通过不同的 Selector（类似过滤器） 可以指定不同类型的元素进行样式处理（渲染），也就是说通过 selector 的特性，一个元素可以按照某种顺序被多种样式渲染（CSS 定义了一组规则）需要的话可以在 MDN 查看，在开发者模式中也可以看到顺序：\n允许覆盖和组合\nCSS 声明一种外观和渲染形式，后续通过选择器将这些 Style 应用到各个 HTML 元素上（在同个元素上可能会出现样式的覆盖或者堆叠的情况），实现对整个页面的渲染。\nHow JavaScript Works JavsScript is the Progamming language at the heart of the modern web.\n实际上 JavaScript 可以完全分成两个不同的分支（flavors）：\nJaveScript inside the browser：用于修改 HTML、网络请求、数据处理和渲染等用于Web JavaScript on the server：(Nodejs)计算机控制和管理，进程和文件处理等，更接近一个普通的编程语言。 两者存在许多独立的有用的库，除了语法，两者在应用和实际编写上重叠的地方很少，该视频后续主要介绍的是 Browser 中的 JS 。\nCSS \u0026amp; HTML 一样，可以\n直接在 HTML 中使用 \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 元素来包裹 JS 的代码块 独立写在一个 js 文件中，并在 html 代码中使用 \u0026lt;script src=\u0026quot;myScript.js\u0026quot;\u0026gt; 将其连接到 HTML 中 JS 和其他语言不一样的特点为，其自带原生的异步处理机制，可以对设定好的事件及时做出反应（触发），如下面的代码当窗口的 load 被触发了，就会执行{}中的代码，实现及时对事件做出反应。\n1 2 3 windows.addEventListener(\u0026#39;load\u0026#39;, () =\u0026gt; { }) 这种机制对用户交互界面原生的友好，如点击，加载完成等浏览器抛出事件，然后使用 JS 及时的对特定的事件做出反应。\nWhat\u0026rsquo;s SVG Scalable Vector Graphics is the only vector image format for the web. 可缩放的矢量图形是网络上唯一的矢量图形。\n图片有两种主要的格式：位图\u0026amp;矢量图；位图是简单的定义每个像素点的颜色行程的图片，web 中最常见的位图格式是 JPEG，PNG，GIF。矢量图则是一组渲染图像的函数，用这些函数来定义图像。两种图像的适用范围不同：\n位图用于更为细节的图像，如照片，具体的描述每个图片的像素点。 矢量图则更适用于，需要使用不同尺寸缩放的不太详细的图像，例如图标，因此对于 web 具备的多种分辨率场景具有无可比拟的优势。 矢量图还具有一些其他的特性：1. 它是一种用标签编写的文本格式，就想 HTML 一样；2.可以用 CSS 进行样式设计；3. 他可以使用 JavaScript 编写脚本来实现一些变化。（绘制或者创建 SVG 需要很好的数学 or 很好的 SVG 绘图软件）\nInskape, Illustrator, Sketch 是最常见的用于绘制 SVG 的软件 （2019） or JS 库：snap.svg, Bonsai, D3.js\nHow web browsers works web browser are mixing things together in order to display web. 接下来分析一下 Web Browser 需要具备什么能力来支撑这样的功能呢？\n首先，Web Browser 需要获取(html)文件，因此实际上：\n最根本的一点就是其通过 HTTP/HTTPs 协议来完成网络连接，实现对文件的 C(Create) R(Read) U(Update) D(Delete)； 此外还可以建立双向的定向通信服务通道，和特定的服务器建立双向连接（WebSockets） 创建 Peer to peer 连接等。 其次，需要理解和执行和渲染不同的语言，字体、图像、视频、文档等。 第三，需要具备交互式功能，可以实现文本选择，点击，滚动等。 第四，需要提供一些缓存存储功能，能够存储部分数据 第五，加密和安全管理功能，避免恶意入侵。\n由于页面是动态的，必须按照一定的刷新频率来对页面进行重绘，以实现预期的显示效果。\nHow WWW works Quota\r互联网：好比地球上纵横交错的道路。 网络连接：道路通到了村子路口。从此，村子里的苹果就可以运出去卖了。 TCP/IP：为了将村里的苹果能规范有效的运卖出去而不出问题，村长作出如下规定：“用规格刚好 20 cm * 20 cm * 20 cm 的泡沫箱来装，之后外面又用相应规格的纸箱包裹上，最后打上透明胶”。并且要求，对方收到时，一定要外包装完好，不然就会补发。而且还给对方发了一张发货单，明确说明了，苹果有多少，是用什么方法包装的，只有货和发货单对上了，对方才会确认收货。 DNS：突然一天，郭德纲想吃苹果，就跟于谦说，“我听说盘溪新村（域名）的苹果好，要他们那个套餐一选项啊！”，于谦一听，得，也不知道盘溪新村在哪，打开地图查（DNS）吧，一查，好嘛，江苏省苏州市（IP 地址），于是于谦去了苏州，找了村子，告诉村长，要套餐一，要用顺丰快递，并且留下了北京德云社的地址。 HTTP：过了几天，德云社的人一看，有快递来了，来了这么一句，“只收‘顺丰’，拒收其他快递”。司机忙说，“是顺丰，是顺丰”，这才对上暗号，德云社的人收下了货。 组成文件：送来的货可不止一车，而且也不止一种苹果，这车是红富士，那车黄富士的。 代码：有点像，村长事先安排的说明书，让司机到了地方，如何卸车，货放到什么位置，而德云社的看说明书，知道什么样的苹果放到什么位置上，什么样苹果如何食用最佳，等等。 资源：不同种类的苹果。 更\u0026quot;专业\u0026quot;一些的写法为：\n网络连接: 允许你在互联网上发送和接受数据。 TCP/IP: 传输控制协议和因特网互连协议是定义数据如何传输的通信协议，对传输的数据进行打包和封装。 DNS: 域名系统服务器像是一本网站通讯录。当你在浏览器内输入一个网址时，浏览器获取网页之前将会查看域名系统。浏览器需要找到存放你想要的网页的服务器，才能发送 HTTP 请求到正确的地方。 HTTP: 超文本传输协议是一个定义客户端和服务器间交流的语言的协议（protocol ），定义传输的方式。 组成文件: 一个网页由许多文件组成，就像商店里不同的商品一样。这些文件有两种类型： 代码 : 网页大体由 HTML、CSS、JavaScript 组成，不过你会在后面看到不同的技术。 资源 : 这是其他组成网页的东西的集合，比如图像、音乐、视频、Word 文档、PDF 文件。 FI","permalink":"https://hugotest-phi.vercel.app/posts/learnweb00-web%E5%85%A5%E9%97%A8/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003eWeb 前端开发者路线学习，基本的目的是能够为自己想做的项目搭建前端界面，从 web 开始再到各个移动设备的前端 UI，基于 Mdn 课程，Roadmap 具体项目逐步推进对各个知识点的学习。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e根据下面的课程、Roadmap、搭建自己的知识架构，在搭建过程中结合具体的项目，包括自己部署的界面去逐步实践，完善和熟悉整个知识体系和技术栈，并通过和现代 AI 辅助工具的合作，建立自己独立的前端开发流。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://metisy.cool/library/library/46/series/398/manga/1714?incognitoMode=false\" target=\"_blank\" rel=\"noopener\"\u003eRoadmap For Beginner\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://metisy.cool/library/library/46/series/397/pdf/1712?incognitoMode=false\" target=\"_blank\" rel=\"noopener\"\u003eRoadmap For All\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Front-end_web_developer\" target=\"_blank\" rel=\"noopener\"\u003eMdn Web Tutor\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"be-ready-准备以及基础了解\"\u003eBe Ready 准备以及基础了解\u003c/h2\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240128213825.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240128213825.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240128213825.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e基础：开发环境准备、页面设计、文件架构规划（由于网站需要包含多种代码、文本、素材、因此如何组织文件是相当重要的）\u003c/li\u003e\n\u003cli\u003e语言：HTML 、CSS、JS 三驾马车为一个网页必不可少的要素，通过结合各自不同的功能来实现多样化的页面设计。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"whats-web\"\u003eWhat\u0026rsquo;s WEB\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=O_GWbkXIqEY\u0026amp;list=PLo3w8EB99pqLEopnunz-dOOBJ8t-Wgt2g\u0026amp;index=1\" target=\"_blank\" rel=\"noopener\"\u003eWhat\u0026rsquo;s WEB?\u003c/a\u003e\n 通过 URL 统一资源定位符向服务器请求 HTML，HTML 通过包含的信息告诉 Browse 需要额外的信息来呈现该页面，因此基于 HTML 提供的信息 web browser 继续请求资源、CSS、JS 等文件，并将这些文件按照 HTML 的描述进行组合最终呈现完整的页面。\u003c/p\u003e","title":"LearnWeb00-Web入门"},{"content":"\rSummary\r有一些希望能在后台运行的任务，例如 nohup,tmux,screen 可实现的一些功能，简单介绍以下 powershell 中的类似用法和功能。\nTo run a Command Prompt (cmd.exe) command in the background from PowerShell and retrieve it later, similar to sessions in tmux, you can use PowerShell Jobs. PowerShell Jobs allow you to start a command or script in the background and then retrieve the results later. Here\u0026rsquo;s how you can do it:\n从 PowerShell 在后台运行命令提示符 (cmd.exe) 命令并稍后检索它（与 tmux 中的会话类似），可以使用 PowerShell Jobs。 PowerShell Jobs 允许在后台启动命令或脚本，然后稍后检索结果。\n具体的一些操作如下：\nStart a Job in the background 使用 Start-Job 和 ScriptBlock 参数执行选定的命令\n1 $job = Start-Job -ScriptBlock { pwsh.exe /c \u0026#34;your_command_here\u0026#34; } 这里将 your_command_here 改为自己需要执行的命令，例如启动局域网内可访问的 Stable-Diffusion Webui：\n1 $job = Start-Job -ScriptBlock { pwsh.exe /c \u0026#34;.\\webui.bat --xformers --listen\u0026#34; } 如果需要同时执行多条命令（例如执行 python 命令之前需要切换环境，默认为 base 环境）可以使用 \u0026amp;\u0026amp;\n1 $job = Start-Job -ScriptBlock { pwsh.exe /c \u0026#34;conda activate flask \u0026amp;\u0026amp; python .\\app.py\u0026#34; } Check the Job Status \u0026amp;\u0026amp; Retrieving the Results 将任务放置于后台执行之后，可能需要检查执行的状态、结果决定是否要将其常驻于后台，可以使用 Get-Job 和 Receive-Job 命令实现\n使用 Get-Job 可列出所有任务 ID 及状态\nGet-Job 也可使用 Get-Job -ID your-task-id 只查看特定 ID 的任务，通过 Get-Job 获得 ID 和基本状态后可以使用 Receive-Job 对任务的运行进行检查。\n1 Receive-Job -Id $job.Id 可以查看当前任务的运行状态决定是否要继续执行或者终止。\nStop the Job \u0026amp;\u0026amp; Remove the Code 当计划中止并移除后台任务，就需要使用到 Stop-Job 和 Remove-Job 命令，指令的名称都相当直观。\n但是在移除指令之前要记得中止指令，否则会有类似的报错，同时无法移除任务：\nTo remove the job, first stop the job, or use the Force parameter. (Parameter \u0026lsquo;SessionId\u0026rsquo;)\n1 2 Stop-Job -Id \u0026lt;JobId\u0026gt; Stop-Job -Name \u0026lt;JobName\u0026gt; 中止完任务就可以安全的移除后台任务：\n1 2 Remove-Job -Id \u0026lt;JobId\u0026gt; Remove-Job -Name \u0026lt;JobName\u0026gt; 如果想要直接删除作业而不停止，就需要使用 Force 参数，通常用于强制删除无响应或者停止时间过长的任务。\n1 2 Remove-Job -Id \u0026lt;JobId\u0026gt; -Force Remove-Job -Name \u0026lt;JobName\u0026gt; -Force 请记住将 \u0026lt;JobId\u0026gt; 或 \u0026lt;JobName\u0026gt; 替换为您要停止或删除的作业的实际 ID 或名称。这种方法可确保作业安全终止并从系统中删除，从而释放其正在使用的所有资源。\nFI","permalink":"https://hugotest-phi.vercel.app/posts/pwsh_bgtask/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e有一些希望能在后台运行的任务，例如 nohup,tmux,screen 可实现的一些功能，简单介绍以下 powershell 中的类似用法和功能。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003eTo run a Command Prompt (cmd.exe) command in the background from PowerShell and retrieve it later, similar to sessions in \u003ccode\u003etmux\u003c/code\u003e, you can use PowerShell Jobs. PowerShell Jobs allow you to start a command or script in the background and then retrieve the results later. Here\u0026rsquo;s how you can do it:\u003c/p\u003e\n\u003cp\u003e从 PowerShell 在后台运行命令提示符 (cmd.exe) 命令并稍后检索它（与 \u003ccode\u003etmux\u003c/code\u003e 中的会话类似），可以使用 PowerShell Jobs。 PowerShell Jobs 允许在后台启动命令或脚本，然后稍后检索结果。\u003c/p\u003e\n\u003cp\u003e具体的一些操作如下：\u003c/p\u003e\n\u003ch3 id=\"start-a-job-in-the-background\"\u003eStart a Job in the background\u003c/h3\u003e\n\u003cp\u003e使用 Start-Job 和 ScriptBlock 参数执行选定的命令\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$job\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eStart-Job\u003c/span\u003e \u003cspan class=\"n\"\u003e-ScriptBlock\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003epwsh\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"py\"\u003eexe\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;your_command_here\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这里将 \u003ccode\u003eyour_command_here\u003c/code\u003e 改为自己需要执行的命令，例如启动局域网内可访问的 Stable-Diffusion Webui：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$job\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eStart-Job\u003c/span\u003e \u003cspan class=\"n\"\u003e-ScriptBlock\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003epwsh\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"py\"\u003eexe\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;.\\webui.bat --xformers --listen\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果需要同时执行多条命令（例如执行 python 命令之前需要切换环境，默认为 base 环境）可以使用 \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \u003cspan class=\"nv\"\u003e$job\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eStart-Job\u003c/span\u003e \u003cspan class=\"n\"\u003e-ScriptBlock\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003epwsh\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"py\"\u003eexe\u003c/span\u003e \u003cspan class=\"p\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;conda activate flask \u0026amp;\u0026amp; python .\\app.py\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Windows Powershell 01 后台任务"},{"content":"[\u0026gt; [!summary]+\nthis article purpose is to build an authority page for stable diffusion webui using nginx \u0026amp; python/js. Which can publish my personal stable diffusion server. Wrote by GPT(try).\nIntroduction In the digital age, the security and user-friendliness of web services are not just conveniences; they are necessities. Balancing robust security protocols with an engaging user experience is key to maintaining both the integrity and popularity of any online service. This blog post dives into the intricacies of securing web services using Nginx for authentication, coupled with designing an appealing frontend. Our journey begins with a practical scenario:\npublishing a stable diffusion webUI service, accessible only to an authenticated audience.\nSetting Up Nginx for Secure Authentication Nginx excels in serving web pages and as a reverse proxy, providing enhanced security through authentication mechanisms. Let’s explore a typical Nginx configuration for secure authentication:\n/verify_token: This block forwards authentication requests to a dedicated server. By excluding the request body and focusing on essential headers, it ensures that only valid, authenticated requests proceed. location = /verify_token {\rproxy_pass http://{your_auth_server}:2424;\rproxy_pass_request_body off;\rproxy_set_header Content-Length \u0026#34;\u0026#34;;\rproxy_set_header X-Original-URI $request_uri;\rproxy_set_header X-Original-Remote-Addr $remote_addr;\rproxy_set_header X-Original-Host $host;\r} /login: Catering to login requests, this configuration forwards the necessary details to the authentication server, preserving crucial information about the request\u0026rsquo;s origin. location /login {\rproxy_pass http://{your_auth_server}:2424;\rproxy_set_header Host $host;\rproxy_set_header X-Real-IP $remote_addr;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\rproxy_set_header X-Forwarded-Proto $scheme;\r} Error Handling (@error401): A clever redirect mechanism that guides unauthenticated users to the login page, keeping the original URL intact. location @error401 {\rreturn 302 {your_domain}/login;\r} Root Location (/): The gateway to your service, which rigorously checks each request for authentication, granting access only to verified users. location / {\rauth_request /verify_token;\rerror_page 401 = @error401;\rproxy_pass http://{your_server}:2323/;\rproxy_http_version 1.1;\rproxy_set_header Upgrade $http_upgrade;\rproxy_set_header Connection \u0026#39;upgrade\u0026#39;;\rproxy_set_header Host $host;\rproxy_cache_bypass $http_upgrade;\r} This setup not only fortifies your service against unauthorized access but also maintains a seamless user experience, redirecting unauthenticated users without hassle.\nImplementing JWT for Robust Backend Authentication Implementing JWT (JSON Web Tokens) in a Flask web application provides a secure way of handling authentication. The provided Flask code demonstrates how JWT can be integrated for a robust backend authentication system:\nSetup and Environment Variables: The Flask app is configured with a secret key, essential for JWT encoding and decoding. 1 2 3 4 5 6 7 from flask import Flask import os from dotenv import load_dotenv load_dotenv() app = Flask(__name__) app.secret_key = os.getenv(\u0026#39;SECRET_KEY\u0026#39;) Login Route: The /login route handles user authentication. Upon successful login, a JWT is encoded with the user\u0026rsquo;s information and expiration time, then sent as a cookie. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def login(): count = update_visit_count() if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] # Validate credentials (use a secure method in production) if username == os.getenv(\u0026#39;chat_username\u0026#39;) and password == os.getenv(\u0026#39;password\u0026#39;): token = jwt.encode({ \u0026#39;user\u0026#39;: username, \u0026#39;exp\u0026#39;: datetime.datetime.utcnow() + datetime.timedelta(minutes=30) }, app.secret_key, algorithm=\u0026#39;HS256\u0026#39;) response = make_response(redirect(\u0026#39;/\u0026#39;)) response.set_cookie(\u0026#39;token\u0026#39;, token, max_age=1800) # Keep login status for 30 mins return response error = \u0026#39;Invalid credentials\u0026#39; return render_template(\u0026#39;login.html\u0026#39;, error=error, count=count), 401 # Show login page return render_template(\u0026#39;login.html\u0026#39;,count=count) Token Verification: A decorator token_required is used to verify the JWT token in subsequent requests. This ensures that only authenticated users can access certain routes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def token_required(f): def decorator(*args, **kwargs): token = request.cookies.get(\u0026#39;token\u0026#39;) if not token: print(\u0026#39;token is none\u0026#39;) return redirect(\u0026#39;/login\u0026#39;) try: jwt.decode(token, app.secret_key, algorithms=[\u0026#39;HS256\u0026#39;]) except: print(\u0026#39;token is invalid\u0026#39;) return redirect(\u0026#39;/login\u0026#39;) return f(*args, **kwargs) decorator.__name__ = f.__name__ return decorator Token Validation Endpoint: The /verify_token endpoint checks the validity of the token, which is essential for integrating with the Nginx authentication mechanism. 1 2 3 4 5 6 7 8 9 10 11 @app.route(\u0026#39;/verify_token\u0026#39;) def verify_token(): token = request.cookies.get(\u0026#39;token\u0026#39;) if not token: return \u0026#39;Access Denied\u0026#39;, 401 try: jwt.decode(token, app.secret_key, algorithms=[\u0026#39;HS256\u0026#39;]) return \u0026#39;Authorized\u0026#39;, 200 except: return \u0026#39;Access Denied\u0026#39;, 401 Dynamic Secret Key Update: A function update_secret_key_in_env is included to update the secret key daily, enhancing security by invalidating old tokens. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # Function to generate a new secret key and write it to the .env file def update_secret_key_in_env(): env_file_path = \u0026#39;.env\u0026#39; secret_key = f\u0026#39;SECRET_KEY={secrets.token_urlsafe(32)}\u0026#39; last_updated = f\u0026#39;LAST_UPDATED={datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d\u0026#34;)}\u0026#39; key_updated = False # Check if .env file exists and read the content if os.path.exists(env_file_path): with open(env_file_path, \u0026#39;r\u0026#39;) as file: lines = file.readlines() # Update or add SECRET_KEY and LAST_UPDATED for i, line in enumerate(lines): if \u0026#39;LAST_UPDATED\u0026#39; in line: last_updated_date = line.strip().split(\u0026#39;=\u0026#39;)[1] if last_updated_date != datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d\u0026#34;): lines[i] = last_updated + \u0026#39;\\n\u0026#39; key_updated = True elif \u0026#39;SECRET_KEY\u0026#39; in line: if key_updated is True: lines[i] = secret_key + \u0026#39;\\n\u0026#39; else: print(\u0026#34;no need to update the secret key today\u0026#34;) key_updated = True # If SECRET_KEY or LAST_UPDATED are not found, add them if not key_updated: lines.append(last_updated + \u0026#39;\\n\u0026#39;) lines.append(secret_key + \u0026#39;\\n\u0026#39;) key_updated = True # Write back to .env file with open(env_file_path, \u0026#39;w\u0026#39;) as file: file.writelines(lines) else: # If .env file doesn\u0026#39;t exist, create one with open(env_file_path, \u0026#39;w\u0026#39;) as file: file.writelines([last_updated + \u0026#39;\\n\u0026#39;, secret_key + \u0026#39;\\n\u0026#39;]) key_updated = True if key_updated: print(\u0026#34;Secret key and last updated date added/updated in .env file.\u0026#34;) else: print(\u0026#34;No update required for today.\u0026#34;) Visitor Count Feature: As part of the user experience, a visitor count is maintained, which is updated with each visit. 1 2 3 4 5 6 7 8 9 10 def update_visit_count(): try: with open(\u0026#34;visit_count.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: count = int(file.read()) with open(\u0026#34;visit_count.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: count += 1 file.write(str(count)) return count except IOError: return \u0026#34;Error\u0026#34; This implementation of JWT in a Flask application exemplifies a secure and efficient way of handling user authentication, ensuring that only authorized users can access protected services.\nDesigning a User-Friendly Frontend In tandem with robust backend security, the frontend of your web service plays a crucial role in user engagement and satisfaction. Let\u0026rsquo;s delve into the key features of our project\u0026rsquo;s frontend design:\nTheme Toggle and Slogan:\nThe theme switcher allows users to choose between dark and light modes. 1 2 3 4 5 6 \u0026lt;div class=\u0026#34;theme-switch-wrapper\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;theme-toggle\u0026#34; class=\u0026#34;theme-toggle\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;moon\u0026#34;\u0026gt;\u0026amp;#9790;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;sun\u0026#34;\u0026gt;\u0026amp;#9728;\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; A catchy slogan is displayed, setting a creative and visionary tone. 1 \u0026lt;div class=\u0026#34;slogan\u0026#34;\u0026gt;Crafting Tomorrow\u0026#39;s Narratives, Today.\u0026lt;/div\u0026gt; Login Interface: The entry point of any web service, the login page, is where security meets user experience. Our Flask-based web application presents a clean and intuitive login interface. It includes fields for username and password and a login button. This simplicity ensures ease of use while maintaining a professional appearance.\n1 2 3 4 5 \u0026lt;form action=\u0026#34;/login\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; placeholder=\u0026#34;Username\u0026#34; name=\u0026#34;username\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; placeholder=\u0026#34;Password\u0026#34; name=\u0026#34;password\u0026#34; required\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; Additional subtitle for contextual information. 1 \u0026lt;p class=\u0026#34;subtitle\u0026#34;\u0026gt;If you want to reach this server, please contact Aiken or Metis.\u0026lt;/p\u0026gt; Interactive Error Handling:\nA unique error message display using a cat image, adding a touch of humor. 1 2 3 4 5 6 {% if error %} \u0026lt;div class=\u0026#34;error-cat\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ url_for(\u0026#39;static\u0026#39;, filename=\u0026#39;images/cat.webp\u0026#39;) }}\u0026#34; alt=\u0026#34;Cat\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;speech-bubble\u0026#34;\u0026gt;{{ error }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {% endif %} Footer with Visitor Count:\nDisplaying the visitor count adds an interactive and transparent element. 1 2 3 \u0026lt;footer\u0026gt; This page has been visited {{ count }} times. \u0026lt;/footer\u0026gt; Comparing Authentication Methods: JWT, OAuth, and Basic Authentication In the realm of web security, selecting the right authentication method is crucial. Let\u0026rsquo;s compare JWT (JSON Web Tokens), OAuth, and Basic Authentication to understand their unique features and use cases:\nJWT (JSON Web Tokens):\nMechanism: Encoded tokens that carry claims and are used for secure data exchange. Use Cases: Ideal for single sign-on (SSO) and stateless applications. Pros: Highly flexible, supports cross-domain requests, and is self-contained with payload data. Cons: Requires careful management of secret keys and token expiration. OAuth:\nMechanism: An authorization framework allowing applications to secure designated access without revealing user credentials. Use Cases: Best for third-party access (like social logins) and granting limited access to user data. Pros: Enhanced security as user credentials are not exposed, and allows token-based access control. Cons: Complex implementation and requires understanding of tokens and scopes. Basic Authentication:\nMechanism: A simple authentication scheme built into the HTTP protocol using username and password. Use Cases: Suitable for simple login needs, especially when accessing APIs for internal use. Pros: Easy to implement and understand. Cons: Less secure as it sends credentials in base64 encoded format, vulnerable to interception. Each of these methods has its strengths and weaknesses, and the choice largely depends on the specific requirements of your web application.\nConclusion: Balancing Security and User Experience in Web Services As we conclude this journey through securing and personalizing web services, it\u0026rsquo;s clear that the right blend of backend security and frontend design can significantly enhance both the security and user experience of a web application.\nFrom implementing robust JWT authentication in a Flask application to designing an engaging and intuitive frontend, each aspect plays a pivotal role in delivering a seamless and secure user experience. Whether it\u0026rsquo;s the compact and scalable nature of JWTs, the interactive and user-friendly design elements on the frontend, or the comparative analysis of different authentication methods, each component contributes to a comprehensive web service solution.\nFor small projects, especially, the choice of JWT stands out for its efficiency, scalability, and ease of implementation, making it a wise choice for developers looking to secure their applications without compromising on performance or user experience.\nIn the end, the key takeaway is that security and usability do not have to be at odds; with the right tools and approaches, they can complement each other to create web services that are not only secure but also enjoyable to use.\nWe encourage our readers to explore the code and concepts discussed in this blog post and to visit the GitHub repository for the original code at ezEncryptYourService . Dive in, experiment, and elevate your web services to new heights of security and user engagement.\n","permalink":"https://hugotest-phi.vercel.app/posts/stablediffusionwebui%E9%89%B4%E6%9D%83%E8%AE%BE%E8%AE%A1/","summary":"\u003cp\u003e[\u0026gt; [!summary]+\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ethis article purpose is to build an authority page for stable diffusion webui using nginx \u0026amp; python/js. Which can publish my personal stable diffusion server. Wrote by GPT(try).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240127161828.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240127161828.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20240127161828.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch3 id=\"introduction\"\u003eIntroduction\u003c/h3\u003e\n\u003cp\u003eIn the digital age, the security and user-friendliness of web services are not just conveniences; they are necessities. Balancing robust security protocols with an engaging user experience is key to maintaining both the integrity and popularity of any online service. This blog post dives into the intricacies of securing web services using Nginx for authentication, coupled with designing an appealing frontend. Our journey begins with a practical scenario:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003epublishing a stable diffusion webUI service, accessible only to an authenticated audience.\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"setting-up-nginx-for-secure-authentication\"\u003eSetting Up Nginx for Secure Authentication\u003c/h3\u003e\n\u003cp\u003eNginx excels in serving web pages and as a reverse proxy, providing enhanced security through authentication mechanisms. Let’s explore a typical Nginx configuration for secure authentication:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e/verify_token\u003c/strong\u003e: This block forwards authentication requests to a dedicated server. By excluding the request body and focusing on essential headers, it ensures that only valid, authenticated requests proceed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-conf\" data-lang=\"conf\"\u003elocation = /verify_token {\r\n    proxy_pass http://{your_auth_server}:2424;\r\n    proxy_pass_request_body off;\r\n    proxy_set_header Content-Length \u0026#34;\u0026#34;;\r\n    proxy_set_header X-Original-URI $request_uri;\r\n    proxy_set_header X-Original-Remote-Addr $remote_addr;\r\n    proxy_set_header X-Original-Host $host;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e/login\u003c/strong\u003e: Catering to login requests, this configuration forwards the necessary details to the authentication server, preserving crucial information about the request\u0026rsquo;s origin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-conf\" data-lang=\"conf\"\u003elocation /login {\r\n    proxy_pass http://{your_auth_server}:2424;\r\n    proxy_set_header Host $host;\r\n    proxy_set_header X-Real-IP $remote_addr;\r\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n    proxy_set_header X-Forwarded-Proto $scheme;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eError Handling (@error401)\u003c/strong\u003e: A clever redirect mechanism that guides unauthenticated users to the login page, keeping the original URL intact.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-conf\" data-lang=\"conf\"\u003elocation @error401 {\r\n    return 302 {your_domain}/login;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRoot Location (/)\u003c/strong\u003e: The gateway to your service, which rigorously checks each request for authentication, granting access only to verified users.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-conf\" data-lang=\"conf\"\u003elocation / {\r\n    auth_request /verify_token;\r\n    error_page 401 = @error401;\r\n    proxy_pass http://{your_server}:2323/;\r\n    proxy_http_version 1.1;\r\n    proxy_set_header Upgrade $http_upgrade;\r\n    proxy_set_header Connection \u0026#39;upgrade\u0026#39;;\r\n    proxy_set_header Host $host;\r\n    proxy_cache_bypass $http_upgrade;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis setup not only fortifies your service against unauthorized access but also maintains a seamless user experience, redirecting unauthenticated users without hassle.\u003c/p\u003e","title":"StableDiffusionWebUI鉴权设计"},{"content":"\rSummary\r在搭建了 Immich 服务之后，考虑到数据本身的重要性，又对硬盘本身的寿命和各种数据安全的场景有所顾虑，对加密备份的需求就浮出水面了，希望能有一个备份的预案来对抗各种数据风险，因此有本篇文章，对各种备份工具做简单调研和选择。\n👾Intro 调研对象介绍 👍出场选手介绍，节选来自以下网站的备份方案：awesome-sysadmin-backup kopia urBackUp restic rclone duplicity Duplicati Duplicacy 脚本实现简单的备份和上传：Crontab+自动 tar 加密+Webdav 接口进行上传 为了备份大量包含隐私的图像信息，这里最基础的需求有以下几点：加密，支持云端存储服务/Webdav，增量备份，免费；\n额外如果能够支持以下的需求则额外加分：压缩，去重，平台一致性，用户界面友好（备份状态检查等）\n🏓Compare 特性对比 Name PSWD Zip Webdav Add Type ui Consis free rate kopia y y y y Full y y y 🔥🔥🔥🔥🔥 urbackup y n n y C/S y y y 🔥 restic y n r/o y CLI n y y 🔥 duplicity y n y y CLI n n y 🔥🔥 duplicati y n y y Full y n y 🔥🔥🔥🔥 duplicacy y y y y Full y- y y- 🔥🔥🔥🔥🔥 C/S: Client \u0026amp; Server 的模式，在需要备份的机器上安装客户端，在存储备份的机器上安装服务端，通常用于 NAS 存储各个终端数据的场景，如urbackup。\nPSWD: Password 支持加密访问数据或者服务，保证数据的安全。 Add: Incremental 额外支持快速增量备份，能够识别出新增文件。 Consis: Consistent 备份数据一致性，多个平台保持一致的备份数据格式，以及数据恢复能力。 Webdav：是否支持云端存储服务？\ny 表示支持 Aliyun 或者 webdav 实现对国内网盘的支持。 o 表示支持 OSS 等对象存储服务。 n 表示只支持本地存储，可能需要通过脚本手动和云端存储进行交互（如果可以表示备份状态也可以） r 表示支持 rclone 挂载的云端对象，rclone+alist 可以支持国内硬盘服务。 Udpate\rupdate：I really need to find this before I Wrote This. https://wiki.archlinux.org/title/Synchronization_and_backup_programs#Chunk-based_increments 🍴Features 具体特性 Kopia: 用户界面友好，支持压缩，支持快照映射到本地，支持定时备份，支持 webdav，支持各种备份策略，支持网页版管理，支持加密，支持同时备份到多个目的地，高效，使用简单。\n参考资料：Kopia: 全平台开源备份软件新秀 urbackup: 可以对整个系统进行完整的定时备份，主要用于重要的服务器的容灾备份，也可灵活备份某个文件夹，但对当前的需求来说并不是最合适的。\nrestic: 命令行备份工具，支持备份到 OSS 或者 RClone 挂载的各种云端对象，通过快照的存储可以实现不同时间备份单文件的恢复，支持增量备份和完全备份，支持备份特定文件夹，支持 Docker 安装，目前看来可以通过 Rclone 和 Alist 的组合来彻底满足我们的需求，可能需要本地环境作中转。\n参考资料：restic操作指令详解 , restic介绍 , restic简介 duplicity: 命令行备份工具，优势在于直接支持 Webdav，极其高效的增量备份，支持单个文件的恢复，支持指定日期的恢复，可使用 GPG 秘钥进行加密解密；缺点在于目前仅支持 Linux 环境，可能需要编写脚本来支持定时运行，可以基于 WSL2 实现对 Windows 本机的备份，但是带宽和 CPU 等要素相对受限，无法完全发挥性能。\nduplicity 有一个严重的缺陷在于其增量备份方法，每一次备份都需要用户选择是否全量备份或者增量备份，并且其设计决定了在一个备份了很多次的仓库中删除任何一个历史的备份变得不可能。\n参考资料：Linux全新的备份神器Duplicity duplicati：带 UI 的备份工具，支持备份到 Webdav，也支持命令行工具，支持 docker，支持增量备份，操作简单，支持计划备份和清除，支持 NGINX 部署访问，单文件恢复可能不支持，但支持选中单文件夹进行恢复，完美符合需求。\n参考资料：Duplicity备份到Alist ，Duplicity备份到COS ，Docker搭建Duplicati duplicacy：CLI 免费，付费提供网页管理界面，支持 webdav，增量备份，支持加密备份，使用 Lock-Free(参考资料 1) 技术来节省空间，不会无法删除快照，支持多个客户端备份到同一个云端存储，支持 docker 安装（可能需要许可证 ）\n参考资料：Duplicacy 增量备份工具使用 ，Duplicacy Docker安装 ，Duplicacy CLI使用 Note\r如果是存储各时段快照的版本，记得使用指定的命令删除过时的快照。\n⛏️Pick 最终选择 KOPIA\rduplicati 在查阅资料 后提前出局，出现的 bug 等相对会多些 duplicacy 看起来十分美好，但是网页管理功能需要付费使用，虽然可以接受，但是当 kopia 有更好选择的时候就暂时被搁置了。 如果后续使用中 kopia 没有 lock-free 的优势或者说在多次备份后需要保存大量快照且无法删除的硬伤，则不会再更新，如果发现 kopia 有所缺陷，则更新该部分内容。\n参考资料：kopia-duplicati-duplicacy-vorta 🦶脚本组成分析 如果要做一个功能完备，但是简单的自用备份服务，个人认为应该包含以下的内容：\n定时任务：对定时脚本进行更改，执行和启用定时任务 文件加密：可以使用简单的打包命令进行加密打包， 文件传输：将备份文件传输至指定地方，包括 webdav 的上传， 增量备份：无论是快照或者版本管理的思路，能够识别出新增内容并仅针对新增内容进行传输 上述任务中无论是定时，还是文件压缩、传输、都有较为简单的基础方式，里面最复杂的且我认为是比较重要的则恰恰是增量备份这一点，这一点对备份的效率和空间占用都是十分关键的，不会使得每次备份都需要较多时间和性能成本。\n这里有时间希望去学习一下上述开源项目，学习如何建立一个快照系统。 🌻FI","permalink":"https://hugotest-phi.vercel.app/posts/backuptoolsforhomeserver/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e在搭建了 Immich 服务之后，考虑到数据本身的重要性，又对硬盘本身的寿命和各种数据安全的场景有所顾虑，对加密备份的需求就浮出水面了，希望能有一个备份的预案来对抗各种数据风险，因此有本篇文章，对各种备份工具做简单调研和选择。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231229113137.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231229113137.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231229113137.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"intro-调研对象介绍\"\u003e👾Intro 调研对象介绍\u003c/h2\u003e\n\u003cp\u003e👍出场选手介绍，节选来自以下网站的备份方案：\u003ca href=\"https://github.com/awesome-foss/awesome-sysadmin#backups\" target=\"_blank\" rel=\"noopener\"\u003eawesome-sysadmin-backup\u003c/a\u003e\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://kopia.io/\" target=\"_blank\" rel=\"noopener\"\u003ekopia\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.urbackup.org/\" target=\"_blank\" rel=\"noopener\"\u003eurBackUp\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://restic.net/\" target=\"_blank\" rel=\"noopener\"\u003erestic\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://rclone.org/\" target=\"_blank\" rel=\"noopener\"\u003erclone\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://duplicity.gitlab.io/\" target=\"_blank\" rel=\"noopener\"\u003eduplicity\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.duplicati.com/\" target=\"_blank\" rel=\"noopener\"\u003eDuplicati\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://duplicacy.com/\" target=\"_blank\" rel=\"noopener\"\u003eDuplicacy\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e脚本实现简单的备份和上传：Crontab+自动 tar 加密+Webdav 接口进行上传\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e为了备份大量包含隐私的图像信息，这里最基础的需求有以下几点：\u003cstrong\u003e加密\u003c/strong\u003e，\u003cstrong\u003e支持云端存储\u003c/strong\u003e服务/Webdav，\u003cstrong\u003e增量备份\u003c/strong\u003e，\u003cstrong\u003e免费\u003c/strong\u003e；\u003c/p\u003e\n\u003cp\u003e额外如果能够支持以下的需求则额外加分：\u003cstrong\u003e压缩\u003c/strong\u003e，\u003cstrong\u003e去重\u003c/strong\u003e，\u003cstrong\u003e平台一致性\u003c/strong\u003e，\u003cstrong\u003e用户界面友好\u003c/strong\u003e（备份状态检查等）\u003c/p\u003e\n\u003ch2 id=\"compare-特性对比\"\u003e🏓Compare 特性对比\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003ePSWD\u003c/th\u003e\n          \u003cth\u003eZip\u003c/th\u003e\n          \u003cth\u003eWebdav\u003c/th\u003e\n          \u003cth\u003eAdd\u003c/th\u003e\n          \u003cth\u003eType\u003c/th\u003e\n          \u003cth\u003eui\u003c/th\u003e\n          \u003cth\u003eConsis\u003c/th\u003e\n          \u003cth\u003efree\u003c/th\u003e\n          \u003cth\u003erate\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ekopia\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003eFull\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003e🔥🔥🔥🔥🔥\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eurbackup\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003en\u003c/td\u003e\n          \u003ctd\u003en\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003eC/S\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003e🔥\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003erestic\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003en\u003c/td\u003e\n          \u003ctd\u003er/o\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003eCLI\u003c/td\u003e\n          \u003ctd\u003en\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003e🔥\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eduplicity\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003en\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003eCLI\u003c/td\u003e\n          \u003ctd\u003en\u003c/td\u003e\n          \u003ctd\u003en\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003e🔥🔥\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eduplicati\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003en\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003eFull\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003en\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003e🔥🔥🔥🔥\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eduplicacy\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003eFull\u003c/td\u003e\n          \u003ctd\u003ey-\u003c/td\u003e\n          \u003ctd\u003ey\u003c/td\u003e\n          \u003ctd\u003ey-\u003c/td\u003e\n          \u003ctd\u003e🔥🔥🔥🔥🔥\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"家庭服务器的备份工具选择"},{"content":"\rSummary\r本文主要介绍笔者的家庭服务器设计方案 V1。该方案中中涵盖影视、图像、图书\u0026amp;文献、博客、智能家居管理、密码管理服务，以及公网上内容分发的初步设计和选择的考量。\n整体架构 整个服务中心在设计的时候主要考虑以下的几个方面：\n💻操作设备\u0026amp;系统(OS)和内容存储方案：如何经济实惠的选择合适的设备和系统 🌦️服务需求：需要搭建哪些服务，应该选择哪个服务进行自托管 🌍部署方案：如何保证在局域网+公网都能顺利且安全的访问 📱访问策略：各个平台上的访问方式的选择 此外，并非所有服务都需要在公网上进行部署，这里的部分服务可以仅用于局域网，由于仅开放了 Nginx 端口，因此从公网中访问不到未分发的内容，因此，部分存储与敏感信息相关的服务可以仅保留在局域网中进行访问。\nNote\r在这种情况下如果希望能够使用一致的域名访问方式，是否可以考虑使用 Nginx 鉴权限制访问 ip 为内网 ip，其他公网访问直接丢弃？\n初版家庭服务中心的架构图如下，(这里并非列出所有的服务组件)，该架构图中所有的应用都是为了方便日常生活中的各项活动，下面会对架构图自底向上的做一些简单的说明。\n设备和存储选择 存储和设备的选择主要来自以下的两个需求，首先是能够用作机顶盒，其次是尽量能省则省，综合考虑上述的两个需求，树莓派+网络云盘的策略有如下的几个优势，也是选择它的原因：\n设备和存储价格相对便宜，长时间在线电费消耗也几乎可以忽略不计 体积较小，作为机顶盒放置的方式较为简单 云盘的转存和资源收集的速度快，且可结合小雅和 Alist 进行网盘的集成，以及线上资源的整合。 劣势就在于非本地存储和对网络的要求相对较高一些，且在系统上需要折腾的时间会比成熟的 NAS 厂家的开箱即用要折腾一些，最后就是一些对性能要求较高的服务树莓派可能无法承担这个职责，因此这里使用自己的个人电脑用来部署一些对性能要求较高的服务。\n服务部署策略 docker 在服务部署的优势有：独立互不影响的环境和一键部署方便性，因此我们使用 docker 进行几乎所有的服务的部署，并使用 portainer 对其进行管理。\n图书\u0026amp;漫画：使用 Kavita+Calibre（进行资源的转换和元信息的不全）+ （Zlibray\u0026amp;漫自由）获取资源。 照片：使用 Immich 满足整个家庭备份手机照片并进行统一管理的需求，可完全代替 icloud 且只需要本地磁盘。 影视：使用 Alist 整合自己的网盘 + 线上的 xiaoya 的 alist 资源 + emby 做一个影视墙（可选）+ Kodi 进行电视端的播放（KORE，kodi 手机端的官方遥控器） 智能家居：使用 HomeAssistant 管理各种不同品牌的智能家居设备 服务分发和服务访问 这里使用 Nginx+腾讯云进行服务的分发，并通过 DDNSgo 动态更新域名解析的 IPV6 地址，之后就可以通过域名对相应服务进行访问。\n可用 Caddy 这个现在的后期之秀来代替 Nginx，Nginx 也可以安装对应的可视化设置界面。\n上述提到的是基于 ipv6 部署到公网后的分发情况，如果没有或者不想部署公网的话就使用如 Zerotier 和 Tailscale 的内网穿透服务来实现虚拟内网 ip+端口去访问服务。\n在各个终端上的服务访问可以通过浏览器的保存为应用/固定到桌面，以及各自对应的官方 APP 为主要的访问手段。\n后续计划 Note\r这里记录后续希望进行补充的服务和设计，最终希望能够作为一个比较全面且完整的方案，覆盖到生活的方方面面，为自己和朋友的生活提供便利。\n设计 StableDiffusionWEBui 的鉴权页面，方便部署到公网上使用，方便作图需求 现已涵盖视频图片和图书等服务，后续考虑是否有必要针对音乐添加相关页面 (eval) 菜谱管理中心，收藏各个不同的平台的菜谱 (eval) RSS Center 可能需要 RSS-HUB 创建自己关心的所有 RSS 源，然后通过 (eval) 使用 Ghost 尝试更新自己的 Blog (eval) 更新 Homepage 更新 CodeServer，是否要在网页上部署Vscode FI","permalink":"https://hugotest-phi.vercel.app/posts/%E5%AE%B6%E5%BA%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B4%E4%BD%93%E6%96%B9%E6%A1%88/","summary":"\u003cblockquote class=\"alert-blockquote alert-summary\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eSummary\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e本文主要介绍笔者的家庭服务器设计方案 V1。该方案中中涵盖影视、图像、图书\u0026amp;文献、博客、智能家居管理、密码管理服务，以及公网上内容分发的初步设计和选择的考量。\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003ch2 id=\"整体架构\"\u003e整体架构\u003c/h2\u003e\n\u003cp\u003e整个服务中心在设计的时候主要考虑以下的几个方面：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e💻操作设备\u0026amp;系统(OS)和内容存储方案：如何\u003cstrong\u003e经济实惠\u003c/strong\u003e的选择合适的设备和系统\u003c/li\u003e\n\u003cli\u003e🌦️服务需求：需要搭建\u003cstrong\u003e哪些服务\u003c/strong\u003e，应该选择\u003cstrong\u003e哪个服务\u003c/strong\u003e进行自托管\u003c/li\u003e\n\u003cli\u003e🌍部署方案：如何保证在局域网+\u003cstrong\u003e公网\u003c/strong\u003e都能顺利且\u003cstrong\u003e安全的访问\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e📱访问策略：各个平台上的访问方式的选择\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e此外，并非所有服务都需要在公网上进行部署，这里的部分服务可以仅用于局域网，由于仅开放了 Nginx 端口，因此从公网中访问不到未分发的内容，因此，部分存储与敏感信息相关的服务可以仅保留在局域网中进行访问。\u003c/p\u003e\n\r\n\r\n\r\n  \r\n  \r\n\r\n\u003cblockquote class=\"alert-blockquote alert-note\"\u003e\r\n  \u003cp class=\"alert-heading\"\u003e\r\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\r\n      \u003cpath d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"\u003e\u003c/path\u003e\r\n    \u003c/svg\u003e\r\n    \u003cspan\u003eNote\u003c/span\u003e\r\n  \u003c/p\u003e\r\n  \u003cp\u003e在这种情况下如果希望能够使用一致的域名访问方式，是否可以考虑使用 Nginx 鉴权限制访问 ip 为内网 ip，其他公网访问直接丢弃？\u003c/p\u003e\n\r\n\u003c/blockquote\u003e\r\n\u003cp\u003e初版家庭服务中心的架构图如下，(这里并非列出所有的服务组件)，该架构图中所有的应用都是为了方便日常生活中的各项活动，下面会对架构图自底向上的做一些简单的说明。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231209082421.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231209082421.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231209082421.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"家庭服务器整体方案"},{"content":"禁止屏幕休眠显示作为 Dashboard 显示 树莓派官方的 Raspbian 系统使用的是 lightdm 桌面显示管理器，可以设置 xservice 桌面交互显示来达到屏幕常亮的目的，也就是修改桌面配置文件 lightdm.Conf\n参考资料：树莓派设置禁止让屏幕休眠，显示器保持常亮状态-树莓派基础学习入门-树莓派极客,raspi.cc - Powered by raspi 1 sudo vim /etc/lightdm/lightdm.conf 找到 x-server-command 取消注释并在后面加 -s 0-dpms，添加完后重启即可。\n参数里的：-s 参数：设置屏幕保护不启动，0 数字零，-dpms 参数：关闭电源节能管理。\nMissing X server or $DISPLAY 无法启动问题 在使用命令行等操作启动 GUI 应用的时候需要为其设定一个显示器，否则会报显示设备设置错误或不存在等问题导致其无法启动。\n参考资料：\nKali Linux安装Google Chrome小记 野马菲比的博客 “无X11显示”相关错误含义和解决 - IT Coding Man 通常 DISPLAY 会自己设置，但是使用远程的一些情况下该参数可能会有缺省的情况，在这种情况下需要我们手动设置一下：\n1 export DISPLAY=:0.0 就可以启动 Gui 界面，例如启动 chrome\n1 nohup chromium-browser --kiosk http://websiteyouwant.com \u0026amp;; 其中 --kiosk 参数代表全屏显示；\nKodi 关闭后黑屏/重启 Xorg 树莓派 kodi 关闭以后经常显示器会处于一个黑屏的状态，如何使其正常的显示内容，也可以是说是图像界面卡死的解决办法；\n参考资料：树莓派图形界面卡死时的处理_安科网 (ancii.com) 1 2 ps -ef | grep Xorg # 获取PID 1 sudo kill -15 「PID」 即可实现自己重启 Xorg，归根结底，就是重启了 X 服务，因为 raspberry 默认用的是 lightdm 作为 X 服务的管理器，所以也可直接重启 lightdm。\n1 sudo service lightdm restart Sudo 无需输入密码 该章节主要是为了后续用 ios 执行快捷方式的时候无需输入密码即可使用 sudo 指令，如果不这样做大部分的操作可能都无法执行。\n1 2 3 # 下面两种选择一种进入编辑相关配置文件 sudo visudo sudo vim /etc/sudoers 在 %sudo 下面新增一行添加自己的用户名。\n1 {user} ALL=(ALL) NOPASSWD:ALL 参考资料：让Linux用户sudo操作免密码 | Bingo\u0026rsquo;s Blog (bingozb.github.io) ios 使用快捷方式控制树莓派Kodi和浏览器切换 之所以介绍上面那些操作，实际上都是为了实现下面的切换脚本，这里使用快捷方式中的 SSH 来链接并执行 bash 指令，代码片段可以参考如下：\n打开 kodi：\n1 nohup kodi \u0026amp; 切换 Dashboard，主要由以下的几个操作组成：关闭 Kodi，刷新 Xorg 显示界面，启动 Chrome 特定界面：\n1 2 3 4 for pid in $(ps -ef | grep kodi | awk \u0026#39;{print $2}\u0026#39;); do; kill -15 $pid; done; 1 2 3 4 5 #for pid in $( ps -ef | grep \u0026#39;Xorg\u0026#39; |awk \u0026#39;{print $2}\u0026#39;); #do; #sudo kill -15 $pid #done; sudo service lightdm restart; 1 2 3 export DISPLAY=:0.0; sleep 10 nohup chromium-browser --kiosk http://\u0026lt;Domain\u0026gt;:\u0026lt;port\u0026gt; \u0026amp;; 快捷方式使用的方法也很简单，找到 SSH 运行脚本，填入主机端口用户密码，然后将上面的代码片段填入即可，这里建议分成三个脚本来使用会比较清晰一点。\nFI","permalink":"https://hugotest-phi.vercel.app/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%B6%E5%BA%AD%E5%BD%B1%E9%9F%B3%E4%B8%AD%E5%BF%832/","summary":"\u003ch2 id=\"禁止屏幕休眠显示作为-dashboard-显示\"\u003e禁止屏幕休眠显示作为 Dashboard 显示\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e树莓派官方的 Raspbian 系统使用的是 lightdm 桌面显示管理器，可以设置 xservice 桌面交互显示来达到屏幕常亮的目的，也就是修改桌面配置文件 lightdm.Conf\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e参考资料：\u003ca href=\"http://www.raspi.cc/read-10-1.html\" target=\"_blank\" rel=\"noopener\"\u003e树莓派设置禁止让屏幕休眠，显示器保持常亮状态-树莓派基础学习入门-树莓派极客,raspi.cc - Powered by raspi\u003c/a\u003e\n\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo vim /etc/lightdm/lightdm.conf\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e找到 x-server-command 取消注释并在后面加 \u003ccode\u003e-s 0-dpms\u003c/code\u003e，添加完后重启即可。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231111132731.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231111132731.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231111132731.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参数里的：-s 参数：设置屏幕保护不启动，0 数字零，-dpms 参数：关闭电源节能管理。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"树莓派家庭影音中心2"},{"content":"Intro 问题描述 以 emby 为例，学习如何对这种自托管的服务，请求验证网站的软件进行破解，破解的整体思路分为以下的两类：\n一种是改客户端，一种是改服务端。两种方式的最终原理一样，都是搭建仿冒认证服务器，客户端访问伪服务器拿到授权信息；【3】\n因此无论是那种方法我们都需要搭建伪验证服务器：所以以下的操作是必须的：\n抓取定位到验证服务器的地址，并获取验证服务器返回的验证信息格式； 使用 Nginx 搭建虚拟的验证服务器，使其返回激活/验证信息； 如果是修改客户端，则在搭建完验证站后需要：\n修改 Host 文件，将请求验证服务器的请求劫持到本地搭建的服务上； 需要伪服务器和客户端都要安装自签名证书 如果是修改服务端，则后续需要：\n修改服务端源文件，将默认的认证服务器 mb3admin.com 地址直接改成伪服务器 这样就不需要安装自签名证书 如果是使用 Docker 进行部署的 emby 可以使用别人修改好的服务端的镜像进行部署安装（like 开心版）\n本文主要介绍验证服务器的搭建、修改客户端的方法，以及一些其他的注意事项；\nServer 伪验证服务器搭建 CA 证书申请 什么是证书：什么是 SSL 认证？- SSL/TLS 认证简介 - AWS (amazon.com) 这里由于我们并没有真正拥有认证网站 md3admin 的域名故而没有对应的证书文件，因此需要为自己的服务自签发一个假的证书文件，并手动让浏览器信任该证书，保证在将该域名通过 hosts 修改转移到自己的服务上时，浏览器能正常请求该页面。\n下面介绍证书的签发过程（转载自参考文献:【2】)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mkdir -p \u0026lt;username\u0026gt;/\u0026lt;docker-file-path\u0026gt;/nginx/cert/mb3admin.com \u0026amp;\u0026amp; cd \u0026lt;username\u0026gt;/\u0026lt;docker-file-path\u0026gt;/nginx/cert/mb3admin.com # 生成 CA 密钥 openssl genrsa -out ca.key 2048 # 生成 CA 证书 openssl req -x509 -new -nodes -key ca.key -subj \u0026#34;/C=CN/ST=Beijing/L=Beijing/O=\u0026lt;username\u0026gt;/OU=\u0026lt;username\u0026gt;/CN=\u0026lt;username\u0026gt;/emailAddress=\u0026lt;user-email\u0026gt;\u0026#34; -days 36500 -out ca.crt # 将 CA 转换成 p12 格式，并指定密码 （\u0026lt;username\u0026gt;） openssl pkcs12 -export -clcerts -in ./ca.crt -inkey ca.key -out ca.p12 -password pass:\u0026lt;username\u0026gt; # 将 p12 格式的证书 Base64 编码 base64 ca.p12 # Base64 一行不能超过 76 字符，超过则添加回车换行符。如果因为换行的原因，不能安装证书，可以使用 -w 参数 base64 -w 0 ca.p12 # 将 CA 转换成 pem 格式 openssl x509 -outform pem -in ca.crt -out ca.pem # 生成服务端私钥 server.key openssl genrsa -out server.key 2048 # 生成服务端证书请求 server.csr openssl req -new -sha256 -key server.key -out server.csr -subj \u0026#34;/C=CN/L=Beijing/O=\u0026lt;username\u0026gt;/OU=\u0026lt;username\u0026gt;/CN=mb3admin.com/CN=*.mb3admin.com\u0026#34; # 生成服务端证书 server.crt openssl x509 -req -extfile \u0026lt;(printf \u0026#34;subjectAltName=DNS:mb3admin.com,DNS:*.mb3admin.com\u0026#34;) -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt 上述代码中替换一下自己的相关信息即可（也可以直接去参考资源中获取直接执行的代码）：\n\\\u0026lt;username\\\u0026gt; \\\u0026lt;user-email\\\u0026gt; \\\u0026lt;docker-file-path\\\u0026gt; 生成对应证书后，对证书的操作还有以下的两步，我们首先介绍证书安装，在对 Nginx 进行配置。\nNginx 配置：将 server.crt 和 server.key 放到 nginx 存放的地方，方便后面配置 Nginx 证书安装：便于浏览器后续正常访问 证书安装 双击打开证书目录中的 crt 进行证书安装，会显示“无法验证到一个受信任的证书颁发机构”，这是因为我们只是自签发并没有找第三方机构认证，不要紧直接安装即可。\n没有安装证书的情况下也可能会发现验证信息正确但是激活失败的情况\n这里简单介绍以下 ubuntu 信任证书的方法【2】（nas 和 ios 可参考该文）\n1 sudo cp ca.crt /usr/local/share/ca-certificates/zhuangzhuang.crt \u0026amp;\u0026amp; sudo update-ca-certificates Nginx 设置 Nginx 可以直接在 conf.d/default.conf 中新增以下代码片段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 server { listen 443 ssl; listen [::]:443 ssl; server_name mb3admin.com; ssl_certificate /etc/nginx/cert/mb3admin.com/server.crt; ssl_certificate_key /etc/nginx/cert/mb3admin.com/server.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers *; add_header Access-Control-Allow-Method *; add_header Access-Control-Allow-Credentials true; location /admin/service/registration/validateDevice { default_type application/json; return 200 \u0026#39;{\u0026#34;cacheExpirationDays\u0026#34;: 365,\u0026#34;message\u0026#34;: \u0026#34;Device Valid\u0026#34;,\u0026#34;resultCode\u0026#34;: \u0026#34;GOOD\u0026#34;}\u0026#39;; } location /admin/service/registration/validate { default_type application/json; return 200 \u0026#39;{\u0026#34;featId\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;registered\u0026#34;:true,\u0026#34;expDate\u0026#34;:\u0026#34;2099-01-01\u0026#34;,\u0026#34;key\u0026#34;:\u0026#34;\u0026#34;}\u0026#39;; } location /admin/service/registration/getStatus { default_type application/json; return 200 \u0026#39;{\u0026#34;deviceStatus\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;planType\u0026#34;:\u0026#34;Lifetime\u0026#34;,\u0026#34;subscriptions\u0026#34;:{}}\u0026#39;; } location /emby/Plugins/SecurityInfo { default_type application/json; return 200 \u0026#39;{\u0026#34;SupporterKey\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;IsMBSupporter\u0026#34;: true}\u0026#39;; } } 可以看到其中最为关键的是以下的几个点：\n设置好 servername 为验证网址的域名 mb3admin.com; 将以下的域名子路径都设置为返回对应的验证信息 /admin/service/registration/validateDevice /admin/service/registration/validate /admin/service/registration/getStatus /emby/Plugins/SecurityInfo ssl_certificate 和 ssl_certificate_key 填写好对应的证书文件地址存放地址 Hosts 文件修改 linux 修改 host 文件地址：/etc/hosts\n1 sudo echo \u0026#34;\u0026lt;server_ip\u0026gt; \u0026lt;domain_address\u0026gt;\u0026#34; \u0026gt;\u0026gt; /etc/hosts Windows 修改 host 文件地址：C:\\Windows\\System32\\drivers\\etc\\hosts\n1 2 .... \u0026lt;server_ip\u0026gt; \u0026lt;domain_address\u0026gt; 修改完立即刷新 dns 不需重启立即生效的方法,在 powershell 执行：\n1 ipconfig /flushdns Test 服务测试 完成上面的服务和 Host 修改后，可以登录对应的网站进行测试或者使用 curl 进行测试：\n可以通过浏览器访问： https://mb3admin.com/admin/service/registration/validateDevice/ 或者 https://mb3admin.com/admin/service/registration/validate/ 查看返回信息是否正确；\n或者在 powershell 中执行以下命令查看返回信息是否正确，这里需要注意的是可能会与 WSL2 部署的 docker 混淆，但是该指令是否生效我们还是要在宿主机上的 powershell 查看。\n1 curl -ik https://mb3admin.com/admin/service/registration/validateDevice/ -k 参数是为了忽略证书不受信任的 https 访问安全限制导致访问失败的问题。例如如下相关报错\n1 \u0026gt; Curl(60) issuer certificate is invalid 如果使用 curl 能够正常返回，但是网页的返回信息有误，或者无法打开网页，可能就要考虑如下的原因：\n证书信任问题，可能要看是否正确配置和安装相关证书 浏览器缓存问题，可以使用隐私(InPrivate)模式再次访问,或者清楚缓存后再次访问； 代理的问题，具体的配置如下 Clash 代理配置 若是由于设置了代理导致网站测试失败，这种情况下可以关掉代理再做测试，或者新增规则，配置验证网址不走代理。\n配置规则的方法以 Clash 为例如下：\n1 2 3 4 5 parsers: # array - url: \u0026lt;你的订阅地址\u0026gt; yaml: prepend-rules: - DOMAIN-SUFFIX,\u0026lt;直连的域名\u0026gt;,DIRECT 添加 DOMAIN-SUFFIX 设置对应的域名为直链即可；\nActivate 激活 访问 emby 服务页面，在 emby premiere 选单中随便选取密钥存储即可，这里会显示无效的密钥但是不要紧，可以切换主题看看是否已经激活成功。\n或者在控制台界面看是否已经有金标即可：\nIOS 使用小火箭解锁 emby 详细图文请访问参考资料【5】，下面是简单的摘要：\n第一步 default.conf（长按） -\u0026gt; 编辑纯文本，将以下代码贴到底部：\n1 2 3 4 [Script] EmbyPremiere = type=http-response,script-path=https://raw.githubusercontent.com/rartv/SurgeScript/main/EmbyPremiere/EmbyPremiere.js,pattern=^https?:\\/\\/mb3admin.com\\/admin\\/service\\/registration\\/validateDevice,max-size=131072,requires-body=true,timeout=10,enable=true [MITM] hostname = mb3admin.com 第二步 default.conf（右侧的 i 按钮） -\u0026gt; https解密 （界面中应该会有 mb3admin.com 的域名信息）-\u0026gt; 证书-\u0026gt; 生成新的 CA 证书 -\u0026gt; 安装证书 -\u0026gt; 系统中信任证书\n第三步打开 vpn，打开 emby，信任证书选择 ok，激活完成后可以关闭小火箭，后续失效的时候再打开一次即可。\nRef 参考资料 群晖上利用现有nginx搭建emby破解服务 (lengyue524) Nas Emby 伪验证服务站搭建 - ZHUANGZHUANG 学习 Emby 解锁及优化 - Gallen\u0026rsquo;s Blog (hgl2.com) Emby全平台开心版、认证服务器设置方法 | Velaciela iOS利用小火箭解锁Emby | 胡萝虎的博客 (huluohu.com) Fi","permalink":"https://hugotest-phi.vercel.app/posts/emby_localhost_crack_by_nginx/","summary":"\u003ch2 id=\"intro-问题描述\"\u003eIntro 问题描述\u003c/h2\u003e\n\u003cp\u003e以 emby 为例，学习如何对这种自托管的服务，请求验证网站的软件进行破解，破解的整体思路分为以下的两类：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e一种是改客户端，一种是改服务端。两种方式的最终原理一样，都是搭建仿冒认证服务器，客户端访问伪服务器拿到授权信息；【3】\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e因此无论是那种方法我们都需要搭建伪验证服务器：所以以下的操作是必须的：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e抓取定位到验证服务器的地址，并获取验证服务器返回的验证信息格式；\u003c/li\u003e\n\u003cli\u003e使用 Nginx 搭建虚拟的验证服务器，使其返回激活/验证信息；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果是\u003cstrong\u003e修改客户端\u003c/strong\u003e，则在搭建完验证站后需要：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e修改 Host 文件，将请求验证服务器的请求劫持到本地搭建的服务上；\u003c/li\u003e\n\u003cli\u003e需要伪服务器和客户端都要安装自签名证书\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果是\u003cstrong\u003e修改服务端\u003c/strong\u003e，则后续需要：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e修改服务端源文件，将默认的认证服务器 mb3admin.com 地址直接改成伪服务器\u003c/li\u003e\n\u003cli\u003e这样就\u003cstrong\u003e不需要安装自签名证书\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果是使用 Docker 进行部署的 emby 可以使用别人修改好的服务端的镜像进行部署安装（like 开心版）\u003c/p\u003e\n\u003cp\u003e本文主要介绍验证服务器的搭建、修改客户端的方法，以及一些其他的注意事项；\u003c/p\u003e","title":"破解本地自托管Emby服务"},{"content":" 本系列主要介绍通过公网的 ipv6 访问局域网设备并部署自己的服务供公网访问；本篇是其中的第三篇，以 DDNS-go 开源项目为例，部署动态域名解析服务，自动更新主机记录值。\njeessy2/ddns-go: 简单好用的DDNS。自动更新域名解析到公网IP(支持阿里云、腾讯云、Dnspod、Cloudflare、Callback、华为云、百度云、Porkbun、GoDaddy、Google Domain) (github.com) 该工具使用起来非常简单，推荐需要动态域名解析的可以尝试使用该工具，简单介绍工具的使用如下：\n配置 DDNS-GO 前往 release 页面下载对应系统的版本：\n解压后双击打开 ddns-go.exe 会自动弹出配置的界面：locahost:9876,选择需要解析域名的 DNS 服务商，选择创建密钥并填入对应的密钥。\n选择需要启用的 ipv4或者 ipv6解析服务,填写需要解析的域名（每个域名单独另起一行）\n其他的保持默认即可，在这里完成了基础配置以后，记得点击保存，之后便可以安装对应的服务，使其后台自动更新，windows 使用管理员打开 powershell 或者 cmd，到对应目录下执行命令如下\n1 .\\ddns.go.exe -s install -f 10 -cacheTimes 360 通过合理的配置 -f 和 -cacheTimes 可以实现 IP 变化即时触发更新且不会被 DDNS 服务商限流, 例如 -f 10 -cacheTimes 360 效果为每 10 秒检查一次本地 IP 变化, 每小时去公网对比一下 IP 变化\n详细的配置可参考置顶的官网连接。\nFi ","permalink":"https://hugotest-phi.vercel.app/posts/deploy_server_byipv6_03_ddnsgo/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本系列主要介绍通过公网的 ipv6 访问局域网设备并部署自己的服务供公网访问；本篇是其中的第三篇，以 DDNS-go 开源项目为例，部署动态域名解析服务，自动更新主机记录值。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jeessy2/ddns-go\" target=\"_blank\" rel=\"noopener\"\u003ejeessy2/ddns-go: 简单好用的DDNS。自动更新域名解析到公网IP(支持阿里云、腾讯云、Dnspod、Cloudflare、Callback、华为云、百度云、Porkbun、GoDaddy、Google Domain) (github.com)\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e该工具使用起来非常简单，推荐需要动态域名解析的可以尝试使用该工具，简单介绍工具的使用如下：\u003c/p\u003e\n\u003ch2 id=\"配置-ddns-go\"\u003e配置 DDNS-GO\u003c/h2\u003e\n\u003cp\u003e前往 \u003ca href=\"https://github.com/jeessy2/ddns-go/releases/tag/v5.6.6\" target=\"_blank\" rel=\"noopener\"\u003erelease\u003c/a\u003e\n 页面下载对应系统的版本：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231108083156.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231108083156.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231108083156.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e解压后双击打开 ddns-go.exe 会自动弹出配置的界面：locahost:9876,选择需要解析域名的 DNS 服务商，选择创建密钥并填入对应的密钥。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231108083447.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231108083447.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231108083447.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"使用Ipv6部署服务03 DDNS-go 动态域名解析"},{"content":" 本系列主要介绍通过公网的 ipv6 访问局域网设备并部署自己的服务供公网访问；本篇是其中的第二篇，以腾讯云和 Nginx 为例，介绍如何将服务部署到 https://域名 。\n需要以下的事前准备：\n腾讯云/阿里云/Cloudflare 等随便一个地方购买一个自己的域名 公网 ipv4/ipv6 地址 本地部署一个服务以供测试 Nginx(Docker) 安装 这里选择 Docker 来分离安装 Nginx 服务，Docker 部署的优势这里就不再赘述，这里建议使用 portainer 进行容器管理和运行状态查看。\n首先创建存放 Nginx 配置文件和证书文件的目录，后续挂载给 Nginx Contrainer 使用：\n1 2 mkdir -p /home/username/docker-file/nginx/conf.d mkdir -p /home/username/docker-file/nginx/cert 配置文件存放到 conf.d 中，各种 SSL 证书则存放到 cert 文件夹中；\n接着部署 Nginx，这次先不挂载目录，将 Nginx 中一些默认配置拷贝出来，以供后续使用和修改：\n1 2 3 # run会自己执行镜像拉取，pull可以不执行 # docker pull nginx sudo docker run --name nginx -p 80:80 -d nginx 将配置文件复制出来：\n1 2 3 sudo docker cp nginx:/etc/nginx/conf.d/default.conf /home/username/docker-file/nginx/conf.d/default.conf sudo docker cp nginx:/etc/nginx/nginx.conf /home/username/docker-file/nginx/conf.d/nginx.conf sudo docker cp nginx:/etc/nginx/mime.types /home/username/docker-file/nginx/conf.d/mime.types 基于原始的配置文件挂载后查看 nginx 是否正常运行：\n1 2 sudo docker rm -f nginx sudo docker run --name nginx -p 80:80 -p 443:443 -v /home/username/docker-file/nginx/conf.d/nginx.conf:/etc/nginx/nginx.conf -v /home/username/docker-file/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /home/username/docker-file/nginx/conf.d/mime.types:/etc/nginx/mime.types -v /home/username/docker-file/nginx/cert:/etc/nginx/cert -d nginx 参考资料：使用docker部署nginx并配置https - 逊老头 - 博客园 (cnblogs.com) 域名解析及申请免费 SSL 证书 账号应该是有50个 SSL 证书限额，但是注意每个二级域名都需要单独申请 SSL 证书，例如 aiken.Com 和 videos.Aiken.Com 需要分别申请 SSL 证书。\n域名解析 注册完域名后到域名控制台，选择特定的域名进行解析：\n主机记录可以设置 www 等二级域名，@既是基础域名（没有二级域名），IPV6的话设置记录类型为 AAAA，记录值这里填入公网 ipv6 地址（基于安全性考虑 Ipv6 地址大多会动态变化，包括 windows 会提供临时 ipv6 地址等等，后续会使用 DDNS-go 动态更新该地址）\nSSL 证书申请 进入 SSL 证书管理界面 -\u0026gt; 申请免费证书 -\u0026gt; 提交证书申请 -\u0026gt;\n提交证书申请界面按照指引填写即可，域名部分记得二级域名也要单独申请即可。\n验证域名部分按照要求添加解析信息后点击验证域名即可，下载证书文件\n耐心等待证书签发后，在我的证书界面下载证书，并将证书文件（解压后）放到挂载的 nginx 的 cert 目录中\nNginx 配置部署服务 不同服务的 Nginx 配置在细节上会有一些差别，如果基础的设置不对，可以 Google 以下 Server+Nginx 查看是否有相关的文档说明，该部分简单介绍以下基本的一些写法。\n为了最大化的利用域名和单机服务，通常而言我们希望仅仅使用一个域名（包括其二级域名和二级目录）能够分别部署单机上分布于多个端口的多个服务，这里简单分别介绍如何为不同服务部署二级域名和二级目录。\n需要注意的是，不同服务在部署的时候有不同的要求，有些服务涉及到一些 url 的跳转等问题，不支持二级目录的域名反代，会导致功能异常，具体需要参见相关文档，这种时候就推荐使用二级域名进行服务代理。\n同时配置过程中需要注意反斜杠不要缺失，使用正确，不同的反斜杠最终会导致转向地址的不一致，参考：nginx 反向代理斜杠问题_clonetx的博客-CSDN博客 证书配置部分 证书配置部分主要按照签发处的指引，会给一个基础的模板，比如腾讯云：SSL 证书 Nginx 服务器 SSL 证书安装部署-证书安装-文档中心-腾讯云 (tencent.com) 二级地址反代： 在挂载的 conf.d 目录下的 default.conf 中新增 server 如下：\nserver {\rlisten 443 ssl ;\rlisten [::]:443 ssl;\rexpires 12h;\rserver_name metisy.cool;\rssl_certificate /etc/nginx/cert/\u0026lt;your domain\u0026gt;.crt;\rssl_certificate_key /etc/nginx/cert/\u0026lt;your domain\u0026gt;.key;\rssl_session_timeout 5m;\rssl_prefer_server_ciphers on;\r# FIXME: for safe reason disable this ---below---.\rlocation /dashboard/ {\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\rproxy_set_header X-Forwarded-Proto $scheme;\rproxy_set_header Host $http_host;\rproxy_set_header X-Real-IP $remote_addr;\rproxy_set_header Range $http_range;\rproxy_set_header If-Range $http_if_range;\rproxy_redirect off;\rproxy_pass \u0026lt;url_local_server_address\u0026gt;:\u0026lt;port\u0026gt;/;\r# the max size of file to upload\r}\r} 其中\n\u0026lt;url_local_server_address\u0026gt;填写本地的局域网 ip 例如192.168.11.23 port 则填写该 ip 对应设备上提供服务的端口，例如1234 ssl_certificate 和 ssl_certificate_key 填写 ssl 证书对应的 crt 和 key 文件的路径 二级域名反代 在挂载的 conf.D 目录下的 default.Conf 中新增 server 如下：\nserver {\rlisten 443 ssl ; listen [::]:443 ssl;\rserver_name {prefix_your domain}; client_max_body_size 50000M;\rssl_certificate /etc/nginx/cert/{prefix_your domain}.crt; ssl_certificate_key /etc/nginx/cert/{prefix_your domain}.key; ssl_session_timeout 5m;\rssl_prefer_server_ciphers on;\rlocation / {\rproxy_set_header Host $host;\rproxy_set_header X-Real-IP $remote_addr;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\rproxy_set_header X-Forwarded-Proto $scheme;\rproxy_set_header X-Forwarded-Protocol $scheme;\rproxy_set_header X-Forwarded-Host $http_host;\rproxy_buffering off;\rproxy_pass \u0026lt;url_local_server_address\u0026gt;:\u0026lt;port\u0026gt;/;\r#root /usr/share/nginx/html;\r#index index.html index.htm;\r}\r} 因为二级域名可以相当于一个新的域名，所以只需要把证书和 server_name 修改为新域名即可\nHttp 跳转Https 在挂载的 conf.D 目录下的 default.Conf 中修改最上面的 server 为如下：\nserver {\rlisten 80 default_server;\rlisten [::]:80 default_server;\rserver_name _;\r# rewrite ^(.*)$ https://metisy.cool:443/$1 permanent;\rreturn 301 https://$host$request_uri;\r#access_log /var/log/nginx/host.access.log main;\r# location / {\r# root /usr/share/nginx/html;\r# index index.html index.htm;\r# }\r#error_page 404 /404.html;\r# redirect server error pages to the static page /50x.html\r#\rerror_page 500 502 503 504 /50x.html;\rlocation = /50x.html {\rroot /usr/share/nginx/html;\r}\r} 使用 return(新) 或者 rewrite(旧) 命令，将针对该域名的 http 请求都重定向到 https 中。\nAlist 的反向代理 Alist 的反向代理参考如下文章：反向代理 | AList文档 (nn.ci) ，如果不修改配置的话需要将其挂载在/根路径下，否则会导致出错，二级路径会导致无法正常运行，如果要挂载到子级目录/alist/下需要按照该文修改配置文件：怎么做 | AList文档 (nn.ci) 此外，挂载完成后会发现由于 Nginx 缓存，会导致卡在登录界面无法进到主页面的问题，该问题可以通过在配置中取消缓存修复，修改 nginx 配置，添加该行：\nImmich 的反向代理 为了安全性和诸多其他考虑，不支持二级目录，建议使用二级域名挂载到根目录，具体的配置参考：\nReverse Proxy | Immich xiaoya Alist 的反向代理 这里提一嘴，xiaoya 的 alist 的挂载目前也仅支持挂载到根路径，因此使用一个二级域名，个人暂时没找到如何挂载到子路径下，欢迎指正，万分感谢。\n而如果是 xiaoya 的 emby 的反向代理，则需要手动重新映射一下 strm 资源库目录下的播放直链，将其改为挂载小雅的公网地址，可以使用以下脚本批量修改：\n1 find /home/user-dockerfile-dir/emby_res/xiaoya -name \u0026#34;*.strm\u0026#34; -exec sed \\-i \u0026#34;s#http://{locahost}:{port}#https://{domain}/#g; s# #%20#g; s#|#%7C#g\u0026#34; {} \\; 这里的{localhost} {port} {domain}请自行修改成自己的对应地址，这样挂载出来的 emby 就可以在公网进行播放了。\n重启 Nginx 完成上述所有对应的配置后，启动 Nginx，即可实现 https 访问对应的网站了。\n1 2 3 # 可以删除当前contrainer重新部署 docker rm -f nginx sudo docker run --name nginx -p 80:80 -p 443:443 -v /home/username/docker-file/nginx/conf.d/nginx.conf:/etc/nginx/nginx.conf -v /home/username/docker-file/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /home/username/docker-file/nginx/conf.d/mime.types:/etc/nginx/mime.types -v /home/username/docker-file/nginx/cert:/etc/nginx/cert -d nginx 但是实际没必要那么麻烦，直接执行：\n1 docker restart nginx 即可，观察容器是否正常运行，如果运行失败查看 log 看是否哪里配置出错。\n参考资料：\nNginx通过二级目录（路径）映射不同的反向代理，规避IP+端口访问 | 张戈博客 (zhang.ge) Docker Nginx 配置安装 SSL 证书（支持 Https 访问） - 犬小哈教程 (quanxiaoha.com) 基于网盘挂载的emby服务端并实现直链播放 - syqman折腾笔记 基于小雅的方式的话无需参考该文，仅需将 address 文档替换成公网连接即可。 小雅Emby反代 nginx反向代理关闭缓存 (baidu.com) Reverse proxy using NGINX - Community Guides - Home Assistant Community (home-assistant.io) Fi 本章就到这边，下一章节讲解由于 Ipv6 的动态特性，需要部署动态域名解析服务，这里以 ddns-go 为例，自动更新对应域名解析中的主机记录值。\n","permalink":"https://hugotest-phi.vercel.app/posts/deploy_server_byipv6_02_nginx/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本系列主要介绍通过公网的 ipv6 访问局域网设备并部署自己的服务供公网访问；本篇是其中的第二篇，以腾讯云和 Nginx 为例，介绍如何将服务部署到 https://域名 。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e需要以下的事前准备：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e腾讯云/阿里云/Cloudflare 等随便一个地方购买一个自己的域名\u003c/li\u003e\n\u003cli\u003e公网 ipv4/ipv6 地址\u003c/li\u003e\n\u003cli\u003e本地部署一个服务以供测试\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"nginxdocker-安装\"\u003eNginx(Docker) 安装\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这里选择 Docker 来分离安装 Nginx 服务，Docker 部署的优势这里就不再赘述，这里建议使用 portainer 进行容器管理和运行状态查看。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e首先创建存放 Nginx 配置文件和证书文件的目录，后续挂载给 Nginx Contrainer 使用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir -p /home/username/docker-file/nginx/conf.d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir -p /home/username/docker-file/nginx/cert\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e配置文件存放到 \u003ccode\u003econf.d\u003c/code\u003e 中，\u003cstrong\u003e各种 SSL 证书则存放到\u003c/strong\u003e \u003ccode\u003ecert\u003c/code\u003e 文件夹中；\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e接着部署 Nginx，这次先不挂载目录，将 Nginx 中一些默认配置拷贝出来，以供后续使用和修改：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# run会自己执行镜像拉取，pull可以不执行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# docker pull nginx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo docker run --name nginx -p 80:80 -d nginx \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e将配置文件复制出来：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo docker cp nginx:/etc/nginx/conf.d/default.conf /home/username/docker-file/nginx/conf.d/default.conf\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo docker cp nginx:/etc/nginx/nginx.conf /home/username/docker-file/nginx/conf.d/nginx.conf\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo docker cp nginx:/etc/nginx/mime.types /home/username/docker-file/nginx/conf.d/mime.types\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e基于原始的配置文件挂载后查看 nginx 是否正常运行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo docker rm -f nginx\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo docker run --name nginx -p 80:80 -p 443:443 -v /home/username/docker-file/nginx/conf.d/nginx.conf:/etc/nginx/nginx.conf -v /home/username/docker-file/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /home/username/docker-file/nginx/conf.d/mime.types:/etc/nginx/mime.types -v /home/username/docker-file/nginx/cert:/etc/nginx/cert -d nginx\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e参考资料：\u003ca href=\"https://www.cnblogs.com/Aamir-Ye/p/16823739.html\" target=\"_blank\" rel=\"noopener\"\u003e使用docker部署nginx并配置https - 逊老头 - 博客园 (cnblogs.com)\u003c/a\u003e\n\u003c/p\u003e","title":"使用Ipv6部署服务02 Nginx和Https"},{"content":"Windows11基于 WSL2启动 docker 后报错如下（需要注意有时候使用启动命令会报错，但是 restart 命令 docker 可以运行，对应服务无法访问）\nBind: An attempt was made to access a socket in a way forbidden by its access permissions.\n观察错误发现占用的信息为2345，从 windows 和 wsl 中分别查看端口是否被占用：\n1 netstat -aon|findstr \u0026#34;2345\u0026#34; 1 netstat -tunlp | grep 2345 均显示没有被占用，这可能是由于协议 tcp 使用的动态端口问题导致，可以使用管理员权限在 powershell 或者 cmd 中执行下列命令查看端口是否在动态范围中：\n动态范围可能是由于 hyper-v 的原因修改过起始端口，所以可能会发现关闭 hyper-v 后没有占用的情况的现\n1 netsh int ipv4 show dynamicport tcp 如在，修改动态范围，之后使用的时候避开这些端口即可。\n1 netsh int ipv4 set dynamicport tcp start=49152 num=16384 重启电脑即可生效。\n","permalink":"https://hugotest-phi.vercel.app/posts/windows%E7%AB%AF%E5%8F%A3%E5%BC%82%E5%B8%B8%E5%8D%A0%E7%94%A8/","summary":"\u003cp\u003eWindows11基于 WSL2启动 docker 后报错如下（需要注意有时候使用启动命令会报错，但是 restart 命令 docker 可以运行，对应服务无法访问）\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eBind: An attempt was made to access a socket in a way forbidden by its access permissions.\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e观察错误发现占用的信息为2345，从 windows 和 wsl 中分别查看端口是否被占用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003enetstat\u003c/span\u003e \u003cspan class=\"n\"\u003e-aon\u003c/span\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e\u003cspan class=\"n\"\u003efindstr\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;2345\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetstat -tunlp \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep \u003cspan class=\"m\"\u003e2345\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e均显示没有被占用，这可能是由于协议 tcp 使用的动态端口问题导致，可以使用管理员权限在 powershell 或者 cmd 中执行下列命令查看端口是否在动态范围中：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e动态范围可能是由于 hyper-v 的原因修改过起始端口，所以可能会发现关闭 hyper-v 后没有占用的情况的现\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003enetsh\u003c/span\u003e \u003cspan class=\"n\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eipv4\u003c/span\u003e \u003cspan class=\"n\"\u003eshow\u003c/span\u003e \u003cspan class=\"n\"\u003edynamicport\u003c/span\u003e \u003cspan class=\"n\"\u003etcp\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如在，修改动态范围，之后使用的时候避开这些端口即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003enetsh\u003c/span\u003e \u003cspan class=\"n\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eipv4\u003c/span\u003e \u003cspan class=\"nb\"\u003eset \u003c/span\u003e\u003cspan class=\"n\"\u003edynamicport\u003c/span\u003e \u003cspan class=\"n\"\u003etcp\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e=\u003c/span\u003e\u003cspan class=\"mf\"\u003e49152\u003c/span\u003e \u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e=\u003c/span\u003e\u003cspan class=\"mf\"\u003e16384\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e重启电脑即可生效。\u003c/p\u003e","title":"Windows端口异常占用"},{"content":" 本系列主要介绍通过公网的 ipv6 访问局域网设备并部署自己的服务供公网访问；本篇是其中的第一篇，以电信宽带为例，说明如何开启 ipv6 服务和外网访问放行。\n开启 IPV6 服务主要需要修改两个地方的配置：**光猫开启桥接模式和 IPV6 **、路由器修改为 pppoe 拨号模式以及防火墙设置；这里以本人的电信光猫和小米路由器为例：\n背景介绍 需要在外网访问部署于家庭内网的一些服务，考虑了以下的几个方案，决定使用 ipv6作为核心\n类型 方案 简要说明 内网穿透 Zerotier 免费，需要注册账户，支持移动端，国内速度极慢，且不稳定 内网穿透 Tailscale（备用） 免费，需要注册账号，支持移动端，国内速度一版，稳定性相 Zetotier 较好，但仍不够稳定 内网穿透 frp 申请一个有公网的服务器，使用 frp 自己作为内网穿透的中转，贵，较为麻烦 公网 IP Ipv4 难以申请，其他都好 公网 IP Ipv6（主力） 获取简单，需要配置一下光猫使用，一劳永逸，快，稳定，多，有暴露公网的危险，需要设置防火墙 其他 Cloudflare Zerotrust 简单，免费，可以绑定域名，但是网站根本登不进去配置页面，速度不快 光猫设置 查看光猫背面的管理员 url，进入光猫管理界面，登录超级管理员账户（非普通账户，会跳转到更详细的管理页面，大部分同地区的超级管理员账户应该是一致的，不对可以询问下宽带师傅）\n管理地址通常为：192.168.1.1 超级管理员账号：useradmin 超级管理员密码：nE7jA%5 开始之前准备 PPPoe 拨号的帐号和密码，不知道的话等询问好了再开始操作。\n在天翼网关-\u0026gt;网络-\u0026gt;网络设置中进行如下的操作：（这里可以尝试改成 pppoe 并通过开发者模式查看密码，不知道密码不要轻易进行后续操作）\n连接名称选择 +++INTERENT_R_VID_41 连接模式从路由改为桥接 IP 模式确认为 IPv4\u0026amp;IPv6 点击保存/应用 在天翼网关-\u0026gt;状态-\u0026gt;网络侧信息中检查 IPv4 和 IPv6 是否都开启成功：\n参考资料：个人宽带如何开启IPv6网络访问 路由器设置 进入小米路由器管理页面：192.168.31.1，选择上网设置并拉到上网设置部分\n将上网方式改成 PPPoE 并设置宽带账号和密码，在路由器进行拨号，其他保持默认即可。\n拉到最下面 IPv6 网络设置 ，将上网方式改为 Native ，自动配置 DNS，上网方式改为 Native，防火墙可以先关掉，测试一下连接后再打开，等完全配置好再最终关掉。\n由于大部分路由器都没有针对 ipv6 的防火墙规则设置，只有单纯的开或者关，所以我们再设置好 windows 防火墙和 https 后再打开。\n这里 DNS 也可以选择手动设置为 ipv6 的 DNS，但我们只是为了公网访问本机的服务就不设置了\n配置好之后应该会显示当前的 IPv6 网络信息：\n可以用以下的几种方式验证是否真正开启成功：\nIPv6 测试 网站 Windows PowerShell 使用 ipconfig/all 查看 IPv6 信息，应该有以下的3条信息； Linux/Raspberry Pi 使用 hostname -I 查看 ip 地址； 获取完 ipv6 地址后可以通过移动数据访问对应端口的服务来确认是否打开了公网访问。 防火墙设置 Windows 防火墙设置 参考官方文档对防火墙的设置：启用具有高级安全性的Windows Defender防火墙并配置默认行为 - Windows Security | Microsoft Learn ，并检查自己的防火墙设置：\n可以发现防火墙默认是阻止未设定的规则实现入站的，可以通过检查入站规则再关闭一些不安全的外网访问端口，\n通过 netstat -an | findstr \u0026quot;LISTENING\u0026quot; 检查正在监听的窗口，并使用 telnet 检查是否开放端口开放（或者参见下列文章中提到的测试网址，最好是关闭了再去尝试）\n禁止 ipv6 指定端口入站，如 135，3389，445，以及 446-65536 可以参考下列文章进行设置，其中 2000::/3 可以代表所有的公网 ipv6 地址；\n可以按照该文章，额外设置防火墙关闭3389端口 「特别篇」在关闭光猫、路由器IPv6防火墙后可能遇到的安全问题 ； Linux 防火墙设置 参考资料： How To Set Up a Firewall with UFW on Ubuntu 22.04 | DigitalOcean 使用 UFW 设置 linux 的防火墙，默认关闭外网访问，简单摘要以下需要执行的指令如下：\n1 2 3 sudo apt-get install ufw sudo vim /etc/default/ufw # 将其中的IPV6也设置为yes 开始配置 ufw，设置为默认禁止入站允许出站：\n1 2 sudo ufw default deny incoming sudo ufw default allow outcoming 设置允许 SSH 连接和指定端口的出站，阻止 http 连接并启用 ufw：\n1 2 3 4 5 sudo ufw allow ssh sudo ufw allow {port} sudo ufw deny http sudo ufw enable #sudo ufw disable #为关闭服务 检查相关设置并删除错误的规则配置\n1 2 3 sudo ufw status verbose # 查看设置，是否activate sudo ufw status numbered # 查看对应规则的idx，后续关闭该规则时候需要 sudo ufw delete {idx} # 删除对应的规则 允许局域网网段访问\n1 2 sudo ufw allow from 192.168.1.0/24 to any port 【port】 # sudo ufw allow from 192.168.1.0/24 to any port 【port】proto tcp 这里注意一下 kodi 可能需要8080，9090，9777这三个端口来支持遥控器的正常连接。\nHTTPS 设置 关注下后续设置服务部署的部分，会介绍通过 Nginx 和腾讯云部署 HTTPs.\nTroubleshooting 路由器改桥接后访问光猫管理页面 \u0026ldquo;光猫使用 Route 模式时，通过光猫的 DHCP 给下游设备地址（192.168.1.*），此时可以从下游终端访问到管理页面，而改为桥接模式时，则使用路由器的 DHCP 进行地址赋予(192.168.31.*), 无法访问光猫管理地址\u0026rdquo;\n网线连接光猫 将 ip 手动设置到光猫同一网段:192.168.1.Xx | 子网掩码 255.255.255.0 访问 192.168.1.1 使用完记得将 ip 修改回自动获取模式\n","permalink":"https://hugotest-phi.vercel.app/posts/deploy_server_byipv6/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本系列主要介绍通过公网的 ipv6 访问局域网设备并部署自己的服务供公网访问；本篇是其中的第一篇，以电信宽带为例，说明如何开启 ipv6 服务和外网访问放行。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e开启 IPV6 服务主要需要修改两个地方的配置：**光猫开启桥接模式和 IPV6 **、\u003cstrong\u003e路由器修改为 pppoe 拨号模式以及防火墙设置\u003c/strong\u003e；这里以本人的电信光猫和小米路由器为例：\u003c/p\u003e\n\u003ch2 id=\"背景介绍\"\u003e背景介绍\u003c/h2\u003e\n\u003cp\u003e需要在外网访问部署于家庭内网的一些服务，考虑了以下的几个方案，决定使用 ipv6作为核心\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e类型\u003c/th\u003e\n          \u003cth\u003e方案\u003c/th\u003e\n          \u003cth\u003e简要说明\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e内网穿透\u003c/td\u003e\n          \u003ctd\u003eZerotier\u003c/td\u003e\n          \u003ctd\u003e免费，需要注册账户，支持移动端，国内速度极慢，且不稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e内网穿透\u003c/td\u003e\n          \u003ctd\u003eTailscale（备用）\u003c/td\u003e\n          \u003ctd\u003e免费，需要注册账号，支持移动端，国内速度一版，稳定性相 Zetotier 较好，但仍不够稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e内网穿透\u003c/td\u003e\n          \u003ctd\u003efrp\u003c/td\u003e\n          \u003ctd\u003e申请一个有公网的服务器，使用 frp 自己作为内网穿透的中转，贵，较为麻烦\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e公网 IP\u003c/td\u003e\n          \u003ctd\u003eIpv4\u003c/td\u003e\n          \u003ctd\u003e难以申请，其他都好\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e公网 IP\u003c/td\u003e\n          \u003ctd\u003eIpv6（主力）\u003c/td\u003e\n          \u003ctd\u003e获取简单，需要配置一下光猫使用，一劳永逸，快，稳定，多，有暴露公网的危险，需要设置防火墙\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e其他\u003c/td\u003e\n          \u003ctd\u003eCloudflare Zerotrust\u003c/td\u003e\n          \u003ctd\u003e简单，免费，可以绑定域名，但是网站根本登不进去配置页面，速度不快\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"光猫设置\"\u003e光猫设置\u003c/h2\u003e\n\u003cp\u003e查看光猫背面的管理员 url，进入光猫管理界面，登录\u003cstrong\u003e超级管理员账户\u003c/strong\u003e（非普通账户，会跳转到更详细的管理页面，大部分同地区的超级管理员账户应该是一致的，不对可以询问下宽带师傅）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e管理地址通常为：192.168.1.1\u003c/li\u003e\n\u003cli\u003e超级管理员账号：useradmin\u003c/li\u003e\n\u003cli\u003e超级管理员密码：nE7jA%5\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e开始之前准备 PPPoe 拨号的帐号和密码，不知道的话等询问好了再开始操作。\u003c/p\u003e\n\u003cp\u003e在天翼网关-\u0026gt;网络-\u0026gt;网络设置中进行如下的操作：（这里可以尝试改成 pppoe 并通过开发者模式查看密码，不知道密码不要轻易进行后续操作）\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e连接名称选择 \u003ccode\u003e+++INTERENT_R_VID_41\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e连接模式从路由改为桥接\u003c/li\u003e\n\u003cli\u003eIP 模式确认为 \u003ccode\u003eIPv4\u0026amp;IPv6\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e点击保存/应用\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231105215512.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231105215512.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231105215512.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e在天翼网关-\u0026gt;状态-\u0026gt;网络侧信息中检查 IPv4 和 IPv6 是否都开启成功：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231105215637.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231105215637.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231105215637.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://cloud.tencent.com/developer/article/1894991\" target=\"_blank\" rel=\"noopener\"\u003e个人宽带如何开启IPv6网络访问\u003c/a\u003e\n\u003c/p\u003e","title":"使用Ipv6部署服务01 IPV6开启和设置"},{"content":"该文作为基础的闪念卡片的使用说明，介绍几种闪念卡片定义的方式，便于后续查阅，参考：\nObsidian: Spaced Repetition插件使用指南 Index - Obsidian Spaced Repetition 基本规则 单个确定为 Flashcards 的笔记文件中可以存放多个闪念卡片。 会根据记忆程度来设立需要复习的时间 卡片分组 在 Tab 中使用 / 可以引出卡片界面的层级，只需要在设置里设定最高层的分组，后续的分组用 / 引出即可。\n使用以下的标签就能实现上述的分组结果：#vocabulary/day00；需要注意到的是只有至少一个问答时才会显示在对应的表中。\n卡片制作 在使用标签确定为 FlashCard 的页面可以使用如下的格式来定义一个一个的问答卡片，基础问答卡片的制作以如下的格式确认：\n1 Question :: Answer. \u003c!DOCTYPE html\u003e\r单行翻转卡片 进行问答的翻转，会将一张卡变为两张，正反各问一遍，互为答案与问题；\n1 Question ::: Answer 效果与单卡相似，只是多了一张卡，这里不再展示。\n多行问答 ? 分割问题和回答，此时的问题和回答都可以使用多行文本，便于编写复杂文本的问题。 类似的文本翻转可以使用 ?? 实现多行文本翻转 1 2 3 4 5 Multi Line Question1 Question2 ?? Answer1 Answer2 完形填空 使用 == 连等号==框起来的文本==将会被自动识别为完形填空, 例如以下情况：\n1 Using ==Obsidian== plugin to achieve ==flashcard== function 会分别识别成两个卡片，将 Obsidian 和 Flashcard 作为完形填空的问题，效果如下所示：\nFI","permalink":"https://hugotest-phi.vercel.app/posts/flashcard_template/","summary":"\u003cp\u003e该文作为基础的闪念卡片的使用说明，介绍几种闪念卡片定义的方式，便于后续查阅，参考：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/558326315\" target=\"_blank\" rel=\"noopener\"\u003eObsidian: Spaced Repetition插件使用指南 \u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.stephenmwangi.com/obsidian-spaced-repetition/\" target=\"_blank\" rel=\"noopener\"\u003eIndex - Obsidian Spaced Repetition\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"基本规则\"\u003e基本规则\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e单个确定为 Flashcards 的笔记文件中可以存放多个闪念卡片。\u003c/li\u003e\n\u003cli\u003e会根据记忆程度来设立需要复习的时间\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"卡片分组\"\u003e卡片分组\u003c/h2\u003e\n\u003cp\u003e在 Tab 中使用 \u003ccode\u003e/\u003c/code\u003e 可以引出卡片界面的层级，只需要在设置里设定最高层的分组，后续的分组用 \u003ccode\u003e/\u003c/code\u003e 引出即可。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231027212958.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231027212958.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231027212958.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e使用以下的标签就能实现上述的分组结果：\u003ccode\u003e#vocabulary/day00\u003c/code\u003e；需要注意到的是只有至少一个问答时才会显示在对应的表中。\u003c/p\u003e","title":"Obsidian使用 Spaced Repetition 制作闪念卡片"},{"content":"本篇简单介绍一些 VsCode 进行文本替换和查找的一些特殊的正则，该文会随着自己的使用来逐步记录，目前主要内容如下：\n捕获组合及其替换模式 这里不会介绍正则表达式的语法，对其基本语法感兴趣可以查看如下链接 VsCode使用正则表达式 ，以及我之前写过的基础的正则表达式 一文，下面进入正题；\nIntro 正则搜索 正则表达式主要思路为模式匹配，通过符号表达来指定一种模式，识别所有符合该模式的字符组合，而非某些特定的文字，因此可以简化我们的搜索和替换过程，下面以一个例子说明。\n例如有一个文件配置如下，而我们希望找到其中所有 user_config ，查看每个 user 的设置是否正确，由于 username 的长度和内容都不是一样的，所以这里需要使用正则来进行搜索：\n1 2 3 4 5 zxc1_config=123 some content we dont need asd2_config=234 and some other infomation or comment qwer3_config=345 对应该场景的正则表达则为 +*_config= 或者 [a-z, 0-9]*_config= 等写法均可，效果如下：\n可以看到我们需要的内容都被高亮了，这也就方便了我们进行一些复杂的文字处理，而搜索，也就是正则最基本也是最正统的用法，这里不再多说。\nCatch 捕获组合与正则替换 这里主要要介绍的是在替换中使用正则。同时实现样式的保留和替代，可以看以下的例子：\n1 2 3 4 5 6 7 8 aiken_config_file_path_1=res/user/aikenhong/code_config_2m.txt aiken_config_file_path_2=res/user/aikenhong/code_config_4m.txt aiken_config_file_path_33=res/user/kiean/config_special.txt ... kiean_config_file_path_1=res/user/aikenhong/code_config_2m.txt some other content and comment here. ... 可以看到该文件定义了不同用户的不同编号的配置文件的地址，假如由于测试的原因，需要将 aiken_的所有配置文件都暂时以一个新的 res/user/aikenhong/tmp.txt 替代，分析可知此时为了不影响 kiean 等其他人的配置受到影响\n我们需要识别出 aiken_config_file 中的 aiken 需要保留 aiken_config_file_{n} 中的序号 n 这里使用普通正则会遇到的问题就是：如何保留匹配到的序号这个样式，并在替换的时候调用它？在 VsCode 中，可以在搜索使用 () 保留样式，并在替换时使用 $n 来调用指定 idx 的样式，n 从1开始。\n所以上述问题使用的搜索和替换表达式分别为:\naiken_config_file_path_([0-9]+)=.*txt ``aiken_config_file_path_$1=res/user/aikenhong/tmp.txt` 替换前搜索的效果如下：\n替换后的效果如下：\n其中+表示匹配1次或以上，保证 idx 为多位的情况不被遗漏，[0-9] 匹配数字，当然也可以加入对字母的匹配，()获取并保留当前匹配到的样式，并在替换过程中使用$1进行调用。\n总结很简单如下，实际难点仅在熟悉正则表达式的使用\n搜索使用 () 保留样式 并在替换时使用 $n 来调用指定 idx 的样式 n 从1开始 Fi","permalink":"https://hugotest-phi.vercel.app/posts/vsocde_regexp/","summary":"\u003cp\u003e本篇简单介绍一些 VsCode 进行文本替换和查找的一些特殊的正则，该文会随着自己的使用来逐步记录，目前主要内容如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e捕获组合及其替换模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里不会介绍正则表达式的语法，对其基本语法感兴趣可以查看如下链接 \u003ca href=\"https://learn.microsoft.com/zh-cn/visualstudio/ide/using-regular-expressions-in-visual-studio?view=vs-2022\" target=\"_blank\" rel=\"noopener\"\u003eVsCode使用正则表达式\u003c/a\u003e\n，以及我之前写过的\u003ca href=\"https://aikenh.cn/cn/Linux%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8B%E6%AD%A3%E5%88%99/\" target=\"_blank\" rel=\"noopener\"\u003e基础的正则表达式\u003c/a\u003e\n 一文，下面进入正题；\u003c/p\u003e\n\u003ch2 id=\"intro-正则搜索\"\u003eIntro 正则搜索\u003c/h2\u003e\n\u003cp\u003e正则表达式主要思路为\u003cstrong\u003e模式匹配\u003c/strong\u003e，通过符号表达来指定一种模式，识别所有符合该模式的字符组合，而非某些\u003cstrong\u003e特定的文字\u003c/strong\u003e，因此可以简化我们的搜索和替换过程，下面以一个例子说明。\u003c/p\u003e\n\u003cp\u003e例如有一个文件配置如下，而我们希望找到其中所有 \u003ccode\u003euser_config\u003c/code\u003e ，查看每个 user 的设置是否正确，由于 username 的长度和内容都不是一样的，所以这里需要使用正则来进行搜索：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-txt\" data-lang=\"txt\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ezxc1_config=123\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esome content we dont need\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003easd2_config=234\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eand some other infomation or comment\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eqwer3_config=345\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e对应该场景的正则表达则为 \u003ccode\u003e+*_config=\u003c/code\u003e 或者 \u003ccode\u003e[a-z, 0-9]*_config=\u003c/code\u003e 等写法均可，效果如下：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231019173213.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231019173213.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20231019173213.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e可以看到我们需要的内容都被高亮了，这也就方便了我们进行一些复杂的文字处理，而搜索，也就是正则最基本也是最正统的用法，这里不再多说。\u003c/p\u003e","title":"VsCode's RegExp Catch 正则捕获"},{"content":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\rGo语言结构 Go语言的基础组成有以下几个部分：\n包声明 引入包 函数 变量 语句\u0026amp;表达式 注释 GOPATH GOPATH是Go语言中使用的一个环境变量，使用绝对路径提供项目的工作目录。在 GOPATH 指定的工作目录下，代码总是会保存在 $GOPATH/src 目录下。在工程经过 go build、go install 或 go get 等指令后，会将产生的二进制可执行文件放在 $ GOPATH/bin 目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。\n设置和使用GOPATH\n将当前目录设置为GOPATH 1 export GOPATH=`pwd` 建立GOPATH中的源码目录 1 mkdir -p src/hello 添加源码文件\n将main.go源码保存到$GOPATH/src/hello目录下\n1 2 3 4 5 package main import \u0026#34;fmt\u0026#34; func main(){ fmt.Println(\u0026#34;hello\u0026#34;) } 编译源码并运行\n在命令行中执行如下指令编译源码：\n1 go install hello 编译完成后的可执行文件会保存在$GOPATH/bin目录下，在bin目录下执行./hello，命令行输出hello world\n包声明 Go语言使用包来组织源代码，并实现命名空间的管理，任何一个go语言程序必须属于一个包，即每个go程序的开头要写上package \u0026lt;pkg_name\u0026gt;\nGo语言包一般要满足如下三个条件：\n同一个目录下的同级的所有的go文件应该属于一个包； 包的名称可以跟目录不同名，不过建议同名 一个go语言程序有且只有一个main函数，他是go语言程序的入口函数，且必须属于main包，没有或者多于一个main函数进行go语言编译时都会报错。 包引用 引用路径 建议采用全路径引用，比如项目对应的GOPATH的目录如下：\n$GOPATH/src\r|-- hello\r|-- app\r| |-- test_struct.go\r|-- main\r|-- main.go 比如在main.go中要调用包app的函数，需要在main.go程序写上 import hello/app\n引用格式： 标准引用 import \u0026quot;fmt\u0026quot;\n设置别名引用 import format_go \u0026quot;fmt\u0026quot;\n省略方式的引用 import . \u0026quot;fmt\u0026quot;，相当于直接把包fmt的命名空间合并到当前程序的命名空间了，因此可以直接引用，不用再加上前缀fmt.\n仅执行包的初始化函数 import _ \u0026quot;fmt\u0026quot;，比如一些数据库方面的包，主要是为了使用包的init函数，只使用_操作是无法通过包名来调用包中的导出函数。\n单行导入\n1 2 import \u0026#34;package1\u0026#34; import \u0026#34;package2\u0026#34; 多行导入\n1 2 3 4 import ( \u0026#34;package1\u0026#34; \u0026#34;package2\u0026#34; ) 引用注意 导入包时按包的唯一路径导入，导入的包默认是必须要使用的，如果不适用则编译失败，需要移除，减少不必要代码的引入。\n常用标准库 fmt\nfmt包实现了类似C语言printf和scanf的格式化I/O，主要分为向外输出内容和获取输入内容两大部分。\nPrint Print直接输出内容，Printf支持格式化输出字符串，PrintIn会在输出内容的结尾添加一个换行符\n1 2 3 4 5 6 7 8 9 10 func main() { fmt.Print(\u0026#34;在终端打印该信息。\u0026#34;) name := \u0026#34;枯藤\u0026#34; fmt.Printf(\u0026#34;我是：%s\\n\u0026#34;, name) fmt.Println(\u0026#34;在终端打印单独一行显示\u0026#34;) } --------------------------输出内容如下： 在终端打印该信息。我是：枯藤 在终端打印单独一行显示 Fprint Fprint系列函数会将内容输出到一个io.Writer接口类型的变量w中，我们通常用这个函数往文件中写入内容。\n1 2 3 4 5 6 7 8 9 fmt.Fprintln(os.Stdout, \u0026#34;向标准输出写入内容\u0026#34;) fileObj, err := os.OpenFile(\u0026#34;./xx.txt\u0026#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\u0026#34;打开文件出错，err:\u0026#34;, err) return } name := \u0026#34;枯藤\u0026#34; // 向打开的文件句柄中写入内容 fmt.Fprintf(fileObj, \u0026#34;往文件中写如信息：%s\u0026#34;, name) 运行后xxx.txt中内容为\n往文件中写如信息：枯藤\nSprint Sprint系列函数会把传入的数据生成并返回一个字符串\nErrorf Errorf函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。 可以通过这种方式来自定义错误类型，例如err := fmt.Errorf(\u0026quot;这是一个错误)\nScan Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。\nScanf Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分割的值保存到传递给本函数的参数中，返回成功扫描的数据个数和遇到的任何问题。 Scanf(format sting, a ...interface{})(n int, err error) fmt.Scanf不同于fmt.Scan简单的以空格作为输入数据的分隔符，fmt.Scanf为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。\n```go\rfunc main() {\rvar (\rname string\rage int\rmarried bool\r)\rfmt.Scanf(\u0026quot;1:%s 2:%d 3:%t\u0026quot;, \u0026amp;name, \u0026amp;age, \u0026amp;married)\rfmt.Printf(\u0026quot;扫描结果 name:%s age:%d married:%t \\n\u0026quot;, name, age, married)\r}\r``` 此例中输入格式只能为1:... 2:... 3:...，如果格式不正确，scanf就无法扫描到正确的数据\nScanln\n类似Scan，遇到换行时才停止扫描，即最后一个数据后面必须有换行或者到达结束位置。\nTime\n时间和日期，详细用法略\nFlag\n命令行参数解析，详细用法略\nLog\n日志服务，详细用法略\nos\nIO操作，文件操作相关\nStrconv\n基本数据类型与其字符串表示的转换，详细用法略\nHttp\n提供了Http客户端和服务段的实现，客户端方面包含基本的HTTP/HTTPS请求GET、HEAD、POST、POSTFORM函数，\n注释 单行注释，以//开头 块注释，以/*开头，以*/结尾 变量 变量声明\n指定变量类型，如果没有初始化，变量默认为零值 1 2 var v_name v_type v_name = value 如果没有初始化，数值类型（int、float）初始值为0，布尔类型初始值为false，字符串为空字符串，指针、数组、字典、error等为nil\n不指定变量类型，根据值自行判定变量类型 1 var v_name = value := 声明 1 2 3 4 5 intVal := 1 # 等价于 var intVal int intVal = 1 已经使用var对变量声明过，再使用:=声明变量将会出错\n注意事项\n全局变量可以声明后不使用，局部变量不可以 要交换两个变量的值可以简单地使用a, b = b, a，两个变量的类型必须相同 空白标识符_是一个只写变量，不能得到它的值，比如 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { _,numb,strs := numbers() //只获取函数返回值的后两个 fmt.Println(numb,strs) } //一个可以返回多个值的函数 func numbers()(int,int,string){ a , b , c := 1 , 2 , \u0026#34;str\u0026#34; return a,b,c } 返回值为\n1 2 str 用于抛弃一个值。\n语句/表达式 循环语句 for循环\n1 2 3 4 5 6 7 8 # 与C语言的for一样 for init; condition; post { } # 与C语言的while一样 for condition { } # 与C语言的for(;;)一样，无限循环 for { } 还可对slice、数组、map、字符串等及逆行循环迭代\n1 2 3 for key, value := range oldMap{ newMap[key] = value } goto语句\n语法格式为：\n1 2 3 4 goto label; .. . label: statement; 实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; func main() { /* 定义局部变量 */ var a int = 10 /* 循环 */ LOOP: for a \u0026lt; 20 { if a == 15 { /* 跳过迭代 */ a = a + 1 goto LOOP } fmt.Printf(\u0026#34;a的值为 : %d\\n\u0026#34;, a) a++ } } 上述例子中，LOOP为循环开始语句的标签，当a == 15时，a直接通过运算变为16，并跳转至循环开始语句，不经过打印和自增，因此输出值中无15。\n函数 go语言函数定义格式为：\n1 2 3 func function_name( [parameter list]) [return_types] { 函数体 } 实例如下：\n1 2 3 4 5 6 7 8 9 10 11 func max(num1, num2 int) int { /* 声明局部变量 */ var result int if (num1 \u0026gt; num2) { result = num1 } else { result = num2 } return result } 默认情况下go语言使用的是值传递，即在调用过程中不会影响到实际参数，如果要在函数中对参数进行修改，则需要通过引用传递实现，传递的参数为指针参数。\n1 2 3 4 5 6 7 /* 定义交换值函数*/ func swap(x *int, y *int) { var temp int temp = *x /* 保持 x 地址上的值 */ *x = *y /* 将 y 值赋给 x */ *y = temp /* 将 temp 值赋给 y */ } Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：\n1 2 3 func (variable_name variable_data_type) function_name() [return_type]{ /* 函数体*/ } 实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; ) /* 定义结构体 */ type Circle struct { radius float64 } func main() { var c1 Circle c1.radius = 10.00 fmt.Println(\u0026#34;圆的面积 = \u0026#34;, c1.getArea()) } //该 method 属于 Circle 类型对象中的方法 func (c Circle) getArea() float64 { //c.radius 即为 Circle 类型对象中的属性 return 3.14 * c.radius * c.radius } defer panic recover defer go语言中存在defer关键字用于注册延迟调用，defer后边会接一个函数，但该函数不会立刻被执行，而是等到包含它的程序返回时（包含它的函数执行了return语句、运行到函数结尾自动返回、对应的goroutine panic）defer函数才会被执行。通常用于资源释放、打印日志、异常捕获等，如果有多个defer函数，调用顺序类似于栈，越后面的defer函数越先被执行（后进先出）。\n例如下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { var whatever [5]struct{} for i := range whatever { defer fmt.Println(i) } } 输出结果为 4 3 2 1 0，验证了defer语句先进后出的顺序，延迟函数的参数在defer声明时就已经决定了，后续i的值改变，并不会影响栈内函数的值。\npanic go语言运行时出错而又没有在编码时显式地返回错误时，go语言会抛出panic，使程序崩溃，异常退出，panic之后的代码不会被执行。\n无论是 Go 语言底层抛出 panic，还是我们在代码中显式抛出 panic，处理机制都是一样的：当遇到 panic 时，Go 语言会中断当前协程（即 main 函数）后续代码的执行，然后执行在中断代码之前定义的 defer 语句（按照先入后出的顺序），最后程序退出并输出 panic 错误信息，以及出现错误的堆栈跟踪信息\nrecover 可以通过 recover() 函数对 panic 进行捕获和处理，从而避免程序崩溃然后直接退出，而是继续可以执行后续代码，实现类似 Java、PHP 中 try\u0026hellip;catch 语句的功能。\n由于执行到抛出 panic 的问题代码时，会中断后续其他代码的执行，所以，显然这个 panic 的捕获应该放到 defer 语句中完成，才可以在抛出 panic 时通过 recover 函数将其捕获，defer 语句执行完毕后，会退出抛出 panic 的当前函数，回调调用它的地方继续后续代码的执行。\n可以类比为 panic、recover、defer 组合起来实现了传统面向对象编程异常处理的 try…catch…finally 功能。\n接口 golang中没有类的概念，取而代之的是通过struct实现封装和继承，通过接口实现多态。接口又称为动态数据类型，在进行接口使用的时候，会将接口的动态类型改为所指向的类型，会将动态值改成所指向类型的结构体。\n接口的定义 1 2 3 4 type Phone interface { speak() read() } 上述代码定义了一个接口Phone，可以使用不同的结构体对接口进行实现，然后利用接口对象作为形式参数，将不同类型的对象传入并调用相关的函数，实现多态。\n一个实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //定义一个接口 type Phone interface { speak() read() } //以下结构体可以分别设置自己的属性 type IPhone struct { name string } type Oppo struct { id int } type Mi struct { f bool } // 手机讲话区域（对相关的接口进行实现） func (a IPhone) speak() { fmt.Println(\u0026#34;我叫sir,您好！\u0026#34;) } func (a Oppo) speak() { fmt.Println(\u0026#34;我是oppo小精灵!\u0026#34;) } func (a Mi) speak() { fmt.Println(\u0026#34;大家好,我是小爱同学!\u0026#34;) } // 中央广场展示大舞台（可以直接将不同的实现接口的结构体对象传进来） func show(myPhone Phone) { myPhone.speak() } func main() { // 将新建对象传入展示大舞台,大舞台代码不变,展示不同的效果 show(new(IPhone)) } ","permalink":"https://hugotest-phi.vercel.app/posts/gometis00_intro/","summary":"\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"aikenhong_blog\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003ch2 id=\"go语言结构\"\u003eGo语言结构\u003c/h2\u003e\n\u003cp\u003eGo语言的基础组成有以下几个部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e包声明\u003c/li\u003e\n\u003cli\u003e引入包\u003c/li\u003e\n\u003cli\u003e函数\u003c/li\u003e\n\u003cli\u003e变量\u003c/li\u003e\n\u003cli\u003e语句\u0026amp;表达式\u003c/li\u003e\n\u003cli\u003e注释\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"gopath\"\u003eGOPATH\u003c/h2\u003e\n\u003cp\u003eGOPATH是Go语言中使用的一个环境变量，使用绝对路径提供项目的工作目录。在 GOPATH 指定的工作目录下，代码总是会保存在 \u003ccode\u003e $GOPATH/src\u003c/code\u003e 目录下。在工程经过 \u003ccode\u003ego build\u003c/code\u003e、\u003ccode\u003ego install\u003c/code\u003e 或 \u003ccode\u003ego get\u003c/code\u003e 等指令后，会将产生的二进制可执行文件放在 \u003ccode\u003e$ GOPATH/bin\u003c/code\u003e 目录下，生成的中间缓存文件会被保存在 \u003ccode\u003e$GOPATH/pkg\u003c/code\u003e 下。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e设置和使用GOPATH\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将当前目录设置为GOPATH\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003eexport\u003c/span\u003e \u003cspan class=\"nv\"\u003eGOPATH\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\u003cspan class=\"nb\"\u003epwd\u003c/span\u003e\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e建立GOPATH中的源码目录\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    mkdir -p src/hello\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e添加源码文件\u003c/p\u003e\n\u003cp\u003e将main.go源码保存到\u003ccode\u003e$GOPATH/src/hello\u003c/code\u003e目录下\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kn\"\u003epackage\u003c/span\u003e \u003cspan class=\"nx\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;fmt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e编译源码并运行\u003c/p\u003e\n\u003cp\u003e在命令行中执行如下指令编译源码：\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    go install hello\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e编译完成后的可执行文件会保存在\u003ccode\u003e$GOPATH/bin\u003c/code\u003e目录下，在bin目录下执行./hello，命令行输出\u003ccode\u003ehello world\u003c/code\u003e\u003c/p\u003e","title":"GoMetis00_INTRO"},{"content":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r受限于 XS20 只能同时保存4个自定义的 Recipes，但是可以通过手机的 XApp 备份相机当前的设置，因此本文主要用于记录各组备份包含的 Recipes 分别有哪些内容。\n该文会通过主要会以如下的方式记录配方内容：\n{ Recipe - Tag - Sample - PS } 三元组的方式来展示对应的配方，同时也会有一个较为粗糙的分类来整理这些配方。 { Backup - Recipes} 记录每个备份文件中包含哪些配方。 备份文件对应配方 Fujifilm-XS20可以通过 X-APP 备份手机当前的配置，保存为多个配置文件，因此这里我们将多组设置分别备份，以便需要的时候直接覆盖。\nTokyo-Recipes C1: 晨间_阴天都市 C2 : 晨间_冷白皮人像 C3: 晨间_晴空室外 C4 : 夜景_城市夜景 配方细节 该部分记录各个配方的详细设置，以及简单放一些样片以供查阅和参考。\n夜景_城市夜景 该配方建议在都市场景下常备，拍都市夜景的效果十分出彩，在城市霓虹和各种灯光效果下均比较容易出图。\n该配方适合用于都市等场景下的夜景拍摄，其整体效果偏向暖色调，灯光色彩等偏黄，却也构成照片的主色调，对整体光影的效果有强调作用，下面展示一些用改配方拍摄出来的图片以供参考。\n\u003c!DOCTYPE html\u003e\rby MetisYang\n晨间_冷白皮人像 该滤镜较为适合白天时候的人像和风景拍色，拍摄出来的整体色彩较为清冷干净。\n该配方适合在晴天的时候进行人像或者风景拍摄，拍摄出来的人像相对而言会偏向冷白皮的效果，白天的景色也会相对更干净和清澈一些。下面是一些效果样例，同样也是一个建议常备的配方。\n\u003c!DOCTYPE html\u003e\rBy MetisYang\n晨间_阴天都市 该滤镜适合阴天一些的非强光场景，重色彩效果。\n该配方适合在阴天的场景去进行扫街，拍摄都市或者特定场景物件的特写，该滤镜目前暂无样片，后续有的时候进行补充。\n晨间_晴空室外 该配方主要适用于光照条件好的晴天下的室外场景。\n该配方还是相对适合的人像的拍摄，在晴天和室内都有不一样的效果。下面是一些人像的样片 by MetisYang \u0026amp; AikenHong\n\u003c!DOCTYPE html\u003e\r","permalink":"https://hugotest-phi.vercel.app/posts/taskphoto00_xs20_recipes/","summary":"\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"aikenhong_blog\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003cblockquote\u003e\n\u003cp\u003e受限于 XS20 只能同时保存4个自定义的 Recipes，但是可以通过手机的 XApp 备份相机当前的设置，因此本文主要用于记录各组备份包含的 Recipes 分别有哪些内容。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e该文会通过主要会以如下的方式记录配方内容：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e{ \u003cstrong\u003eRecipe\u003c/strong\u003e - Tag - \u003cstrong\u003eSample\u003c/strong\u003e - PS } 三元组的方式来展示对应的配方，同时也会有一个较为粗糙的分类来整理这些配方。\u003c/li\u003e\n\u003cli\u003e{ \u003cstrong\u003eBackup\u003c/strong\u003e - \u003cstrong\u003eRecipes\u003c/strong\u003e} 记录每个备份文件中包含哪些配方。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"备份文件对应配方\"\u003e备份文件对应配方\u003c/h2\u003e\n\u003cp\u003eFujifilm-XS20可以通过 X-APP 备份手机当前的配置，保存为多个配置文件，因此这里我们将多组设置分别备份，以便需要的时候直接覆盖。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTokyo-Recipes\u003c/strong\u003e  C1: \u003ca href=\"#%e6%99%a8%e9%97%b4-%e9%98%b4%e5%a4%a9%e9%83%bd%e5%b8%82\"\u003e晨间_阴天都市\u003c/a\u003e\n  \u003cstrong\u003eC2\u003c/strong\u003e : \u003ca href=\"#%e6%99%a8%e9%97%b4-%e5%86%b7%e7%99%bd%e7%9a%ae%e4%ba%ba%e5%83%8f\"\u003e晨间_冷白皮人像\u003c/a\u003e\n C3: \u003ca href=\"#%e6%99%a8%e9%97%b4-%e6%99%b4%e7%a9%ba%e5%ae%a4%e5%a4%96\"\u003e晨间_晴空室外\u003c/a\u003e\n \u003cstrong\u003eC4\u003c/strong\u003e : \u003ca href=\"#%e5%a4%9c%e6%99%af-%e5%9f%8e%e5%b8%82%e5%a4%9c%e6%99%af\"\u003e夜景_城市夜景\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"配方细节\"\u003e配方细节\u003c/h2\u003e\n\u003cp\u003e该部分记录各个配方的详细设置，以及简单放一些样片以供查阅和参考。\u003c/p\u003e\n\u003ch3 id=\"夜景_城市夜景\"\u003e夜景_城市夜景\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e该配方建议在都市场景下常备，拍都市夜景的效果十分出彩，在城市霓虹和各种灯光效果下均比较容易出图。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cimg src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005005438.png\" style=\"zoom: 33%;\"\u003e\r\n\u003cp\u003e该配方适合用于都市等场景下的夜景拍摄，其整体效果偏向暖色调，灯光色彩等偏黄，却也构成照片的主色调，对整体光影的效果有强调作用，下面展示一些用改配方拍摄出来的图片以供参考。\u003c/p\u003e\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta name=\"viewport\" content=\"user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1\"\u003e\r\n    \u003cscript src=\"https://cdn.jsdmirror.com/npm/jquery@3.3.1/dist/jquery.min.js\"\u003e\u003c/script\u003e\r\n    \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdmirror.com/npm/nanogallery2@3.0.5/dist/css/nanogallery2.min.css\"\u003e\r\n    \u003cscript src=\"https://cdn.jsdmirror.com/npm/nanogallery2@3.0.5/dist/jquery.nanogallery2.min.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n\u003cdiv data-nanogallery2='{\r\n\t \"thumbnailDisplayTransition\":          \"none\",\r\n     \"thumbnailDisplayTransitionDuration\":  500,\r\n     \"thumbnailDisplayInterval\":            30,\r\n     \"galleryDisplayTransition\":            \"none\",\r\n     \"galleryDisplayTransitionDuration\":    500,\r\n     \"galleryDisplayMode\": \"rows\",\r\n     \"thumbnailDisplayOutsideScreen\": \"false\",\r\n     \"eventsDebounceDelay\": 10,\r\n     \"thumbnailL1BorderHorizontal\": 0,\r\n     \"thumbnailL1BorderVertical\": 0,\r\n     \"thumbnailLabel\": {\r\n        \"titleFontSize\": \"0.6em\"\r\n     },\r\n     \"thumbnailHoverEffect2\": \"image_scale_1.00_1.10|label_backgroundColor_rgba(0,0,0,0)_rgba(255,255,255,0)\",\r\n     \"galleryTheme\": {\r\n        \"thumbnail\": {\r\n            \"borderRadius\": \"8px\"\r\n        }\r\n     },\r\n     \"thumbnailToolbarImage\": {\r\n        \"topLeft\": \"\",\r\n        \"topRight\": \"\",\r\n        \"bottomLeft\": \"\",\r\n        \"bottomRight\": \"\"\r\n     },\r\n     \"viewerToolbar\":   {\r\n        \"display\": true,\r\n        \"standard\": \"label\"\r\n     },\r\n     \"viewerTools\":     {\r\n        \"topLeft\":    \"pageCounter, playPauseButton\",\r\n        \"topRight\":   \"downloadButton, rotateLeft, zoomButton, fullscreenButton, closeButton\"\r\n     },\r\n     \"viewerGalleryTWidth\": 40,\r\n     \"viewerGalleryTHeight\": 40\r\n}'\u003e\r\n\u003cp\u003e\u003ca href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005005911.png\" data-ngThumb=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005005911.png\"\u003e\u003c/a\u003e\n\u003ca href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005010107.png\" data-ngThumb=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005010107.png\"\u003e\u003c/a\u003e\n\u003ca href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005011633.png\" data-ngThumb=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005011633.png\"\u003e\u003c/a\u003e\n\u003ca href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005011713.png\" data-ngThumb=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005011713.png\"\u003e\u003c/a\u003e\n\u003ca href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005011751.png\" data-ngThumb=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20231005011751.png\"\u003e\u003c/a\u003e\u003c/p\u003e","title":"Photography00 XS20_Recipes"},{"content":" 接下来本文安装的是 Container 版本的 HA，并非 Supervised 的版本，所以其中是不包含 Add-on 的，如果需要特定的 Add-on 的版本请注意。\n基于本篇流程安装 HA 的前置条件是系统上已经安装好了可用的 Docker，该文会介绍 HA 和 HACS 的安装以及一些基础的配置。\nHA \u0026amp; HACS 安装 本文安装于 Raspberry pi 4B，与其他操作环境可能会存在一些差异，要注意甄别。\nHA 安装过程主要参考 Raspberry Pi - Home Assistant 中 Install Home Assistant Container 的章节，如果为其他的 OS 也可以在官网找到类似的指引，不过 docker 版本的差异应该不会特别的大，个人的 Docker Compose File 也已经上传到 GITHUB 可自行取用。\n修改完 -v 的挂载目录以后（将数据保存在本地的目录）和 -e 的时区后，即可执行拉取和安装 docker，这里-v 挂载的本地目录要记得，后面有用。\n1 docker compose up -d 安装完后基于 Host 模式的 HA 会运行在 http://localhost:8123 中，localhost 也可以用 ip 替代。安装完后随着指引 完成一些基础的设置，设置好默认的账号密码即可重启 docker 进入 HA 的界面；\n到这里已经可以做一些基础的使用了，但是为了支持更多智能家具产品，往往需要安装第三方用户商店 HACS ，从中去下载对于其他智能家具产品的支持。\nHACS Home Assistant Community Store 第三方用户商店，便于下载各种各样的集成实现对于各个不同智能家具品牌和产品的支持。\n各种不同版本的安装方式可以参考官方网页 ，以下只介绍基于 Container 的安装方式，官方提供了安装脚本，因此现在下载已经相对简单，具体如下：\n进入挂载的本地目录，执行下面命令，即包含了下载和执行。 1 wget -O - https://get.hacs.xyz | bash - 如果下不下来也可以直接打开网页复制进.Sh 脚本中；也可以去我的仓库中拉下来\n安装完重启 HA，在集成页面添加集成，搜索 HACS，搜索到直接进行安装，跟随配置进行安装，并打开 GITHUB 进行登录和授权即可。\n查看是否出现了 HACS 的选项，如果安装完后面出现了如下的界面即为安装完成。\n由于后续的一些社区插件都是需要从 Github 拉取，因此需要为 HACS 设置代理，目前版本的代理设置在如下位置：\u0026lt;挂载的本地目录/即HA的config文件夹\u0026gt;/custom_compomemts/hacs/base.py。\n使用编辑器打开该文件进行修改，搜索到 session.get(url = url 的字段，添加自己的 proxy 设置如下。重启即可，可以在设置搜索到重启服务进行重启。\n该方法参考于：HACS更新后怎么添加代理从而顺畅下载 - 『HomeAssistant』综合讨论区 - 『瀚思彼岸』» 智能家居技术论坛 - Powered by Discuz! (hassbian.com) 如果无法直接安装，也可以直接上 github 界面下载压缩包，解压到 custom_components 文件夹中。\n一些简单的基础配置和说明 完成上述安装后，就可以开始搭建自己的 HA 系统了，该部分简单对逻辑和一些集成的使用进行说明介绍；\n简单说明 基于个人的粗浅入门尝试，HA 的配置可以简单理解为实体 entity 和 UI 模板 lovelace 的组合，两者结合来构成我们的控制中心和可视化界面。\n实体既是智能家居中的各种物件组成，如：灯泡，开关，电视，温度计等，其主要提供：数据源（用于显示和统计），以及控制单元和权限（开关，温度设置等） Lovelace 是针对 HA 集成的 UI 模块，其为一种或多种类型的实体提供可视化方案，基于 UI 模块结合读取的实体信息来设计我们的控制台。 Lovelace is the user interface that has been packaged with Home Assistant and has been the standard for several versions now.\n因此，安装 HA 中自带的一些集成和 HACS 提供的额外集成提供的是：对各种智能家具的数据和控制权限的获取能力。\n一开始安装完 HA 可以发现其已经默认可以获取一些实体了，这些可以都勾上，然后可以去上述安装 hacs 集成的地方勾选一些有用的系统集成安装，这些实体和默认的一些 UI 的界面可以自行尝试搭配。\n添加系统信息监控 在 \u0026lt;挂载的本地目录/即HA的config文件夹\u0026gt;/configuration.yml 中添加系统监管信息如下：\n1 2 3 4 5 6 7 8 9 sensor: - platform: systemmonitor resources: - type: memory_use_percent - type: disk_use_percent - type: processor_use - type: last_boot - type: processor_temperature - type: memory_free 可以添加的选项可以在官方页面查看 ，配置完成后重启 HA 即可在实体中看到对应的选项。\n小米系列设备 通过在 HACS 中安装 Xiaomi Miot Auto 集成，即可添加诸多小米的设备，空调伴侣也可简单的实现集成。\nOnvir 监视器设备添加 HA 集成中添加 onvir 集成，添加对应的 IP 和用户名密码即可添加对应摄像头。\n小米温湿度计2代 参考： 【HA】HomeAssistant 添加 小米温湿度计2代_小米温湿度计接入ha_叼辣条闯天涯的博客-CSDN博客 HACS 安装 passive ble monitor intgration 集成\n通过此 Telink Flasher for Mi Thermostat 点击 Connect，\n选择设备 LYWSD03MMC 进行配对连接 显示了 Connected 后，点击 Do Activation 获取32位密钥 Mi Bind Key 获取 MAC 地址\n终端中使用蓝牙搜索对应设备 使用以下的命令扫描蓝牙设备，由于是被动接受信号，所以可能需要等待一段时间，等待 LYWSD03MMC 设备出现 1 2 3 4 bluetoothctl # 进入蓝牙连接命令行后 scan on # 等待LYWSD03MMC设备出现 添加集成：Passive BLE monitor，选择树莓派的蓝牙进入下一步，选择 Add device，在新的窗口中配置设备；仅需添加 MAC 地址和加密密钥选项，选择提交后会返回到上一个界面而不是没反应。\n将设备选项放在 --Devices-- 直接提交即可，由于设备广播需要一定的时间，因此需要耐心等待一定时间即可。\nTroubleShoot 问题解决 Clear Banned Ips 解除 IP 封禁 使用 Nginx 部署 HA 服务后，由于密码输入错误和密码尝试次数限制等原因，可能会导致 IP 被 HA 封禁，这种情况下可以通过手动编辑配置文件中的 ip_bans.yaml 文件（和 configuration.Yaml 在同一个目录下），删除自己的 IP 从而实现解封。\n参考资料：Clear Banned LAN IPs - Installation / Home Assistant OS - Home Assistant Community (home-assistant.io) FI 分享一下个人的成品：\n\u003c!DOCTYPE html\u003e\r","permalink":"https://hugotest-phi.vercel.app/posts/homeassistant_init/","summary":"\u003cblockquote\u003e\n\u003cp\u003e接下来本文安装的是 Container 版本的 HA，并非 Supervised 的版本，所以其中是不包含 Add-on 的，如果需要特定的 Add-on 的版本请注意。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e基于本篇流程安装 HA 的前置条件是系统上已经安装好了可用的 Docker，该文会介绍 HA 和 HACS 的安装以及一些基础的配置。\u003c/p\u003e\n\u003ch2 id=\"ha--hacs-安装\"\u003eHA \u0026amp; HACS 安装\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文安装于 Raspberry pi 4B，与其他操作环境可能会存在一些差异，要注意甄别。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"ha\"\u003eHA\u003c/h3\u003e\n\u003cp\u003e安装过程主要参考 \u003ca href=\"https://www.home-assistant.io/installation/raspberrypi\" target=\"_blank\" rel=\"noopener\"\u003eRaspberry Pi - Home Assistant \u003c/a\u003e\n 中 Install Home Assistant Container 的章节，如果为其他的 OS 也可以在官网找到类似的指引，不过 docker 版本的差异应该不会特别的大，个人的 Docker Compose File 也已经上传到 \u003ca href=\"https://github.com/AikenH/aikenh-DockerComposeYML/blob/master/HomeAssistant/docker-compose.yml\" target=\"_blank\" rel=\"noopener\"\u003eGITHUB\u003c/a\u003e\n 可自行取用。\u003c/p\u003e\n\u003cp\u003e修改完 \u003ccode\u003e-v\u003c/code\u003e 的挂载目录以后（将数据保存在本地的目录）和 \u003ccode\u003e-e\u003c/code\u003e 的时区后，即可执行拉取和安装 docker，这里-v 挂载的本地目录要记得，后面有用。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker compose up -d \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e安装完后基于 Host 模式的 HA 会运行在 http://localhost:8123 中，localhost 也可以用 ip 替代。安装完后随着\u003ca href=\"https://www.home-assistant.io/getting-started/onboarding/\" target=\"_blank\" rel=\"noopener\"\u003e指引\u003c/a\u003e\n完成一些基础的设置，设置好默认的账号密码即可重启 docker 进入 HA 的界面；\u003c/p\u003e\n\u003cp\u003e到这里已经可以做一些基础的使用了，但是为了支持更多智能家具产品，往往需要安装第三方用户商店 HACS ，从中去下载对于其他智能家具产品的支持。\u003c/p\u003e\n\u003ch3 id=\"hacs\"\u003eHACS\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHome Assistant Community Store 第三方用户商店，便于下载各种各样的集成实现对于各个不同智能家具品牌和产品的支持。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e各种不同版本的安装方式可以参考\u003ca href=\"https://hacs.xyz/docs/setup/download\" target=\"_blank\" rel=\"noopener\"\u003e官方网页\u003c/a\u003e\n，以下只介绍基于 Container 的安装方式，官方提供了安装脚本，因此现在下载已经相对简单，具体如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e进入挂载的本地目录，执行下面命令，即包含了下载和执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget -O - https://get.hacs.xyz \u003cspan class=\"p\"\u003e|\u003c/span\u003e bash -\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e如果下不下来也可以直接打开网页复制进.Sh 脚本中；也可以去我的仓库中拉下来\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e安装完重启 HA，在集成页面添加集成，搜索 HACS，搜索到直接进行安装，跟随配置进行安装，并打开 GITHUB 进行登录和授权即可。\u003c/p\u003e","title":"HomeAssistant01 入门基础篇"},{"content":" 想要通过命令行直接下载文件，通常想到的就是下面的两个工具：wget 和 curl，下面简单介绍一下两者的使用。\nWget wget 全称为 web get ，其基本用法为：wget [-para] url ，常用的参数有以下几种：\n-O 指定下载文件的保存名称 -b 为后台下载模式 -P 下载到指定目录 -c 支持断电续传 -p 下载页面内的所有资源、包括图片视频等 -r 递归下载 -t 最大尝试次数 1 2 3 4 # 默认无需参数的情况下即会将文件下载到当前文件夹下。 # 也是最常见的用法，可以加入-c避免下载中断 wget url wget -O file.tgz url 参考 Man Page 或者 ExplainShell 可以找到完整的参数列表；支持从文件中读取 url ；将 log 写入指定的文件等等功能；\n可以看出 wget 是一个简单，专职的下载利器，无论是用来下载安装包还是 pdf 之类的东西是一个相当方便的下载工具。\nCurl 参考资料：linux - wget 与 curl 命令详解 - 个人文章 - SegmentFault 思否 Curl 的全称为：CommandLine URL 即 CommandLine Uniform Resource Locator，即在命令行的方式下基于 URL 的语法来进行数据或者文件的传输的工具。除了 Wget 的下载功能之外，Curl 还支持处理复杂的 web 请求，进行网络接口测试等等。\nURL 统一资源定位符\nDownload 下载功能 基本的单个文件下载功能如下：\n1 2 3 4 curl [-o 自定义文件名] [-O] [-C 偏移量] url # -o 输出到指定文件 # -O 以最后一个/后面的部分最为文件名 # -C 偏移量，从指定的偏移量处继续下载，偏移量以字节为单位，一般用 - 代替偏移量，让其自动推算出正确的续传位置 WEB 请求处理和接口测试 该功能和 postman 是一致的，在进行前后端编写和交互的时候能起到很好的测试作用。\n自动跳转 curl -L \u0026lt;url\u0026gt; 显示响应头信息 -i，显示通信过程 -v ，将通信过程另存到文件 --trace \u0026lt;file\u0026gt; \u0026lt;url\u0026gt; 或 --trace-ascii \u0026lt;file\u0026gt; \u0026lt;url\u0026gt; 指定 http 请求方式 -X 指定 post|get|put|delete 添加 http 请求头 -H 'key:value' \u0026lt;url\u0026gt; 例如 -H 'Content-Type:application/json' 设置 cookie 可以使用 -b 或者 --cookie 输入参数，或者 -c 文件 设置用户名和密码 -u 'user[:password]' 设置代理 -A '代理信息' 或者 --user-agent '代理信息' 也可以用 -H 直接设置请求头 User-Agent 文件上传 -F 'file=@文件' 更多参数形式 file=@文件;name1=value1;name2=value2 传递请求参数 1 curl -X POST -d \u0026#39;参数\u0026#39; \u0026lt;url\u0026gt; -d 参数会自动加上标头\u0026quot;Content-Type:application/x-www-form-urlencoded\u0026quot;，并将请求方式转为 POST。\nFi","permalink":"https://hugotest-phi.vercel.app/posts/linuxcli_download/","summary":"\u003cblockquote\u003e\n\u003cp\u003e想要通过命令行直接下载文件，通常想到的就是下面的两个工具：wget 和 curl，下面简单介绍一下两者的使用。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"wget\"\u003eWget\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ewget\u003c/code\u003e 全称为 \u003ccode\u003eweb get\u003c/code\u003e ，其基本用法为：\u003ccode\u003ewget [-para] url \u003c/code\u003e ，常用的参数有以下几种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e-O 指定下载文件的保存名称\u003c/li\u003e\n\u003cli\u003e-b 为后台下载模式\u003c/li\u003e\n\u003cli\u003e-P 下载到指定目录\u003c/li\u003e\n\u003cli\u003e-c 支持断电续传\u003c/li\u003e\n\u003cli\u003e-p 下载页面内的所有资源、包括图片视频等\u003c/li\u003e\n\u003cli\u003e-r 递归下载\u003c/li\u003e\n\u003cli\u003e-t 最大尝试次数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 默认无需参数的情况下即会将文件下载到当前文件夹下。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 也是最常见的用法，可以加入-c避免下载中断\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget url\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget -O file.tgz url\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e参考 Man Page 或者 \u003ca href=\"https://www.explainshell.com/explain/1/wget\" target=\"_blank\" rel=\"noopener\"\u003eExplainShell\u003c/a\u003e\n 可以找到完整的参数列表；支持从文件中读取 url ；将 log 写入指定的文件等等功能；\u003c/p\u003e\n\u003cp\u003e可以看出 wget 是一个简单，专职的下载利器，无论是用来下载安装包还是 pdf 之类的东西是一个相当方便的下载工具。\u003c/p\u003e","title":"linux下载命令之Wget和Curl"},{"content":"多次循环进行 Numpy Concentrate 操作后，当原始数组变得过大的时，单步处理时间会逐渐变长，处理大量数据的时候时间成本极高。\n解决思路 这里简单的讲一下问题的定位过程，通过装饰器 Check 每个函数的执行时间，重点关注执行时长逐渐变长的部分。\n1 2 3 4 5 6 7 8 9 10 11 from time import time def timer(func): def func_wrapper(*args, **kwargs): time_start = time() result = func(*args, **kwargs) time_end = time() res = time_end - time_start print(\u0026#34;{} cost time: {} s\u0026#34;.format(func.__name__, res)) return result return func_wrapper 就会发现当 np.Concatenate 导致 Array 很大之后，运行就会逐渐减缓。由于运行缓慢是由于对大数组操作导致的，因此这里考虑将大数组切分成多个小数组，然后再最后进行合并。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 with open(file, \u0026#39;r\u0026#39;) as rf: for line in rf: ... new_row_array = ... key = ... if len(res_list[key][-1]) == 0 : res_list[key][-1] = new_row_array else: if len(res_list[key][-1]) \u0026gt;= MAX_LENGTH: res_list[key].append(new_row_array) else: res_list[key][-1] = np.concatenate([ res_list[key][-1], new_row_array ]) for i in range(len(res_list)): res_list[i] = np.concatenate(res_list[i], axis=0) 可以看上述这段代码，通过对-1 的使用，来自动的切分 Array，最后再整体合并，这样就能避免每个数组过大的问题。\n本地实验测试也成功，将原本耗时 400s 的处理过程减少到了 30s\nFi ","permalink":"https://hugotest-phi.vercel.app/posts/numpyconcatenate%E5%8A%A0%E9%80%9F/","summary":"\u003cp\u003e多次循环进行 Numpy Concentrate 操作后，当原始数组变得过大的时，单步处理时间会逐渐变长，处理大量数据的时候时间成本极高。\u003c/p\u003e\n\u003ch2 id=\"解决思路\"\u003e解决思路\u003c/h2\u003e\n\u003cp\u003e这里简单的讲一下问题的定位过程，通过装饰器 Check 每个函数的执行时间，重点关注执行时长逐渐变长的部分。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efrom \u003cspan class=\"nb\"\u003etime\u003c/span\u003e import \u003cspan class=\"nb\"\u003etime\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edef timer\u003cspan class=\"o\"\u003e(\u003c/span\u003efunc\u003cspan class=\"o\"\u003e)\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    def func_wrapper\u003cspan class=\"o\"\u003e(\u003c/span\u003e*args, **kwargs\u003cspan class=\"o\"\u003e)\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nv\"\u003etime_start\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e time\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nv\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e func\u003cspan class=\"o\"\u003e(\u003c/span\u003e*args, **kwargs\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nv\"\u003etime_end\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e time\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nv\"\u003eres\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e time_end - time_start\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        print\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;{} cost time: {} s\u0026#34;\u003c/span\u003e.format\u003cspan class=\"o\"\u003e(\u003c/span\u003efunc.__name__, res\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e result\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e func_wrapper\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e就会发现当 np.Concatenate 导致 Array 很大之后，运行就会逐渐减缓。由于运行缓慢是由于对大数组操作导致的，因此这里考虑将大数组切分成多个小数组，然后再最后进行合并。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewith open\u003cspan class=\"o\"\u003e(\u003c/span\u003efile, \u003cspan class=\"s1\"\u003e\u0026#39;r\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e as rf:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003efor\u003c/span\u003e line in rf:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nv\"\u003enew_row_array\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nv\"\u003ekey\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e len\u003cspan class=\"o\"\u003e(\u003c/span\u003eres_list\u003cspan class=\"o\"\u003e[\u003c/span\u003ekey\u003cspan class=\"o\"\u003e][\u003c/span\u003e-1\u003cspan class=\"o\"\u003e])\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"m\"\u003e0\u003c/span\u003e :\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\tres_list\u003cspan class=\"o\"\u003e[\u003c/span\u003ekey\u003cspan class=\"o\"\u003e][\u003c/span\u003e-1\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e new_row_array\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e len\u003cspan class=\"o\"\u003e(\u003c/span\u003eres_list\u003cspan class=\"o\"\u003e[\u003c/span\u003ekey\u003cspan class=\"o\"\u003e][\u003c/span\u003e-1\u003cspan class=\"o\"\u003e])\u003c/span\u003e \u0026gt;\u003cspan class=\"o\"\u003e=\u003c/span\u003e MAX_LENGTH:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\tres_list\u003cspan class=\"o\"\u003e[\u003c/span\u003ekey\u003cspan class=\"o\"\u003e]\u003c/span\u003e.append\u003cspan class=\"o\"\u003e(\u003c/span\u003enew_row_array\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\tres_list\u003cspan class=\"o\"\u003e[\u003c/span\u003ekey\u003cspan class=\"o\"\u003e][\u003c/span\u003e-1\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e np.concatenate\u003cspan class=\"o\"\u003e([\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\tres_list\u003cspan class=\"o\"\u003e[\u003c/span\u003ekey\u003cspan class=\"o\"\u003e][\u003c/span\u003e-1\u003cspan class=\"o\"\u003e]\u003c/span\u003e, new_row_array\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"o\"\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003efor\u003c/span\u003e i in range\u003cspan class=\"o\"\u003e(\u003c/span\u003elen\u003cspan class=\"o\"\u003e(\u003c/span\u003eres_list\u003cspan class=\"o\"\u003e))\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\tres_list\u003cspan class=\"o\"\u003e[\u003c/span\u003ei\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e np.concatenate\u003cspan class=\"o\"\u003e(\u003c/span\u003eres_list\u003cspan class=\"o\"\u003e[\u003c/span\u003ei\u003cspan class=\"o\"\u003e]\u003c/span\u003e, \u003cspan class=\"nv\"\u003eaxis\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e可以看上述这段代码，通过对-1 的使用，来自动的切分 Array，最后再整体合并，这样就能避免每个数组过大的问题。\u003c/p\u003e","title":"NumpyConcatenate加速"},{"content":" 树莓派家庭服务器的搭建以 docker 为核心，通过 docker 统一管理家庭服务，目前搭建的服务还在持续完善中，主要目的是为了方便日常使用、满足学习和探索的需求。\nDocker 的安装这里不再赘述，参考 Docker Configuration01 Install on Linux 一文进行安装即可；本篇主要侧重于介绍部署的镜像和服务，以及简单介绍使用方式。\n一些 Docker 容器推荐 这里推荐一些 Docker 容器：Alist、XiaoYa、PiDashboard、redis、mysql、portainer、memos、wikijs\n相关的 Docker-Compose 文件会上传到AikenH/aikenh-DockerComposeYML (github.com) 数据库部署与远程连接测试 sqlite 3 Sqlite 与 Mysql 等不同，是一个无服务器、零配置的数据库，其更像是一个解析特定数据库文件的命令接口（CLI 工具），其将数据完全存储于一个单一的跨平台磁盘文件中；\n由于 sqlite3 的特性，决定了其是一个轻量级且不需要额外配置的数据库，但是在远程访问方面，只能通过文件共享来实现远程操作数据库。\n大多数的 Linux 系统版本都会附带 SQLite 的安装，因此我们可以直接使用下面的指令验证一下是否安装：\n1 sqlite3 如果没有安装的话，可以去官方的下载页面 下载对应的预编译包，然后进行安装即可。\n1 2 3 4 5 6 wget https://www.sqlite.org/2023/sqlite-autoconf-3420000.tar.gz tar -zxvf sqlite-autoconf-3420000.tar.gz cd sqlite-autoconf-3420000 ./configure --prefix=/usr/local make make install 这里也提供使用 Docker-compose 安装的方式，但实际上看该数据库的特性，用 docker 安装的并不是推荐的选择。\n参考资料：SQLite 3 Docker Compose – Mustafa Bugra 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#39;3\u0026#39; services: sqlite3: container_name: sqlite3_container image: nouchka/sqlite3:latest stdin_open: true tty: true volumes: #Modify following line - path-to/your/databases/sqlite3:/root/db/ ports: - \u0026#39;9000:9000\u0026#39; # expose ports - HOST:CONTAINER restart: unless-stopped 如果是树莓派的 ARM64，可能需要使用另一个镜像 。\n1 docker run --rm -it -v \u0026#34;$(pwd):/workspace\u0026#34; -w /workspace keinos/sqlite3 但是该镜像的使用方式，实际上就是将其当成一个命令来用，所以还是建议本机安装。\nredis 使用 docker-compose 拉取指定的镜像进行安装：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.9\u0026#39; services: redis: image: redis:6.2.5 container_name: docker_redis privileged: true volumes: - ./data:/data - ./conf/redis.conf:/usr/local/etc/redis/redis.conf - ./logs:/logs command: [\u0026#34;redis-server\u0026#34;,\u0026#34;/usr/local/etc/redis/redis.conf\u0026#34;] ports: - 29005:6379 environment: - TZ=\u0026#34;Asia/Shanghai\u0026#34; 设置对应的配置文件：\nbind 0.0.0.0\r# Allow Lan should be 0,0,0,0\r# requirepass 123456\r# need password or not\rport 6379\rtimeout 0\rsave 60 10000\rrdbcompression yes\rdbfilename dump.rdb\rdir /data\rlogfile \u0026#34;redis.log\u0026#34; 这里为了方便远程连接，不设置密码，同时将 bind 设置为 0.0.0.0 允许局域网访问。\n在 Python 中测试远程连接是否正常：\n1 2 3 import redis r = redis.Redis(host=\u0026#34;192.168.31.111\u0026#34;, port=1234, decode_resonses=True) r.set(\u0026#34;key\u0026#34;, \u0026#34;balue\u0026#34;) mysql 参考文献：docker-compose 安装mysql - 掘金 (juejin.cn) | 配置MySQL 远程连接 | myfreax 使用 Docker-Compose 安装 mysql 的 docker，启用服务，设置配置文件来完成基础设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#34;3.3\u0026#34; services: mysql: image: mysql:latest environment: MYSQL_ROOT_PASSWORD: \u0026#34;password\u0026#34; MYSQL_USER: \u0026#39;extra-user\u0026#39; MYSQL_PASS: \u0026#34;extra-password\u0026#34; restart: unless-stopped volumes: - ./data:/var/lib/mysql - ./config/my.cnf:/etc/my.cnf - ./init:/docker-entrypoint-initdb.d/ ports: - \u0026#39;29006:3306\u0026#39; 随便设置一个基础配置文件如下，将 Bind 地址改为 0.0.0.0 便于局域网访问\n1 2 3 4 5 6 7 8 9 [mysqld] user=mysql default-storage-engine=INNODB character-set-server=utf8 bind-address=0.0.0.0 [client] default-character-set=utf8 [mysql] default-character-set=utf8 启动服务后，进入 mysql 初始化用户密码（未设置密码前使用 mysql 命令）\n1 2 mysql # mysql -u root -p 初始化用户脚本，其中%为允许局域网，默认是 LocalHost，密码的引号不要删除。\n1 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;Aa123456\u0026#39;; 可以执行 show 查看当前所有的数据表，并通过 use 进入 mysql 表中，提升用户权限 ；\n1 2 SHOW databases; USE mysql 具体提升权限的命令如下：\n1 2 3 CREATE USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;PASSWORD\u0026#39;; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; WITH GRANT OPTION; FLUSH PRIVILEGES; 完成后可以通过 mysql 表中查看各用户的权限是否正确\n1 SELECT host, user,authentication_string FROM user; 配置完成后即可在局域网内测试远程连接：\n1 mysql -u root -ppassword -h 192.168.31.108 -P 29006 这里需要注意的是-p 和密码之间不要有空格，否则可能会提示你在输入一次密码，并表示数据表不存在。\n树莓派性能检测 除了 Docker 的一系列应用之外，这里推荐移动端/mac 端的应用 ServerCat 来对 SSH 终端和 Linux 来进行性能监控，该监控无论是可视化还是连接各方面都做的十分完备。推荐。\n","permalink":"https://hugotest-phi.vercel.app/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/","summary":"\u003cblockquote\u003e\n\u003cp\u003e树莓派家庭服务器的搭建以 docker 为核心，通过 docker 统一管理家庭服务，目前搭建的服务还在持续完善中，主要目的是为了方便日常使用、满足学习和探索的需求。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eDocker 的安装这里不再赘述，参考 Docker Configuration01 Install on Linux 一文进行安装即可；本篇主要侧重于介绍部署的镜像和服务，以及简单介绍使用方式。\u003c/p\u003e\n\u003ch2 id=\"一些-docker-容器推荐\"\u003e一些 Docker 容器推荐\u003c/h2\u003e\n\u003cp\u003e这里推荐一些 Docker 容器：Alist、XiaoYa、PiDashboard、redis、mysql、portainer、memos、wikijs\u003c/p\u003e\n\u003cp\u003e相关的 Docker-Compose 文件会上传到\u003ca href=\"https://github.com/AikenH/aikenh-DockerComposeYML\" target=\"_blank\" rel=\"noopener\"\u003eAikenH/aikenh-DockerComposeYML (github.com)\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"数据库部署与远程连接测试\"\u003e数据库部署与远程连接测试\u003c/h2\u003e\n\u003ch3 id=\"sqlite-3\"\u003esqlite 3\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSqlite 与 Mysql 等不同，是一个无服务器、零配置的数据库，其更像是一个解析特定数据库文件的命令接口（CLI 工具），其将数据完全存储于一个单一的跨平台磁盘文件中；\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e由于 sqlite3 的特性，决定了其是一个\u003cstrong\u003e轻量级\u003c/strong\u003e且\u003cstrong\u003e不需要额外配置\u003c/strong\u003e的数据库，但是在远程访问方面，只能通过文件共享来实现远程操作数据库。\u003c/p\u003e\n\u003cp\u003e大多数的 Linux 系统版本都会附带 SQLite 的安装，因此我们可以直接使用下面的指令验证一下是否安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esqlite3\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果没有安装的话，可以去官方的\u003ca href=\"https://www.sqlite.org/download.html\" target=\"_blank\" rel=\"noopener\"\u003e下载页面\u003c/a\u003e\n下载对应的预编译包，然后进行安装即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget https://www.sqlite.org/2023/sqlite-autoconf-3420000.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -zxvf sqlite-autoconf-3420000.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e sqlite-autoconf-3420000\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./configure --prefix\u003cspan class=\"o\"\u003e=\u003c/span\u003e/usr/local\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emake \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emake install\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这里也提供使用 Docker-compose 安装的方式，但实际上看该数据库的特性，用 docker 安装的并不是推荐的选择。\u003c/p\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://www.mustafabugra.com/development/sqlite-3-docker-compose/\" target=\"_blank\" rel=\"noopener\"\u003eSQLite 3 Docker Compose – Mustafa Bugra\u003c/a\u003e\n。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eversion\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;3\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003eservices\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003esqlite3\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003econtainer_name\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003esqlite3_container\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003enouchka/sqlite3:latest\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003estdin_open\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003etty\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003evolumes\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"c\"\u003e#Modify following line\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003epath-to/your/databases/sqlite3:/root/db/\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eports\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s1\"\u003e\u0026#39;9000:9000\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# expose ports - HOST:CONTAINER\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003erestart\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eunless-stopped\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果是树莓派的 ARM64，可能需要使用另一个\u003ca href=\"https://hub.docker.com/r/keinos/sqlite3\" target=\"_blank\" rel=\"noopener\"\u003e镜像\u003c/a\u003e\n。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker run --rm -it -v \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"k\"\u003e$(\u003c/span\u003e\u003cspan class=\"nb\"\u003epwd\u003c/span\u003e\u003cspan class=\"k\"\u003e)\u003c/span\u003e\u003cspan class=\"s2\"\u003e:/workspace\u0026#34;\u003c/span\u003e -w /workspace keinos/sqlite3\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e但是该镜像的使用方式，实际上就是将其当成一个命令来用，所以还是建议本机安装。\u003c/p\u003e","title":"树莓派02 家用服务器"},{"content":" 将 RaspBerry Pi 4B 作为家庭影视中心/机顶盒的核心就是 KODI 软件，这是考虑到以下的几点：遥控器的控制、对挂载 webdav 和其他的支持\n最方便的方式可以选择以 KODI 为核心的两个 OS：LibreELEC、OSMC（推荐），这两个系统以 KODI 为默认启动，同时也支持远程登录和 Docker 部署等 Linux 的功能。后者更为推荐应该是前者的官方改进版本。\n考虑到后续可能会将该 SD 卡用于其他用处，因此本文选择的是使用 RaspBerryPi OS 的方案，以下围绕该方案进行展开：\nRaspBerry Pi OS+Kodi+Alist 方案探究 可以参考 trouble shooting，可以发现实际上安装 kodi 最简单的方式就是直接使用 apt，无需做其他的 PPA 添加。\n安装Kodi 1 sudo apt-get install kodi 安装完后，使用 kodi 命令开启或者在开始菜单的软件中心中选择 kodi 打开。\n设置 GPU 显存（硬解相关） 首先做一下固件的升级：\n1 sudo rpi-update 然后调整一下显存：系统设置里面将 gpu_mem 调高一些，我使用的是 4G，调整到了 256MB，切记不要调整太高，否则可能会开机失败，重启后查看显存是否设置成功。\n查看 GPU 显存的方式：\n1 vcgencmd get_mem arm \u0026amp;\u0026amp; vcgencmd get_mem gpu 最后在 kodi 中查看相关的选项的开关情况：\n参考资料：树莓派RaspberryPi 4B设置显存开启硬件加速 支持Emby|Plex|JellyFin转码 LiuJason\u0026rsquo;sBlog KODI 界面设置（中文） 里面 Interface 选项 -\u0026gt; 皮肤 -\u0026gt; 字体选择 Arial（支持中文，不然会乱码）\n如果皮肤下面没有字体的子项，可以选择切换左下角的模式，切换到专家就可看到\n切换完字体，选择皮肤下面的区域 Region-\u0026gt; Language -\u0026gt; Chinese 即可。\nKODI 添加 WebDav 首先选择资料库中的进入文件区 -\u0026gt; 添加视频 -\u0026gt; 添加视频源处选择浏览 -\u0026gt; 添加网络位置处\n如果是本地挂载的协议一般选择 HTTP，服务器地址填写局域网 IP 即可，远程路径填写 Dav，端口是设定好的端口； 如果是远程的一些 Alist 网站，可以选择 WebDav 的 HTTPs ，其他的参考相关网站给出的设置即可。 本地就一葫芦画瓢就行，添加完后可以看到相关的源，然后选择文件夹和对应显示的名称即可，需要注意的是，这里我们最好不启用刮削服务（Alist 等网盘的情况下），避免被封号等一系列问题。\nKodi 设置 iptv 播放 kodi 支持 iptv 播放主要依赖于PVR IPTV Simple Client 插件，通过该插件设置 m3u 直播源即可实现 iptv 的播放。\nPVR IPTV Simple Client的几种安装方法：\nkodi 直接询问是否启用； kodi-\u0026gt;设置-\u0026gt;插件-\u0026gt;从库安装-\u0026gt;pvr clients-\u0026gt; PVR IPTV Simple Client 如果上述两个方法都失效，使用插件中的从 zip 安装，相关的 zip 文件可以从此处安装：Kodi中文网 安装后在插件的设置目录中，设置 m3u 的获取方式是本地文件还是 url 即可。\n设置完成后可在首页的 TV 观看电视直播，iptv 源的获取参照 Windows App01 Potplayer \u0026amp; Alist 一文中的 iptv 列表获取。\nKODI 手机遥控器设置和添加 手机端直接下载 Kodi remote control ，参考设置进行配置即可\n这里可能需要设置以下用户名和密码，来允许 HTTP 控制。\n树莓派投屏方案 根据 kodi 的 wiki 已知其已经不支持 ios8 以上的 Airplay 功能，因此针对投屏的需求，只能通过视频软件或者播放器的 UpnP/DLNA 支持进行投屏。\n在 kodi 的设置界面-\u0026gt;服务-\u0026gt;UpnP/DLNA 中选择启用的相关选项 在 ios 中设置-\u0026gt;对应的视频软件（如bilibili）-\u0026gt;本地网络选择启用 播放视频时左上角 tv 的按钮，并选中本地局域网中的 kodi 即可。\nTrouble Shooting 问题解决 Kodi 官方教程安装失败原因及解决 问题描述与分析\n尝试了 Ubuntu22.04+RaspBerry 4B+Kodi+Alist 的方案，发现这种方案遵循官方教程无法在 Ubuntu 中成功的安装 Kodi，成功安装后出现以下的问题：\ncommand not found 无对应的 desktop app desktop app 无法打开 该原因是由于基于官方PPA在 Ubuntu 上安装的 Kodi 似乎无法在 RaspBerry 的架构上执行，因此无法成功安装，具体可以参考如下的几个连接，其中的讨论对该原因也会有所讲解。\nHas anyone got kodi working on ubuntu 21.04 - Raspberry Pi Forums KODI for Ubuntu Raspberry Pi version : r/kodi (reddit.com) 同时官方 指出，这种方式不适用于 armhf，（似乎 raspberry 4b 的 arm64 也无法执行\nNote that this PPA only provides builds for Ubuntu i386 and Ubuntu amd64 but not for Ubuntu armhf, which can run on a Raspberry Pi.\n可以以此查看系统的架构：查看linux系统是哪种架构：AMD、ARM、x86、x86_64、pcc 或 查看Ubuntu的版本号-菜鸟笔记 (coonote.com) 架构间的区别如下：安装包amd,amd64,arm,arm64都有什么区别？ - Cloudreve Forum amd64是 X86架构的 CPU，64位版。amd64又叫 X86_64。主流的桌面 PC，笔记本电脑，服务器（包括虚拟机）都在用 X86_64的 CPU。 arm64是 ARM 架构的 CPU，64位版。苹果新出的电脑在用 ARM 架构的 CPU。有些路由器和嵌入式设备在用 arm64的 CPU。手机和安卓平板电脑最常用的 CPU 也是 ARM 架构的。 MIPS 是 MIPS 架构的 CPU。有些嵌入式设备和家用路由器在用 MIPS 架构的 CPU。 简单的说就是：\nAMD64=linux-64bit=X86 ARM64=linux- Aarch64 =ARM Aarch 指的就是 ARM architecture\n解决方案\n发现是架构不匹配的原因导致的时候，去查询相关的源是否有对应架构的安装包：Kodi Download (APK, DEB, EOPKG, PKG, RPM, TXZ, XBPS, ZST) (pkgs.org) 找到了 Arm64 的版本\n但是进去看可以发现实际上该安装还是指向了官方 PPA，安装的 ARCH 描述为 ALL（not true），不过好在后面有别的选项：\n找到下面的 arm64 的版本，详情页就能找到下载说明，由于是官方软件源，只需要 apt 安装就行，前提是将之前安装的会导致错误版本的 PPA 源卸载干净。\n可以到/etc/apt/sources.list.d/检查并将不需要的软件源删掉，再 sudo apt-get update 一下\nUbuntu 播放 4k 视频卡顿掉帧 这部分可能是由于 Ubuntu 和 RaspBerryPi 一起用的时候，对于硬件的控制比较麻烦，导致功能中的硬解没有开启的地方导致，而在后续开启 Ubuntu 22.04 硬解的时候，需要去修改 Bios 文件，导致我这边系统损坏了无法开机，就没有做进一步的测试。\n20.04 和之前的版本有找到对应的文档， 22.04 好像暂时没有，参考之前的方案进行修改的时候出现了开机损坏的情况，所以还是要慎重。\n检查硬解是否启用\n1 2 cat /proc/device-tree/soc/firmwarekms@7e600000/status cat /proc/device-tree/v3dbus/v3d@7ec04000/status 设置的参考资料：RPI4 \u0026amp; Ubuntu MATE - How to enable video acceleration (dedoimedo.com) 树莓派 HDMI 热插拔 树莓派的 HDMI 接口在长时间未使用，或者在开机的时候未连接显示器的时候，会默认以无显示输出的情况启动，导致电视无法正常输出图像。\n为此，我们需要开启设置中的 hdmi_force_hotplug=1，无论是否检测到 Hdmi 显示器，都默认有 hdmi 连接，确保无需每次需要视频输出的时候都重启树莓派，具体的操作步骤如下：\n适用于 RaspBerryPi OS\n1 vim /boot/config.txt # 默认配置文件的地址 如果不在该地址，就需要找到启动分区所在的目录，应该在该目录下，找到该文件后修改将以下两项打开或新增之后重启树莓派即可；\n1 2 hdmi_force_hotplug=1 hdmi_drive=2 hdmi_force_hotplug=1 设置树莓派使用 HDMI 热插拔模式，即使没有检测到 HDMI 显示器。 hdmi_drive=2 将树莓派设置为正常的 HDMI 模式（如果支持和启用，将发送声音）。如果没有这条线，树莓派将默认切换到 DVI（无音频）模式。 但是热插拔的情况下，可能会导致在最终使用 hdmi 输出的时候，树莓派自动设定的分辨率不符合我们的使用和设备预期，因此我们可能还要基于设备对树莓派的分辨率和输出模式做一个限制；\n1 2 hdmi_group=1 hdmi_mode=16 hdmi_group 指定分辨率格式1为 CEA，电视规格的分辨率；2为 DMT，计算机显示器使用的分辨率 hdmi_mode 不同分辨率格式下的指定分辨率和刷新率情况，具体可以见表 参考资料：\n解决树莓派不接HDMI导致开机VNC无信号问题和分辨率不对问题 – CyanDragon 树莓派配置文件 config.txt - HDMI 热插拔 | Cafeting (likfe.com) 自定义树莓派的显示分辨率 | 树莓派实验室 (nxez.com) 树莓派HDMI配置 — Cloud Atlas 0.1 文档 (cloud-atlas.readthedocs.io) FI","permalink":"https://hugotest-phi.vercel.app/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%B6%E5%BA%AD%E5%BD%B1%E9%9F%B3%E4%B8%AD%E5%BF%83/","summary":"\u003cblockquote\u003e\n\u003cp\u003e将 RaspBerry Pi 4B 作为家庭影视中心/机顶盒的核心就是 KODI 软件，这是考虑到以下的几点：遥控器的控制、对挂载 webdav 和其他的支持\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e最方便的方式可以选择以 KODI 为核心的两个 OS：LibreELEC、OSMC（推荐），这两个系统以 KODI 为默认启动，同时也支持远程登录和 Docker 部署等 Linux 的功能。后者更为推荐应该是前者的官方改进版本。\u003c/p\u003e\n\u003cp\u003e考虑到后续可能会将该 SD 卡用于其他用处，因此本文选择的是使用 RaspBerryPi OS 的方案，以下围绕该方案进行展开：\u003c/p\u003e\n\u003ch2 id=\"raspberry-pi-oskodialist-方案探究\"\u003eRaspBerry Pi OS+Kodi+Alist 方案探究\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e可以参考 trouble shooting，可以发现实际上安装 kodi 最简单的方式就是直接使用 apt，无需做其他的 PPA 添加。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"安装kodi\"\u003e安装Kodi\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install kodi\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e安装完后，使用 kodi 命令开启或者在开始菜单的软件中心中选择 kodi 打开。\u003c/p\u003e\n\u003ch3 id=\"设置-gpu-显存硬解相关\"\u003e设置 GPU 显存（硬解相关）\u003c/h3\u003e\n\u003cp\u003e首先做一下\u003cstrong\u003e固件的升级\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo rpi-update\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e然后\u003cstrong\u003e调整一下显存\u003c/strong\u003e：系统设置里面将 gpu_mem 调高一些，我使用的是 4G，调整到了 256MB，切记不要调整太高，否则可能会开机失败，重启后查看显存是否设置成功。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e查看 GPU 显存\u003c/strong\u003e的方式：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evcgencmd get_mem arm \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e vcgencmd get_mem gpu\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e最后在 kodi 中查看相关的选项的开关情况：\u003c/p\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://www.liujason.com/article/656.html\" target=\"_blank\" rel=\"noopener\"\u003e树莓派RaspberryPi 4B设置显存开启硬件加速 支持Emby|Plex|JellyFin转码 LiuJason\u0026rsquo;sBlog\u003c/a\u003e\n\u003c/p\u003e","title":"树莓派01 家庭影音中心"},{"content":" 本文介绍基于 Windows Clash Desktop 的代理服务器设置，可以为局域网内的设备提供代理服务，该方案可以解决一定的科学上网需求，但是没办法覆盖所有的场景，例如 PS5 的 Netflix ，其不走代理服务器，因此无法通过该方案解决，（软路由可破）\n本篇的设置内容主要会从两个方面出发：一个是服务器的开启和防火墙的设置、另一个是客户端如何设置使用对应的代理服务器。\nClash开启代理服务器 Clash 作为局域网代理服务器开启的方式十分简单，主要是以下几步。\n开启局域网访问 -\u0026gt; 设置端口，查看 ip -\u0026gt; 防火墙允许通行\n配置代理服务器 开启局域网访问： Allow LAN 打钩即可。 端口：设置好想要的 mixport 即可。\n防火墙允许通行： 防火墙-\u0026gt; 高级设置，找到 Clash 所有项，允许其在专用网络上通行。\n查看 ip：命令行输入 ipconfig/ all 里面的 WLAN 模块，可以找到自己的局域网 ip\n一些坑 TroubleShoot 这一部分主要的问题在于，防火墙这一步很多地方都没有提到，这样会导致 Clash 被防火墙拦截，客户端就无法找到代理服务器，导致设置代理服务器后（比如 IOS），显示 WIFI 异常，无法访问网络的问题。 有一些相关的资料表示，如果连接失败，也有可能是 server 服务和 TAp 服务的原因，将两个服务卸载后在尝试即可。（这一部分我没有遇到） 客户端设置代理服务器 这里介绍一下 IOS 设置代理服务器的步骤，Ubuntu 等桌面系统（包含网络设置的）设置步骤都是差不多的，\n实例：IOS 在 Wifi 链接的详细信息界面，选择配置代理服务器\n进入设置页后，改为手动，输入我们设置好的代理服务器的 IP 和对应的端口即可。\n设置完成后连接至该 WiFi 即可。\n","permalink":"https://hugotest-phi.vercel.app/posts/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BB%A3%E7%90%86%E5%85%B1%E4%BA%AB/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文介绍基于 Windows Clash Desktop 的代理服务器设置，可以为局域网内的设备提供代理服务，该方案可以解决一定的科学上网需求，但是没办法覆盖所有的场景，例如 PS5 的 Netflix ，其不走代理服务器，因此无法通过该方案解决，（软路由可破）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e本篇的设置内容主要会从两个方面出发：一个是服务器的开启和防火墙的设置、另一个是客户端如何设置使用对应的代理服务器。\u003c/p\u003e\n\u003ch2 id=\"clash开启代理服务器\"\u003eClash开启代理服务器\u003c/h2\u003e\n\u003cp\u003eClash 作为局域网代理服务器开启的方式十分简单，主要是以下几步。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e开启局域网访问 -\u0026gt; 设置端口，查看 ip -\u0026gt;  防火墙允许通行\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"配置代理服务器\"\u003e配置代理服务器\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e开启局域网访问\u003c/strong\u003e： Allow LAN 打钩即可。\n\u003cstrong\u003e端口\u003c/strong\u003e：设置好想要的 mixport 即可。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230626091350.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230626091350.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230626091350.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e防火墙允许通行\u003c/strong\u003e： 防火墙-\u0026gt; 高级设置，找到 Clash 所有项，允许其在专用网络上通行。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230626091506.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230626091506.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230626091506.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\n\u003cstrong\u003e查看 ip\u003c/strong\u003e：命令行输入 \u003ccode\u003eipconfig/ all\u003c/code\u003e 里面的 WLAN 模块，可以找到自己的局域网 ip\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230626091742.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230626091742.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230626091742.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Clash局域网代理共享"},{"content":"不同于 Docker 在 Windows 端借助 Desktop 可视化进行安装和配置，Linux 端没有默认的 Desktop 界面，因此会额外安装 portainer 作为我们 docker 的 Dashboard.\nInstall Docker on Ubuntu 该部分完全转载自官方 的安装指引，如果流程需要更新的时候可以移步官网检查，此外官网还包含了其他几种安装方式，这里就不介绍，这里只介绍基于 apt 的安装方式。\n设置 apt 的 repo 1 更新 apt 的索引，同时通过下载包来允许 Apt 基于 http 来索引仓库\n1 2 sudo apt-get update sudo apt-get install ca-certificates curl gnupg 2 安装 docker 官方的 GPG 秘钥\n1 2 3 sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg 3 配置对应的 repository\n1 2 3 4 echo \\ \u0026#34;deb [arch=\u0026#34;$(dpkg --print-architecture)\u0026#34; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \u0026#34;$(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;)\u0026#34; stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 完成上述设置之后，就可以开始安装 Docker 了。\n安装 docker-engine 1 2 3 # 更新apt索引 sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 查看是否安装成功 1 2 3 docker -v docker-compose -v docker compose version （待验证）理论上安装了 docker-compose-plugin 后，应该是已经成功安装了 compose，如果没有的话，可以尝试用下列命令来安装。\n1 sudo apt-get install docker-compose 测试服务是否能正常使用 1 sudo docker run hello-world 通过 hello-world 项目测试 docker 的拉取、构建、运行是否存在问题，通常来说正常安装之后，镜像是能正常的启动，可能出现问题的大多是网络部分，也就是 Pull 的环节，这个环节出问题，通常可以使用两种方式来解决：代理设置/ 换源。\nInstall Docker on RaspberryPi 参考官方的安装指令，下载官方提供的安装脚本进行安装，安装完后按照 Ubuntu 中的方式同样校验即可。\n1 2 3 4 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh # can add --dry-run to know what step we invoked # sudo sh ./get-docker.sh --dry-run 简单便捷\nSource Change or Proxy Setup 科学上网为了科学，通过换源或设置代理来加速镜像拉取，避免镜像拉取产生的问题，镜像拉取 docker pull 在 docker 中实际上是 daemon 及守护进程执行的，因此主要修改的是其相关设置部分。\n参考资料：docker更换镜像源 | 配置 HTTP/HTTPS 网络代理 - Docker从入门到实践 换源 Source Change 打开配置文件：\n1 vim /etc/docker/daemon.json 添加镜像源相关设置（添加如下内容）\n1 2 3 4 5 6 7 8 9 { \u0026#34;registry-mirrors\u0026#34; : [ \u0026#34;https://registry.docker-cn.com\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://cr.console.aliyun.com\u0026#34;, \u0026#34;https://mirror.ccs.tencentyun.com\u0026#34; ] } 配置完使用的所有镜像源后，即可重启 docker 来实现换源：\n1 2 sudo systemctl daemon-reload sudo systemctl restart docker.service 使用 docker info 查看配置是否成功：\n1 sudo docker info 在为 Ubuntu 的网络添加代理设置后，换源操作没有解决我无法 pull 相关镜像的问题，后续通过设置了 daemon 也使用代理解决了镜像拉取的问题。\n代理配置 Proxy Setup \u0026ldquo;docker pull\u0026rdquo; 命令是由 dockerd 守护进程执行。而 dockerd 守护进程是由 systemd 管理。因此，如果需要在执行 \u0026ldquo;docker pull\u0026rdquo; 命令时使用 HTTP/HTTPS 代理，需要通过 systemd 配置\nDocker 在拉取、构建、运行三个阶段中，代理的配置是相互独立互不影响的，如果我们希望某个阶段中使用相应的代理，就需要分别进行配置，这里主要介绍的是镜像拉取环节使用的代理，其他部分的代理设置也可以在参考文章中找到。\nA. 为 docker 创建对应的配置文件夹\n1 mkdir -p /etc/systemd/system/docker.service.d B. 创建代理相关的配置文件，并填入代理相关信息，配置文件的路径为：/etc/systemd/system/docker.service.d/http-proxy.conf\n1 vim /etc/systemd/system/docker.service.d/http-proxy.conf C. 填入相关的代理信息：\n1 2 3 4 5 [Service] Environment=\u0026#34;HTTP_PROXY=http://192.168.157.231:7890/\u0026#34; Environment=\u0026#34;HTTPS_PROXY=http://192.168.157.231:7890\u0026#34; Environment=\u0026#34;NO_PROXY=localhost,127.0.0.1,.example.com\u0026#34; D. 服务重启\n1 2 sudo systemctl daemon-reload sudo systemctl restart docker E. 查看是否配置成功\n1 sudo docker info 通常来说只要代理服务器正常运行，到这里应该就可以解决镜像拉取不下来的问题了，接下来为 Docker 安装一个 Dashboard 便于我们查看 Container 的运行情况，以及进行简单的修改等。\nInstall Portainer for Docker 参考资料：Docker环境5分钟快速部署Portainer-ZHIHU 这里我们使用 docker-compose 安装 portainer，实际上 docker-compose 实际上就是将 docker 的运行指令写成一个 yml 文件的形式，个人偏好这种方式，这种方式更方便对执行指令的掌握和查看，而且便于长期管理。\n首先随便创建一个目录来存放对应的数据和配置：\n1 2 3 4 5 mkdir -p ~/workspace/docker-compose-dir/portainer cd ~/workspace/docker-compose-dir/portainer touch docker-compose.yml vim docker-compose.yml 编写对应的 docker-compose 文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3\u0026#39; services: portainerce: image: portainer/portainer-ce:latest container_name: portainerce restart: unless-stopped security_opt: - no-new-privileges:true volumes: - /etc/localtime:/etc/localtime:ro - /var/run/docker.sock:/var/run/docker.sock:ro - ./portainer-data:/data ports: - 9000:9000 在当前目录执行指令，启动安装和构建\n1 docker-compose up -d 执行后我们即可访问：localhost:9000 进入 portainer ，首次进入需要设置一个管理员账户，设置完成后即可，\nFI 完成了上述设置之后，就可以开始用 docker 拉取和构建自己需要的镜像了，对于 NAS，树莓派，服务器，各种东西都可以开始愉快的玩耍了。\n","permalink":"https://hugotest-phi.vercel.app/posts/docker01_linux/","summary":"\u003cp\u003e不同于 Docker 在 Windows 端借助 Desktop 可视化进行安装和配置，Linux 端没有默认的 Desktop 界面，因此会额外安装 portainer 作为我们 docker 的 Dashboard.\u003c/p\u003e\n\u003ch2 id=\"install-docker-on-ubuntu\"\u003eInstall Docker on Ubuntu\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e该部分完全转载自\u003ca href=\"https://docs.docker.com/engine/install/raspbian/\" target=\"_blank\" rel=\"noopener\"\u003e官方\u003c/a\u003e\n的安装指引，如果流程需要更新的时候可以移步官网检查，此外官网还包含了其他几种安装方式，这里就不介绍，这里只介绍基于 apt 的安装方式。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"设置-apt-的-repo\"\u003e设置 apt 的 repo\u003c/h3\u003e\n\u003cp\u003e1 更新 apt 的索引，同时通过下载包来允许 Apt 基于 http 来索引仓库\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install ca-certificates curl gnupg\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e2 安装 docker 官方的 GPG 秘钥\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo install -m \u003cspan class=\"m\"\u003e0755\u003c/span\u003e -d /etc/apt/keyrings\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecurl -fsSL https://download.docker.com/linux/ubuntu/gpg \u003cspan class=\"p\"\u003e|\u003c/span\u003e sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo chmod a+r /etc/apt/keyrings/docker.gpg\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e3 配置对应的 repository\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  \u003cspan class=\"s2\"\u003e\u0026#34;deb [arch=\u0026#34;\u003c/span\u003e\u003cspan class=\"k\"\u003e$(\u003c/span\u003edpkg --print-architecture\u003cspan class=\"k\"\u003e)\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s2\"\u003e  \u0026#34;\u003c/span\u003e\u003cspan class=\"k\"\u003e$(\u003c/span\u003e. /etc/os-release \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"nv\"\u003e$VERSION_CODENAME\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"k\"\u003e)\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34; stable\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e完成上述设置之后，就可以开始安装 Docker 了。\u003c/p\u003e","title":"Docker Configuration01 Install on Linux"},{"content":" 最近入手了树莓派 4B，打算基于树莓派做一些有趣\u0026amp;有用的项目，该系列笔记来记录个人树莓派学习和开发的历程。\n连载确认！该系列文章将会从装机开始，介绍树莓派用于以下几个项目的开发和部署过程：\n基于 Docker 的家庭服务器 智能家居控制中枢 影音中心 \u0026amp; 电视机顶盒 物联网 or AI 的衍生应用实践 本篇首先介绍亮机和开发环境设置过程，包含：组装、系统安装、远程开发环境设置（SSH、XRDP）\n树莓派组装 树莓派组装上比较防呆接口，唯一需要注意的是散热块和风扇的安装：\n在 CPU 和缓存等模块上装上散热片 风扇的固定位置在外壳上，接线如下图所示 SD 卡的安装位置在背面 系统安装 该部分仅介绍我使用的系统安装和烧录软件，系统的选择需要根据自己所拥有的设备，以及目的去选择。\n硬件准备：SD 卡，读卡器，一台正常运行的 PC，可外接的屏幕。\n系统烧录软件安装 Raspberry-Software : 安装 Raspberry Pi Image 系统烧录软件\n系统选择和安装 使用读卡器将 SD 卡连接至电脑，即可通过烧录软件选择系统进行安装：\n耐心等待即可。\n远程开发环境设置 开发环境主要需要注意的是以下几项设置，实现了如下的设置之后就可以在没有显示器的条件下实现对树莓派的开发和控制。\nSSH 开放远程连接，实现远程开发环境 Proxy 设置，这里使用 Ubuntu 读取局域网代理服务器的方案。 Docker 项目部署和实现 【optional】XRDP、VNC 远程桌面连接 【optional】Zerotier 等方案实现内网穿透 【optional】文件同步（rsync）、共享（smb）方案 SSH 的部分参考 [[SSH]] 一文中的远程权限开放设置，以及免密登陆配置，方便对树莓派的远程连接，这里就不再赘述。\nProxy 部分可以参考本文的解决方案，基于 ubuntu 系统设置全局的网络代理服务器，减少在终端环境中需要为多个不同 CLI 工具设置代理的压力，需要注意的是，Docker 的代理设置还是需要独立进行配置，参考下面的 docker 一文。\nDocker 安装的部分参考 [[Docker01_linux]] 一文进行 Linux 环境下的 Docker 和对应的 Dashboard：portainer 的安装和测试。\nXRDP、VNC 设置 这里推荐 XRDP 做 Windows 和 Linux 之间的远程桌面连接，GUI 界面首选，我这里只简单介绍以下 XRDP 远程连接的方式。\n参考连接：如何在Ubuntu 20.04上安装Xrdp服务器 | myfreax Xrdp 是 Microsoft 远程桌面协议（RDP）的开源实现\n安装 Xrdp 以及验证 直接使用 apt 安装xrdp\n1 sudo apt-get install xrdp 安装完成后，服务应该会自动启动，可以输入下列的内容进行验证：\n1 sudo systemctl status xrdp 输出将如下所示，则服务已经运行了：\n如果服务还未运行，尝试将 xrdp 用户添加到 ssl-cert 组，然后重启服务\n1 2 sudo adduser xrdp ssl-cert sudo systemctl restart xrdp 至此已经安装完成了，其默认监听 3389 端口，如果系统上配备了防火墙，则需要打开其监听的端口，同时要允许从指定的 IP 地址和 IP 范围来访问其服务器。可以运行以下的命令\n1 sudo ufw allow from 192.168.33.0/24 to any port 3389 xrdp 服务运行起来以后需要添加对应的用户用来登录：\n1 sudo adduser aiken 这里可能会遇到使用 windows 远程登录之后，输入密码以后蓝屏没有进入主界面的现象，这可能是由于 Root 用户远程登录的默认问题 ，有以下两种方式可以解决：\n可以通过使用别的账户进行登录即可。 1 sudo adduser others （推荐）修改远程连接的配置，实现主用户可正常登录远程桌面 1 2 sudo adduser xrdp ssl-cert sudo vim /etc/X11/xrdp/xorg.conf 找到 Option DRMDevice 行，并将其选项修改为如下\nOption \u0026#34;DRMDevice\u0026#34; \u0026#34;\u0026#34; 重启树莓派，即可实现远程桌面的正常连接。\nWindows 连接远程桌面 Win+S+\u0026lsquo;mstsc\u0026rsquo;| 远程桌面连接 输入指定的 IP 即可打开对应的远程连接页面，输入 Ubuntu 的对应密码即可进入远程桌面。 内网穿透方案 使用 zerotier 执行初步的内网穿透方案，可以参考 [[NAT穿透]]一文\n文件同步\u0026amp;共享方案 该部分实际上主要介绍两种方案：RSYNC 文件夹同步 \u0026amp; SMB 文件共享\n【不推荐】基于 RSYNC 和 SSH 免密登陆和计划任务，来进行文件夹的同步：这样会在两个系统上存有同个文件的备份，也可以选择同步删除和上传，保持文件夹的一致性。\n但是该方案实际上不太符合树莓派的使用场景：除非需要做备份，否则通常仅有少量的文件传输场景，便于环境配置，因此跑计划任务算是比较多余的一件事。\n如果有相关需求的话可以参考该文 [[Transfer-Sync-Files]]\n【推荐】使用 SMB 进行文件的共享：这种方案实际上就是 Windows 的共享文件夹策略，方便局域网内的各个设备进行访问。\nwindows 共享文件的设置和 Ubuntu 上访问共享文件夹的方式可以参考[[局域网共享]]进行配置\n","permalink":"https://hugotest-phi.vercel.app/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8%E5%88%9D%E6%8E%A2/","summary":"\u003cblockquote\u003e\n\u003cp\u003e最近入手了树莓派 4B，打算基于树莓派做一些有趣\u0026amp;有用的项目，该系列笔记来记录个人树莓派学习和开发的历程。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e连载确认！该系列文章将会从装机开始，介绍树莓派用于以下几个项目的开发和部署过程：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e 基于 Docker 的家庭服务器\u003c/li\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e 智能家居控制中枢\u003c/li\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e 影音中心 \u0026amp; 电视机顶盒\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e 物联网 or AI 的衍生应用实践\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e本篇首先介绍亮机和开发环境设置过程，包含：组装、系统安装、远程开发环境设置（SSH、XRDP）\u003c/p\u003e\n\u003ch2 id=\"树莓派组装\"\u003e树莓派组装\u003c/h2\u003e\n\u003cp\u003e树莓派组装上比较防呆接口，唯一需要注意的是散热块和风扇的安装：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在 CPU 和缓存等模块上装上散热片\u003c/li\u003e\n\u003cli\u003e风扇的固定位置在外壳上，接线如下图所示\u003c/li\u003e\n\u003cli\u003eSD 卡的安装位置在背面\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230626091027.jpg\"\u003e\r\n    \u003cimg alt=\"微信图片_20230626091027.jpg\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230626091027.jpg\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230626091027.jpg\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"微信图片_20230626091027.jpg\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"系统安装\"\u003e系统安装\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e该部分仅介绍我使用的系统安装和烧录软件，系统的选择需要根据自己所拥有的设备，以及目的去选择。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e硬件准备：SD 卡，读卡器，一台正常运行的 PC，可外接的屏幕。\u003c/p\u003e","title":"树莓派00 组装和亮机篇"},{"content":" Tmux 作为一款优秀的终端复用器，前面已经介绍过，这里在介绍一款有着相同功能的平替，个人认为 zellij 的 UI 各方面的设计，使得其相比于 Tmux 有着更低的入门难度，也避免了需要记大量快捷键，因此这里介绍一下该工具。\nZellij 是一款终端复用器，有什么功能可以完全参考 Tmux ，还支持了许多有趣的特性和自定义 Layout 等功能（可能后续用到的话会完善该部分笔记），详细的可以参考官网的介绍，接下来就简单的介绍一下安装和一些自定义的 Alias。\nInstall 安装 Zellij 是基于 Rust 编写，因此在安装之前需要安装 rust 和 cargo（类似 rust 的包管理器），安装可以参考 Rust 官方网站（推荐） | The Cargo Book | Rust Wiki CN 官方网站中介绍了 WSL 的安装指令如下：\n1 2 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh #--proto以及--tlsvl在Linux或者Macos安装的时候可以忽略 安装完成后可以使用如下命令，基于 Cargo 安装 zellij：\n1 cargo install --locked zellij 如果出现了问题也可以尝试先更新 rust\n1 rustup update Binary Download 二进制文件安装下载 如果是不便于安装的环境可以使用这种方式来使用 zellij，在 release page 中下载二进制包 .tar.gz 后执行：\n解压二进制文件：\n1 tar -xvf zellij*.tar.gz 修改执行权限：\n1 chmod +x zellij 然后就可以直接执行 zellij 文件了，可以将该文件路径加入系统的路径 中，即可随处调用（也可以使用 alias 的方式），可以参考一下上文中系统路径的添加方法。\nAlias 别名设置 由于 Zellij 的一些指令比较长，可以简单的设置一下别名（bashrc, zshrc），用来便于日常使用：\n1 2 3 4 alias ze=\u0026#39;zellij\u0026#39; alias zels=\u0026#39;zellij list-sessions\u0026#39; alias zeks=\u0026#39;zellij kill-sessions\u0026#39; alias zeat=\u0026#39;zellij attach\u0026#39; 可以看出上述的指令和 Tmux 的十分相似，功能也和名称一致，这里就不在赘述，其他的使用快捷键在进入了 zellij 界面后都可以看到。\n效果展示 简单放一下 zellij 使用的效果图，相信能 Get 到为啥说比较容易上手，同时 UI 也十分的舒服。\nFI 基础的功能对于日常使用已经十分充分，后续又其他的功能需求（如果有自己定制的东西）的话会慢慢更新，否则的话应该就是基于官方文档去配置和使用了。\n","permalink":"https://hugotest-phi.vercel.app/posts/linuxzellij/","summary":"\u003cblockquote\u003e\n\u003cp\u003eTmux 作为一款优秀的终端复用器，前面已经介绍过，这里在介绍一款有着相同功能的平替，个人认为 zellij 的 UI 各方面的设计，使得其相比于 Tmux 有着更低的入门难度，也避免了需要记大量快捷键，因此这里介绍一下该工具。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://zellij.dev/documentation/installation.html\" target=\"_blank\" rel=\"noopener\"\u003eZellij\u003c/a\u003e\n 是一款终端复用器，有什么功能可以完全参考 Tmux ，还支持了许多有趣的特性和自定义 Layout 等功能（可能后续用到的话会完善该部分笔记），详细的可以参考官网的介绍，接下来就简单的介绍一下安装和一些自定义的 Alias。\u003c/p\u003e\n\u003ch2 id=\"install-安装\"\u003eInstall 安装\u003c/h2\u003e\n\u003cp\u003eZellij 是基于 Rust 编写，因此在安装之前需要安装 rust 和 cargo（类似 rust 的包管理器），安装可以参考 \u003ca href=\"https://www.rust-lang.org/tools/install\" target=\"_blank\" rel=\"noopener\"\u003eRust 官方网站（推荐）\u003c/a\u003e\n |  \u003ca href=\"https://doc.rust-lang.org/cargo/getting-started/installation.html\" target=\"_blank\" rel=\"noopener\"\u003eThe Cargo Book\u003c/a\u003e\n  | \u003ca href=\"https://rustwiki.org/zh-CN/cargo/getting-started/installation.html\" target=\"_blank\" rel=\"noopener\"\u003eRust Wiki CN\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e官方网站中介绍了 WSL 的安装指令如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecurl --proto \u003cspan class=\"s1\"\u003e\u0026#39;=https\u0026#39;\u003c/span\u003e --tlsv1.2 -sSf https://sh.rustup.rs \u003cspan class=\"p\"\u003e|\u003c/span\u003e sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#--proto以及--tlsvl在Linux或者Macos安装的时候可以忽略\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e安装完成后可以使用如下命令，基于 Cargo 安装 zellij：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecargo install --locked zellij\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果出现了问题也可以尝试先更新 rust\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erustup update\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Terminal multiplexer Zellij"},{"content":" 该章节主要介绍 Stable-Diffusion 中模型的训练，考虑到硬件条件的限制，实际上这里介绍的训练，都是针对大模型的各种微调技术（Lora，Dreambooth，HyperNetwork, \u0026hellip;），这里会以 LoRA 模型的训练为主。\n参考文献：\nAIGC教程：Stable Diffusion精进，如何训练特定画风LoRA模型？ | 游戏大观 | GameLook.com.cn stable diffusion打造自己专属的LORA模型 - 王清培 - 博客园 (cnblogs.com) sd-scripts/train_README-zh.md at main · kohya-ss/sd-scripts · GitHub Train LoRA LoRA 的优势就是其模型更小，且更加模块化；也就是说其的训练成本和要求都更低，同时使用代价小，可以作为某种风格插件或者角色插件来使用。\n使用 LoRA 进行 Stable Diffusion 的高效参数微调 (huggingface.co) [2106.09685] LoRA: Low-Rank Adaptation of Large Language Models (arxiv.org) 其中蓝色的是预训练好的源网络，而橙色的是新加的网络，通过控制 R 的宽度（文章主要论证了大模型的参数可能存在较低维度的秩，因此可以使用较小的 R 来对大模型的参数造成有效的影响），可以有效的减少需要训练的网络的 Size。\n事前准备 这里只介绍本地训练，训练也可以在 Colab Notebook 等在线训练集群中进行，这里就不进行介绍了\nWebUI + 想训练的基础 SD 模型 .txt 带说明的文本文件 Training Repo（sd-script 、lora-script ） 数据集准备（准备好训练图像） 训练包准备 这里我们使用 lora-script 来进行模型训练，lora-script 实际上是 sd-script 之外在包了一层，新增了一些可视化的功能和一些其他的脚本，让 sd-script 更加易用，它调用 sd 中的脚本来实现训练，但是封装了一些注释和整理，此外还支持的 tensorboard 可视化。\nsd-script 本身包含了训练 lora、dreambooth、text-embedding、UNet、Text Encoder、图像生成、模型转换等多种功能。lora-script 还是主要专注于 LoRA 训练\n查看 repo 也能知道 lora-script 中包含了 sd-script，所以我们部署的时候只需\n1 git clone --recurse-submodules https://github.com/Akegarasu/lora-scripts 即可将需要的库安装下来，然后安装环境和相关以来只需要执行 .\\install.ps1 即可（该脚本有 cn 版本，但是可能会出现问题），其会安装 sd-scripts 和 lora-scripts 需要的库。具体的可以参考相关 repo（sd-script 详细说明，lora-script 有简化版说明）。\n安装的时候可能会出现虚拟环境未激活的问题，我们可以提前在改目录执行一次 python -m venv venv 一次即可。\nFinish.\n数据集准备 准备数据集的时候，要根据当前的设备显存对图片进行预处理，避免图片的分辨率过大，导致显存爆了，这里可以使用微软自己的 Powertoys 对文件进行批量 resize。\n数据需求：\n如果希望有更好的泛化性，训练素材中应该包含各种：角度、表情、光线。 如果是角色的话，建议尽可能的手机正面，侧面，背面，头像特写， 画风素材可以多一点 可以考虑扣白底： https://pickwant.com/home 简单预处理：调整分辨率（64 的倍数），裁剪。 数据量：如果是角色训练集在 20~50 左右足够，但是重要的是训练数据和训练轮次之间需要根据可视化做一个协调，避免过拟合（有时候可能也允许过拟合，取决于使用的场景）或者欠拟合的情况发生，原则上讲数据数量和轮次是正相关的关系。 预处理之生成图像描述：图像描述实际上是作为训练的标签存在，而显然，我们需要自动生成描述，如果还记得之前的文档，图生图功能中有反向推演提示词的方法，同样我们也会用该 Deepbooru 方法去生成标签，webui 中提供了一个专门的入口：\n在 resize 完成后，我们执行改生成图像描述的方法，指定好原图像位置和预处理之后的文件夹名字位置即可。\n预处理之后的文件夹会包含原图和对应生成的描述 txt 文件。 生成的描述文件可以 check 一下进行手动修改，错误的标签可能会引导出错误的训练方向。 为了便于 LoRA 的后续描述生成相同的效果，可以删除部分不必要的标签，令重要的标签和效果的相关度提高，并覆盖部分细节标签，可以理解成把一系列标签打包成一个标签。 训练数据就位： 将训练数据转移到 \u0026lt;...\u0026gt;/lora-scripts/train/ 中，如果没有该 train 目录就创建一个，单次的训练数据放在一个文件夹中，例如 \u0026lt;..\u0026gt;/train/train_1_person/\n正则化数据准备(option)：在 train 中新建一个 reg 文件夹，用于正则化训练，命名和此次训练的文件夹名相同，例如：\u0026lt;..\u0026gt;/train/reg/train_1_person/，在其中放的数据和训练数据应该是同类的不同对象。\n正则化的作用通常是避免模型过拟合，对模型添加额外的约束。例如我们训练一个猫，正则文件夹里应该同样存放猫（别的猫）的照片。\n基础模型就位：将训练用到的基础模型复制到 \u0026lt;...\u0026gt;/lora-scripts/sd-models/ 中，lora 是针对基础模型的注入（额外的 FC），对原模型进行部分的调整。\n注意事项： 避免文件名重复，使用相同的文件后缀能够避免文件名重复的问题。\n训练脚本编辑 better read: sd-scripts/train_network_README-zh.md at main · kohya-ss/sd-scripts (github.com) 接下来就是编辑训练脚本中的基础设置，lora-scripts 中的注释已经非常详细的写好了每个参数的含义，这里就介绍一些可能需要或者常用的参数设置：\n训练相关的一些设置如下\nsave_every_n_epochs 会决定我们最终获得几个模型，这里也可以设置一下。 reg_data_dir 设置正则化的目录，为空为默认不启用。 \u0026hellip; 其他的看看注释 还有一些输出相关的设置，包括输出模型的目录和名称，名称最好修改，避免一直都是默认的错误覆盖了：\n目录最好用 10_\u0026lt;EN\u0026gt; 或者纯数字的目录，然后路径填写的时候只填写到上级目录，比如说数据存放在 \u0026lt;...\u0026gt;/train/10_ron，那么脚本中就填写到 ./train，正则化目录同理。\n其他参数设置简单推荐：\nunet_lr 一般=lr lr_scheduler: constant_with_warmup 用的蛮多 优化器： use_lion 目前最好的，但是有正则化素材最好别开 编辑完成后直接执行该 ps1 脚本即可。\n脚本运行过程中可能会出现 nomodule named triton 的错误，可能是由于 windows 不支持该模块导致的，但是不影响最后的生成。\nLoRA 模型测试和选择 将模型导入 /extensions/sd-webui-additional-networks/models/lora 中，然后利用之前介绍过的 scripts 的 xyzplot 功能，分别测试和对比各个模型的效果，选择其中效果好的保留。\n成品展示 \u0026amp; 简单心得 用我家猫小荣的 10-14 张照片训练出来了小荣的 Lora 模型（DreamBooth）也训了一下，但是显存（3070）不太够。\n训练 Lora 中使用了如下的参数配置：\nClilloutmix 作为底层模型 使用训练 DreamBooth 中生成的 700 张猫的图片作为正则化数据集 BatchSize=2，Lr=e-4, Lion, Cosine_with_restarts, Max_train_epoch=10 此外，由于图片少（一致性太强）训练轮次多，应该是有些过拟合，Lora 调用时只能在 3 以下，不然难以和原图区分，可以对训练轮次和图片数量做一下调整。\n训练的时候打标签除了自动生成的，最好还是主动去修改，各种细节剖开来，描述好姿势，颜色，背景，表情等，后面学到的模型对各个部分进行修改的化比较方便区分，避免全都耦合在一起。\n此外标签中要给特定的对象一个特定的标签，方便我们产出该指定效果（或者角色）。\n\u003c!DOCTYPE html\u003e\r00009-3706840146.png\r00021-1903439770.png\r00031-4141742147.png\r00034-1003575578.png\r00000-4244496505.png\r00021-3282103832.png\r00024-4215830362.png\r00056-533810957.png\r00001-2335627500.png\rDreambooth DreamBooth: Fine Tuning Text-to-Image Diffusion Models for Subject-Driven Generation。 这种训练方式旨在微调 diffusion model 使其生成的图像专注于某个 object，具体可以看下面的示例图\n相关资源链接： webui训练插件 | offical repo | Paper | Dreambooth原理与实践 如果需要深入了解实现原理的可以查看官方论文和对应的 repo 内容。\n其具备以下的优势：\n仅需要同一个主体（动物，模型，等） 的少量图片即可（3 到 5 张可以，但是越多越好） 可以基于该主体生成各种图片 针对该场景考虑将训练数据扣成白底可能也会使得生成的效果更好。\n具体的训练的详细介绍，可以参考训练插件页面的说明进行尝试，这里简单介绍一下工作流程：\nA. 模型创建：Dreambooth tab -\u0026gt; \u0026ldquo;Create Model\u0026rdquo; sub-tab -\u0026gt; 确定一个新的模型名称 -\u0026gt;选择本地的模型 / HF(model URL \u0026amp; token) -\u0026gt; 确定后源 ckpt 会暂时存储在 models\\dreambooth\\MODELNAME\\working -\u0026gt; 点击 Create\nB. 参数设置：Settings tab -\u0026gt; 是否使用 LoRA、BatchSize、Epochs 、学习率等等的设置都是基本的参数就不在介绍\n设置(settings)中的 performance wizard (WIP) 中可以查看建议的参数。\nC. Concepts 设置：主要有两个类别：数据路径 + （class + prompt）\n数据路径不在赘述 Prompt 指的是我们的目标样本应该用什么提示词 Class 填入的是与目标同类但是不同个体的样本，避免过拟合 D. Saving 设置： 主要是设置我们各种模型的保存策略，类似步长之类的。\nE. Generate 设置：生成过程中的调整\n设置完成后开始训练即可，可以看训练中的 loss 和模型训练过程中生成的图片，AFK，训练完成后就可以看到训练好的 CKPT 了。\nTextual Inversion 相关资源链接：论文 | 官方代码 | webui说明 | textual-inversion.github.io 其全称为 An Image is Worth One Word: Personalizing Text-to-Image Generation using Textual Inversion\nTextual Inversion： 功能和其名字相互对应，反转 Text2Img 的过程，Img2Text 地建立图像与指定文本（Prompt）的关联。也就是说，当我们希望输入特定的 Prompt 能稳定的产生某个效果的时候，可以利用 Textual Inversion 技术来对模型进行改造，使得该特定的 prompt 能取得特定效果。\n实际上该技术也能取得和 Dreambooth 类似的效果，具体可以看论文和例子，这里也只简单介绍一下训练和使用。\nA. 创建 Word Embedding（指定 Prompt）：\n在 Train 标签页下创建 Embedding 页面，name 指定一个关键字（prompt），该 prompt 代表我们后续要训练出来的概念，创建完成后，就可以在 /\u0026lt;...\u0026gt;/stable-diffusion-webui/embeddings 路径下看到我们创建的 pt 文件\nB.数据预处理：同 Lora 介绍的预处理图像，准备好训练数据\nC.参数设置：\nTrain-\u0026gt; Train 页面中，只训练 Embedding，所以 Hypernetwork 的地方放空。 填写的基本学习率等参数就不再赘述， 填写：数据集目录、Log 目录等即可 \u0026ldquo;Prompt template\u0026quot;需要注意下, 提供了几种可选的训练模式: style_filewords.txt: 表示训练画风 subject_filewords.txt: 表示训练人物或物体 D.选择训练 Embedding：即可开始训练\nE.使用：放在 /\u0026lt;...\u0026gt;/stable-diffusion-webui/embeddings 中，在相关生成过程中，填写 Prompt 的时候像 easynagetive 启用即可。\nHyperNetworks NovelAI Improvements on Stable Diffusion | by NovelAI | Medium Hypernetwork 是一种微调技术（by Novel AI ），它是一个小型附加神经网络附加在 Stable Diffusion 模型上以修改其风格，这种方式和当时的论文并不一致，当时的 HyperNetwork 是通过修改权重来进行调整，NovelAI 中使用到的则是添加一个小型的线性附加网络。\n具体而言，其插入到噪声预测器 UNet 的交叉注意力模块中，（通常情况下是一个简单的神经网络：具有 dropout 和激活函数的全连接线性网络）通过插入两个转换 key 和 query 向量的网络来劫持交叉注意力模块。\n其训练过程与 Text Inversion 几乎一致，这里就不在赘述，只描述部分不同：\n创建模型的时候在 Train/Create Hypernetwork 选项卡 训练的时候选择 train hypernetwork 使用时存放的目录（应该也可以存放在 Addition Network 的文件夹中）为： stable_difusion\\stable-diffusion-webui\\models\\hypernetworks 像 Lora 一样启用即可。 FI stable diffusion 的介绍暂时就到这边了，原理相关的东西就先不介绍了，以后如果有必要的话，或者谁有需求的话可以联系我更新。\n通过训练小荣来给出一个详细的参数设置（Dreambooth 和 Lora 和 TextInversion） ","permalink":"https://hugotest-phi.vercel.app/posts/stablediffusiontraining/","summary":"\u003cblockquote\u003e\n\u003cp\u003e该章节主要介绍 Stable-Diffusion 中模型的训练，考虑到硬件条件的限制，实际上这里介绍的训练，都是针对大模型的各种微调技术（Lora，Dreambooth，HyperNetwork, \u0026hellip;），这里会以 LoRA 模型的训练为主。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e参考文献：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://www.gamelook.com.cn/2023/04/514936\" target=\"_blank\" rel=\"noopener\"\u003eAIGC教程：Stable Diffusion精进，如何训练特定画风LoRA模型？ | 游戏大观 | GameLook.com.cn\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnblogs.com/wangiqngpei557/p/17301360.html\" target=\"_blank\" rel=\"noopener\"\u003estable diffusion打造自己专属的LORA模型 - 王清培 - 博客园 (cnblogs.com)\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/kohya-ss/sd-scripts/blob/main/train_README-zh.md\" target=\"_blank\" rel=\"noopener\"\u003esd-scripts/train_README-zh.md at main · kohya-ss/sd-scripts · GitHub\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"train-lora\"\u003eTrain LoRA\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLoRA 的优势就是其模型更小，且更加模块化；也就是说其的训练成本和要求都更低，同时使用代价小，可以作为某种风格插件或者角色插件来使用。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://huggingface.co/blog/zh/lora\" target=\"_blank\" rel=\"noopener\"\u003e使用 LoRA 进行 Stable Diffusion 的高效参数微调 (huggingface.co)\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://arxiv.org/abs/2106.09685\" target=\"_blank\" rel=\"noopener\"\u003e[2106.09685] LoRA: Low-Rank Adaptation of Large Language Models (arxiv.org)\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230706171541.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230706171541.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230706171541.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e其中蓝色的是预训练好的源网络，而橙色的是新加的网络，通过控制 R 的宽度（文章主要论证了大模型的参数可能存在较低维度的秩，因此可以使用较小的 R 来对大模型的参数造成有效的影响），可以有效的减少需要训练的网络的 Size。\u003c/p\u003e\n\u003ch3 id=\"事前准备\"\u003e事前准备\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这里只介绍本地训练，训练也可以在 Colab Notebook 等在线训练集群中进行，这里就不进行介绍了\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003eWebUI + 想训练的基础 SD 模型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.txt\u003c/code\u003e 带说明的文本文件\u003c/li\u003e\n\u003cli\u003eTraining Repo（\u003ca href=\"https://github.com/kohya-ss/sd-scripts\" target=\"_blank\" rel=\"noopener\"\u003esd-script\u003c/a\u003e\n、\u003ca href=\"https://github.com/Akegarasu/lora-scripts\" target=\"_blank\" rel=\"noopener\"\u003elora-script\u003c/a\u003e\n）\u003c/li\u003e\n\u003cli\u003e数据集准备（准备好训练图像）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"训练包准备\"\u003e训练包准备\u003c/h3\u003e\n\u003cp\u003e这里我们使用 lora-script 来进行模型训练，lora-script 实际上是 sd-script 之外在包了一层，新增了一些可视化的功能和一些其他的脚本，让 sd-script 更加易用，它调用 sd 中的脚本来实现训练，但是封装了一些注释和整理，此外还支持的 tensorboard 可视化。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003esd-script 本身包含了训练 lora、dreambooth、text-embedding、UNet、Text Encoder、图像生成、模型转换等多种功能。lora-script 还是主要专注于 LoRA 训练\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e查看 repo 也能知道 lora-script 中包含了 sd-script，所以我们部署的时候只需\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone --recurse-submodules https://github.com/Akegarasu/lora-scripts\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e即可将需要的库安装下来，然后安装环境和相关以来只需要执行 \u003ccode\u003e.\\install.ps1\u003c/code\u003e 即可（该脚本有 cn 版本，但是可能会出现问题），其会安装 sd-scripts 和 lora-scripts 需要的库。具体的可以参考相关 repo（sd-script 详细说明，lora-script 有简化版说明）。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e安装的时候可能会出现虚拟环境未激活的问题，我们可以提前在改目录执行一次 python -m venv venv 一次即可。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eFinish.\u003c/p\u003e","title":"AIGC05 Stable Diffusion Model Training"},{"content":" 手机到电脑端的图像备份和预览往往是一个大问题，特别是当多个手机要备份的时候，说难不难，但说简单也确实有很多麻烦的地方，因此我推荐 Immich 的解决方案。\nImmich 是一个基于个人开发者开发的开源 Github 项目，immich-app/immich ，该解决方案有以下的一些优势：\n移动端支持：移动端实现便于手机的随时和自动同步； 多用户支持：多用户的权限管理、分割、以及用户间的相册共享； Live 格式支持：支持各种原生格式存储， Self-hosted photo and video backup solution directly from your mobile phone.\n因此我本人推荐按照以下的方式来使用：针对家庭等环境，多用户部署在 NAS 或者某台 PC 上，可以长期或者定期的启动备份服务，然后就可以将手机中的照片空间释放掉。由此可以实现：\n通过共享文件夹共建家庭相册； 权限分割个人相册； 定期/自动备份手机中的照片，并清理对应的存储空间； Install 安装和部署 官方网站中有各种不同环境下安装的说明和实例已经足够详细，强烈建议根据自己的不同需求查看相关文档；和官方一样，我这边也推荐使用 docker compose 进行安装和部署。Thanks to docker，部署与安装变得简单。\n1 2 mkdir ./immich_app cd ./immich_app Download 下载 安装实际上只需要两个文件，一个是 .env 用来填写配置，另一个是 docker-compose.yml 文件用来拉取镜像和部署。\n下载 docker-compose.Yml 文件和 example.env 文件，可以使用下列的 wget 命令，或者直接去对应的 Page。\n1 2 # get compose file. wget https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml 接着下载 example env 文件，在完成了配置填写后记得将其重命名为 .env\n1 2 # get the exmple env file. wget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env Configuration 配置 env 的详细文件说明查看：Docker Compose [Recommended] | Immich ，主要需要修改或者填写的地方有：\nUPLOAD_LOCATION：存储图像备份文件的地址。 TYPESENSE_ENABLED: 如果出现一些问题报错的话，可能需要添加此项，并将其设置为 false 其他的参考配置官方的即可。 Start 启动服务 使用 docker compose command 启动对应的 containers 即可。\n1 docker-compose up -d 最终呈现的效果大致如图，其他的功能，比如下面的用户管理，图像识别等自动任务，还有一些就不逐一展示了，移动端的使用也十分简单，只要指定好对应的用户密码，以及 ip 端口即可连接，（须在同一个局域网内，或者使用内网穿透）\n该界面上可以在线预览，管理相册，查看存储情况，自动识别图像种类等等，手机端则主要是用于同步。\nUpgrade 更新 进入到 docker-compose 对应的目录中，重新拉取镜像再重新启动即可。\n1 docker-compose pull \u0026amp;\u0026amp; docker-compose up -d TroubleShooting A. 启用用户登录后还是显示禁止了用户登录；\n可以看看对应的登录界面可不可以下拉，下拉可以看到登录界面，应该是前端未刷新的问题。\nB. 局域网无法访问的时候检查防火墙通行。\n检查防火墙对 Docker Desktop 的放行\n","permalink":"https://hugotest-phi.vercel.app/posts/immich_backup/","summary":"\u003cblockquote\u003e\n\u003cp\u003e手机到电脑端的图像备份和预览往往是一个大问题，特别是当多个手机要备份的时候，说难不难，但说简单也确实有很多麻烦的地方，因此我推荐 Immich 的解决方案。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eImmich 是一个基于个人开发者开发的开源 Github 项目，\u003ca href=\"https://github.com/immich-app/immich\" target=\"_blank\" rel=\"noopener\"\u003eimmich-app/immich\u003c/a\u003e\n，该解决方案有以下的一些优势：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e移动端支持：移动端实现便于手机的随时和自动同步；\u003c/li\u003e\n\u003cli\u003e多用户支持：多用户的权限管理、分割、以及用户间的相册共享；\u003c/li\u003e\n\u003cli\u003eLive 格式支持：支持各种原生格式存储，\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSelf-hosted photo and video backup solution directly from your mobile phone.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e因此我本人推荐按照以下的方式来使用：针对家庭等环境，多用户部署在 NAS 或者某台 PC 上，可以长期或者定期的启动备份服务，然后就可以将手机中的照片空间释放掉。由此可以实现：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e通过共享文件夹共建家庭相册；\u003c/li\u003e\n\u003cli\u003e权限分割个人相册；\u003c/li\u003e\n\u003cli\u003e定期/自动备份手机中的照片，并清理对应的存储空间；\u003c/li\u003e\n\u003c/ol\u003e","title":"Docker-App 1 Backup Photos by Immich"},{"content":" 本篇主要介绍一下播放器 PotPlayer 的设置以及结合 Alist\u0026amp;小雅 alist 的使用，这样就可以直接在播放器访问本地网盘上的内容，便于使用和观看。\nAlist Deploy Alist 作为一个网盘管理中心，可以将各大网盘中的资源进行统一管理，同时支持视频的 webdav 播放，这里推荐的安装方式是使用 Docker-Compose 进行安装，根据自己的情况来选择对应的挂载和安装目录。\n由于官方的文档已经事无巨细，这里就不在赘述如何安装和配置 alist 的各个网盘挂载，详情参见：Home | AList Docs (nn.ci) 安装完并启动 Alist 服务即可，记住自己的端口和设置的账号密码。\nAria2离线下载支持 该部分介绍如何通过 docker 为 Alist 添加 Aria2 作为离线下载服务，以及一些常见的问题解决方法。\n参考资料：aria2-pro | aira2-pro-github | aria2认证失败 这里介绍使用 docker-compose 安装 aria2的方法，并将 docker 版本的 aria2和 alist 结合起来使用，在基于 docker 安装之前，我们先准备几个文件夹：\n1 2 cd \u0026lt;your-path-2-aria2\u0026gt; \u0026amp;\u0026amp; mkdir aria2-config \u0026amp;\u0026amp; chmod 777 aria2-config mkdir aria2-downloads \u0026amp;\u0026amp; chmod 777 aria2-downloads 其中 downloads 目录是我们用来下载文件的目录，我们也可以使用挂载的目录或者共享的目录来存储下载的文件；然后我们准备一下 alist 中用于离线下载的目录，该目录需要在 alist 的 docker 和 aria2的 docker 中都将该 volume 挂载到同一个地方。\n本文将 aria2的队名目录挂载到 alist 的对应目录中，对应的 alist 的 compose 文件有\n而 aria2的 compose 文件则有：\n再将该目录的权限改成777，chmod 777 \u0026lt;this-dir\u0026gt; 之后即可再 alist 中离线下载成功，而且该下载文件会在指定的网盘中上传，当上传完成时会删除临时文件，不占用本地磁盘空间。\n完整的 Compose 文件可以参考 Aria2-Pro-Docker/docker-compose.yml at master · P3TERX/Aria2-Pro-Docker · GitHub 官方的配置进行安装，我个人的 compose 文件则会上传到AikenH/aikenh-DockerComposeYML (github.com) 中。\nAria2Ng 界面认证失败的问题，是因为我们再 compose 中设置了密码之后，要在该界面的设置中设置密码后才能正常认证。\n密码需要到如下地方设置：\n设置完成后应该就不会有认证失败的提示了。\nalist 设置 Aria2失败，由于使用的 docker 部署的 aria2，这里不能使用 localhost，要使用对应的 ip 来设置该服务，如下图所示\n完成这些设置后应该就可以正常使用了，但是由于现在都是网盘场景更多，所以离线下载的可能使用场景也有限，而且通过测试发现，如果完全装在树莓派上的话，可能会对系统的性能造成一定的负担。\nXiaoya Deploy Xiaoya 是基于 Alist 做改版的个人资源站，里面涵盖了大量的影视资源，并在不断的更新，通过在本地挂载 xiaoya 我们也可以用来通过 webdav 在播放器中直接选择视频进行播放，大多数情况下都免去了找资源的痛苦。\n官方网站：主页 | 小雅的分类 Alist (xiaoya.pro) 拥有了 Docker 环境后，就可以基于 xiaoya 提供的脚本实现一键拉取镜像和启动 Docker，默认的端口是 5678，安装指令如下：\n1 sudo bash -c \u0026#34;$(curl -s http://docker.xiaoya.pro/update_new.sh)\u0026#34; 安装过程中会需要填入如下内容：token、open_token、转存目录的 folder id，具体和后续更新参考配置页 ，（跟随安装引导界面进行安装即可。）\n对应文件 获取方式 token /etc/xiaoya/mytoken.Txt link 1 link 2 open token /etc/xiaoya/myopentoken.Txt https://alist.nn.ci/zh/guide/drivers/aliyundrive_open.html 转存目录的 folder id /etc/xiaoya/temp_transfer_folder_id.Txt 在阿里网盘网页版上创建一个转存目录，比如“temp”，然后点击目录，浏览器显示的 URL https://www.aliyundrive.com/drive/folder/640xxxxxxxxxxxxxxca8a 最后一串就是 安装完成后确保服务启动正常，该部分的准备即结束，但是该端口我们还是要记住，因为在大量资源中搜索的时候还是得借助网页版中的搜索功能。\n安装完成后后续使用 Potplayer 挂载 Dav 时，账号密码为：\n1 2 guest guest_Api789 PotPlayer 设置 支持 WebDav 的免费视频播放器，同时也支持音乐播放，录频截图等功能，虽然支持 Iptv 源，但是实际上很多频道都比较卡，所以不是很推荐（也可能是我没找到好用的源，如果有的话感谢分享。）\n参考资料：Potplayer全面设置教程 ，最后配置完的设置和对应的皮肤文件我会到处到我的 dotfile 仓库。\n基础设置 具体的设置和皮肤下载路径如下：\n下载：Search \u0026lsquo;potplayer\u0026rsquo; on DeviantArt 基本 -\u0026gt; 皮肤/配色 -\u0026gt; 打开皮肤文件夹 -\u0026gt; 进阶皮肤 -\u0026gt; 启用 Direct3D 渲染。 播放 -\u0026gt; 打开多线程，旋转，标题，记忆位置，隐蔽指针，进度条显示缩略图，以及设置是否循环播放。 时间跨度 -\u0026gt; 设置一下方向键快进的时间 列表 -\u0026gt; 显示缩略图和两行信息，按文件路径排序并全部对齐 宽高比 -\u0026gt; 缩放时保持宽高比 字幕 -\u0026gt; 画面底部、自动重载被修改的字幕 可以通过播放时右键 -\u0026gt; 实时字幕翻译 -\u0026gt; 使用 详细的设置在：选项 -\u0026gt; 拓展功能 -\u0026gt; 实时字母翻译 滤镜相关的我这里不懂就不设置 声音 -\u0026gt; 最大音量调整到 200 效果展示如下：\n\u003c!DOCTYPE html\u003e\rWebdav 挂载 Alist 和小雅 播放列表中新建专辑，按照下图的方式进行填写，其中端口就是你 Alist 或者小雅在本地部署的端口，IP 如果是本地部署的话就按下列的方式填写，否则就填写提供的 IP，用户名和密码使用自己设置的用户密码即可（小雅的话可以参考默认账号和密码）\n至此，PotPlayer 和对应的 Alist 列表就挂载成功了，可以畅爽实现本地看剧了。\nIptv 列表 虽然不推荐使用 Iptv 因为大多数源是真的卡，看起来要么卡，要么不够高清，要么找一个频道找半天，确实是不是很想费心折腾这块，也不建议，但是还是简单介绍。\n使用的话就将下载的 iptv 源文件拖入播放列表即可，下面有几个 iptv 源的地址：\niptv-org/iptv: Collection of publicly available IPTV channels from all over the world (github.com) imDazui/Tvlist-awesome-m3u-m3u8: 直播源相关资源汇总 每天更新：中国电视IPTV直播源.m3u fanmingming/live: ✯ 一个国内可直连的直播源分享项目 ✯ 🔕 永久免费 直连访问 完整开源 不含广告 完善的台标 直播源支持IPv4/IPv6双栈访问 🔕 (github.com) 电视直播源搜索｜最新东森多线路直播源分享 (foodieguide.com) 使用前可以使用 iptv-checker 来检查源的可用性，然后过滤掉一些不可用的源。\n","permalink":"https://hugotest-phi.vercel.app/posts/alist_potplayer/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本篇主要介绍一下播放器 PotPlayer 的设置以及结合 Alist\u0026amp;小雅 alist 的使用，这样就可以直接在播放器访问本地网盘上的内容，便于使用和观看。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"alist-deploy\"\u003eAlist Deploy\u003c/h2\u003e\n\u003cp\u003eAlist 作为一个网盘管理中心，可以将各大网盘中的资源进行统一管理，同时支持视频的 webdav 播放，这里推荐的安装方式是使用 Docker-Compose 进行安装，根据自己的情况来选择对应的挂载和安装目录。\u003c/p\u003e\n\u003cp\u003e由于官方的文档已经事无巨细，这里就不在赘述如何安装和配置 alist 的各个网盘挂载，详情参见：\u003ca href=\"https://alist.nn.ci/\" target=\"_blank\" rel=\"noopener\"\u003eHome | AList Docs (nn.ci)\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e安装完并\u003cstrong\u003e启动 Alist 服务\u003c/strong\u003e即可，记住自己的\u003cstrong\u003e端口\u003c/strong\u003e和设置的\u003cstrong\u003e账号密码\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"aria2离线下载支持\"\u003eAria2离线下载支持\u003c/h3\u003e\n\u003cp\u003e该部分介绍如何通过 docker 为 Alist 添加 Aria2 作为离线下载服务，以及一些常见的问题解决方法。\u003c/p\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://p3terx.com/archives/docker-aria2-pro.html\" target=\"_blank\" rel=\"noopener\"\u003earia2-pro\u003c/a\u003e\n |  \u003ca href=\"https://github.com/P3TERX/Aria2-Pro-Docker/blob/master/docker-compose.yml\" target=\"_blank\" rel=\"noopener\"\u003eaira2-pro-github\u003c/a\u003e\n |  \u003ca href=\"https://yiwangmeng.com/aria2-status-page-to-prompt-the-solution-of\" target=\"_blank\" rel=\"noopener\"\u003earia2认证失败\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e这里介绍使用 docker-compose 安装 aria2的方法，并将 docker 版本的 aria2和 alist 结合起来使用，在基于 docker 安装之前，我们先准备几个文件夹：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e \u0026lt;your-path-2-aria2\u0026gt; \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e mkdir aria2-config \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e chmod \u003cspan class=\"m\"\u003e777\u003c/span\u003e aria2-config\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir aria2-downloads \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e chmod \u003cspan class=\"m\"\u003e777\u003c/span\u003e aria2-downloads\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e其中 downloads 目录是我们用来下载文件的目录，我们也可以使用挂载的目录或者共享的目录来存储下载的文件；然后我们准备一下 alist 中用于离线下载的目录，\u003cstrong\u003e该目录需要在 alist 的 docker 和 aria2的 docker 中都将该 volume 挂载到同一个地方\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e本文将 aria2的队名目录挂载到 alist 的对应目录中，对应的 alist 的 compose 文件有\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709161919.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709161919.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709161919.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e而 aria2的 compose 文件则有：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709161956.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709161956.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709161956.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e再将该目录的权限改成777，\u003ccode\u003echmod 777 \u0026lt;this-dir\u0026gt;\u003c/code\u003e 之后即可再 alist 中离线下载成功，而且该下载文件会在指定的网盘中上传，当上传完成时会删除临时文件，不占用本地磁盘空间。\u003c/p\u003e\n\u003cp\u003e完整的 Compose 文件可以参考 \u003ca href=\"https://github.com/P3TERX/Aria2-Pro-Docker/blob/master/docker-compose.yml\" target=\"_blank\" rel=\"noopener\"\u003eAria2-Pro-Docker/docker-compose.yml at master · P3TERX/Aria2-Pro-Docker · GitHub\u003c/a\u003e\n 官方的配置进行安装，我个人的 compose 文件则会上传到\u003ca href=\"https://github.com/AikenH/aikenh-DockerComposeYML\" target=\"_blank\" rel=\"noopener\"\u003eAikenH/aikenh-DockerComposeYML (github.com)\u003c/a\u003e\n中。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAria2Ng 界面认证失败\u003c/strong\u003e的问题，是因为我们再 compose 中设置了密码之后，要在该界面的设置中设置密码后才能正常认证。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709162444.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709162444.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709162444.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e密码需要到如下地方设置：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709162537.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709162537.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709162537.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e设置完成后应该就不会有认证失败的提示了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ealist 设置 Aria2失败\u003c/strong\u003e，由于使用的 docker 部署的 aria2，这里不能使用 localhost，要使用对应的 ip 来设置该服务，如下图所示\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709162724.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709162724.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230709162724.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e完成这些设置后应该就可以正常使用了，但是由于现在都是网盘场景更多，所以离线下载的可能使用场景也有限，而且通过测试发现，如果完全装在树莓派上的话，可能会对系统的性能造成一定的负担。\u003c/p\u003e\n\u003ch2 id=\"xiaoya-deploy\"\u003eXiaoya Deploy\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eXiaoya 是基于 Alist 做改版的个人资源站，里面涵盖了大量的影视资源，并在不断的更新，通过在本地挂载 xiaoya 我们也可以用来通过 webdav 在播放器中直接选择视频进行播放，大多数情况下都免去了找资源的痛苦。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e官方网站：\u003ca href=\"http://alist.xiaoya.pro/\" target=\"_blank\" rel=\"noopener\"\u003e主页 | 小雅的分类 Alist (xiaoya.pro)\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e拥有了 Docker 环境后，就可以基于 xiaoya 提供的脚本实现一键拉取镜像和启动 Docker，默认的端口是 5678，安装指令如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo bash -c \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"k\"\u003e$(\u003c/span\u003ecurl -s http://docker.xiaoya.pro/update_new.sh\u003cspan class=\"k\"\u003e)\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e安装过程中会需要填入如下内容：token、open_token、转存目录的 folder id，具体和后续更新参考\u003ca href=\"https://xiaoyaliu.notion.site/xiaoya-docker-69404af849504fa5bcf9f2dd5ecaa75f\" target=\"_blank\" rel=\"noopener\"\u003e配置页\u003c/a\u003e\n，（跟随安装引导界面进行安装即可。）\u003c/p\u003e","title":"Windows App01 Potplayer \u0026 Alist"},{"content":" 该章节主要包括 Promot 生成和部分工作流的分析，旨在了解如何写出更好的关键词，如何生成更好的图片，当我们不知道怎么描述的时候也可以将该工作交给 ChatGPT，让其为我们攥写一般基础的提示词\nPrompt 编写范式 参考资料：【Stable Diffusion】Prompt 通常编写可以遵照以下的类别进行组织，主要有 \u0026lt;质量控制\u0026gt; + \u0026lt;前置\u0026gt; + \u0026lt;主体\u0026gt; + \u0026lt;场景词\u0026gt; 几类，其中分别包括以下的几类词：\n质量控制：画质、镜头效果、光照效果 前置词：画风、艺术家、风格 主体：人物\u0026amp;对象、姿势、服装、道具 场景：环境、背景、细节 Additional Network：载入额外模型 分割符号： 各个关键词之间用 , 分割，且对应的权重从前到后依次递减，因此在编写关键词的时候也要注意先后顺序。\n权重加权符号：各种括号代表各种不同的加权系数，这里建议用 (prompt: weight) 统一来编写提示词的权重规则，整体可读性会更好。\n这里的 weight 指的是权重变成原本的 weight 倍，就可以调整加强或减弱。\n各个括号的默认系数如下: () -\u0026gt; 1.1 ; {} -\u0026gt; 1.05 ; [] -\u0026gt; 0.952 可以通过(())进行叠加即 1.1*1.1\n额外模型调取：编写格式为 \u0026lt;lora:loramodelname:multiplier\u0026gt;，即载入 loramodelname 模型，权重为 multiplier，该权重不建议过大。\n关键词的切换： 语法如下 [key1:key2:step]，通过该语法可以实现在进行到不同步骤的时候使用不同的关键词进行渲染，其中 :key2 可以忽略，忽略后即可理解为 [\u0026quot;\u0026quot;:key1:step]，有一下的一些规则：\nStep 在大于 1 时表示具体的步骤，小于 1 时表示迭代步数的百分比 如果想要在某步之后忽略 key1，与上面忽略 key2 正好相反，可以写成 [key1::step] [key1|key2] 则表示两个关键词交替选择渲染 反向提示词：反向提示词就是让 AI 避免生成什么样的图片，使用得当可以帮助我们更好的生成想要的图片，后面再关键词的地方会介绍一些常见的反向关键词，例如低画质相关和一些容易变形身体部位的描述等\n这里介绍一个 easynegative 的 embedding 模型，其是通过大量的不好的图片训练出来的模型，通过在反向关键词部分调用 easynegative 调用该模型即可过滤。\n具体的使用方式如下：\n首先去 C 站下载模型， EasyNegative - EasyNegative | Stable Diffusion Textual Inversion | Civitai ; 然后将其放入 stable-diffuison-webui 资料夹下的 embeddings 文件夹；重启之后在负向关键词中填入 EasyNegative 即可生效（也可从额外网络中选择 Textual inversion/tembeding，然后将该模型填入 Negative 中）\n但是单独使用的话，效果可能还是没有那么好，所以最好还是结合着一些特定的负向关键词一起使用。\nKeyword 关键词 该部分主要来自参考资料，原文推荐 阅读，如果觉得有用，请给原文点赞。\n通过在文章前面添加画质关键词能提升生成图片的质感，质量，描述简单通用而有效\nprompt Desc HDR, UHD, 8 k 这样的质量词可以带来巨大的差异提升照片的质量 Best quality 最佳质量 masterpiece 杰作 Highly detailed 细节添加 Studio lighting 演播室灯光 ultra-fine painting 精细绘图 sharp focus 清晰聚焦 physically-based rendering 基于物理渲染 extreme detail description 详细刻画 Professional 改善图片的对比细节 Vivid Colors 色彩鲜艳 Bokeh 模糊背景，突出主题 (EOS R8, 50mm, F1.2, 8K, RAW photo:1.2) 相机设置 High resolution scan 年代感 Sketch 素描 Painting 绘画 还有一些诸如：depth of field 景深、wide angle 广角之类术语，也能帮助我们生成更好的或者更符合预期的图片。\n可以通过添加艺术家关键词来使得生成图片具备特定风格，常用于固定的风格模仿。\nprompt Artist 肖像画（Portraits） Derek Gores, Miles Aldridge, Jean Baptiste-Carpeaux, Anne-Louis Girodet 风景画（Landscape） Alejandro Bursido, Jacques-Laurent Agasse, Andreas Achenbach, Cuno Amiet 恐怖画（Horror） H.R.Giger, Tim Burton, Andy Fairhurst, Zdzislaw Beksinski 动漫画（Anime） Makoto Shinkai, Katsuhiro Otomo, Masashi Kishimoto, Kentaro Miura 科幻画（Sci-fi） Chesley Bonestell, Karel Thole, Jim Burns, Enki Bilal 摄影（Photography） Ansel Adams, Ray Earnes, Peter Kemp, Ruth Bernhard 概念艺术家（视频游戏）Concept artists video game Emerson Tung, Shaddy Safadi, Kentaro Miura 常用的反向 Prompt 常有如下的这些，实际上可以根据生成的情况放上去，或者根据需要的图片直接一股脑的放上去即可，希望 AI 画好一个元素，可以通过正 tag 结合反向的约束来实现。\nnegative prompt Desc mutated hands and fingers 变异的手和手指 deformed 变形的 bad anatomy 解剖不良 disfigured 毁容 poorly drawn face 脸画的不好 mutated 变异的 extra limb 多余的肢体 ugly 丑陋 poorly drawn hands 手画的不好 missing limb 缺少肢体 floating limb 漂浮的四肢 disconnected limbs 肢体不连贯 malformed hands 畸形的手 out of focus 脱离焦点 long neck 长脖子 long body 长身体 Sample一些简单成品 \u003c!DOCTYPE html\u003e\rexam1\rexam 2\r参考资料 Stable Diffusion prompt: a definitive guide - Stable Diffusion Art (stable-diffusion-art.com) 繪圖AI - Stable Diffusion 相關教學與參考資源 202303 update - yoyojojo的創作 - 巴哈姆特 (gamer.com.tw) 魔咒百科词典 (aitag.top) AI繪圖魔導書 - Google 表格 https://majinai.art/zh-tw/index.php ","permalink":"https://hugotest-phi.vercel.app/posts/stablediffusionprompt/","summary":"\u003cblockquote\u003e\n\u003cp\u003e该章节主要包括 Promot 生成和部分工作流的分析，旨在了解如何写出更好的关键词，如何生成更好的图片，当我们不知道怎么描述的时候也可以将该工作交给 ChatGPT，让其为我们攥写一般基础的提示词\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"prompt-编写范式\"\u003ePrompt 编写范式\u003c/h2\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://zhuanlan.zhihu.com/p/619247417?utm_id=0\" target=\"_blank\" rel=\"noopener\"\u003e【Stable Diffusion】Prompt\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e通常编写可以遵照以下的类别进行组织，主要有 \u003ccode\u003e\u0026lt;质量控制\u0026gt; + \u0026lt;前置\u0026gt; + \u0026lt;主体\u0026gt; + \u0026lt;场景词\u0026gt;\u003c/code\u003e 几类，其中分别包括以下的几类词：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e质量控制\u003c/strong\u003e：画质、镜头效果、光照效果\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e前置词\u003c/strong\u003e：画风、艺术家、风格\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e主体\u003c/strong\u003e：人物\u0026amp;对象、姿势、服装、道具\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e场景\u003c/strong\u003e：环境、背景、细节\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAdditional Network\u003c/strong\u003e：载入额外模型\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e分割符号：\u003c/strong\u003e 各个关键词之间用 \u003ccode\u003e,\u003c/code\u003e 分割，且对应的权重从前到后依次递减，因此在编写关键词的时候也要注意先后顺序。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e权重加权符号\u003c/strong\u003e：各种括号代表各种不同的加权系数，这里建议用 \u003ccode\u003e(prompt: weight)\u003c/code\u003e 统一来编写提示词的权重规则，整体可读性会更好。\u003c/p\u003e\n\u003cp\u003e这里的 weight 指的是权重变成原本的 weight 倍，就可以调整加强或减弱。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e各个括号的默认系数如下: () -\u0026gt; 1.1 ; {} -\u0026gt; 1.05 ; \u003ccode\u003e[]\u003c/code\u003e -\u0026gt; 0.952\n可以通过(())进行叠加即 1.1*1.1\u003c/p\u003e\n\u003c/blockquote\u003e","title":"AIGC04 Stable Diffusion Write Prompt Better"},{"content":" ControlNet 是 Stable Diffusion 最强力的插件之一，它能够控制 SD 的整个扩散过程，包括让 AI 参考动作/骨架/线条/景深，从而更精准的生成图片。\nControlNet 按照骨架動作繪圖 | Stable Diffusion WebUI使用手冊 骨架人偶 PoseX | Stable Diffusion WebUI 使用手冊 生成多個人物 Latent Couple | Stable Diffusion WebUI使用手冊 拓展地址：Mikubill/sd-webui-controlnet: WebUI extension for ControlNet (github.com) ControlNet 地址：lllyasviel/ControlNet: Let us control diffusion models! (github.com) 模型地址：lllyasviel/ControlNet-v1-1 at main (huggingface.co) 插件安装和模型下载 AssertionError: extension access disabled because of command line flags 无法在 Listen 模式下安装插件，这是为了安全性考虑。\n插件安装界面安装 ControlNet 的 webui 插件，然后去模型地址下载 ControlNet 的模型，将模型放置在：stable-diffusion-webui/extensions/sd-webui-controlnet/models 目录中，而 CN 其中包含了很多种类，包括：\nAnime Lineart ：偵測線條，生成的圖片亦會保留原始的線條，適合處理動漫圖像 Canny：偵測圖片邊緣，比較模糊，不如 Scribbles 完整。 Depth：偵測輸入圖片的深度圖(depth map)。 Illumination：偵測輸入圖片的光源與照明效果。 Inpaint： 功能類似「內補繪製」，使用50%隨機遮罩＋50%隨機光流遮罩訓練而成。 Instruct Pix2Pix 模型檔名為ip2p，類似「圖生圖」，但是使用訓練50%的指示(instruction)提示詞和50%的敘述(description)提示詞訓練而成。因為是ControlNet，使用此模型時不需要調整CFG Scale。 根據原作者的說法，此模型在下「使其成為X」的提示詞所生成的圖，效果比「使Y成為X」要好。 Also, it seems that instructions like “make it into X” works better than “make Y into X”. Lineart：偵測線條，適合處理線稿，生成的圖片亦會保留原始的線條。 M-LSD ：偵測輸入圖片的直線。 Normalbae Openpose： 使用 OpenPose 技術偵測輸入圖片人物的動作，不一定會保留線條。 Scribbles：偵測線條，偵測到的線條品質介於 Soft Edge 和 Lineart 之間。 Segmentation：模型檔名為 seg，將偵測的圖片物件切成一個一個色塊處理，例如房子一個色塊，後面的天空一個色塊。 Shuffle： 把輸入圖片的概念轉移到生成的圖片。作者給的例子：輸入灰色裝甲圖片，生成的鋼鐵人盔甲也會是灰色的。 Soft Edge：偵測圖片邊緣，效果較為柔和，像用炭筆塗過。 Tile：輸入圖片，選取一個區域，使其變清晰的模型。 模型放置完后，就可以开始使用 ControlNet 插件了。\n插件设置和使用 安装完插件和模型后，就能在文生图和图生图部分看到 Control Net 的选项，点击该选项就能进入 ControlNet 的选单，\n其中大部分的直接看字面意思就行了，解释一下重要或者难理解的几个：\nEnable 必须启用 Low VRAM 降低现存使用，无脑启用 Pixel Perfect 由 ControlNet 决定预处理的分辨率，无脑启用 Allow Preview 允许预览，包括线条和骨架，无脑启用 Preprocessor 预处理器，通常要和模型一致，先将上传的处理过一轮，处理成骨架等线稿，如果图片是白底黑线，则需要选取反转 Control Weight：control 的生效权重 Start/ending step: 开始和结束参与的步数 Loopback，将生成的图像在传回 ControlNet unit PoseX 使用 可以代替提供图片作为参照，可以自己作画画一个骨架，依赖项：\n插件：hnmr293/posex (github.com) openpose 的 controlnet 模型 装完插件就可以使用了，在列表中选择 Posex 即可开启调整，选择 send this to controlnet； 然后在 ControlNet 选单中\nEnable preprocess：None Model：openpose 其他的照常设置即可，效果如下：\nLatent Couple 使用 结合 ControlNet 和 PoseX 使用，可以分割提示词，同时绘制多个人，指定不同的提示词和动作。\nWorkFlow：\n选中选单 -\u0026gt; Enable -\u0026gt; Create Blank Canvas 建立画布 -\u0026gt; 不同颜色鼠标绘制不同区域标识不同个体 -\u0026gt; finish sketch -\u0026gt; fill prompt in for the mask -\u0026gt; prompt info update 会自动上传到提示词窗口\nFI 本章节暂时到这，上述的两个插件在不同的场景下的使用是类似的，就不再赘述，本篇主要还是基于参考资料来的，建议查看原文，还有更多的插件推荐和说明。\n下一章节主要整理一些 Prompt 相关的写法和资源推荐，最后有时间了再来梳理模型训练和原理。\n","permalink":"https://hugotest-phi.vercel.app/posts/stablediffusioncontrolnet/","summary":"\u003cblockquote\u003e\n\u003cp\u003eControlNet 是 Stable Diffusion 最强力的插件之一，它能够控制 SD 的整个扩散过程，包括让 AI 参考动作/骨架/线条/景深，从而更精准的生成图片。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://ivonblog.com/posts/stable-diffusion-webui-manuals/extensions/controlnet/\" target=\"_blank\" rel=\"noopener\"\u003eControlNet 按照骨架動作繪圖 | Stable Diffusion WebUI使用手冊\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ivonblog.com/posts/stable-diffusion-webui-manuals/extensions/posex/\" target=\"_blank\" rel=\"noopener\"\u003e骨架人偶 PoseX | Stable Diffusion WebUI 使用手冊\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ivonblog.com/posts/stable-diffusion-webui-manuals/extensions/latent-couple/\" target=\"_blank\" rel=\"noopener\"\u003e生成多個人物 Latent Couple | Stable Diffusion WebUI使用手冊\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e拓展地址：\u003ca href=\"https://github.com/Mikubill/sd-webui-controlnet\" target=\"_blank\" rel=\"noopener\"\u003eMikubill/sd-webui-controlnet: WebUI extension for ControlNet (github.com)\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003eControlNet 地址：\u003ca href=\"https://github.com/lllyasviel/ControlNet\" target=\"_blank\" rel=\"noopener\"\u003elllyasviel/ControlNet: Let us control diffusion models! (github.com)\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e模型地址：\u003ca href=\"https://huggingface.co/lllyasviel/ControlNet-v1-1/tree/main\" target=\"_blank\" rel=\"noopener\"\u003elllyasviel/ControlNet-v1-1 at main (huggingface.co)\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"AIGC03 Stable Diffusion Control Net"},{"content":" 本篇章介绍关于 Stable DIffusion 的一些基础概念和 WebUI 的基本功能元素，同时介绍一些启动项和模型加载的东西。\n启动项设置（局域网） 最常用的启动项是 --listen，通过该启动项允许局域网内的其他设备通过 ip 和端口访问部署好的 Stable Diffusion 服务。而设置启动项的方式有以下几种：\n命令行执行启动脚本的时候携带 1 2 ./webui.bat --listen # ./webui.sh --listen 修改主入口脚本中的启动选项 vim launch.py 1 2 3 # 修改下面这一行的参数, 将\u0026#34; \u0026#34;中填入需要的参数 # commandline_args = os.environ.get(\u0026#39;COMMANDLINE_ARGS\u0026#39;, \u0026#34;\u0026#34;) commandline_args = os.environ.get(\u0026#39;COMMANDLINE_ARGS\u0026#39;, \u0026#34;--listen\u0026#34;) 其他的启动项介绍可以参考：2.3. 命令列引數 | Stable Diffusion WebUI使用手冊(正體中文)｜Ivon的部落格 (ivonblog.com) 模型相关 提供相关模型下载的网址主要有以下几个：\nC站 | AI绘画模型博物馆 (subrecovery.top) | Hugging Face – The AI community building the future. Stable Diffusion Models 模型百科 Stable Diffusion Textual Inversion Embeddings Embeding，不建议访问，我个人好像访问了就很卡 Stable Diffusion Models (cyberes.github.io) | NOVALAI 该文章中有写，是被黑客泄露的模型 这些网站都会提供各种模型的下载，包括 LoRA、Ckpt、HyperNetwork 等。\n模型部署和加载 下载完模型后，我们进到如下的目录中，会发现有针对于各种不同模型的子目录(Lora, stable-diffusion, VAE)等\n1 cd \u0026lt;pth\u0026gt;/stable-diffusion-webui/model/models 将对应的模型的放到对应的目录中即可，然后重启 stable-diffusion 服务，其会读取路径下的所有模型，在 webui 的对应选项中实现加载。\n其中：Ckpt 存放于其中的 stable-diffusion 目录中，是整个生成过程的基础模型，可以在下图所示的地方读取：\n可以看到此处已经加载了诸多我们下载好的 ckpt 模型，并可随意选择和切换。\n下面介绍一下各种模型之间的区别：Stable Diffusion中的各种模型 CKPT（Checkpoint）模型 基于某个数据集训练出来的 Stable Diffusion 完整的大模型本身，因此相比于其他的微调模型来说体积一般较大。\nLora 模型 Low-Rank Adaptation of Large Language Models，直译为大语言模型的低阶适应，为了解决大语言模型微调而开发的一项技术，LoRA 的冻结预训练好的大模型模型参数，然后在每个 Transformer 块里注入可训练的层，大大减少了需要训练的计算量。\nStable Diffusion爱好者常说的LoRa是什么？ Using LoRA for Efficient Stable Diffusion Fine-Tuning (huggingface.co) cloneofsimo/lora: Using Low-rank adaptation to quickly fine-tune diffusion models. (github.com) LORA: LOW-RANK ADAPTATION OF LARGE LAN GUAGE MODELS ：官方论文 VAE 模型 Variational autoencoder，变分自编码器，负责做隐含空间和 RGB 空间的变换，可以实现添加滤镜和风格的效果，通常来说大模型中会包含该部分变换，不是所有的模型都适合一起使用。\nHypernetwork 网络 Hypernetwork 是一种微调技术，最初由 Novel AI 开发，他们是 Stable Diffusion 的早期采用者。它是一个小型神经网络，附加在 Stable Diffusion 模型上以修改其风格。插入到噪声预测器 UNet 的交叉注意力模块中，通常情况下，hypernetwork 是一个简单的神经网络：具有 dropout 和激活函数的全连接线性网络。它通过插入两个转换 key 和 query 向量的网络来劫持交叉注意力模块。\nEmbedding 嵌入 文本嵌入，应该和 HyperNetwork 类似，通过影响 Prompt 的嵌入构建过程来实现特定风格的方法，作为原本网络的拓展组件或者控制器来使用。\n使用这些模型的地方我们将在下面的页面基本功能元素一起介绍：这些参数或者模型主要是作为 Additional Network 来使用的，这个我们后续介绍使用的方式，其对 Ckpt 进行进一步的调整，因此不同的搭配使用本身可能会有不同的效果。\n需要注意的是，各个模型，各个参数可能都会有各自生成的类型偏向性，一些模型可能是专门过拟合某一些风格，因此用的时候对额外网络的比重调整也是个学问。\n基本功能介绍 加载完基础模型后，就可以试用各个基础功能了，该章节基于文生图的功能每一部分的操作和配置进行介绍，其他的功能会放在后续小节。\n基础结构介绍 Basic 首先从文生图的功能开始介绍，该功能的名字很直观就是通过提供的提示词（Prompt）生成对应的图像，其中控制图片生成的主要有这么几个地方：\nPrompt：描述生成的图像：图像的内容，质量，风格等； Negative Prompt：反向提示词，限定一些边界，生成的图像不会包含这其中的内容； Sampling：采样器，实际上不是寻常理解上的采样，而是指的扩散方法，即选用生成图像的扩散模型。 Sampling Steps：采样步骤，同上实际上指的应该是扩散步骤，可以根据显存来调整该步骤，可以适当调大。 Width、Height：生成图像的分辨率（Shape \u0026amp; Size） CFG Scale：提示词关联程度，和提示词的相关程度 Seed：随机种子，虽然只是一个随机种子，实际上也会很明显的影响图像生成的样式。 设定好了上述对应参数后，就可以点击 Generate 进行图片生成了，右下角的按钮可以将生成的图片转到后续的后处理步骤中，或者保存。\n额外模型使用 Additional Networks 如果要加载额外的模型参数，比如说要针对模型额外加载 Lora，具体的操作过程如下图所示：\n加载： 点击 Additional Network 按钮后 -\u0026gt; 会弹出下面一排界面 -\u0026gt; 选择对应需要的模型种类（比如这里选择了 Lora 选项卡）-\u0026gt; 然后选择一个（或者多个）特定的模型 -\u0026gt; 则该 Lora 模型会以 \u0026lt;model:weight\u0026gt; 的形式出现在 Prompt 的地方，这样就完成了额外模型参数的加载了。\n调整思路：\n这里的权重我们通常不会选择 1，从 0.1 开始向上调整是一个比较好的思路。 此外在加载 Lora 的时候，可以参考 C 站中别人和什么 Ckpt 组合使用。 可以看到这里除了 Lora，还有 HyperNetwork 等选项卡，这些可选项都可以使用类似的方式来进行调用。支持同时使用多个，但是权重的调整要自己选择。\n此外如果要使用插件来调整 lora 的比例的话，则需要把 lora 模型放到 /extensions/sd-webui-additional-networks/models/lora 中，这里可以使用超链接的方式，然后在 addition network 选项卡下点击刷新按钮：即可。\n参数搜索功能 Scripts stable-diffusion-webui prompt语法详解 由于可供设置的参数数量较多，因此在出一张让人满意的图之前，总免不了各种试，这种时候就需要参数搜索功能来简化整个 workflow，我们设置好需要搜索的参数空间，让 Stable Diffusion 自己逐一的遍历每个参数。\nwebui 中就提供了这样的功能，可以通过 script 实现各种实验的脚本；也就是下图所示的，Script 选项，其中内置的也提供了几种参数搜索的方式：\n非参数搜索）从文件中读取提示词，便于导入导出 提示词搜索（即提示词矩阵） XYZ Plot，可自定义各种参数的搜索 提示词矩阵功能讲解：用 | 分割 prompt 词，可达到如下的效果，以 a|b 为例，SD 将会生成如下的四种结果：\n^a \u0026amp; ^b , a \u0026amp; ^b , b \u0026amp; ^a , a \u0026amp; b\n这里顺便提一嘴，用（prompt）可以强化对提示词的关注程度，(prompt:1.5) 即将该 prompt 的关注程度提升为 150%，[prompt] 则是和(prompt) 相反，则是弱化对提示词的关注程度。\nXYZ Plot功能讲解：通过设定 2~3 个变量（甚至可以包括模型），可以同时对这三个变量进行排列组合的参数搜索，建议不要把变量范围设置过大，不然搜索空间太大了。\n在 XYZ 中选择好对应的变量后，在对应的值选框中，用 , 分割可选的各个变量即可开始进行搜索，最后的结果大概如下，便于让我们找出合适的参数。\n其他功能介绍 基于上述对于字生图的功能介绍，基础的功能就大概了解了，接下来拓展介绍一下其他的功能。\n图生图功能 图生图的定位是，基于提示词对原图进行重绘改造，核心参数是重绘强度。也可以在文生图之后送到图生图模块中进行逐步的迭代优化。\n参考资料：5分钟学会Stable Diffusion图生图功能 这里有个新的核心可配置项为：\nDenoising Strength（重绘强度）： 也就是偏离原图的程度，越大和原图越不相似，较常取值于 0.6-0.7 之间 同时要注意调整 Size 和原图保持一致，不然原图会被拉伸。 新功能：同时这里也存在两个模型可以帮助我们根据原图去反向推演提示词，上传完图片之后点击这两个其中一个即可反向推演出 Prompt 供我们参考（但是对于生成一个好图还远远不够）：\n剩下的和文生图一致，就可以基于我们的图片和提示词去生成一张新的图片。\n这里还有一些其他的功能做一下简单介绍：\nSketch：涂鸦绘制，给一张涂鸦和 Prompt 去生成一个新的图片（可以用于作画），会保留草图的颜色信息 Inpaint：局部绘制，涂抹原图中的部分，并只对该部分进行重新生成，可以换风格，换图案，换脸，换衣服之类的，可以选择重绘蒙版部分或者非蒙版部分的内容，也可以调整蒙版的模糊程度 Inpaint sketch：两者的结合体，会保留颜色信息进行重绘 \u0026hellip; 高清化功能 简单理解就是超分辨率和面部重建等重建图片质量的一系列模型，无需过多介绍。\n图像信息 应该是提取生成图的信息。\nFI 本篇章就到这里结束，下一章节会讲一下 Control Net，有时间的话会去淘一下有没有什么插件值得讲解的。本篇章中有希望进一步详细或者让我去了解的也可以留言。\n","permalink":"https://hugotest-phi.vercel.app/posts/stable-diffusion-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本篇章介绍关于 Stable DIffusion 的一些基础概念和 WebUI 的基本功能元素，同时介绍一些启动项和模型加载的东西。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"启动项设置局域网\"\u003e启动项设置（局域网）\u003c/h2\u003e\n\u003cp\u003e最常用的启动项是 \u003ccode\u003e--listen\u003c/code\u003e，通过该启动项允许局域网内的其他设备通过 ip 和端口访问部署好的 Stable Diffusion 服务。而设置启动项的方式有以下几种：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e命令行执行启动脚本的时候携带\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e./\u003c/span\u003e\u003cspan class=\"n\"\u003ewebui\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"py\"\u003ebat\u003c/span\u003e \u003cspan class=\"p\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003e-listen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e# ./webui.sh --listen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e修改主入口脚本中的启动选项 \u003ccode\u003evim launch.py\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 修改下面这一行的参数, 将\u0026#34; \u0026#34;中填入需要的参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# commandline_args = os.environ.get(\u0026#39;COMMANDLINE_ARGS\u0026#39;, \u0026#34;\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecommandline_args\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eenviron\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;COMMANDLINE_ARGS\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;--listen\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e其他的启动项介绍可以参考：\u003ca href=\"https://ivonblog.com/posts/stable-diffusion-webui-manuals/installation/command-line-arguments-and-settings/\" target=\"_blank\" rel=\"noopener\"\u003e2.3. 命令列引數 | Stable Diffusion WebUI使用手冊(正體中文)｜Ivon的部落格 (ivonblog.com)\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"AIGC02 Stable Diffusion 基础功能介绍"},{"content":" 在 Windows 和 WSL2 中安装 Cuda 和 Cudnn ，是配置 GPU 开发环境中重要的一步，其支撑了 AI 模型进行 Training 和 Interface 。本篇介绍安装 CUDA 和 Cudnn 的步骤和一些踩过的坑。\n参考资料如下：版本查看 | Win 安装 Cuda 和cuDNN | WSL 2 安装 CUDA 和cuDNN Win 11 安装 CUDA 和 cuDNN CUDA 首先在 Nvidia 的控制面板：帮助-系统信息的如下位置，查看 GPU 最大支持的 CUDA 版本：\n也可以使用 Nvidia-smi 命令在 Powershell 或者 CMD 中查看:\n确定了版本之后到 Nvidia CUDA下载页面 下载指定版本的 CUDA 进行安装（根据安装指引进行）即可，安装位置等默认即可，其中有一些安装选项即是 Nvidia GeForce Experience 安装的内容。\n安装完成后在 CMD 或者 PowerShell 确认是否安装完成（需要重启终端）：\n1 nvcc -V 显示如上信息可看到指定的版本已经安装成功，然后我们可以在 CMD 中执行如下命令来获取安装地址/设置环境变量：\n1 set cuda 完成这些后我们就可以开始安装 CuDNN 了，CuDNN 的安装需要我们记住 Cuda 的安装地址。\ncuDNN 在 Nvidia 官网注册账号，并在 cuDNN 下载界面 下载对应版本的 Package 后，讲 Package 中各个目录下的内容放到 CUDA 文件夹的对应目录下即可。\n即 mv cuDNN/lib/* CUDA/lib/* \u0026hellip;；拷贝完成后可以执行 CUDA 中自带的校验工具查看安装情况：\n/cuda/extras/demo_suite/deviceQuery.exe /cuda/extras/demo_suite/bandwidthTest.exe 可以看到验证详细结果和是否通过。\nWSL 2 配置 CUDA 和 cuDNN 建议可以先看看： NVIDIA GPU Accelerated Computing on WSL 2 新版的 WSL 2 对于 GPU 的支持已经相当的友善，能够直接调用 Windows 的 GPU，但是在使用过程前还是需要对环境进行一定的配置。具体分为以下的两步：\n安装 cuda-toolkit：注意不能重复安装 CUDA 驱动，避免和 Windows 系统的 CUDA 驱动产生冲突 安装 cuDNN （非必须）设置环境变量 以下以 Ubuntu WSL 2 为例，介绍以下具体的安装过程。\nCUDA-toolkit on WSL 2 通过 Nvidia 的官方下载页面 选择 WSL-Ubuntu 即可找到对应的安装工具，我们这里选择 runfile 的方式进行，按照官方给出的安装指令进行，即：\n1 2 3 wget https://developer.download.nvidia.com/compute/cuda/12.1.1/local_installers/cuda_12.1.1_530.30.02_linux.run sudo sh cuda_12.1.1_530.30.02_linux.run 下载对应的 run 包后执行安装即可。\ncuDNN on WSL 2 在 Ubuntu 上安装 cuDNN 实际上除了网上资料很多的下载包进行安装，直接用以下的方式进行安装即可。\n1 sudo apt install nvidia-cudnn 安装后执行 nvcc \u0026ndash;version 验证版本。\nEnv 这一块的设置好像目前已经是不需要的，首先可以尝试不配置这一块内容。以下我会给出我这边的配置\n环境配置这块好像并不需要执行，如果还是报错的话，可以按照以下的方式来配置 zshrc 或者 bashrc。\n1 2 3 4 export CPATH=/usr/local/cuda/include:$CPATH export LD_LIBRARY_PATH=/usr/local/cuda/lib64/:$LD_LIBRARY_PATH export PATH=/usr/local/cuda/bin:$PATH export CUDA_ROOT=/usr/local/cuda or\n1 export LD_LIBRARY_PATH=/usr/local/cuda-12.1/lib64/{LD_LIBRARY_PATH:+:{LD_LIBRARY_PATH}} 这里顺便给出一个路径 /usr/lib/wsl/lib 中会有相关的 so 文件的路径，应该是和主机互通的地方。\n报错分析 Could not load library libcudnn_cnn_infer.so.8. Error: libcuda.so: cannot open shared object file: N\n没有安装或者配置 cudnn\n","permalink":"https://hugotest-phi.vercel.app/posts/windowscudacudnn/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在 Windows 和 WSL2 中安装 Cuda 和 Cudnn ，是配置 GPU 开发环境中重要的一步，其支撑了 AI 模型进行 Training 和 Interface 。本篇介绍安装 CUDA 和 Cudnn 的步骤和一些踩过的坑。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e参考资料如下：\u003ca href=\"https://blog.csdn.net/halou10200912/article/details/106048719\" target=\"_blank\" rel=\"noopener\"\u003e版本查看\u003c/a\u003e\n | \u003ca href=\"https://zhuanlan.zhihu.com/p/99880204\" target=\"_blank\" rel=\"noopener\"\u003eWin 安装 Cuda 和cuDNN\u003c/a\u003e\n | \u003ca href=\"https://blog.csdn.net/Apple_Coco/article/details/129293019\" target=\"_blank\" rel=\"noopener\"\u003eWSL 2 安装 CUDA 和cuDNN\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"win-11-安装-cuda-和-cudnn\"\u003eWin 11 安装 CUDA 和 cuDNN\u003c/h2\u003e\n\u003ch3 id=\"cuda\"\u003eCUDA\u003c/h3\u003e\n\u003cp\u003e首先在 Nvidia 的控制面板：\u003cstrong\u003e帮助-系统信息\u003c/strong\u003e的如下位置，查看 GPU 最大支持的 CUDA 版本：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230424130608.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230424130608.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230424130608.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e也可以使用 Nvidia-smi 命令在 Powershell 或者 CMD 中查看:\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230424130700.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230424130700.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230424130700.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e确定了版本之后到 \u003ca href=\"https://developer.nvidia.com/cuda-downloads\" target=\"_blank\" rel=\"noopener\"\u003eNvidia CUDA下载页面\u003c/a\u003e\n 下载指定版本的 CUDA 进行安装（根据安装指引进行）即可，安装位置等默认即可，其中有一些安装选项即是 Nvidia GeForce Experience 安装的内容。\u003c/p\u003e\n\u003cp\u003e安装完成后在 CMD 或者 PowerShell 确认是否安装完成（需要重启终端）：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003envcc\u003c/span\u003e \u003cspan class=\"n\"\u003e-V\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230424131341.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230424131341.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230424131341.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Windows Configuration05 CUDA \u0026 Cudnn"},{"content":" This Chapter introduce how to set up stable diffusion and mid-journey, and record some problem I meet when I deploy it.\n(Deprecated) midjourney 由于 midjourney 现需要付费使用，同时没有开源，因此我们讲一笔带过该部分内容，该部分内容大多转载于 超详细！AI 绘画神器 Midjourney 基础使用手册 midjourney 的安装步骤主要分成以下的几步：\n点击 Join the Beta 注册账号，注册完会跳转到； Discord 首页，亲自创建自己的服务器，仅供我和我的朋友使用； 下载客户端，在默认对话界面讯在或开始新的对话，输入 Midjourney Bot，添加到服务器 付费开启体验。 (Deprecated) DreamStudio 说是可以本地部署，但是实际体验非常不好，应该只是部署了 Webui，然后调用官方提供的免费 API；所以有时候生成不出来，但是又不报错，不知道是不是使用姿势有问题，反正很屎。\nhttps://github.com/Stability-AI/StableStudio 装好 npm 和 yarn 参考 quick start，git clone -\u0026gt; (cd) yarn 安装 -\u0026gt; yarn dev 部署在本地端口上。 官网注册账号-\u0026gt; 获取 API -\u0026gt; 填入并在最上方转到 Generate 页面即可。 Stable Diffusion 部署专题 该部分作为 Intro，仅介绍 Stable Diffusion 的安装和部署，以及一些启用参数等，具体的使用在后面的文章进行进一步的讲解。\n基于官方 REPO： AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI (github.com) 这里介绍基于 windows 的安装和 WSL2 的安装部署过程。整体的安装可能会分成以下的几个步骤进行：（推荐在安装和部署之前，参考 [[WindowsCudaCudnn]] 一文，首先配置 CUDA，也可以遇到问题再部署）\n基础依赖和环境安装（python、CUDA） Stable DIffusion 的 UI 界面和部分插件安装 模型下载和加载 Win 部署 一些像是 Conda 之类的包的安装这里都不会再赘述，可以参考相关文章 [[python_pack_manager]]，这一部分仅针对 Stable Diffusion 的安装进行描述\n(optional) 创建 Conda 环境，避免依赖冲突和污染，envname 可以是你自选的一个环境名。 1 conda create -n \u0026lt;envname\u0026gt; python=3.10.6 下载 stable-diffusion-webui 仓库, 会将该 repo 下载到当前目录，即 ./stable-diffusion-webui/ 1 git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 安装 python 依赖的过程已经集成在启动脚本中，因此无需执行依赖安装 xformers 可能需要手动安装，并且需要额外的启动参数，安装脚本如下 pip install -U xformers\n（已安装就忽略）安装 cuda，cudnn，参考相关文章\n启动网页客户端进行使用和测试 - 其中如果带 listen 参数的话可以开启局域网访问。 - 带 share （不推荐）可通过 python 的库托管，会给定一个公网 url，支持进行公网访问。 - 带 xformers 可以在 webui 中启用 xformer，手动先安装一下\n1 ./web-ui.bat --listen --xformers 或者直接双击运行即可。\nWSL 2 部署 这里的部署也可以作为 LINUX 部署的方式，实际上安装的过程和 windows 是相似的，只是最后启动的脚本不同。\n其中 1~4 的步骤都是类似的，cuda 安装参考相关文章中 WSL2 专题即可；最后的执行脚本如下：\n1 sudo ./webui.sh -f 这样执行的原因是可能会提示不是 root 用户，使用-f 参数强制其运行，并通过 sudo 避免访问受限。\nDocker 部署 参考资料：Docker版Stable Diffusion WebUI，可cpu运行 Docker Image：AbdBarho/stable-diffusion-webui-docker: Easy Docker setup for Stable Diffusion with user-friendly UI (github.com) 安装的时候记得使用 -v 将 model 和 output 目录挂载出来，方便后续下载模型以及下载图片。\n参考的启动脚本如下（WSL 2）：\n1 2 3 4 5 docker run -it --name sdw --network host \\ -v /mnt/d/software/ai/stable-diffusion-webui/models:/app/stable-diffusion-webui/models \\ -v /mnt/d/software/ai/stable-diffusion-webui/outputs:/app/stable-diffusion-webui/outputs \\ --rm siutin/stable-diffusion-webui-docker \\ bash webui.sh --skip-torch-cuda-test --precision full --no-half --use-cpu Stable-diffusion GFPGAN ESRGAN VAE --all --share 后续有空的话会修改一下，或者给出 compose 文件。\n插件安装和设置 插件安装，下列位置 URL 填入 Github 地址，点击安装后重启 UI 即可。\nAddition Net Work插件：kohya-ss/sd-webui-additional-networks (github.com) 中文插件安装和设置：VinsonLaro/stable-diffusion-webui-chinese: stable-diffusion-webui 的汉化版本 (github.com) 中文插件的启用主要在 Setting 选项卡中，用户界面的最下面，选择后保存（Apply Setting）并重载 UI （Reload Web UI）即可。\n插件更新\u0026amp;其他安装方式 直接到 extensions 目录下进行 git clone、git pull 或者下载安装包来进行解压都可以。\n安装问题汇总 Something went wrong Expecting value: line 1 column 1 (char 0) ： 该错误和代理有关，关闭或者重启部分代理设置可解决。\n虚拟环境启动失效的问题：删除 wsl2 中 stable-diffusion-webui 目录下的虚拟环境目录，重新执行即可。\n1 rm -rv venv FI 后续安排 部署的部分到这里就结束了，之后的篇章会如下安排，时间未定，有时间的话会写：\n基础的使用：页面和基本功能元素、各种模型的介绍、载入和使用、以及各种启动项的介绍； 插件和拓展：Control Net 和部分插件专题 训练：提供自己的图像训练自己的模型 Prompt：整理 Prompt 资源，归纳自己用的 Prompt、Prompt 小技巧 not sure）原理：Stable Diffusion 的论文原理和代码解读 ","permalink":"https://hugotest-phi.vercel.app/posts/stable-diffusion/","summary":"\u003cblockquote\u003e\n\u003cp\u003eThis Chapter introduce how to set up stable diffusion and mid-journey, and record some problem I meet when I deploy it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"deprecated-midjourney\"\u003e(Deprecated) midjourney\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e由于 midjourney 现需要付费使用，同时没有开源，因此我们讲一笔带过该部分内容，该部分内容大多转载于  \u003ca href=\"https://www.uisdc.com/midjourney\" target=\"_blank\" rel=\"noopener\"\u003e超详细！AI 绘画神器 Midjourney 基础使用手册\u003c/a\u003e\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://midjourney.com/home/?callbackUrl=%2Fapp%2F\" target=\"_blank\" rel=\"noopener\"\u003emidjourney\u003c/a\u003e\n 的安装步骤主要分成以下的几步：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e点击 Join the Beta 注册账号，注册完会跳转到；\u003c/li\u003e\n\u003cli\u003eDiscord 首页，亲自创建自己的服务器，仅供我和我的朋友使用；\u003c/li\u003e\n\u003cli\u003e下载客户端，在默认对话界面讯在或开始新的对话，输入 Midjourney Bot，添加到服务器\u003c/li\u003e\n\u003cli\u003e付费开启体验。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"deprecated-dreamstudio\"\u003e(Deprecated) DreamStudio\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e说是可以本地部署，但是实际体验非常不好，应该只是部署了 Webui，然后调用官方提供的免费 API；所以有时候生成不出来，但是又不报错，不知道是不是使用姿势有问题，反正很屎。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Stability-AI/StableStudio\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/Stability-AI/StableStudio\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e装好 npm 和 yarn\u003c/li\u003e\n\u003cli\u003e参考 quick start，git clone -\u0026gt; (cd) yarn 安装 -\u0026gt; yarn dev 部署在本地端口上。\u003c/li\u003e\n\u003cli\u003e官网注册账号-\u0026gt; 获取 API -\u0026gt; 填入并在最上方转到 Generate 页面即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"stable-diffusion-部署专题\"\u003eStable Diffusion 部署专题\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e该部分作为 Intro，仅介绍 Stable Diffusion 的安装和部署，以及一些启用参数等，具体的使用在后面的文章进行进一步的讲解。\u003c/p\u003e","title":"AIGC01 Stable Diffusion and midjourney Setup"},{"content":" Linux 三剑客之 Awk (由三个创始人的姓氏首字母组成)，相比于 Grep 和 Sed 而言更为特殊一些，它是一种模式匹配的编程语言，其主要的作用匹配文本进行处理，其擅长实现对文本的格式化输出，而作为一门编程语言：支持函数，变量，循环，运算，但相对简单。\nAWK 的执行逻辑是：搜索文件的每一行，如果发现匹配内容，就执行下一个编程步骤，如果没发现，就继续处理下一行的内容。\nIntro 由于 AWK 实际上是一个编程语言，本篇主要只介绍其命令行用法。\n首先介绍 AWK 命令，其主要用于匹配文本并格式化输出，适用于对表格化的数据机型处理。其使用模板大致如下：\n1 2 3 4 awk [options] \u0026#39;program\u0026#39; var=value file... awk [options] \u0026#39;pattern {action1; action2; ...}\u0026#39; file ... awk [options] -f programfile var=value file... awk [options] \u0026#39;BEGIN{ action;... } pattern{ action;... } END { action;... }\u0026#39; file ... -f scriptfile: 从脚本文件中读取 awk 命令 -v var=value: 赋值一个用户定义变量，也可用这种方式修改内置变量 -F fs: fs 可为任意字符串或者正则表达式，用于指定分隔符（也可以通过-v 的方式修改内置的分隔符变量来实现） 每个 action 或者说 statement 之间用 ； 分割\n参考资料：AWK wikipedia | practical-programming-books/awk.md | 一. AWK入门指南 — AWK程序设计语言 | Linux文本三剑客超详细教程\u0026mdash;grep、sed、awk - alonghub Variant 变量 变量：awk 主要涵盖两种变量，变量和内置变量，定义变量使用-v 命令，在每个变量前都要加 -v\n接下来分别介绍如何使用这些变量来对文件进行操作。\n内置变量 awk 进行文件处理的时候，会有一组默认变量，基于这组默认变量可以支持各种脚本需求，同时也对应一些操作。\n内置变量 功能 默认值 FS 分割符变量 \u0026quot;\u0026quot; OFS 输出时的字段分隔符 \u0026quot;\u0026quot; NF 分割后的字符串数量(可以被分成几段)， $NF 引用最后一列；$ (NF-1) 引用倒数第二列 NR 行号；后跟多个文件时，第二个文件的行号从第一个的末尾开始 FNR 行号；但各个文件分别计数 FILENAME 当前文件名 ARGC 命令行参数的个数 ARGV 数组，存储了命令行给定的各个参数 RS 指定输入时的换行符，（原换行符效果保留） ORS 替代输出时的换行符 接下来我会用简单的例子来说明以下这些指令，基于以下的测试文件 awk_test：\n1 2 3 4 hello:awk:world good-for-u the:env:basic:on:bash fi:example 第一个主要参数的例子如下：\n1 2 3 awk -v FS=\u0026#34;:\u0026#34; -v OFS=\u0026#34;|\u0026#34; \u0026#39;print{$0,NF,NR,FILENAME,ARGC}\u0026#39; awk_test #BTW等同于如下的文件 awk -F\u0026#34;:\u0026#34; -v OFS=\u0026#34;|\u0026#34; \u0026#39;{print $0,NF,NR,FILENAME,ARGC,ARGV[3]}\u0026#39; awk_test 该命令将输出如下结果，各个参数的含义可以在上面查表。\n1 2 3 4 hello:awk:world|3|1|awk_test|2 good-for-u|1|2|awk_test|2 the:env:basic:on:bash|5|3|awk_test|2 fi:example|2|4|awk_test|2 $n 代表指定列，如果是 $ 0 就会输出每一列。\n1 ARGV[i] 上述对应第 i 个参数。\n第二个介绍NF 的特殊用法：\n1 awk -F\u0026#34;:\u0026#34; -v OFS=\u0026#34;|\u0026#34; \u0026#39;{print $(NF-1)}\u0026#39; awk_test 会得到如下的输出：\n1 2 3 4 awk good-for-u on fi 基于上面的例子也能对 print 命令的使用有个大致的概念。\n自定义变量 这里主要介绍自定义变量的几种方式，\nWay 1: 直接通过输入参数设置好变量值 -v var=value Way 2: 在 program 中定义 - awk -F':' {name=\u0026quot;admin\u0026quot;; print name, $0} 一切正常 - awk -F':' {print name, $0;name=\u0026quot;admin\u0026quot;} 第一行的 name 会为空\n数组 （1）可使用任意字符串；字符串要使用双引号括起来 （2）如果某数组元素事先不存在，在引用时，awk 会自动创建此元素，并将其值初始化为“空串” （3）若要判断数组中是否存在某元素，要使用“index in array”格式进行遍历 （4）若要遍历数组中的每个元素，要使用 for 循环for(var in array) {for-body}\n这里简单介绍一下数组的使用，{ line[NR] = $0 } # 记下每个输入行 ，!arr[$ 0]++ 去除重复元素，并对每个元素出现的次数进行计数。\n1 2 3 4 5 6 7 8 # 反转 - 按行逆序打印输入 { line[NR] = $0 } # 记下每个输入行 END { i = NR # 逆序打印 while (i \u0026gt; 0) { print line[i] i = i - 1 } } 1 2 ---打印文件内容，和该行重复第几次出现 awk \u0026#39;{!arr[$0]++;print $0,arr[$0]}\u0026#39; awktest 下面将 value 赋值给数组下标为 index 的元素：\n1 array[index]=value Printf 命令 比 print 更强大的专注于格式化的输出命令，而 FORMAT 也是 AWK 的一个重要核心，所以这里额外的介绍以下 printf，并以此引入FORMAT\n其使用方式大致如下：\n1 printf \u0026#34;FORMAT\u0026#34;, item1,item2,... 同时相比于 print，其具备如下特性需要注意：\nFORMAT 必须指定； 不会自动换行，需要显式的给出换行控制符，\\n FORMAT 需要为后面的每个 item（如 $1, $ 2 等需要输出的变量） 指定格式符 格式写法 format 的定义得与 item 相互一一对应，下面是一些格式的写法。\n%c：显示字符的 ASCII 码 %d，%i：显示十进制整数 %e，%E：显示科学计数法数值 %f：显示为浮点数，小数：%5.1f 指的是带小数点，宽度共 5 位，其中小数 1 位，不够的情况用空格补上。 %g，%G：以科学计数法或者浮点形式显示数值 %s：显示字符串，例如 %5s，显示最少 5 个字符，不够用空格补上，超过还继续显示 %u：无符号整数 %%：显示%本身 除了这些字符格式之外，还有一类修饰词，用来规范输出的样式，修饰词放 %\u0026lt;修饰词\u0026gt;\u0026lt;格式写法\u0026gt;\n\u0026lt;digit\u0026gt;[.\u0026lt;digit\u0026gt;]：\u0026lt;digit\u0026gt; 表示数字，第一个数字控制显示的宽度，第二个表示小数点后的精度。 -：左对齐（默认右对齐），%-15s 左对齐显示 15 个字符 +：显示数值的正负符号，%+d 举个例子，假如我们有如下的 person_info 文件\n1 2 ponywang 123456 hollyx 234567 则使用该 awk 命令\n1 awk \u0026#39;{printf \u0026#34;%10s:%11s\\n\u0026#34;, $1, $2}\u0026#39; contract 输出如下：\n1 2 ponywang: 123456 hollyx: 234567 而如果约定左对齐的话，即使用下条 awk 命令，对应的结果如下\n1 2 3 awk \u0026#39;{printf \u0026#34;%-10s:%11s\\n\u0026#34;, $1, $2}\u0026#39; contract ponywang : 123456 hollyx : 234567 Operator 基本操作符 各种算数操作符、比较操作符、逻辑操作符，和普通的操作符是一致的，就不在赘述了；而字符串操作符是无符号操作符，做字符串连接。这里介绍一些其他的特别的操作符。\n赋值操作符： =，+=，-=，*=，/=，%=，^= ++ ，-- 模式匹配符： ~：左边是否和右边匹配 !~：是否不匹配 函数操作符：function_name(arg1, arg2) 三目表达式：selector?if-true-expression:if-false-expression （三目表达式使用）例子 1：在未使用的 drive 的行面前添加 null，否则添加 nonull，该例子实际上包含了赋值和三目表达式。\n1 df -h | awk \u0026#39;{$3==0?name=\u0026#34;null\u0026#34;:name=\u0026#34;nonull\u0026#34;;print name,$0}\u0026#39; （模式匹配符使用）例子 2：仅打印 dev 的磁盘，有以下的两种匹配方式：\n1 2 df -h | awk \u0026#39;/^\\/dev/ {print $0}\u0026#39; df -h | awk \u0026#39;$1 ~ /^\\/dev/ {print $0}\u0026#39; 其中可以用模式匹配符结合$n 来指定在哪一列中进行匹配。\n同时我们可以看出 awk 和管道结合使用的方式，那么如果我们要过滤出 dev 中使用超过 40% 的可以使用以下的方式进行，awk 也可以仅仅只做模式匹配。\n1 df -h | awk \u0026#39;/^\\/dev/ {print $(NF-1)\u0026#34;---\u0026#34;$0}\u0026#39; | awk -F% \u0026#39;$1 \u0026gt; 40\u0026#39; （逻辑和比较符使用）例子 3：筛选/etc/passwd 中第三列=0 或者\u0026gt;=1000 的用户名。\n1 cat /etc/passwd | awk -F: \u0026#39;$3==0 || $3\u0026gt;=1000 {print $1}\u0026#39; 这里也可以试一下算数运算符\n1 cat /etc/passwd | awk -F: \u0026#39;$3==0 || $3\u0026gt;=1000 {print $1,$2,$3+10086} Pattern 匹配格式 从上面的例子也可以知道模式匹配也是 awk 中重要的组成部分，下面介绍一下 awk 的匹配逻辑：\n根据 pattern 条件，过滤出匹配的行后再做后续的{action}处理，如果没有 action 就仅过滤\n主要有以下的几种模式：\nNone: 不写的话就匹配每一行 /regular expression/：仅处理能被模式匹配到的行，正则需要被 // 包起来 condition expression：awk 的条件表达式，结果为真的行才会被处理。 line ranges：行范围 /pattern 1/, /pattern 2/ ：用两个 pattern 匹配到的行的范围，不支持直接给出数字，可以有多段，中间可以有间隔。 BEGIN/END 模式 BEGIN{}：仅在开始处理文件的文本之前执行一次 END{}：尽在文本处理完成之后执行 结合 BEGIN 和 END 等模式，就可以更好的格式化输出文件了，比如我们模拟 df -h 的标题行和新增总结行。我们提前备好一个没有对应的头的文件。\n1 2 3 4 df -h | awk -v TOTAL=0 -v USED=0 \u0026#39;BEGIN{printf \u0026#34;%-10s\\t%10s\\t%10s\\t%10s\\t%10s\\t%10s\\n\u0026#34;,\u0026#34;FILESYSTERM\u0026#34;,\u0026#34;SIZE\u0026#34;,\u0026#34;USED\u0026#34;,\u0026#34;AVAIL\u0026#34;,\u0026#34;USE%\u0026#34;,\u0026#34;MONTED ON\u0026#34;} {TOTAL+=$2;USED+=$3;printf \u0026#34;%-10s\\t%10s\\t%10s\\t%10s\\t%10s\\t%10s\\n\u0026#34;,$1,$2,$3,$4,$5,$6}\\ END{printf \u0026#34;%-10s\\t%10s\\t%10s\\t%10s\\t%10s\\t%10s\\n\u0026#34;,\u0026#34;SUM\u0026#34;,TOTAL,USED,\u0026#34;-\u0026#34;,USED/TOTAL*100,\u0026#34;WINDOWS\u0026#34;}\u0026#39; 可以看到这里由 BEGIN、{}、END 三部分组成，结合 Printf 来实现文件的对齐。\nCondition 条件语句 介绍一下条件语句怎么编写。\n1 if (condition){statement,...}else if(condition2){statement2,...} else {statement} 举个例子，\n1 df -h | awk \u0026#39;{if ($1==\u0026#34;none\u0026#34;) print $1,$2,$3}\u0026#39; 可以看出，条件表达式是包在{ action }中的 action 的部分，其中 condition 要用 () 抱起来，然后后接 statement 即可。当然如果要 if、else 的话，statement 最好还是用 {} 包起来更好。\nLoop 循环语句 loop 的写法主要有三种，while；do-while；for；接下来主要简单介绍一下各个循环的写法。\n此外，控制循环的 continue 和 break 的用法和其他语言是一致的这里就不再说；这里再介绍一下对 awk 本身循环控制的一个指令：next\nawk 本身有个逐行处理的循环，next 会提前结束对本行的处理，进入对下一行的处理。\nWhile 1 while(condition){statement;...} 使用场景\n对一行内的多个字段逐一类似处理时使用 对每一列的各元素逐一处理时使用 举个例子：匹配以 None 开头的行，每一行输出每一列的值和长度。\n1 df -h | awk \u0026#39;/^none/ {i=1;while(i\u0026lt;NF){print $i, length($i); i++}}\u0026#39; For 1 2 3 for (expr1;expr2;expr3) {statement;...} or for (var in array){statement;...} 可以看出 for 循环和 cpp 的写法是一致的，两种就不在赘述了。\ndo-while 1 do {statement;...} while(condition) 这里举个例子，计算 1+\u0026hellip;..+100=5050\n1 awk \u0026#39;BEGIN{sum=0;i=1;do{sum+=i;i++}while(i\u0026lt;=100);print sum}\u0026#39; （addition）switch 这里额外介绍一下 switch 语句：\n1 switch(expression) {case VALUE1 or /REGEXP/:statement1; case VALUE2 or /REGEXP2/: statement2;...; default: statementn} 自定义函数 和bash区别：定义函数（）中需加参数，return返回值不是$?，是相当于echo输出\n1 2 3 4 function name ( parameter, parameter, ... ) { statements return expression } 举例：\n1 2 3 4 5 function max(v1,v2) { v1\u0026gt;v2?var=v1:var=v2 return var } BEGIN{a=3;b=2;print max(a,b)} 其他的一些函数介绍 rand()生成 0-1 之间的随机数，需要首先 srand()初始化 length([s]) ：返回指定字符串的长度 sub(r,s,[t]) ：对t 字符串进行搜索r 表示的模式匹配的内容，并将第一个匹配的内容替换为s gsub(r,s,[t]) ：对t 字符串进行搜索r 表示的模式匹配的内容，并全部替换为s 所表示的内容 plit(s,array,[r]) ：以 r 为分隔符，切割字符串 s ，并将切割后的结果保存至 array 所表示的数组中，第一个索引值为1, 第二个索引值为2,… awk 中调用 shell 命令 使用 system 命令：\nawk BEGIN'{system(\u0026quot;hostname\u0026quot;) }' awk 'BEGIN{name=\u0026quot;along\u0026quot;;system(\u0026quot;echo \u0026quot;name)}' Fi 该篇还远不到结束，后续随着工作生活中用到再慢慢补充把，初步就到这里了，主要还是参考的网上的文献，实践还是太少了。\n","permalink":"https://hugotest-phi.vercel.app/posts/linux%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bawk/","summary":"\u003cblockquote\u003e\n\u003cp\u003eLinux 三剑客之 Awk (由三个创始人的姓氏首字母组成)，相比于 Grep 和 Sed 而言更为特殊一些，它是一种模式匹配的编程语言，其主要的作用匹配文本进行处理，其擅长实现对文本的格式化输出，而作为一门编程语言：支持函数，变量，循环，运算，但相对简单。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAWK 的执行逻辑是：搜索文件的每一行，如果\u003cstrong\u003e发现匹配内容，就执行下一个编程步骤，如果没发现，就继续处理下一行\u003c/strong\u003e的内容。\u003c/p\u003e\n\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e由于 AWK 实际上是一个编程语言，本篇主要只介绍其命令行用法。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e首先介绍 AWK 命令，其主要用于匹配文本并格式化输出，适用于对\u003cstrong\u003e表格\u003c/strong\u003e化的数据机型处理。其使用模板大致如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk \u003cspan class=\"o\"\u003e[\u003c/span\u003eoptions\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;program\u0026#39;\u003c/span\u003e \u003cspan class=\"nv\"\u003evar\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003evalue file...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk \u003cspan class=\"o\"\u003e[\u003c/span\u003eoptions\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;pattern {action1; action2; ...}\u0026#39;\u003c/span\u003e file ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk \u003cspan class=\"o\"\u003e[\u003c/span\u003eoptions\u003cspan class=\"o\"\u003e]\u003c/span\u003e -f programfile \u003cspan class=\"nv\"\u003evar\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003evalue file...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk \u003cspan class=\"o\"\u003e[\u003c/span\u003eoptions\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;BEGIN{ action;... } pattern{ action;... } END { action;... }\u0026#39;\u003c/span\u003e file ...\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e-f\u003c/strong\u003e scriptfile: 从脚本文件中读取 awk 命令\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e-v\u003c/strong\u003e var=value: 赋值一个用户定义变量，也可用这种方式修改内置变量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e-F\u003c/strong\u003e fs: fs 可为任意字符串或者正则表达式，用于指定分隔符（也可以通过-v 的方式修改内置的分隔符变量来实现）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e每个 action 或者说 statement 之间用 \u003ccode\u003e；\u003c/code\u003e 分割\u003c/p\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://zh.wikipedia.org/wiki/AWK\" target=\"_blank\" rel=\"noopener\"\u003eAWK wikipedia\u003c/a\u003e\n | \u003ca href=\"https://github.com/EZLippi/practical-programming-books/blob/master/src/awk.md\" target=\"_blank\" rel=\"noopener\"\u003epractical-programming-books/awk.md \u003c/a\u003e\n | \u003ca href=\"https://awk.readthedocs.io/en/latest/chapter-one.html\" target=\"_blank\" rel=\"noopener\"\u003e一. AWK入门指南 — AWK程序设计语言\u003c/a\u003e\n | \u003ca href=\"https://www.cnblogs.com/along21/p/10366886.html\" target=\"_blank\" rel=\"noopener\"\u003eLinux文本三剑客超详细教程\u0026mdash;grep、sed、awk - alonghub\u003c/a\u003e\n\u003c/p\u003e","title":"Grep、Sed、Awk 03 Awk"},{"content":" Linux 三剑客之 Sed，相比于擅长数据查找定位的 Grep，Sed（Stream Editor）擅长做的是数据修改，做的主要是做一些增删改的功能。 sed 和 awk 的区别是什么？ Intro 首先介绍 Sed 命令，Stream Editor 流编辑器，针对字符流来进行文件编辑，同样，其核心也在于正则匹配式，其用法如下：\n1 sed [option] {script} [input-file] 其中{script}可以理解为三者的组合：sed 动作指令+Reg 用正则\u0026amp;行号确定修改位置+修改的内容：Script 是 Sed 的核心，分别对应着：操作的行为，操作的位置和操作的内容。\nSed 的用法也可以按照这个来记：\n1 sed [-hnV] [-e \u0026lt;script\u0026gt;] [-f \u0026lt;script文件\u0026gt;] [文本文件] h 显示 helo ；-n 表示静默输出，-V 显示版本；参考第一种用法，-e 可以指定多个 script 对输入的文件进行处理，-f 则可以将多个 script 写在文件中，通过读取文件中的 scripts 来对文本文件进行处理。\n作为文本流编辑器，Sed 是一行一行的处理文件内容，将正在处理的每一行内容放在缓冲区中按照约定进行修改，处理后按照约定修改文件或输出，接着在处理下一行，直到整个文件处理内容。\n其主要用来编辑和处理一个或者多个文件，简化对于文件的重复操作。\n参考资料：sed 和 awk 的区别-知乎 | Man | sed 简明教程 | CoolShell | Linux sed 命令 | 菜鸟教程 | Linux文本三剑客超详细教程\u0026mdash;grep、sed、awk Options 常用选项 -e 多点编辑，对每行处理时使用多个 Script -f 将 scrips 写到文件里，如果是多个 script 之间换行 -r/E 支持拓展的正则表达式 -i 直接将修改写入文件（如果不加入 i 的话不会修改文件，只会讲修改过后的内容进行输出，后续也可以使用重定向输入到文件中） -i.bak 直接将修改写入文件，但是会将原本的文件备份到*.bak -n 静默输出。 Scripts 编辑命令编写 上述提到，Sed 的核心在于 Script，其编写主要由三个部分组成，Command（行为） + Located（定界，确定修改的位置）+ Content（修改内容，增或者改的时候需要，删无需）这里主要介绍以下常用的动作指令和定界方式。\nCommand 动作指令 具体的所有动作指令还是要参考 Man 文档，这里只介绍一些常用的 command，\nCommand Type Desc a 增 Append 后接字符，在指定行的下一行添加指定的新的字符，支持 \\n i 增 Insert 后接字符，在指定行的上一行添加指定的新的字符，支持 \\n d 删 删除通常不接任何字符，删除当前行 c 改 change 可接字符串，可以取代 n1，n 2 之间的行，支持 \\n s /// 改 查找与替换，通常搭配正则表达式使用，将指定的词替换成新词 p 输出 Print，将某个指定的数据输出，通常会配合-n 一起用 = 输出 为模式匹配空间的行打印行号 w 输出 保存模式匹配空间的行到指定文件 ！ 功能 模式空间中匹配行取反处理 其中 s 替换命令，在诸多动作指令中算是一个非常常见的命令，其用法略为复杂一些，这里做基础介绍：\n1 s /\u0026lt;before\u0026gt;/\u0026lt;after\u0026gt;/\u0026lt;type\u0026gt; 这里的 before 和 after 都好理解，type 为 g 表示对匹配到的行内进行全局替换，为任意 num 的时候则是匹配每一行中第几个匹配到的值，num+g 的话就代表从 num 个起。\n这里介绍一个替换的例子，假如我们希望删除 html 中的 tags\n1 \u0026lt;b\u0026gt;This\u0026lt;/b\u0026gt; is what \u0026lt;span style=\u0026#34;text-decoration: underline;\u0026#34;\u0026gt;I\u0026lt;/span\u0026gt; meant. Understand? 若使用以下的指令，会将\u0026lt;b 和 span\u0026gt;中的内容全部删除，并非理想的效果。\n1 sed \u0026#39;s/\u0026lt;.*\u0026gt;//g\u0026#39; html.txt 我们需要借助正则的方式来避免这种情况，如下除了\u0026gt;的字符重复 0 次或多次即可；\n1 sed \u0026#39;s/\u0026lt;[^\u0026gt;]*\u0026gt;//g\u0026#39; html.txt Located 地址定界 sed 会使用到的\u0026quot;定界\u0026quot;方式实际上主要有两种：\n匹配：使用正则表达式进行匹配 地址范围：指定行 但是其中匹配的方式，可以按照模式能够匹配到的每一行进行理解，这样的话就可以整理成以下的几种方式；\n不给地址：对全文进行处理\n指定地址：\nn 即指定的第 n 行 /pattern/ 即被此处模式能匹配到的每一行 地址范围有以下的表示方式\nn1,n2 表示处理 n1 到 n2 的范围， n1,+n 表示处理 n 1 到 $n 1+n$ 的范围 /pat1/，/pat2/ 表示从 pattern1 到 pattern2 的范围，但是注意会匹配每一个这样的组，如果某个 patern1 没有被 pattern2 闭起来的话就会输出到末尾。 n,/pat1 表示从 n 行到 pattern1 的范围 /pat1/,+n 则表示从 pattern 1 即之后的 n 行 类似这种方式可以对这几种行匹配方式进行自由组合 步进表达式，通常用以表示单双行\nsed -n '1~2p' 表示只打印奇数行，从第一行开始，搁两行输出 sed -n '2~2p' 表示只打印偶数行 需要注意，sed 定义的行号是从第 1行开始的，没有第 0 行；此外，进行测试的时候输入-n 能够防止输出未匹配到的行从而混淆视听，这里可以使用如下的命令，结合-n 和 p command 来做测试。\n1 sed -n \u0026#39;\u0026lt;locate\u0026gt;p\u0026#39; \u0026lt;file\u0026gt; Usage 用法展示 这里会零零散散的展示一些没那么常规或者值得一提的用法，具体的类型会通过 title 指出；还有一些什么单双行匹配的使用特定的定界符号 1~2 在地址的前面就行，\nType 1 在行末或行前添加 如果需要在每行末尾或行首添加指定内容（非换行的情况），则不能使用 a 或者 i 命令，需要使用 s 结合正则的方式实现：\n例如给 ip 地址添加端口 ：22，原文件如下\n1 2 192.168.0.1 192.168.0.2 则使用 ^ 代表行首，$ 代表行尾，使用如下的命令进行修改\n1 2 sed \u0026#34;1,2s/$/:22/g\u0026#34; ip_file #末尾添加,但是只处理1-2行 sed \u0026#34;s/^/ip:/g\u0026#34; ip_file #头部添加 拓展：当源文件如下，我们只需要添加缺失的时候，同样可以使用正则表达式进行处理。\n1 2 192.168.0.1 192.168.0.2:80 使用正则定界并取反，排除存在:port 的行，对剩下的行进行替换\n1 sed \u0026#34;/:[0-9]*$/ ! s/$/:22/g\u0026#34; ip_file 参考资料：sed - Add text at the end of each line - Stack Overflow Type 2 多 Script 匹配 还是上面的例子，如果我们希望同时在头部和尾部添加东西（或者类似的多个匹配操作），可以用以下方式来同时执行多个匹配模式。\n1 sed -e \u0026#34;/:[0-9]*$/ ! s/$/:22/g\u0026#34; -e \u0026#34;s/^/ip:\u0026#34; ip_file 就可以同时执行头部和尾部的内容添加，同样也可以按照以下的方式写：\n1 sed -e \u0026#34;/:[0-9]*$/ ! s/$/:22/g; s/^/ip:\u0026#34; ip_file 还可以使用 -f 参数将多个 script 写在文件中\nType 3 多 Script 组合 当处理的是不同地方的多个脚本，可以使用多 script 匹配的方式进行，但是当我们针对一个匹配字符进行多个处理的时候，可以使用 {} 来组合 command ，每个命令之间用 ; 分割。\n比如我们希望将 192 修改成 172 后输出：\n1 sed -n \u0026#34;/192/{s/192/172/g;p}\u0026#34; 上面这个命令首先找到 192 匹配的行，然后针对改行执行替换后，执行输出指令；\nType 4 将匹配值作变量 可以用 \u0026amp; 代表被匹配到的变量，然后就可以基于该变量进行修改，比如我们识别到 192 开头的就在其前面加上 LAN_ADDR:\n1 sed \u0026#34;s/192/LAN_ADDR:\u0026amp;/g\u0026#34; ip_file 当然这里也可以直接用 192 表示，但是如果我们的 192 只是一个用通配符匹配到的模式的时候就能发挥其作用。\n可以用来做大小写转换\n同样，根据该命令我们也可以进行特定字符的大小写转换，首先给出部分特殊参照符号如下，结合以下的参数就可以实现大小写转换。\nsymbol function \\u 将下一个字符转变成大写 \\l 将下一个字符转变为小写 \\U 将 replacement 的字符转变为大写，直到 \\U 或 \\E 出现 \\L 将 replacement 的字符转变为大写，直到 \\L 或 \\E 出现 \\E 停止大小写转换 1 sed \u0026#34;s/[a-z]/\\u\u0026amp;/g\u0026#34; ip_file 这样就可以将全文的英文字符做大小写转换了，可以以类似方式对指定的字符进行转换。\n圆括号匹配也是一种将匹配值作为变量的方式\n圆括号匹配: 使用圆括号括起来的正则表达式所匹配的字符串可以当成变量来使用，sed 中使用 \\1 ; \\2 \u0026hellip;来引用对应的匹配值。\n参考自sed 简明教程 CoolShell 1 sed \u0026#34;s/\\([^.]*\\).1\\([^1]*\\).1/\\1:\\2/g\u0026#34; ipfile 其中 \\1 代表 \\([^.]*\\) 匹配到的内容也就是 192，\\2 则是代表 \\([^1]*\\) 匹配到的内容是 68.0，该行命令会将 192.168.0.1 转换成 1 92:68 .0\n注意使用圆括号匹配的时候需要使用 \\ 转义符，不然会当成普通的括号或者报错。\nType 5 管道处理 1 cat log_file | sed \u0026#34;s/bef/aft\u0026#34; Advanced 高级用法 该部分摘自参考资料：Linux文本三剑客超详细教程\u0026mdash;grep、sed、awk Manual 格式手册 进阶命令格式（用的时候再来查表吧），通过 Hold Space 相当于可以引入一个中间变量来做一些单变量无法实现的处理，比如说将文章倒序输出；\nh：把模式空间中的内容覆盖至保持空间中 H：把模式空间中的内容追加至保持空间中 g：从保持空间取出数据覆盖至模式空间 G：从保持空间取出内容追加至模式空间 x：把模式空间中的内容与保持空间中的内容进行互换 n：读取匹配到的行的下一行覆盖 至模式空间 N：读取匹配到的行的下一行追加 至模式空间 d：删除模式空间中的行 D：删除 当前模式空间开端至\\n 的内容（不再传 至标准输出），放弃之后的命令，但是对剩余模式空间重新执行sed Reverse 倒序显示文件 1 sed \u0026#39;1!G;h;$!d\u0026#39; num.txt 该命令能将文本倒序输出，具体的原理如下：\n该 Hold Space 还能用于什么情况我们后续补充，文中的其他例子好像不需借助 Hold Space 就可以实现了。\nExtra Info 其他设置 Delimiter 分隔符选择 实际上在 sed 中，除了使用 / 还可以使用 @ , | , ! , ` 四种分隔符，其中比较推荐的还是 |,其他的几个分隔符和原本的 / 在可读性上没有优势。/ 主要是涉及到转义符号的时候有些头皮发麻。\n参考资料： sed 模式分隔符 - sed 基础教程 Special Symbol 特殊符号 添加制表符直接使用 \\t 是无效的无法正确识别 Tab，原本说 sed 不支持 \\n 和 \\t 但是实际测试以下的方式 是可以添加两种字符的。\n1 2 3 4 # create the origin file echo \u0026#34;hello world\u0026#34; \u0026gt;\u0026gt; test_file sed -i \u0026#34;1a\\ \\tThis slash spc and slash t will add tab\u0026#34; test_file sed -i \u0026#34;1a\\ \\nThis way can generate n also\u0026#34; test_file Mac 上的特殊处理 需要注意的是 Sed 命令在 Linux 和 Macos 上存在较大的不同，在 Linux 中的功能更全面一些，这是由于 MacOs 是基于 BSD 的存在一些不足，可以通过 homebrew 下载额外的 sed\nsed -i 在 mac 中需要指定用于备份的后缀，也可以用 \u0026quot;\u0026quot; 取消备份，否则会报错 invalid command code sed -i 在 mac 中输入需要添加的行的时候，需要需要换行 1 2 3 sed -i \u0026#34;\u0026#34; -e \u0026#34;${line_num} a\\\\ plugins=\\( \u0026#34; test.sh ","permalink":"https://hugotest-phi.vercel.app/posts/linux%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bsed/","summary":"\u003cblockquote\u003e\n\u003cp\u003eLinux 三剑客之 Sed，相比于擅长数据查找定位的 Grep，Sed（Stream Editor）擅长做的是数据修改，做的主要是做一些增删改的功能。\u003ca href=\"https://www.zhihu.com/question/297858714\" target=\"_blank\" rel=\"noopener\"\u003e sed 和 awk 的区别是什么？\u003c/a\u003e\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cp\u003e首先介绍 Sed 命令，Stream Editor 流编辑器，针对字符流来进行文件编辑，同样，其核心也在于正则匹配式，其用法如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esed \u003cspan class=\"o\"\u003e[\u003c/span\u003eoption\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003escript\u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003einput-file\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e其中{script}可以理解为三者的组合：\u003cstrong\u003esed 动作指令+Reg 用正则\u0026amp;行号确定修改位置+修改的内容\u003c/strong\u003e：Script 是 Sed 的核心，分别对应着：操作的行为，操作的位置和操作的内容。\u003c/p\u003e\n\u003cp\u003eSed 的用法也可以按照这个来记：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esed \u003cspan class=\"o\"\u003e[\u003c/span\u003e-hnV\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003e-e \u0026lt;script\u0026gt;\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003e-f \u0026lt;script文件\u0026gt;\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003e文本文件\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eh 显示 helo ；-n 表示静默输出，-V 显示版本；参考第一种用法，-e 可以指定多个 script 对输入的文件进行处理，-f 则可以将多个 script 写在文件中，通过读取文件中的 scripts 来对文本文件进行处理。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e作为文本\u003cstrong\u003e流\u003c/strong\u003e编辑器，Sed 是一行一行的处理文件内容，将正在处理的每一行内容放在缓冲区中按照约定进行修改，处理后按照约定修改文件或输出，接着在处理下一行，直到整个文件处理内容。\u003c/p\u003e\n\u003cp\u003e其主要用来编辑和处理一个或者多个文件，简化对于文件的重复操作。\u003c/p\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://www.zhihu.com/question/297858714\" target=\"_blank\" rel=\"noopener\"\u003esed 和 awk 的区别-知乎\u003c/a\u003e\n | Man | \u003ca href=\"https://coolshell.cn/articles/9104.html\" target=\"_blank\" rel=\"noopener\"\u003esed 简明教程 | CoolShell\u003c/a\u003e\n | \u003ca href=\"https://www.runoob.com/linux/linux-comm-sed.html\" target=\"_blank\" rel=\"noopener\"\u003eLinux sed 命令 | 菜鸟教程 \u003c/a\u003e\n |  \u003ca href=\"https://www.cnblogs.com/along21/p/10366886.html\" target=\"_blank\" rel=\"noopener\"\u003eLinux文本三剑客超详细教程\u0026mdash;grep、sed、awk \u003c/a\u003e\n\u003c/p\u003e","title":"Grep、Sed、Awk 02 Sed"},{"content":" Linux 三剑客之 Grep。Grep 估计会是大部分 Linux 用户最常用的文本搜索命令了，在三剑客中的使用场景也是最广泛的。在对正则有了基本了解之后，就可以更好的使用 Grep，同时也可以通过 Grep 的使用来更好的掌握常用的正则表达式。\nIntro 首先介绍 Grep 命令，Global Regular Expression Print 全局正则表达式输出，使用正则表达式搜索文本内容输出。其使用模板如下：\n1 grep [option] pattern file option 指定 grep 的搜索模式 pattern 需要搜索的内容，可以用正则表达式指定一个模式来做匹配 file 可以是文件夹等路径，用来确定搜索的范围（仅支持通配符）[[Linux三剑客之正则]] 接下来分别对两个部分进行简单的说明，file 的范围指定参考正则文章中对通配符的介绍即可。\nOption 搜索模式 参考资料：man grep ，ManPage-zh 具体完整的有哪些搜索模式可以在 man page 中进行查看。这里主要介绍一些常见的搜索模式和一些使用场景。\noption 对照表 Key Word Function -w 全词匹配 -i 忽略大小写 -I 搜索时忽略二进制文件 -r 搜索时递归搜索文件夹里的内容 -l 仅输出搜寻到匹配的文件名 -c 仅输出每一个输入文件中的匹配次数(v 结合的话就是不匹配的次数) -n 显示行号 -o 仅输出每行中的匹配内容 -v 反向搜索，搜索不匹配该模式的行 -A num 同时打印出匹配行的下 num 行 -B num 同时打印出匹配行的上 num 行 -C num 同时打印出匹配行的前后 num 行 -E 将模式按照拓展正则来读取 -q 取消输出，在匹配到时输出非 0 值，未匹配时返回 0，用于条件判断 -f 指定 Pattern 文件，每行一个 patten，匹配到其中一个即可（-F 会视为固定的字符串） -x 仅显示整行匹配的 Pattern 匹配模式 正则匹配的部分这里就不在赘述，参考前文的正则表达式部分。（用 Grep 来熟悉正则也是一个不错的选择）\n下面会结合使用方式来介绍一些例子。参考资料：grep 命令，Linux grep 命令详解：强大的文本搜索工具 Usage 使用方式 Type 1 在文件(夹)中搜索单词 1 2 grep match_pattern file_name grep -r match_pattern * 如果不指定 file_name 或者目录会在默认目录中搜索，所以启用-r 的时候记得要指定目录。同时通常搜索的时候，我们也希望能够知道匹配文本的位置；\n1 grep -rniI match_pattern * --color=auto 这里 r 用于搜索目录，n 输出行数，i 忽略大小写，I 忽略二进制文件，color 指定输出带颜色，便于观看，但是对新的 shell 来说，通常已经将 color 参数写入了 grep 的 alias，可以在命令行中查看。\nType 2 在多个文件中查找 不同于在目录中搜索，如果要指定特定的多个文件，可以按照以下的方式来：\n1 grep -w \u0026#34;key_word\u0026#34; file_1 file_2 file_3 ... 上面的命令希望在 file1~3 中搜索完全匹配 key_word 的行\nType 3 管道搜索 当我们需要对一些指令的输出内容中进行搜索的时候，就会用到这种方式，比如：\n编译或运行过程中的 Log 筛选出 Fatal 1 sh makr_run.sh | grep FATAL \u0026gt;\u0026gt; FATAL.log 查看特定的历史指令 1 history -i | grep git Type 4 用作条件判断 其实该部分主要是使用静默输出参数，该参数主要在 shell 脚本中用作条件测试。\n1 2 3 cat $file | grep model | grep -q resnet # is_model=$? # $? 返回上一条命令的执行结果，0表示成功，其他表示失败 Type 5 与或非 与可以利用管道连接符进行多次匹配即可，非则是-v\n1 grep -in key1 file | grep key2 或有以下的几种方式\n1 2 grep \u0026#39;key1\\|key2\u0026#39; filename grep -E \u0026#39;pattern1|pattern2\u0026#39; filename 或者使用-e 来制动多个匹配模式\n1 echo \u0026#34;model=tcnn\u0026#34; | grep -e \u0026#34;resnet\u0026#34; -e \u0026#34;tcnn\u0026#34; Type 6 包含或排除指定文件 1 2 3 4 5 6 # 只在目录中所有的.php和.html文件中递归搜索字符\u0026#34;main()\u0026#34; grep \u0026#34;main()\u0026#34; . -r --include *.{php,html} # 在搜索结果中排除所有README文件 grep \u0026#34;main()\u0026#34; . -r --exclude \u0026#34;README\u0026#34; # 在搜索结果中排除filelist文件列表里的文件 grep \u0026#34;main()\u0026#34; . -r --exclude-from filelist ","permalink":"https://hugotest-phi.vercel.app/posts/linux%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bgrep/","summary":"\u003cblockquote\u003e\n\u003cp\u003eLinux 三剑客之 Grep。Grep 估计会是大部分 Linux 用户最常用的文本搜索命令了，在三剑客中的使用场景也是最广泛的。在对正则有了基本了解之后，就可以更好的使用 Grep，同时也可以通过 Grep 的使用来更好的掌握常用的正则表达式。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cp\u003e首先介绍 Grep 命令，\u003cstrong\u003eGlobal Regular Expression Print\u003c/strong\u003e 全局正则表达式输出，使用正则表达式搜索文本内容输出。其使用模板如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep \u003cspan class=\"o\"\u003e[\u003c/span\u003eoption\u003cspan class=\"o\"\u003e]\u003c/span\u003e pattern file\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eoption 指定 grep 的搜索模式\u003c/li\u003e\n\u003cli\u003epattern 需要搜索的内容，可以用\u003cstrong\u003e正则表达式\u003c/strong\u003e指定一个模式来做匹配\u003c/li\u003e\n\u003cli\u003efile 可以是文件夹等路径，用来确定搜索的范围（仅支持\u003cstrong\u003e通配符\u003c/strong\u003e）[[Linux三剑客之正则]]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e接下来分别对两个部分进行简单的说明，file 的范围指定参考正则文章中对通配符的介绍即可。\u003c/p\u003e","title":"Grep、Sed、Awk 01-Grep"},{"content":" “awk、grep、sed 是 linux 操作文本的三大利器，合称文本三剑客，也是必须掌握的 linux 命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属 awk 功能最强大，但也最复杂。grep 更适合单纯的查找或匹配文本，sed 更适合编辑匹配到的文本，awk 更适合格式化文本，对文本进行较复杂格式处理。“\nLinux文本三剑客超详细教程\u0026mdash;grep、sed、awk 在介绍这三个命令之前，需要对正则表达式有所了解，结合正则表达式来使用，才能发挥这 linux 三剑客的的全部能力。\n正则表达式 RegExp 正则表达式： Regual Expression 为一类特殊字符和文本符号共通约定的一种 pattern，其中的一些字符并不表示其本身的含义，而是用来做通配符号。\n其中基本正则表达式 BRE 是普遍支持的，而拓展正则表达式 ERE 通常则是需要特殊的参数来启用的。通过正则表达式中特殊符号的辅助，能够更快的过滤，查找，替换，处理字符流等。\n除了在 grep、sed、awk 的 linux 三剑客中，在各个语言和各种搜索函数的地方，正则表达式都被普遍支持，应用相当广泛。\n基础正则表达式对应的元字符主要有以下几个：\n1 ^ $ . [ ] * 而拓展正则表达式在上述元字符的基础上增加了：\n1 ( ) { } ? + | 等字符，接下来我们将逐一展开各个元字符的作用。\n基础正则表达式 BRE 正则表达式的元字符会起到以下的三个作用，从而定义某种特殊的字符模式：\n匹配字符（. [anychar], \\） 匹配次数（*） 位置锚定（^, $） 粗略的可以划分为以上的三类，而详细的作用则如同下表所示。\n字符 作用 ^ 写在 Pattern 的开头，如 ^header，匹配以 header 开头的行 $ 写在 Pattern 的结尾，如 tail$ ，将匹配以 tail 结尾的行 ^$ 组合符，表示空行 \\ 转义符，让特殊的这些元字符不做元字符，而作为普通字符来进行匹配 . 匹配任意一个字符（非空行）一次 * 匹配前一个字符（连续出现）0 次到无穷次 .* 组合符，将匹配一切 ^.* 组合符，匹配以任意字符串开头的内容 .*$ 组合符，匹配以任意字符串结尾的内容 [abc] 匹配 [] 集合中的任意字符，a 或 b 或 c，可以写成 [a-c] [^abc] 上述匹配的反向，匹配除了 [] 集合中的任意字符，^表示取反 此外还有如下的两种正则：\n\\\u0026lt; 表示词首。如：\\\u0026lt;abc 表示以 abc 为首的词。 \\\u0026gt; 表示词尾。如：abc\\\u0026gt; 表示以 abc 结尾的词。 拓展正则表达式 ERE 拓展表达式拓展了上述三个字符模式的元组，拓展字符支持的如下：\n匹配字符：|，() 匹配次数：+，？，{n, m} 位置锚定： 字符 作用 + 匹配前一个字符（连续出现）1 次到无穷次 [ab]+ 组合符，匹配 [] 中的 a/b 一次到 N 次 ? 匹配前一个字符（连续出现）0 次到 1 次 | 或者，表示同时过滤多个字符串 () 分组过滤，括号起来的内容表示一个整体 {n,m} 匹配前一个字符 n 到 m 次，n, 表示\u0026gt;=n, ,m 表示\u0026lt;=m, n 表示正好为n 其中表示或者的是|，由于表格的原因显示有问题。\n特殊符号表 下面这些特殊匹配的字符，需要用的时候查表即可。\n符号 匹配字符 [:alnum:] 同 [0-9a-zA-Z] 匹配数字和字母 [:alpha:] 同 [a-zA-Z] 匹配大小写字母 [:upper:] / [:lower:] 同 [A-Z] / [a-z] 匹配大/小写字母 [:blank:] 空白字符，空格和制表符 [:space:] 水平和垂直的空白字符，比 blank 的范围更广 [:cntrl:] 不可打印的控制字符（退格，删除，警铃） [:digit:] 十进制数字或 [0-9] [:xdigit:] 十六进制数字 [:graph:] 可打印的非空白字符 [:print:] 可打印字符 [:punct:] 标点符号 需要注意的是，使用 zsh 的时候，这些特殊字符可能会出现 zsh no matches found 的错误，这是因为 zsh 把这些特殊符号当成了命令行的参数，而不是 grep 的参数，因此导致失效。\n为此可以在 zshrc 中添加以下命令，使其兼容 bash 的模式。\nsetopt no_nomatch 参考资料： zsh下报错“zsh: no matches found:” CSDN 用法补充 分组机制详解 待补充\n正则表达式与通配符 参考资料：通配符 | Linux基础概要 (gitbooks.io) 通配符用于通配文件名，正则表达式用于匹配文本内容；且通配符通常只能用于 shell，被 shell 自解释，正则表达式则需要正则引擎进行处理，用在支持正则表达式的引擎或者命令中。\n在 Bash 中，通配符只有三个符号：*，?, []\n通配符 作用 ？ 匹配任意的单个字符 * 匹配任意的多个字符 ** 匹配任意级别目录(bash 4.0以上版本支持，shopt -s globstar) [] 匹配一个单字符范围,如[a-z],[0-9],特殊用法可以参考上面的特殊符号表，^亦可表示反向 注意 \\ 或者 “ ” ‘’ 都会使得通配符失效。\n一些具体的用法：\n1 2 3 4 5 6 ls *.txt # 匹配全部后缀为.txt的文件 ls file?.log # 匹配file1.log, file2.log, ... ls [a-z]*.log # 匹配a-z开头的.log文件 ls [^a-z]*.log # 上面的反向匹配 ls /etc/**/*.conf # etc中任意多级目录下的conf文件。 Fi 正则部分的基本内容就是上述的这些，后续如果有遇到一些特殊的用法，以及进阶的用法会在上述补充；基础的正则规则了解后，介绍 grep 的使用，并基于 grep 的使用对正则表达式进行练习。\n","permalink":"https://hugotest-phi.vercel.app/posts/linux%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8B%E6%AD%A3%E5%88%99/","summary":"\u003cblockquote\u003e\n\u003cp\u003e“awk、grep、sed 是 linux 操作文本的三大利器，合称文本三剑客，也是必须掌握的 linux 命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属 awk 功能最强大，但也最复杂。grep 更适合单纯的查找或匹配文本，sed 更适合编辑匹配到的文本，awk 更适合格式化文本，对文本进行较复杂格式处理。“\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.cnblogs.com/along21/p/10366886.html\" target=\"_blank\" rel=\"noopener\"\u003eLinux文本三剑客超详细教程\u0026mdash;grep、sed、awk\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e在介绍这三个命令之前，需要对正则表达式有所了解，结合正则表达式来使用，才能发挥这 linux 三剑客的的全部能力。\u003c/p\u003e\n\u003ch2 id=\"正则表达式-regexp\"\u003e正则表达式 RegExp\u003c/h2\u003e\n\u003cp\u003e正则表达式： Regual Expression 为一类特殊字符和文本符号共通约定的一种 pattern，其中的一些字符并不表示其本身的含义，而是用来做通配符号。\u003c/p\u003e\n\u003cp\u003e其中基本正则表达式 BRE 是普遍支持的，而拓展正则表达式 ERE 通常则是需要特殊的参数来启用的。通过正则表达式中特殊符号的辅助，能够更快的过滤，查找，替换，处理字符流等。\u003c/p\u003e\n\u003cp\u003e除了在 grep、sed、awk 的 linux 三剑客中，在各个语言和各种搜索函数的地方，正则表达式都被普遍支持，应用相当广泛。\u003c/p\u003e\n\u003cp\u003e基础正则表达式对应的元字符主要有以下几个：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e^ $ . \u003cspan class=\"o\"\u003e[\u003c/span\u003e \u003cspan class=\"o\"\u003e]\u003c/span\u003e *\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e而拓展正则表达式在上述元字符的基础上增加了：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e ? + \u003cspan class=\"p\"\u003e|\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e等字符，接下来我们将逐一展开各个元字符的作用。\u003c/p\u003e","title":"Grep、Sed、Awk 00 RegExp"},{"content":"本文简要介绍对内网穿透技术、对内网穿透技术的需求以及介绍一些用于\u0026quot;个人\u0026quot;进行内网穿透的工具和使用。\n1. 什么是内网穿透(NAT traversal） 在计算机科学中，NAT穿越（NAT traversal）涉及TCP/IP中的一个常见问题，即在处于使用了NAT设备的私有TCP/IP网络中的主机之间创建连接的问题。\n其中 NAT 即网络地址转换 （Network Address Translation）在计算机网络中是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问互联网的私有网络中。它是一个方便且得到了广泛应用的技术。当然，NAT 也让主机之间的通信变得复杂，导致了通信效率的降低。\nNAT 是作为一种解决IPv4地址短缺 以避免保留 IP 地址困难的方案而流行起来的。NAT 成了家庭和小型办公室网络连接上的路由器的一个标准特征。\n其中最为常见的 NAT 设备就是家家户户都有的路由器，将所有的设备在局域网中统一管理，并基于唯一的公网 ip 对互联网（私有网络）进行访问。\n而 NAT 会带来以下的问题，因此会需要内网穿透的技术：\n外网主动发起的服务无法准确的定位到内网的指定机器，会被 NAT 设备丢弃，因此链接会变成单项的，无法双向交互。 因此无法在外网访问内网机器提供给局域网的服务，因此我们的机器，我们部署于 NAS、docker 的服务就只能在局域网中访问，在一定程度上就造成不便。\n2.如何实现内网穿透 解决方法也比较直观，在内网中建立一个代理服务器，其暴露在公网中，这样，通过直接访问该代理服务器进行中转，进而直接访问到指定的机器，这样其实就是建立了一个反向代理 来实现内网穿透。\n反向代理如何理解呢，就正向代理而言，我们要访问的服务器 IP 是已知的，而我们自身是隐藏的，代理服务器是客户端的。\n而反向代理则是我们要访问的服务器是隐藏的，我们需要借由代理服务器去访问它。\n3.内网穿透工具 Zerotier https://github.com/ffay/lanproxy-go-client jpillora/chisel: A fast TCP/UDP tunnel over HTTP (github.com) ngrok 使用 Zerotier 搭建内网穿透的话极其简单，这里就不在赘言，上述还包含了一些其他搭建内网穿透的工具。\n","permalink":"https://hugotest-phi.vercel.app/posts/nat%E7%A9%BF%E9%80%8F/","summary":"\u003cp\u003e本文简要介绍对内网穿透技术、对内网穿透技术的需求以及介绍一些用于\u0026quot;个人\u0026quot;进行内网穿透的工具和使用。\u003c/p\u003e\n\u003ch2 id=\"1-什么是内网穿透nat-traversal\"\u003e1. 什么是内网穿透(NAT traversal）\u003c/h2\u003e\n\u003cp\u003e在计算机科学中，\u003cstrong\u003eNAT穿越\u003c/strong\u003e（NAT traversal）涉及TCP/IP中的一个常见问题，即在处于使用了NAT设备的私有TCP/IP网络中的主机之间创建连接的问题。\u003c/p\u003e\n\u003cp\u003e其中 NAT 即\u003ca href=\"https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\" target=\"_blank\" rel=\"noopener\"\u003e网络地址转换\u003c/a\u003e\n（Network Address Translation）在计算机网络中是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。\u003cstrong\u003e这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问互联网的私有网络中\u003c/strong\u003e。它是一个方便且得到了广泛应用的技术。当然，NAT 也让主机之间的通信变得复杂，导致了通信效率的降低。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNAT 是作为一种解决\u003ca href=\"https://zh.wikipedia.org/wiki/IPv4%E4%BD%8D%E5%9D%80%E6%9E%AF%E7%AB%AD\" title=\"IPv4位址枯竭\" target=\"_blank\" rel=\"noopener\"\u003eIPv4地址短缺\u003c/a\u003e\n以避免保留 IP 地址困难的方案而流行起来的。NAT 成了家庭和小型办公室网络连接上的路由器的一个标准特征。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e其中最为常见的 NAT 设备就是家家户户都有的路由器，将所有的设备在\u003cstrong\u003e局域网\u003c/strong\u003e中统一管理，并基于唯一的公网 ip 对互联网（私有网络）进行访问。\u003c/p\u003e\n\u003cp\u003e而 NAT 会带来以下的问题，因此会需要内网穿透的技术：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e外网主动发起的服务无法准确的定位到内网的指定机器，会被 NAT 设备丢弃，因此链接会变成单项的，无法双向交互。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因此无法在外网访问内网机器提供给局域网的服务，因此我们的机器，我们部署于 NAS、docker 的服务就只能在局域网中访问，在一定程度上就造成不便。\u003c/p\u003e","title":"内网穿透（NAT穿透）"},{"content":"Mac 的 Terminal 和 Ubuntu 的操作上较为相似，都是 Unix 的吧，但是要注意一下安全和软件管理库。\n其他的参考资料： https://www.youtube.com/watch?v=RNqDkF17ogY\u0026t=787s Temrinal 终端 The default terminal is zsh, so we do not need to install zsh from scratch.\nBrew we install brew follow the official website settings :\n1 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Iterm 2 After install brew we can install iterm 2 like this :\n1 brew install iterm2 --cask Then we download and config its\u0026rsquo; setting in the preference menu. Or export the profile.\nThose following settings are what i\u0026rsquo;m most concerned about, and because of the simple UI, we will not introduce too much.\nTransparent Snippets Status line Split windows 这将会是我们的主终端应用，后续会结合 fig 一起使用，这给我们提供了媲美，甚至超越 windows terminal 的使用体验。\nSeems like 可以取代 tmux 来进行分屏\nThemes \u0026amp; Snipnet\nFig Fig adds autocomplete to your terminal. Install it from brew.\n1 brew install fig --cask After install Fig, we need to start the dashboard to config our terminal (vscode \u0026amp; iterm 2)\nWarp A modern terminal design for macOS, which is like terminal + fig + multi-tabs but without transparent.\nwe could download this from warps , it provide another good terminal experience.\nDeprecate for now\nOmz Like in all bash: omz , Use it with powerlevel10k ;\nNeoVim Configuration: We download the dotfile from our GitHub rep o then replace it.\nDownload :\n1 brew install --HEAD neovim Tar 的使用事项 Mac 使用 tar 压缩，每个文件会多生成 \u0026quot;._\u0026quot; 文件副本，该文件在 mac 中解压的时候，他自己能删除这些多余的文件，而在多平台使用的时候，就会很麻烦，因此我们使用 COPYFILE_DISABLE 防止生成此类文件\n1 COPYFILE_DISABLE=1 tar -zcvf files.tar files_dir Others Ranger Zenith Duf: disk usage/ free utility Dust: file tree ","permalink":"https://hugotest-phi.vercel.app/posts/macos_bash_config/","summary":"\u003cp\u003eMac 的 Terminal 和 Ubuntu 的操作上较为相似，都是 Unix 的吧，但是要注意一下安全和软件管理库。\u003c/p\u003e\n\u003cp\u003e其他的参考资料： \u003ca href=\"https://www.youtube.com/watch?v=RNqDkF17ogY\u0026amp;t=787s\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.youtube.com/watch?v=RNqDkF17ogY\u0026t=787s\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"temrinal-终端\"\u003eTemrinal 终端\u003c/h2\u003e\n\u003cp\u003eThe default terminal is zsh, so we do not need to install zsh from scratch.\u003c/p\u003e\n\u003ch3 id=\"brew\"\u003eBrew\u003c/h3\u003e\n\u003cp\u003ewe install brew follow the \u003ca href=\"https://brew.sh\" target=\"_blank\" rel=\"noopener\"\u003eofficial website\u003c/a\u003e\n settings :\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/bin/bash -c \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"k\"\u003e$(\u003c/span\u003ecurl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh\u003cspan class=\"k\"\u003e)\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"iterm-2\"\u003eIterm 2\u003c/h3\u003e\n\u003cp\u003eAfter install brew we can install iterm 2 like this :\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ebrew install iterm2 --cask\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eThen we download and config its\u0026rsquo; setting in the preference menu. Or export the profile.\u003c/p\u003e\n\u003cp\u003eThose following settings are what i\u0026rsquo;m most concerned about, and because of the simple UI, we will not introduce too much.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTransparent\u003c/li\u003e\n\u003cli\u003eSnippets\u003c/li\u003e\n\u003cli\u003eStatus line\u003c/li\u003e\n\u003cli\u003eSplit windows\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这将会是我们的主终端应用，后续会结合 fig 一起使用，这给我们提供了媲美，甚至超越 windows terminal 的使用体验。\u003c/p\u003e\n\u003cp\u003eSeems like 可以取代 tmux 来进行分屏\u003c/p\u003e","title":"Macos Configuration01 MacOS terminal 设置"},{"content":"在一个庞大的组织架构中，CI/CD 和 Devops 的概念是避不开的，了解它的工作原理和概念能帮助我们更好的与他人进行协作。\nCI/CD 介绍 这是一个用来描绘 CI/CD 的示意图，其描绘了 CI/CD 的工作流和各自的一些职责，接下来本文分别对两者进行介绍。\nCI (Continuous integration) 持续集成 持续集成是面向开发者（Developer）的环节。从上述的图也可以看出，整体的流程如下：\nDeveloper 基于给出的需求进行编码（code），完成 Feature 或者 Bug 修复后，提交（Commit）代码，然后平台会对这些需要（Merge Request）代码进行编译（Build），编译通过后，执行自动化的持续测试（Continuous Test），待测试通过后才会正式合并入主干。\n也就是说，CI 工具在检测到代码变更后，自动对其执行编译和单元测试，验证其代码的正确性和可用性，以及是否适合与源代码进行集成，然后进行自动集成。\n该流程有以下的优势：\n能够避免不同开发环境带来的不一致问题 减少手动操作 清晰的版本管理和控制 降低人为操作的风险 CD (Continuous deployment)持续部署 持续部署则是面向 IT 运维技术人员（ops）的环节，整体流程如下：\nDevs 成功 发布代码(release) 后，CD 工具会自动 部署（deploy） 该 service 到服务器上，进行发布，直接部署到生产环境中，可供 操作（operate），并通过 监控（monitor） 来确保服务的正常运行，如果出现问题后，就即时 FeedBack 给开发者。\n持续交付是一种软件开发实践，它与 CI 结合使用，可自动执行基础结构预配和应用程序发布过程。作为 CI 过程的一部分测试和构建代码后，CD 会在最后阶段接管，以确保它包含随时部署到任何环境所需的一切。CD 可以涵盖从调配基础结构到将应用程序部署到测试或生产环境的所有内容。使用 CD，软件的构建使其可以随时部署到生产环境。然后，可以手动触发部署或移动到持续部署，其中部署也是自动化的。\n该流程提供了这样的能力：\n确保随时随地能进行部署 确保更新能够正常执行 CT (Continuous Test) 持续测试 持续测试是一种软件测试实践，其中测试持续运行，以便在错误引入代码库后立即识别错误。在 CI/CD 管道中，持续测试通常是自动执行的，每次代码更改都会触发一系列测试，以确保应用程序仍按预期工作。\n持续测试能够在早期就识别潜在的问题，也能在交付的初期发现 Bug，避免后期 Debug 的困难，也能帮助提示和提高开发人员的代码质量，其主要依赖的测试类型为：\n单元测试，检查各个代码单元是否按预期工作 集成测试，验证应用程序中的不同模块或服务如何协同工作 回归测试，在修复错误后执行，以确保特定错误不会再次发生 CI/CD工具介绍 该部分内容来自 reference 该文\nGitLab (Version Control) GitHub (Version Control) Jenkins (自动 build 工具) Drone (自动 build 工具) Circle (自动 build 工具) Docker (迅速佈署環境工具) K8S (管理 Docker Container 工具) Helm (快速建置各環境 K8S 工具) Grafana (機器數據監控工具) ELK (Log 蒐集工具) Telegram (通訊、錯誤通知工具) Slack (通訊、錯誤通知工具) CI/CD 的优点 参考 Gitlab 该文中的相关部分 什么是 CI/CD？ |吉特实验室 (gitlab.com) ，无非是更安全，更快速，更透明，更易于开发，减少 merge 地狱。\nDevOps 介绍 DevOps 实际上是一种方法论：主要强调软件开发测试运维的一体化，目标是减少各个部门之间的沟通成本从而实现软件的快速高质量的发布。\n（Development和Operations的混成词 ）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。\n而 CI/CD 实际上就是 DevOps 的核心，可以看下面这张图，实际上与 CI、CD 高度重合，但是 DevOps 并不完全等同于 CI/CD，要实现 DevOps 还依靠公司的各种架构组织等。\n下面这些是对应的工作流和相应的软件：\nReference Day12 什麼是 CICD - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw) DevOps漫谈之一：DevOps、CI、CD都是什么鬼？ - 晶晶的博客 (jjonline.cn) 什么是 CI/CD？ |吉特实验室 (gitlab.com) What Is CI/CD and How Does It Work? | Synopsys How to build a CI/CD pipeline with GitHub Actions in four simple steps | The GitHub Blog CI/CD - Wikipedia DevOps - Wikipedia 持续集成cicd和devops - 知乎 (zhihu.com) ","permalink":"https://hugotest-phi.vercel.app/posts/devops/","summary":"\u003cp\u003e在一个庞大的组织架构中，CI/CD 和 Devops 的概念是避不开的，了解它的工作原理和概念能帮助我们更好的与他人进行协作。\u003c/p\u003e\n\u003ch2 id=\"cicd-介绍\"\u003eCI/CD 介绍\u003c/h2\u003e\n\u003cdiv style=\"text-align:center\"\u003e\r\n    \u003cimg src= https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230403173436.png title=\"devops\"\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003e这是一个用来描绘 CI/CD 的示意图，其描绘了 CI/CD 的工作流和各自的一些职责，接下来本文分别对两者进行介绍。\u003c/p\u003e\n\u003ch3 id=\"ci-continuous-integration-持续集成\"\u003eCI (Continuous integration) 持续集成\u003c/h3\u003e\n\u003cp\u003e持续集成是面向开发者（Developer）的环节。从上述的图也可以看出，整体的流程如下：\u003c/p\u003e\n\u003cp\u003eDeveloper 基于给出的需求进行\u003cstrong\u003e编码（code）\u003c/strong\u003e，完成 Feature 或者 Bug 修复后，\u003cstrong\u003e提交（Commit）代码\u003c/strong\u003e，然后平台会对这些需要（Merge Request）代码进行\u003cstrong\u003e编译（Build）\u003c/strong\u003e，编译通过后，执行自动化的\u003cstrong\u003e持续测试（Continuous Test）\u003c/strong\u003e，待测试通过后才会正式合并入主干。\u003c/p\u003e\n\u003cp\u003e也就是说，CI 工具在检测到代码变更后，自动对其执行编译和单元测试，验证其代码的正确性和可用性，以及是否适合与源代码进行集成，然后进行自动集成。\u003c/p\u003e\n\u003cp\u003e该流程有以下的优势：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e能够避免不同开发环境带来的不一致问题\u003c/li\u003e\n\u003cli\u003e减少手动操作\u003c/li\u003e\n\u003cli\u003e清晰的版本管理和控制\u003c/li\u003e\n\u003cli\u003e降低人为操作的风险\u003c/li\u003e\n\u003c/ul\u003e","title":"Whats DevOps?"},{"content":"本文的博客页面基于 Hexo +Icarus 主题搭建，在使用过程中对该主题做了一些简单的配置，以适应自己的需求。这里介绍一下自己粗浅的方案。\n十分推荐 Icarus 这个主题，功能支持十分全面而且作者的文档也较为详实，推荐大家去了解。\n拓宽显示页面区域 include/style/base.styl 中定义了各种基本页面尺寸：\n1 2 3 4 5 $gap ?= 64px $tablet ?= 769px $desktop ?= 1088px $widescreen ?= 1280px $fullhd ?= 1472px 可以在 include/style/responsive.styl 中定义 2 栏 3 栏情况下所使用的宽度：\n1 2 3 4 5 6 7 8 +widescreen() .is-3-column .container max-width: $fullhd- $gap width: $fullhd - $gap .is-1-column .container, .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen- 2 * $gap 移动端优化 该主题在移动端表现的时候，两侧的 widget 会自动挪到下方，这样每个文章看完的时候体验很差，所以我希望在移动端的时候能隐藏这些 widget。\nsource/js/main.js 中仿照下面的格式添加对应 widget 的 type 即可：\n1 $(\u0026#39;div.container div.card[data-type=categories]\u0026#39;).addClass(\u0026#39;is-hidden-mobile\u0026#39;); 但是该代码会有问题，就是相应 disable 的 widget 对应的单独界面在移动端会失效。\n自定义 404 界面 在 hexo 的默认配置（非 icarus 的配置）_config.yml 中跳过对 404.html 的渲染，直接使用该静态 html 页面进行页面的配置。\n1 2 skil_render: - 404.html 404 静态页面可以使用腾讯公益界面，或者网上找一个模版 使用，效果如下：\n夜间模式（切换 variant） 夜间模式的实现主要参考 ，网上大多用的都是这个方案，但是个人非常喜欢 cyberpunk 的变体，所以希望实现夜间模式的时候切换成 cyberpunk 的 variant ，本文基于其实现做了一些改动，基本实现了该功能，但是目前而言还存在一些问题。\n本人不是很懂前端，因此这个 dom 加载完成后重新加载 css 过程中，导致的页面畸变问题目前不知道该如何解决，望前端大大给点指导\n添加主题切换按钮 在 layout/common/navbar.jsx 中添加夜间模式切换按钮，绑定 night-nav 事件，\n1 2 3 4 5 6 7 //{showSearch ? \u0026lt;a class=\u0026#34;navbar-item search\u0026#34; title={searchTitle} href=\u0026#34;javascript:;\u0026#34;\u0026gt; //\t\u0026lt;i class=\u0026#34;fas fa-search\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; //\u0026lt;/a\u0026gt; : null} \u0026lt;a class=\u0026#34;navbar-item night\u0026#34; id=\u0026#34;night-nav\u0026#34; title=\u0026#34;Night Mode\u0026#34; href=\u0026#34;javascript:;\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-lightbulb\u0026#34; id=\u0026#34;night-icon\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; 预先载入两个 css 文件 在 layout/common/head.jsx 中预先载入可选的第二个 stylesheet（css 文件）\n1 2 3 4 {/* \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href={url_for(\u0026#39;/css/\u0026#39; + variant + \u0026#39;.css\u0026#39;)} /\u0026gt; */} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href={url_for(\u0026#39;/css/\u0026#39; + \u0026#39;default\u0026#39; + \u0026#39;.css\u0026#39;)} title=\u0026#39;default\u0026#39;/\u0026gt; \u0026lt;link rel=\u0026#34;alternate stylesheet\u0026#34; href={url_for(\u0026#39;/css/\u0026#39; + \u0026#39;cyberpunk\u0026#39; + \u0026#39;.css\u0026#39;) } title=\u0026#39;cyberpunk\u0026#39;/\u0026gt; 编写 js 实现 css 跳转 本部分主要来自 imagegoo 的夜间模式实现，修改了一下其调用的文件和变体变量，在 source/js/night.js 中实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 (function () { /** * Icarus 夜间模式 by iMaeGoo * https://www.imaegoo.com/ */ var isNight = localStorage.getItem(\u0026#39;default\u0026#39;); var nightNav; function applyNight(value) { $(window).trigger(\u0026#39;resize\u0026#39;); if (value.toString() === \u0026#39;true\u0026#39;) { // document.body.classList.remove(\u0026#39;light\u0026#39;); // document.body.classList.add(\u0026#39;night\u0026#39;); setStyleSheet(\u0026#39;cyberpunk\u0026#39;); } else { // document.body.classList.remove(\u0026#39;night\u0026#39;); // document.body.classList.add(\u0026#39;light\u0026#39;); setStyleSheet(\u0026#39;default\u0026#39;); } } function findNightNav() { nightNav = document.getElementById(\u0026#39;night-nav\u0026#39;); if (!nightNav) { setTimeout(findNightNav, 100); } else { nightNav.addEventListener(\u0026#39;click\u0026#39;, switchNight); } } function switchNight() { location.reload(); isNight = isNight ? isNight.toString() !== \u0026#39;true\u0026#39; : true; applyNight(isNight); localStorage.setItem(\u0026#39;default\u0026#39;, isNight); } function setStyleSheet(title){ var link_list = document.getElementsByTagName(\u0026#34;link\u0026#34;); if (link_list){ for (var i=0; i\u0026lt;link_list.length; i++){ if (link_list[i].getAttribute(\u0026#34;rel\u0026#34;).indexOf(\u0026#34;style\u0026#34;) != -1 \u0026amp;\u0026amp; link_list[i].getAttribute(\u0026#34;title\u0026#34;)){ link_list[i].disabled = true; if (link_list[i].getAttribute(\u0026#34;title\u0026#34;) == title) link_list[i].disabled = false; } } } } findNightNav(); isNight \u0026amp;\u0026amp; applyNight(isNight); }()); 并在 layout/common 完成对该 js 的引入。\n1 2 3 \u0026lt;script src={url_for(\u0026#39;/js/main.js\u0026#39;)} defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src={url_for(\u0026#39;/js/night.js\u0026#39;)} defer={true}\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/Fragment\u0026gt;; 添加访客数和访问次数 该主题原本就支持 busuanzi 的访客统计，在设置中打开就行，但是只显示其中一种，如果想要全部打开，可以仿照其原本的补充编写：\n1 2 3 // 在如下的地方依照类似的方法添加访客计数pv visitorCounterTitle: _p(\u0026#39;plugin.visitor_count\u0026#39;, \u0026#39;\u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt;\u0026#39;), visitorCounterTitle: _p(\u0026#39;plugin.visitor_count\u0026#39;, \u0026#39;\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt;\u0026#39;) 同样对该值的调用和渲染也要到相应的地方注册。\n1 2 visitorCounterTitle, visitCounterTitle 并添加渲染：\n1 2 3 4 5 6 {showVisitorCounter ? \u0026lt;span id=\u0026#34;busuanzi_container_site_pv\u0026#34; dangerouslySetInnerHTML={{ __html: visitorCounterTitle }}\u0026gt;\u0026lt;/span\u0026gt; : null} {showVisitorCounter ? \u0026#34; and \u0026#34;: null} {showVisitorCounter ? \u0026lt;span id=\u0026#34;busuanzi_container2_site_uv\u0026#34; dangerouslySetInnerHTML={{ __html: visitCounterTitle }}\u0026gt;\u0026lt;/span\u0026gt; : null} 所有图片居中 参考资料：请问如何实现文章中图片居中显示 单张图片居中可以使用：\n1 2 3 \u0026lt;div style=\u0026#34;text-align:center\u0026#34;\u0026gt; \u0026lt;img src= https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230403173436.png title=\u0026#34;devops\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; 全部图片居中可以在 hexo-theme-icarus/source/css/style.styl 中的 article 部分添加如下的最后四行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 .article .article-meta margin-bottom: 0.5rem !important .content font-size: 1.1rem blockquote.pullquote float: right max-width: 50% font-size: 1.15rem position: relative a img margin: auto display: block 新版的修改的地址已经迁移到：themes/icarus/include/style/article.styl 中,同样还是找到这一段描述中添加最后四行即可。\n文章以更新时间排序 修改 node_modules\\hexo-generator-index\\lib\\generator.js 文件为以下内容重新 hexo s 即可：\n修改之前记得备份\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026#39;use strict\u0026#39;; var pagination = require(\u0026#39;hexo-pagination\u0026#39;); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top \u0026amp;\u0026amp; b.top) { // 当两篇文章top都有定义时 if(a.top == b.top) return b.updated - a.updated; // 若top值一样，则按照文章更新日期降序排列 else return b.top - a.top; // 否则按照top值降序排列 } else if(a.top \u0026amp;\u0026amp; !b.top) { // 以下两种情况是若只有一篇文章top有定义，则将有top的排在前面（这里用异或操作居然不行233） return -1; } else if(!a.top \u0026amp;\u0026amp; b.top) { //上一条已解释 return 1; } else return b.updated - a.updated; // 若都没定义，则按照文章更新日期降序排列 }); var paginationDir = config.pagination_dir || \u0026#39;page\u0026#39;; return pagination(\u0026#39;\u0026#39;, posts, { perPage: config.index_generator.per_page, layout: [\u0026#39;index\u0026#39;, \u0026#39;archive\u0026#39;], format: paginationDir + \u0026#39;/%d/\u0026#39;, data: { __index: true } }); }; Troubleshooting map 迭代错误 执行 hexo cl \u0026amp;\u0026amp; hexo g 会出现以下的错误：\nUncaught TypeError: Cannot read properties of undefined (reading ‘map‘)\n该错误主要是由于使用 map 进行循环之前未判断变量是否非空，导致对 undefined 变量做遍历导致，因此只需要在循环之前加上判断即可。\n主要出错的是在一下的两个文件里：\nLayout/category.Jsx Layout/index.Jsx 使用如下的方式在使用 map 对变量进行遍历之前做一个非空判断：\n在react中使用map遍历，出现错误：Uncaught TypeError: Cannot read properties of undefined (reading ‘map‘)_学习前端的渣渣的博客-CSDN博客 spawn failed 解决方法 执行 hexo d 进行部署的时候可能会遇到 spawn failed 的各种问题，主要有两种情况\n网络问题 文件结构问题 网络问题可以使用 ss -T git@github 测试连接情况；而文件结构问题的话，其实就是我们的链接库 .deploy_git 文件夹无法正常推送到 github，这种情况下可以考虑以下几种解决方式：\n【重置部署文件夹】 删除 .depoly_git 文件夹，重新执行 hexo d 【不推荐】进入 .deploy_git 文件夹强制推送，git push -f 【多系统编写导致文件混合编码问题】 git config –global core.autocrlf false 参考资料：Hexo错误：spawn failed的解决方法 | 张洪Heo (zhheo.com) Reference 博客主题源码和配置文件 - iMaeGoo\u0026rsquo;s Blog Hexo theme: icarus| Highly personalize it - Karobben Icarus 主题自定义 - Alpha Lxy hexo及icarus主题个性定制 - Jingjing\u0026rsquo;s blog (angericky.github.io) 干志雄的博客 (ganzhixiong.com) hexo笔记：文章排序 | 高深远的博客 (gsy00517.github.io) and here are some theme I may want to try：\nArknights (yue.zone) Hexo 主题 Ringo - Hexo Theme Ringo (heliumoi.github.io) 二丫讲梵 (eryajf.net) ","permalink":"https://hugotest-phi.vercel.app/posts/custom_icarus/","summary":"\u003cp\u003e本文的博客页面基于 \u003ca href=\"[Hexo]%28https://hexo.io/zh-cn/%29\"\u003eHexo\u003c/a\u003e\n+\u003ca href=\"https://ppoffice.github.io/\" target=\"_blank\" rel=\"noopener\"\u003eIcarus\u003c/a\u003e\n 主题搭建，在使用过程中对该主题做了一些简单的配置，以适应自己的需求。这里介绍一下自己粗浅的方案。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e十分推荐 Icarus 这个主题，功能支持十分全面而且作者的文档也较为详实，推荐大家去了解。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"拓宽显示页面区域\"\u003e拓宽显示页面区域\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003einclude/style/base.styl\u003c/code\u003e  中定义了各种基本页面尺寸：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003e$gap\u003c/span\u003e \u003cspan class=\"o\"\u003e?=\u003c/span\u003e \u003cspan class=\"mi\"\u003e64\u003c/span\u003e\u003cspan class=\"nx\"\u003epx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003e$tablet\u003c/span\u003e \u003cspan class=\"o\"\u003e?=\u003c/span\u003e \u003cspan class=\"mi\"\u003e769\u003c/span\u003e\u003cspan class=\"nx\"\u003epx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003e$desktop\u003c/span\u003e \u003cspan class=\"o\"\u003e?=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1088\u003c/span\u003e\u003cspan class=\"nx\"\u003epx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003e$widescreen\u003c/span\u003e \u003cspan class=\"o\"\u003e?=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1280\u003c/span\u003e\u003cspan class=\"nx\"\u003epx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003e$fullhd\u003c/span\u003e \u003cspan class=\"o\"\u003e?=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1472\u003c/span\u003e\u003cspan class=\"nx\"\u003epx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e可以在 \u003ccode\u003einclude/style/responsive.styl\u003c/code\u003e  中定义 2 栏 3 栏情况下所使用的宽度：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"nx\"\u003ewidescreen\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eis\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ecolumn\u003c/span\u003e \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003econtainer\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003emax\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ewidth\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e$fullhd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"nx\"\u003e$gap\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003ewidth\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e$fullhd\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"nx\"\u003e$gap\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eis\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ecolumn\u003c/span\u003e \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003econtainer\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eis\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ecolumn\u003c/span\u003e \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003econtainer\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003emax\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ewidth\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e$widescreen\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nx\"\u003e$gap\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003ewidth\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e$widescreen\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nx\"\u003e$gap\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Hexo Icarus 配置"},{"content":"本文介绍计算大规模数据流中的元素出现频次的方法 CMS，以及其简单改进Count-Mean-Min-Sketch\nIntro \u0026amp; Scene 在大数据场景下，比如网页的 TopK 问题，爬虫的是否访问过的问题，都是一种出现频次相关的问题，那么在系统设计的时候，如何选择策略和数据结构去存储相关的数据是最高效合适的呢？\n计算元素的出现频次，如果出现与普通的场景下，简单的方案就是用 hashmap 来记录元素出现的次数：\n1 2 3 4 5 6 7 8 std::unordered_map\u0026lt;std::string, int\u0026gt; freq; for(const auto\u0026amp; e: elements){ if (freq.find(e) == freq.end()){ freq[e] = 1; }else{ freq[e] += 1; } } 但是这种方式在大量数据流的情况下，如果存在大量唯一元素的情况下，会占用大量的内存，导致其无法应对大数据场景，因此在\u0026quot;时间换空间\u0026quot;like 的策略选择中，这里就需要考虑通过时间，或者准确率等其他的因素来换空间。\n通常来说，针对大数据场景，会无限扩张的数据结构显然是不适用的，所以希望能用固定的空间来进行计数的管理，同时希望尽量不要影响到运行的时间，换言之，可以牺牲掉一定的准确性，来实现节省空间的效果。\n基于上述需求，我们可以想到 Hash 算法：将无限大的空间映射到固定的 size 的输出上；而大数据场景下的 Hash 会遇到冲突会被无限放大的问题，如何解决冲突是最核心的问题\n基于概率数据结构实现的 Blomm Filter 算法采取多 Hash 的方法来减少冲突 而其衍生出来的 CMS 算法以同样的思想，基于不同的设计，更为适应这种计数场景 下面介绍该方法的具体实现\nCMS 的具体实现 首先第一点，通过 hash 来实现数值空间的转换，通过哈希函数 H 将输入元素 x 映射到一维数组上，通过该 index 的值来判断元素的 Count（是否存在）\n1 2 3 4 5 6 7 # 伪代码 vector\u0026lt;int\u0026gt; array(size, 0); 初始数组 for (auto x : input_element) { idx = H(x); array[idx] += 1; } 实际上这就是 Blomm Filter 的基础思想，然而无论是定长数组的\u0026quot;有限\u0026quot;还是 Hash 函数本身，都需要考虑冲突问题（两个元素被映射到同一个 index 上），冲突会导致 Count 比真实的大。\n于是接下来面临的问题就是：如何降低冲突的概率？如何提高计数的准确性（实际上也包含在降低冲突的概率中）\n可以参考 Bloom Filter 的策略，其通过多个 Hash 函数来映射同一个数，从而来降低元素的冲突概率（未考虑超大数据场景），进而也能提高计数的准确性，那么我们看一下 bloom filter 方法：\nBloom Filter 算法解决的是存在性问题，因此只需要一个 01 向量，当且仅当所有 Hash 计算出来的 index 的值都为 1 的时候，这个元素才可能存在；\n考虑将该方法向 Count 问题上迁移：\n计数过程中：使用 n 个 Hash 函数计算 idx{1~n} ，然后 vec[idx[i]] += 1 对技术+1 查询过程中：使用 n 个 Hash 函数计算 idx{1~n}，然后取 vec[idx[i]] 的最小值，考虑冲突场景可知，这个最小值\u0026gt;=实际的 count。 1 2 3 4 5 6 int query_count = INT_MAX; for (size_t i=0; i \u0026lt; function_size; ++i){ int idx = Hash[i](query); int tmp_count = count_set[idx]; query_count = (tmp_count \u0026lt; query_count)? tmp_count: query_count; } 实际上取多个 hash 的最小值就是 Count-Min Sketch 的核心，但如果仅是如此很明显有个问题，就是多个 hash 函数算出的多个 idx 会进一步的“污染”计数，得不偿失，导致 Count 更加不准确。\n实际上很容易想到，为了通过多个 hash 来减少冲突，并使得多 hash 的索引更加的唯一，最好的办法就是使得每个 hash 对应的计数空间是独立的，也就是将我们的计数空间在拓展成二维数组，其 size 为 $depth \\times width$ 其中 depth 就代表 hash 函数的个数。\n那么假设每个 Hash 函数的冲突概率是 $p_i$ 那么优化后的冲突概率就从 $min(P_i)$ 减小到\n$$ P = \\prod_{i=1}^{n} p_i\r$$\r1 2 3 4 5 for (size_t i=0; i\u0026lt;function_size; ++i){ int idx = Hash[i](query); int tmp_count = count_set[i][idx]; query_count = (tmp_count \u0026lt; query_count)? tmp_count: query_count; } 结合了这个二维数组就是完整的 CMS 算法了，最终求得的 count 是实际 Count 的近似值（上界）。\nCMS 的参数选择 如果确定使用 CMS，接下来面对的就是计数的精度问题，那么如何选择这个数组的 shape 才能尽可能的减少误差呢？（很明显都是越大越好，那么怎么样是最优/达标的呢）\n确定一些变量参数：\n数据流大小： $n$ 实际计数： $c_x$ 估计计数： $\\hat c_x$ hash 函数数目 $k$ ，存储向量长度 $w$ 设定误差范围：\n$$ (c_x \\leq \\hat c_x \\leq c_x + \\epsilon n) $$\r以及结果在这个范围内的概率为:\n$$ P(c_x \\leq \\hat c_x \\leq c_x + \\epsilon n) \\geq 1-\\sigma\r$$\r那么可以计算出： $e$ 是自然常数\n$$ d = [\\frac{e}{\\epsilon}] , w = [ln(\\frac{1}{\\sigma})]\r$$\r计算公式来自论文，有效性分析也可以从论文中阅读\n添加一个新哈希函数以指数级别迅速降低超出边界异常数据的概率；当然，增加矩阵的宽度也可以增加减少冲突的概率，但这个只是线性级别。\nCount-Mean-Min-Sketch 由于 Hash 的冲突，CMS 对于低频的元素误差还是太大了，引入噪音对于高频元素可以接受（topk）但是对于低频长尾来说太不准确了，因此有了以下的改进：\n首先按照 CMS 的流程取出 d 可 sketch 对于每个 hash 估计出一个噪音，噪音为该行的所有整数（除了被查询元素）的平均值 该行的 sketch 减去该行的噪音，作为真正的 sketch 返回 d 个 sketch 的中位数 1 2 3 4 5 6 7 8 9 10 11 12 13 class CountMeanMinSketch { // initialization and addition procedures as in CountMinSketch // n is total number of added elements long estimateFrequency(value) { long e[] = new long[d] for(i = 0; i \u0026lt; d; i++) { sketchCounter = estimators[i][ hash(value, i) ] noiseEstimation = (n - sketchCounter) / (m - 1) e[i] = sketchCounter – noiseEstimator } return median(e) } } 该算法显著改善了在长尾数据上的精确度。\n其他解决方式 数据分片 + Hashmap 假设有 k 台机器，使用以下的方式进行分片后进行 hashmap 的存储，但是这种方式基本上不降低什么存储需求。\n1 hash(elem) % k = i Reference Bloom Filter CountMinSketch Paper Top K Problem iwiki Advanced Data Structures: Count-Min Sketches - YouTube Hash 频率估计 System Design ","permalink":"https://hugotest-phi.vercel.app/posts/countminsketch/","summary":"\u003cp\u003e本文介绍计算大规模数据流中的元素出现频次的方法 CMS，以及其简单改进Count-Mean-Min-Sketch\u003c/p\u003e\n\u003ch2 id=\"intro--scene\"\u003eIntro \u0026amp; Scene\u003c/h2\u003e\n\u003cp\u003e在大数据场景下，比如网页的 TopK 问题，爬虫的是否访问过的问题，都是一种出现频次相关的问题，那么在系统设计的时候，如何选择策略和数据结构去存储相关的数据是最高效合适的呢？\u003c/p\u003e","title":"Count_Min Sketch算法"},{"content":"@Aikenhong 的旧笔记翻新完善 1.0\nPython 的灵活和广泛应用场景来自于众多的第三方库，由于强大的可拓展性和众多的库，使得 Python 的使用简单灵活，且应用面极广。\n但是不同库之间的相互依赖关系，对版本的不同要求等等因素，使得\u0026quot;环境配置\u0026quot;成为了开发者闻之变色的一词，对一个新的库和项目环境的配置尝尝会花去大量的时间，这可能也是 Docker、Venv（虚拟环境）必须存在的原因之一。\n这里不对 Docker 及其相关技术，进行说明，会另开章节进行学习。\n才疏学浅的本菜鸡希望从 python 开发者避不开的 conda 和 pip 出发介绍一下关于库安装的一些事情，以及这两个 CLI 的关系。\nAnaconda MiniConda 和 Conda anaconda 是一个针对数据科学的 Python 发行版，其包含了一下三个方面的内容：\n完整的 python，ipython numpy、Script 等常用的数据科学库 包管理器 Conda 和 pip 软件发行版是在系统上提前编译和配置好的软件包集合， 装好了后就可以直接用\nminiconda 是 conda 的发行版，其包含了 conda 本体和其所需的所有环境，安装了 miniconda 后就可以正常使用 conda，由于其不包含 python 和诸多第三方包，所以会比 anaconda 纯净得多，我们可以基于其从零开始搭建一个完整的环境。\n而 conda 只是一个包（lib、package）和环境（env）的管理工具，其用于自动安装，升级，（也可分析包之间的相互依赖关系）的工具。\nConda 和 Pip 的关联和区别 conda 是通用（语言无关且跨平台）的包管理器，它发源于 python 的 pydata 社区，但他不仅适用于 python 包的管理，还适用于任何语言写的包和依赖，但是我们应该大多数时候只用来做 python 管理。\n其只能在 conda 环境中安装包，但是可以安装各种语言和各种类型的包。 pip（pip install package） 是 python 官方认证的 python 包通用管理器，只能管理 python 包，安装发布于 python package index（pypi）上的所有包，均由 python 官方管理。\n其支持所有平台，但是只能安装 python 包 接下来从一些重要的特性来讲述两者的区别和联系。\n虚拟环境支持对比 上述提到，我们希望有一个纯净的开发环境，在配置环境的时候出现诸多冲突，例如：\nPackageA 需要 PackageC\u0026gt;3.11，而 PackageB 需要 PackageC\u0026lt;3.10 导致运行起来冲突，或者无法安装的情况。\n因此我们希望能将每个开发环境隔离起来，项目 A、B、C 有分离的 python 版本和对应的一些 python 库。（这里我把环境简单的理解为 python+python 安装的所有 Package ）\n而通过 pip 和 conda 都能在不同程度上，实现以上的需求，conda 原生支持虚拟环境管理，pip 则是需要借助 venv 或者 virtualenv 库来支持。参考：[pip 与 conda 的区别] ( https://zhuanlan.zhihu.com/p/379321816 )\nCLI Python 版本独立 Python 依赖（lib）独立 非 Python 的其他依赖管理 Conda y y y Pip+vir* n y y python 版本独立的意思是，不同环境之间是不是可以安装不同的 python，pip 只能将依赖分离，而对应的 python 都是同一个。\n可以看出在于包管理上，conda 还是更具优势，主要是因为其本身不需要依赖于某个既有的 python，不需要和该 Python 建立连接，没有沾亲带故的就更铁面无私嘛。具体可以参考上面的链接。\n包管理逻辑对比 基于上述说明，开发一个 python 项目，我们可以优先创建一个虚拟环境，再在其中安装需要的依赖，这样能保证每一个环境的纯净，也能减少一些不必要的麻烦，也就是说，创建完环境的下一步，就是需要安装和管理每个环境中的包了。\nCLI Source 依赖校验 是否需要换源加速/代理 Conda Anaconda \u0026amp; Cloud auto(且支持非 python 的依赖) 狗头 Pip Pypi 自动检查、手动选择是否 狗头 从上述简单的对比可以看出，两者安装 package 的源不同，这样有以下的两个影响：\nConda 最好是添加一些常用的 Channel，添加其软件来源，方便使用 conda 进行包的安装； 即使倾向于使用 conda 做管理，还是会在开发中遇到需要混用 pip 的场景（蛮多） ，那么这样是否会有影响呢？下面我们从两个管理器的安装逻辑来说（结合虚拟环境）： conda 安装包的逻辑是这样的：\n基于 conda install \u0026lt;pkg\u0026gt; 安装的库都会放在 Anaconda 的 Pkgs 目录下统一存储，例如 windows 就是 E:\\anaconda\\pkgs\\\u0026lt;pkg\u0026gt; ，通过这样的方式，当新的环境中需要一个某个环境中已经安装过的包的时候，就只需要把对应的文件复制到到新环境的 lib\\python\u0026lt;*\u0026gt;\\site-packages 目录中即可，无需重复下载。\nanaconda 中会对每个环境创建一个新的目录。而该环境的的库就是存在 、env\\\u0026lt;env-name\u0026gt;\\lib\\pythonxxx\\site-packages 路径下。\npip 安装包的逻辑是这样的：\n基于 pip install \u0026lt;pkg\u0026gt; 安装的库会放在对应的就会放在 xxx\\pythonxxx\\site-packages 中。\n综上所述，（正常）混用的话基本上是没有影响的，还是能保证我们的环境进行分离，这是因为：\n当 conda 切换虚拟环境的时候，对应的 pip 也会进行切换，这样通过 pip 安装的包也会仅安装在当前环境的目录中，和 conda 进行安装是一致的 同时两者之间还有这样的交互关系：\nconda list 列出的包中，build 项目为 pypi 的即为 pip 安装的包。 卸载的时候两者是一致的： conda uninstall \u0026lt;pkg\u0026gt; 和 pip uninstall \u0026lt;pkg\u0026gt; 都只是讲当前环境中的库删除了，不会删除 conda 的 pkg 目录中的备份，如果要清空该已下载库，通过 conda clean -h 实现 （need check）（not recommand）理解了这样的安装关系后，我们也可以知道如何为一个环境手动安装一个 package 了，在 pypi 上下载压缩包后，解压到对应的目录中，执行以下命令即可\n1 python setup.py install 网络问题的话建议换源，还是不要手动安装。\n其他相关资料 windows conda 路径问题 在 windows 上安装 anaconda 之前，如果原本有 python，建议是删掉该 python 避免带来不必要的路径问题。 windows 上如果出现输入 python 跳转 win 商店的话，八成是系统路径中的问题，可以将 winstore 的路径往后挪。 pip 和 pip3 python2 只能用 pip python3 都可以用，如果仅有 python3，那么两者等价 如果装了 python2 和 python3，那么默认 pip 给 python2 用，pip3 给 python3 用，功能一样。 虚拟环境中，若只存在一个 python 版本，可以认为在用系统中 pip 和 pip3 命令都是相同的 pip 删除所有安装的包 删除pip安装的所有软件包的最简单方法是什么？ (qiniu.com) ","permalink":"https://hugotest-phi.vercel.app/posts/python_pack_manager/","summary":"\u003cp\u003e@Aikenhong 的旧笔记翻新完善 1.0\u003c/p\u003e\n\u003cp\u003ePython 的灵活和广泛应用场景来自于众多的第三方库，由于强大的可拓展性和众多的库，使得 Python 的使用简单灵活，且应用面极广。\u003c/p\u003e\n\u003cp\u003e但是不同库之间的相互依赖关系，对版本的不同要求等等因素，使得\u0026quot;环境配置\u0026quot;成为了开发者闻之变色的一词，对一个新的库和项目环境的配置尝尝会花去大量的时间，这可能也是 Docker、Venv（虚拟环境）必须存在的原因之一。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这里不对 Docker 及其相关技术，进行说明，会另开章节进行学习。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e才疏学浅的本菜鸡希望从 python 开发者避不开的 conda 和 pip 出发介绍一下关于库安装的一些事情，以及这两个 CLI 的关系。\u003c/p\u003e","title":"Python00 Conda 与 Pip"},{"content":"Update:@20230214\nshift+右键: 在此处打开 powershell.\nPowerShell ，这里的 PowerShell 和 windows 的已经不是同一个东西了，可能要更先进一些，通过 msi 进行安装，安装完后重启 terminal 就会自动的添加配置，后续的配置在这个 new shell 中进行会更好一些\nBasic Setting Setting \u0026amp; Cancel Proxy 设置代理如下：\n1 2 3 netsh winhttp set proxy 127.0.0.1:8890 # 查看代理设置情况 netsh winhttp show proxy 取消代理设置使用：\n1 netsh winhttp reset proxy Setting Policy 如果 powershell 中禁止运行脚本运行：\n1 2 3 4 5 # 查看当前的策略 get-executionpolicy # 管理员打开并执行以下命令修改策略 set-executionpolicy remotesigned 执行完策略以后就可以安装模块\nAbout Module 关于模块 - PowerShell | Microsoft Learn 模块是包含了 Powershell 命令，函数，工作流，变量或者别名的包，打包作为一个整体来提供和加载，便于共享使用。可以作为 powershell 的 “插件”或者拓展功能来理解他。\n模块自动加载的新功能占位，目前还没有很理解。\nget-module 可以查看当前会话已经加载的模块，我们也可以通过 get-module -ListAvailable 列出所有可供加载的模块（已安装）\n如何安装模块（上述参考链接中提供了迁移模块目录的方法）：\nInstall-Module 命令可以从联机存储库获取符合指定条件的模块，并将其安装到默认的模块安装地址。\n1 install-module -name -dirColors -verbose 该命令有许多参数，这里主要推荐 -scope 指定安装用户，-name 指定搜索的包名，-verbose 可视化安装过程，便于 Check 是否卡住（可以用 get-module 命令来检查是否安装完成）\n其他的参数可以参考官方链接： Install-Module (PowerShellGet) - PowerShell | Microsoft Learn ，包括安装指定版本，查找结合安装等等。\n在完成 module 的安装过后，我们需要将该模块导入会话，类似 import 之于 python，也可以借助 $PROFILE 默认导入每一个会话。那么\n如何导入模块：使用 Import-Module，导入模块 到当前会话，也可以将导入命令写到配置文件中，使其默认导入每一个新开的会话中，配置文件我们可以通过如下的方法进行编辑\n1 2 echo $PROFILE # 找到配置文件的目录，使用自己喜欢的编辑器进行编辑。 vim $PROFILE # 或者使用 vim 在这里直接编辑，我这里使用的是 vscode，将 vim 换成 code 也一样。 其他一些关于配置文件的操作和用法展示可以参考： 关于配置文件 - PowerShell | Microsoft Learn ，在后续介绍了特定模块的安装之后，我将会展示一个对应的配置文件例子。\n如何卸载\u0026amp;取消导入模块：\n当我们不希望载入部分模块或者觉得一些模块是鸡肋的时候，可以通过 remove-module 命令取消该模块在当前会话中的加载，或者通过 Uninstall-Module -name 命令直接将该模块删除，这里需要注意的是，有些模块的 Uninstall 可能不会立即生效，这个时候我们可以重启会话看是否已经卸载。\n在对模块的定义和模块的一些操作有了基本的了解之后，接下来我们通过安装一些模块来美化\u0026amp;优化 Powershell 使其在更好看的同时也更好用。\nInstall Module Install PSReadLine \u0026amp; config it 新版的 Powershell 会默认安装 PSReadLine，没有默认安装 PSReadLine 模块的话：\n1 Install-Module -name PSReadLine -verbose 也可以按照下面的流程，安装 PowerShell 插件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 后面的这些User的限制倒是不需要 # 安装PSReadLine Install-Module -Name PSReadLine -Scope CurrentUser # 如果上面安装出现问题, 可以尝试下面的 Install-Module -Name PSReadLine -Scope CurrentUser -Force -SkipPublisherCheck # 安装PSR包，让命令行更好用，类似ZSH Install-Module -Name PSReadLine Install-Module -Name PSReadLine -Scope CurrentUser # 查看是否安装完成 Get-Module -ListAvailable Import-Module PSReadLine # 安装Posh-git包，让git更好用 Install-Module -Name posh-git Install-Module -Name posh-git -Scope CurrentUser 可以在会话中 Import 测试效果，并将满意的配置写入 $PROFILE。\n1 Import-Module PSReadLine 设置 PSReadLine 将以下的内容写入 PROFILE （或者逐一在会话中执行验证效果）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 设置预测文本来源为历史记录 Set-PSReadLineOption -PredictionSource History # 每次回溯输入历史，光标定位于输入内容末尾 Set-PSReadLineOption -HistorySearchCursorMovesToEnd # 设置 Tab 为菜单补全和 Intellisense Set-PSReadLineKeyHandler -Key \u0026#34;Tab\u0026#34; -Function MenuComplete # 设置 Ctrl+d 为退出 PowerShell Set-PSReadlineKeyHandler -Key \u0026#34;Ctrl+d\u0026#34; -Function ViExit # 设置 Ctrl+z 为撤销 Set-PSReadLineKeyHandler -Key \u0026#34;Ctrl+z\u0026#34; -Function Undo # 设置向上键为后向搜索历史记录 Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向下键为前向搜索历史纪录 Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward 完成设置后 PSReadLine 会基于历史记录对已输入的命令进行补全。\nInstall Posh-git and Oh-My-Posh Windows | Oh My Posh ，posh-git 可以强化 omp 的 git 的表现，首先安装两个包。\n1 2 Install-Module -name posh-git winget install JanDeDobbeleer.OhMyPosh -s winget 安装完进行导入：\n1 2 oh-my-posh init pwsh | Invoke-Expression Import-Module posh-git 完成安装 oh-my-posh 后，重启 Terminal，然后查看存在的主题，并设置为你希望的主题，将后面的 jandedobbeleer 改成需要的主题名称（后续写入 PROFILE）。\n1 2 Get-PoshThemes oh-my-posh init pwsh --config \u0026#39;C:\\Users\\Aiken\\AppData\\Local\\Programs\\oh-my-posh\\themes\\jandedobbeleer.omp.json\u0026#39; | Invoke-Expression 字体安装与下载：按照链接 下载安装就行了\nInstall Scoop ScoopInstaller/Install: 📥 Next-generation Scoop (un)installer (github.com) Windows Terminal美化（配置Powershell7+PSReadLine+oh-my-posh） / Drrany Windows 系统缺失的包管理器：Chocolatey、WinGet 和 Scoop - 少数派 (sspai.com) 安装 Scoop 的话只需要执行：\n1 irm get.scoop.sh | iex Scoop 的默认安装位置为：C:\\User\\Your Username\\scoop，(option) 如果需要将其安装在默认目录以外的地方的话，执行：\n1 2 3 4 $env:SCOOP=\u0026#39;D:\\Applications\\Scoop\u0026#39; $env:SCOOP_GLOBAL=\u0026#39;D:\\GlobalScoopApps\u0026#39; [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP_GLOBAL\u0026#39;, $env:SCOOP_GLOBAL, \u0026#39;User\u0026#39;) irm get.scoop.sh | iex 安装完毕后即可，安装个 neofetch 试试：\n1 scoop install neofetch Scoop 会自动将 \u0026lt;install_path\u0026gt;\\Scoop\\shims and \u0026lt;install_path\u0026gt;\\Scoop\\apps 加入系统的环境变量，免去自行添加的麻烦。\nScoop 设置/取消代理：\n1 2 scoop config proxy 127.0.0.1:8889 scoop config rm proxy 添加 bucket 等操作之后再 Scoop 章节中介绍\n安装 sudo 安装 curl 安装 wget （代理使用 powershell 的代理） Install other module 高亮 ls 的文件夹(DirColors )并添加文件图标（Terminal-Icons）\n1 2 3 Install-Module -Name DirColors Install-Module -Name Terminal-Icons Import-Module DirColors 安装 z-jumper\n1 2 3 Install-Module ZLocation -Scope CurrentUser import-module zlocation z 查看现存主题：\n1 2 3 Get-PoshThemes # 设置主题 Set-PoshPrompt -Theme half-life 设置 Terminal 中的启动参数\n1 code $PROFILE 并设置成如下的形式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 导入包 Import-Module posh-git Import-Module oh-my-posh oh-my-posh init pwsh | Invoke-Expression Import-Module PSReadLine # 设置主题 Set-PoshPrompt -Theme spaceship # ================psreadline setting # 设置预测文本来源为历史记录 Set-PSReadLineOption -PredictionSource History # 每次回溯输入历史，光标定位于输入内容末尾 Set-PSReadLineOption -HistorySearchCursorMovesToEnd # 设置 Tab 为菜单补全和 Intellisense Set-PSReadLineKeyHandler -Key \u0026#34;Tab\u0026#34; -Function MenuComplete # 设置 Ctrl+d 为退出 PowerShell Set-PSReadlineKeyHandler -Key \u0026#34;Ctrl+d\u0026#34; -Function ViExit # 设置 Ctrl+z 为撤销 Set-PSReadLineKeyHandler -Key \u0026#34;Ctrl+z\u0026#34; -Function Undo # 设置向上键为后向搜索历史记录 Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向下键为前向搜索历史纪录 Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward Some Command Findstr/Find 1 2 3 4 # this command is like grep in Linux Common-u-want-to-carry-out | findStr \u0026#34;String\u0026#34; # for example conda list | Select-String (\u0026#34;matplot\u0026#34; , \u0026#34;pillow\u0026#34;, \u0026#34;scipy\u0026#34;, \u0026#34;tensorboard\u0026#34;) Generate GUID this command can generate the only GUID\n1 new-guid reference 个人的知乎回答 Style your Windows terminal Windows Terminal 完美配置 Upgrading | Oh My Posh ","permalink":"https://hugotest-phi.vercel.app/posts/powershell/","summary":"\u003cp\u003eUpdate:@20230214\u003c/p\u003e\n\u003cp\u003eshift+右键: 在此处打开 powershell.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/PowerShell/PowerShell/releases\" target=\"_blank\" rel=\"noopener\"\u003ePowerShell \u003c/a\u003e\n，这里的 PowerShell 和 windows 的已经不是同一个东西了，可能要更先进一些，通过 \u003ccode\u003emsi\u003c/code\u003e 进行安装，安装完后重启 terminal 就会自动的添加配置，后续的配置在这个 new shell 中进行会更好一些\u003c/p\u003e\n\u003ch2 id=\"basic-setting\"\u003eBasic Setting\u003c/h2\u003e\n\u003ch3 id=\"setting--cancel-proxy\"\u003eSetting \u0026amp; Cancel Proxy\u003c/h3\u003e\n\u003cp\u003e设置代理如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003enetsh\u003c/span\u003e \u003cspan class=\"n\"\u003ewinhttp\u003c/span\u003e \u003cspan class=\"nb\"\u003eset \u003c/span\u003e\u003cspan class=\"n\"\u003eproxy\u003c/span\u003e \u003cspan class=\"mf\"\u003e127.0\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"py\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"mf\"\u003e1\u003c/span\u003e\u003cspan class=\"err\"\u003e:\u003c/span\u003e\u003cspan class=\"mf\"\u003e8890\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e# 查看代理设置情况\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003enetsh\u003c/span\u003e \u003cspan class=\"n\"\u003ewinhttp\u003c/span\u003e \u003cspan class=\"n\"\u003eshow\u003c/span\u003e \u003cspan class=\"n\"\u003eproxy\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e取消代理设置使用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetsh winhttp reset proxy\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Windows Powershell 00 Install and Config"},{"content":"整理脚本编写的一些最基本语法，包括参数传递，赋值，循环等基本语句，方便后续的脚本编写和改动。\n语句注释 单行注释：# ，多行注释：\n1 2 3 4 :\u0026#39; 多行注释用冒号加单引号即可 \u0026#39; echo \u0026#39;legal\u0026#39; 命令行参数传递 命令行传递参数的方式极其简单， $1 \u0026hellip; $ 9 可分别代表输入的 9 个参数，第 10 个参数则使用 ${10} 表示，可以将其赋予变量后便于使用。\n一些特殊参数：\n$0 脚本本身的名称 $# 输入参数的数量 $$ 进程 ID $* | $ @ 所有参数（从第一个开始 $(PWD) | `pwd` 都能输出当前的工作路径 举个脚本例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 # we accept args from commandline and print it to the screen # define args1=$1 args2=$2 # print echo \u0026#34;using $ { } to get the value of val, what we receive is : ${args1} and ${args2}\u0026#34; echo \u0026#34;$ can also show : $args1 and $args2\u0026#34; # we can make those statement in a string, which may transfer to its value echo \u0026#34;using $ / {} in a string can also get the value like $args1 and $args2\u0026#34; echo \u0026#39;using $ / {} in a string single quotes cannot get the value like $args1 and $args2\u0026#39; 一些特殊的参数，用来描述基础信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # basic infomation of script. name_of_script=$0 num_of_args=$# PID=$$ args_list=$* echo \u0026#34;the name of this script is ${name_of_script}\u0026#34; echo \u0026#34;we have ${num_of_args} args\u0026#34; echo \u0026#34;and this process\u0026#39; ID is $PID\u0026#34; echo \u0026#34;$args_list\u0026#34; echo \u0026#34;$@\u0026#34; echo \u0026#34;${PWD}\u0026#34; echo \u0026#34;`pwd`\u0026#34; 基本数据类型 数组和字符串的通用操作：切片方法${name:位置:长度}，位置可以取负值，0的话也可以省略成冒号\n数组 数组的定义基本规则是：用（）定义数组，用 SPC 区分元素。\n1 2 Fruits_Array=(\u0026#39;apple\u0026#39; \u0026#39;banana\u0026#39; \u0026#39;ogange\u0026#39;) Array1=({A..D}) # =\u0026gt; A B C D 还可以使用声明 的方式构造数组：\nBash 的变量定义可以不需要指定类型，但是声明的方式，可以在定义的同时指定变量的类型，其中参数列表可以参考跳转链接。\n1 2 declare -a Numbers=(1 2 3) # 不支持{}的方式构造，会只剩下最后一个元素，这个问题还需要深究。 数组的调用和大部分语言一样使用 [] 结合索引来调用其中的元素，元素的索引从 0 开始，同时在使用 echo 等特殊情况下，调用数组的时候，由于 [] 的存在所以要使用 ${} 来引用。不能只是用 $ 1 echo ${Array1[0]} Append 操作支持使用 += 实现数组的延伸，如下所示：\n1 Array1+=(2 3) 数组的拼接、添加、删除等操作，其中拼接，添加等操作存在一致性，从文件中获取数组的方式更是一个比较实用的命令，但是注意能不能自动识别其中的分隔符，或者自定义呢？\n1 2 3 4 5 6 7 8 9 Array2=(\u0026#34;${Array1[@]}\u0026#34; \u0026#34;New Element\u0026#34;) # 如果不添加的话也可以用作赋值，同样也可以用这样的方式连接两个数组。 Array1+=(\u0026#34;new element\u0026#34;) # 通过正则表达式删除的方法暂时还没掌握，占位。 unser Array1[2] # 删除一项 # 从文件中获取数组 Lines=(`cat \u0026#34;logfile\u0026#34;`) 数组的快速索引列表：便于调用或者分析数组的状态，其中范围的用法暂时比较不明确，暂时不使用，后续进行补充。\n字符串 在大多语言中，对字符串的操作和数组的操作都会有很多的共通性，同样在bash中也是如此，例如切片之类的行为都和数组是一致的，在这里我们基于独有的共通的来描述。\n字符串定义\n1 name=\u0026#34;AikenHong.bash\u0026#34; 字符串操作\n删除第一个匹配(前缀)的字符串\u0026quot;suffix\u0026quot; 1 echo ${name%bash} # 会输出AikenHong. 删除最后一个匹配（后缀）的字符串\u0026quot;prefix\u0026quot; 1 echo ${name#AikenHong} # 会输出.bash 删除（长后缀）%%，和删除（长前缀）##和非长版本的区别如下，实际上可以理解为删除第一个匹配到的或者最后一个匹配到的，长的版本最好是使用通配符来使用比较好理解。 1 2 3 4 5 name2=\u0026#34;aikenhong.github.bash.aikenhong\u0026#34; echo ${name2%%.*} # 输出aikenhong echo ${name2%.*} # 输出aikenhong.github.bash echo ${name2# *.} # 输出github.bash.aikenhong echo ${name2## *.} # 输出 aikenhong 只要记住前缀后缀删除的关键命令分别是#和%即可，同理，替换的关键词是/from/to和//from(all)/to一个代表替换第一个，一个代表替换所有。\n替换命令 1 echo ${name/AikenHong/Metis} # 会输出metis.bash 全部替换的话\n1 echo ${name//n/i} # 会输出aikeihoig.bash 大小写切换，切换大写使用^，切换小写使用,，全部切换使用,,或^^，或使用foo[@],和foo[@]^^ 字符串的路径处理\n1 2 3 4 5 6 SRC=\u0026#34;/path/to/foo.cpp\u0026#34; BASEPATH=${SRC##*/} echo $BASEPATH # =\u0026gt; \u0026#34;foo.cpp\u0026#34; DIRPATH=${SRC%$BASEPATH} echo $DIRPATH # =\u0026gt; \u0026#34;/path/to/\u0026#34; 字典 bash 对字典的支持是后续引入的，如果 bash 在旧的版本可能会出现 declare -A 参数无效的问题。\n字典类型有点像是原生之外拓展的类型，只能用 declare 来进行声明，声明后的定义方式借助数组，下面举个例子：\n1 declare -A myDict 接着给字典赋值，一种是用来赋初值，另一种是动态赋值方法：\n1 2 myDict=([key1]=\u0026#34;value1\u0026#34; [key2]=\u0026#34;value2\u0026#34; [key3]=\u0026#34;value3\u0026#34;) myDict[\u0026#39;key\u0026#39;]=value 调用变量进行打印的时候参照定义数组的方式：\n1 echo ${myDict[key1]} 其他的一些常见索引，和数组是类似的，但是注意的是！输出的是 key，默认的输出的是 value：\n字典的拼接好像没有很方便，建议是使用循环来进行复制实现复制。\n基础运算符 这里还需要搞清楚两个括号和一个括号的区别 Shell 中test 单中括号[] 双中括号的区别 与或非 [[ ! EXPR ]] ：Not [[ X \u0026amp;\u0026amp; Y ]] | [ -a ] ：And [[ X || Y ]] | [-o ] ：Or 1 2 3 4 5 6 7 if [ \u0026#34;$1\u0026#34; = \u0026#39;y\u0026#39; -a $2 -gt 0 ]; then echo \u0026#34;yes\u0026#34; fi if [[ X \u0026amp;\u0026amp; Y ]]; then ... fi 数字比较运算符 用于 [[]] 的比较运算符如下\n-eq | -ne ：（equal）等于 \u0026amp; 不等于 -lt | -le ：（less than）小于 \u0026amp; 小于等于（less or equal） -gt | -ge ：（greater than）大于 \u0026amp; 大于等于 1 [[ NUM -eq NUM ]] 用于 (()) 情况下的比较运算符\n\u0026lt; | \u0026lt;= | \u0026gt; | \u0026gt;= 1 ( NUM \u0026lt; NUM ) 字符串比较运算符 [[ -z STR ]] ：空字符串 [[ -n STR ]] ：非空字符串 [[ STR == STR ]] | [[ STR = STR ]] | [[ STR != STR]] ：相等 | 不相等 [[ STR \u0026lt; STR ]] | [[ STR \u0026gt; STR ]] ：基于 ASCII 的大于小于 [[ STR =~ re ]] ：正则表达式（re） 1 2 3 4 5 6 7 if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; else echo \u0026#34;This never happens\u0026#34; fi 文件比较运算符 循环语句 Shell 中的循环语句主要分为以下的几种，for | while | until 模式，以循环输出数字给出例子。for 和 while 和其他语言中的一致，until 为当条件不满足的时候一直进入循环，直到满足条件的时候退出循环（和 while 相反）\n在描述循环之前，先解释一下生成序列的一些方法(下面都能生成 1 到 n 的序列)，就像range:\n1 2 3 4 seq 1 n | seq 1 step n {1..n} | {1..n..step} \u0026#34;a b c d\u0026#34; # 会产生 a b c d 的序列 ‘word1’ ‘word2’ # 也会产生相应的序列 break 和 Continue 的用法和其他语言中的是一致的，这里不再赘述。 for 循环 for \u0026hellip; in \u0026hellip; 模式： 和 python 类似，针对任何类型的列表进行循环，可以结合上述的序列生成方法进行循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 echo \u0026#39;using seq to generate list\u0026#39; for i in `seq 1 3`; do echo $i done for i in $(seq 1 3); do echo $i done echo \u0026#39;using {...} to generate list\u0026#39; for i in {1..3}; do echo $i done c 模式：类似 c 语言系列的 for 循环，相比于 list 相对灵活一些，较好构造。\n1 2 3 4 for ((i=0;i\u0026lt;3;i+=2)); do echo $i done 利用 for 循环遍历文件：和*一起使用可以方便的遍历文件，算是 for 循环的一个优势。\n1 2 3 4 5 6 7 for i in *.sh; do echo $i done for i in /etc/rc.*; do echo $i done 需要注意的事：如果 do 和循环同行的话就需要分号，如果执行了换行就不需要分号了。\nwhile 循环 当条件满足的时候进入循环，用法如下：\n1 2 3 4 5 i=3 while [[ $i -gt 0 ]]; do echo \u0026#34;Number: $i\u0026#34; ((i--)) done 典型的用法就是用来读取文件，这种时候可以通过管道命令来使用 while；\n1 2 3 cat file.txt | while read line; do echo $line done until 循环 until 是当条件不满足的时候进入循环，用法如下：\n1 2 3 4 5 count=0 until [ $count -gt 10]; don echo \u0026#34;$count\u0026#34; ((count++)) done 基本函数定义和使用 函数定义\n1 2 3 4 5 get_name() { echo \u0026#34;Aikenhong\u0026#34; } echo \u0026#34;you are $(get_name)\u0026#34; 也可以使用 function 的关键字来替换\n1 2 3 4 5 function get_name() { echo \u0026#34;Aikenhong\u0026#34; } echo \u0026#34;you are $(get_name)\u0026#34; 函数的参数传递：函数相当于另一个命名空间，所以其中的传入的函数参数列表和函数的参数列表本身是互不影响独立的。\n1 2 3 4 5 6 7 8 9 # 假设此时的脚本的参数输入$1=Aikenhong print_string(){ echo $1 echo $2 } echo \u0026#34;author is $1\u0026#34; print_string hello world # 最终会输出author is Aikenhong hello world 传入参数的方式也如上面的例子所示。\n函数的返回值： https://www.runoob.com/linux/linux-shell-func.html 1 2 3 4 5 myfunc() { local myresult=\u0026#39;some value\u0026#39; echo $myresult } result=\u0026#34;$(myfunc)\u0026#34; 函数用于抛出错误：\n1 2 3 4 5 6 7 8 9 myfunc() { return 1 } if myfunc; then echo \u0026#34;success\u0026#34; else echo \u0026#34;failure\u0026#34; fi Reference The Art of Command Line Quick Reference Man Page CN Linux-shell 中 $(( ))、$ ( )与${ } In Addition 1 2 g++ helloworld.cpp -o a ./a \u0026lt;input \u0026gt;output 更新 Mac 的 bash 版本 安装新版 bash 版本 brew install bash 查看安装完的 bash 路径 which -a bash 并通过 bash --version 确认新bash 注册新 bash：sudo vim /etc/shells，将新路径加在最后一样，重启终端即可。 Zsh 不需要操作，重启后会自动使用新的这个 bash。 但是注意执行的时候可能需要改成 bash 而不是 sh，sh 我们并没有更新。 ","permalink":"https://hugotest-phi.vercel.app/posts/shell/","summary":"\u003cp\u003e整理脚本编写的一些最基本语法，包括参数传递，赋值，循环等基本语句，方便后续的脚本编写和改动。\u003c/p\u003e\n\u003ch2 id=\"语句注释\"\u003e语句注释\u003c/h2\u003e\n\u003cp\u003e单行注释：\u003ccode\u003e#\u003c/code\u003e ，多行注释：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:\u003cspan class=\"s1\"\u003e\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e多行注释用冒号加单引号即可\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;legal\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"命令行参数传递\"\u003e命令行参数传递\u003c/h2\u003e\n\u003cp\u003e命令行传递参数的方式极其简单，\u003ccode\u003e $1\u003c/code\u003e \u0026hellip; \u003ccode\u003e$ 9\u003c/code\u003e 可分别代表输入的 9 个参数，第 10 个参数则使用 \u003ccode\u003e${10}\u003c/code\u003e 表示，可以将其赋予变量后便于使用。\u003c/p\u003e\n\u003cp\u003e一些特殊参数：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e$0\u003c/code\u003e 脚本本身的名称\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$#\u003c/code\u003e 输入参数的数量\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$$\u003c/code\u003e 进程 ID\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e $*\u003c/code\u003e | \u003ccode\u003e$ @\u003c/code\u003e 所有参数（从第一个开始\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$(PWD)\u003c/code\u003e | `pwd` 都能输出当前的工作路径\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e举个脚本例子如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# we accept args from commandline and print it to the screen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# define\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eargs1\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003e$1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eargs2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003e$2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# print\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;using \u003c/span\u003e$\u003cspan class=\"s2\"\u003e { } to get the value of val, what we receive is : \u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003eargs1\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e and \u003c/span\u003e\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003eargs2\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e$\u003cspan class=\"s2\"\u003e can also show : \u003c/span\u003e\u003cspan class=\"nv\"\u003e$args1\u003c/span\u003e\u003cspan class=\"s2\"\u003e and \u003c/span\u003e\u003cspan class=\"nv\"\u003e$args2\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# we can make those statement in a string, which may transfer to its value\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;using \u003c/span\u003e$\u003cspan class=\"s2\"\u003e / {} in a string can also get the value like \u003c/span\u003e\u003cspan class=\"nv\"\u003e$args1\u003c/span\u003e\u003cspan class=\"s2\"\u003e and \u003c/span\u003e\u003cspan class=\"nv\"\u003e$args2\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;using $ / {} in a string single quotes cannot get the value like $args1 and $args2\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Bash Notebook 01"},{"content":"该文介绍基于 Windows11 系统的双系统安装和删除，安装的双系统选择 Ubuntu（开发还是比较推荐使用 WSL2 即可）\nInstall Dual System 参考资料：全面解决各种问题 双系统安装 Windows+Ubuntu20.04双系统安装教程 1. 安装 u 盘制作 这里推荐 ventoy 来做启动盘，ventoy 可以同时将很多系统的镜像放到一个 u 盘中，最最重要的是：干净简洁，可以参考其官方文档 来制作盘，制作后将镜像文件放到指定目录即可。\n2. 硬盘分区 win+s 搜索创建并格式化分区，找一块空闲空间较大的硬盘，右键压缩卷，设定好预留给 Linux 的空间即可（记住该大小，方便后续辨认，可以将各个盘的大小拍照记录下来，安装的时候别把 windows 覆盖了）。\n该预留的未分配空间，建议至少 30G 以上，如果需要开发和机器学习啥的话可以 50G、100G 以上。\n3. 进入 bios 选择 U 盘启动 各个主板进入 bios 的方式不同，可以参考自己使用主板的进入方式，在开机的时候狂按某个 Fx 键，然后再启动方式中把启动盘调整到第一位，保存并重启。然后启动的时候就会进入 grub 界面。\n（该部分主要参考 HNU 跃鹿战队 ）然后开始安装，安装前期一些比较常规的就不说了，关键的地方如下，记得选择其他选项，保证共存：\n找到未分配的空闲空间（可以按照预留的大小辅助判断），为其划分 Ubuntu 需要的几个分区：\nEFI 系统分区：逻辑分区 \u0026gt;=512mb 用于加载和启动（不要太大浪费）（空间起始位置） Ext4 日志文件系统：主分区、可以大一些，许多程序的默认安装地址在根目录的 /opt 中，挂载点：/ Ext4 日志文件系统：逻辑分区（看下默认的是啥）、剩下的都放在这，挂载点：/home 然后安装的时候需要选择刚刚分的系统分区 EFI，千万注意不要和 windows 搞混了，可以通过设备和大小来划分，后续按照引导来即可。\n++Grub 开机引导界面美化 https://zhuanlan.zhihu.com/p/94331255 BitLocker 科普 【科普】Win10电脑的Bitlocker是什么 Remove Dual System 参考资料: [华为云-删除双系统]（ https://bbs.huaweicloud.com/blogs/303695 ）[知乎-删除双系统]（ https://zhuanlan.zhihu.com/p/392633489 ）\nOutline：1 （option）备份 - 2 修改默认启动项 - 3 删除硬盘分区 -4 删除开机启动引导 - 5 （option）重新分配磁盘空间\n1. Backup 有重要文件 / 对操作不完全清楚推荐备份，不在赘述。\n2. 修改默认启动项 开机时，微星 F2 或 Del （不同品牌不同）进 Bios 修改 Boot 启动项，改回 windows 默认启动。\n3. 删除 Ubuntu 分区 Windows + S 搜索硬盘分区打开磁盘管理器，删除 Ubuntu 相关分区，主要特征如下：\n为主分区 非 EFI 系统分区（!）、非恢复分区、非基本数据分区 不是 windows 当前使用的分区（删除的时候会提示非Windows） 没有命名 不是未分配的分区 且一般会有磁盘 1-2 的区别，注意甄别。\n删除完分区后，可以找到相邻的分区，使用拓展卷功能，将多余的空间分配过去即可。\n折腾的话可以记住当前的系统大小分配备用。\n4. 删除 Ubuntu 开机引导 A. 管理员身份打开 CMD/Powershell，进入磁盘管理\n1 list disk B. 选择系统磁盘\n1 select disk 1 C. 查看对应的分区信息\n1 list partition 其中类型为系统的是 EFI 分区，Win11 一般为 100M，也可以再去磁盘管理器里面看一下。\nD. 为其分配盘符, 注意盘符当前未被使用，可以 Win+E 打开资源管理器看看。\n1 2 select partition 1 assign letter=k E. 盘无法直接进入，使用记事本访问，打开开始菜单，找到记事本，管理员权限打开。\n右上角【文件】-\u0026gt;【打开】进入新的磁盘，看到 EFI 文件夹，进入 EFI 文件夹，删除 Ubuntu 文件夹。\nF. 返回刚刚的命令行界面，删除分配的盘符即可\n1 2 remove letter=k exit 结束\n","permalink":"https://hugotest-phi.vercel.app/posts/dualsystemubuntu/","summary":"\u003cp\u003e该文介绍基于 Windows11 系统的双系统安装和删除，安装的双系统选择 Ubuntu（开发还是比较推荐使用 WSL2 即可）\u003c/p\u003e\n\u003ch2 id=\"install-dual-system\"\u003eInstall Dual System\u003c/h2\u003e\n\u003cp\u003e参考资料：\u003ca href=\"https://blog.csdn.net/NeoZng/article/details/122779035\" target=\"_blank\" rel=\"noopener\"\u003e全面解决各种问题\u003c/a\u003e\n \u003ca href=\"https://www.cnblogs.com/masbay/p/10745170.html\" target=\"_blank\" rel=\"noopener\"\u003e双系统安装\u003c/a\u003e\n \u003ca href=\"https://zhuanlan.zhihu.com/p/363640824\" target=\"_blank\" rel=\"noopener\"\u003eWindows+Ubuntu20.04双系统安装教程\u003c/a\u003e\n\u003c/p\u003e\n\u003ch3 id=\"1-安装-u-盘制作\"\u003e1. 安装 u 盘制作\u003c/h3\u003e\n\u003cp\u003e这里推荐 \u003ca href=\"https://github.com/ventoy/Ventoy\" target=\"_blank\" rel=\"noopener\"\u003eventoy\u003c/a\u003e\n 来做启动盘，ventoy 可以同时将很多系统的镜像放到一个 u 盘中，最最重要的是：干净简洁，可以参考其\u003ca href=\"https://www.ventoy.net/cn/doc_start.html\" target=\"_blank\" rel=\"noopener\"\u003e官方文档\u003c/a\u003e\n来制作盘，制作后将镜像文件放到指定目录即可。\u003c/p\u003e\n\u003ch3 id=\"2-硬盘分区\"\u003e2. 硬盘分区\u003c/h3\u003e\n\u003cp\u003ewin+s 搜索创建并格式化分区，找一块空闲空间较大的硬盘，右键压缩卷，设定好预留给 Linux 的空间即可（记住该大小，方便后续辨认，可以将各个盘的大小拍照记录下来，安装的时候别把 windows 覆盖了）。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230323085002.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230323085002.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230323085002.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230323085239.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230323085239.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230323085239.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e该预留的\u003cstrong\u003e未分配\u003c/strong\u003e空间，建议至少 30G 以上，如果需要开发和机器学习啥的话可以 50G、100G 以上。\u003c/p\u003e","title":"Windows Configuration04 Dual-System-Ubuntu"},{"content":"Reference\n本文介绍如何配置自己的 Github 的个人资料界面，同时会介绍相关美化个人资料的一些资源网站和项目，并简单介绍其用法。最终结果如下（还有许多优化的空间）：\n创建同名仓库 Github 中创建用户名的同名仓库，该仓库的 README.md 将会在个人的资料页进行展示。(附上官方的说明如下)\nAikenH/AikenH is a special repository. Its README.md will appear on your public profile.\n创建该仓库之后，我们对 Readme 的改动将会实时的同步到我们的个人界面，后续我们就只需要专注于编写和修改该 Readme 即可。\n相关资源推荐 由于大家的审美和风格不同，这里不做设计上的推荐，仅推荐一些用于美化个人界面的资源和部分项目的用法（以本人的 blog 为例）。\n名字部分，简单文字转图片随便找一个工具箱 或者网站生成即可，不在赘述；\n这里是一个工具和推荐仓库的大全集：abhisheknaiidu/awesome-github-profile-readme 这里是一些优秀的 readme profile 动态字幕 介绍使用的动态字幕效果实现：DenverCoder1/readme-typing-svg ，进入其 Demo Site ，设定想要的样式和文字即可生成对应的 markdown 和 html 代码。\n1 2 3 \u0026lt;p align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://git.io/typing-svg\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;https://readme-typing-svg.demolab.com?font=Fira+Code\u0026amp;pause=1000\u0026amp;color=CC7DF7\u0026amp;width=435\u0026amp;lines=The+five+boxing+wizards+jump+quickly\u0026#34; alt=\u0026#34;Typing SVG\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; 并通过 Html 样式指定居中对齐，将其放入 readme 中即可，效果如下：\n统计卡片 笔者更喜欢统计卡片 anuraghazra/github-readme-stats 的风格和 ui，也可以展示特定的仓库等，统计指标更为完善。\n使用时只需要指定 Username 即可，并根据自己的需求，添加和调整对应的参数，如添加 \u0026amp;count_private=true。\n该项目也能展示如：热门语言卡片、pin 其他的 repo 等等功能的卡片。\n徽章定制 徽章定制主要是 Shields ，输入自己的信息和颜色定制特定徽章，结合 Html 使用 href 超链接为佳，同时可以使用下面其他的样式来改变自己的徽标。\nhttps://img.shields.io/badge/\u0026lt;LABEL\u0026gt;-\u0026lt;MESSAGE\u0026gt;-\u0026lt;COLOR\u0026gt; 原始默认的样式如下： 可以改变写法，引入样式进行改变：\nhttps://img.shields.io/static/v1?label=github\u0026amp;message=aikenh\u0026amp;color=blue\u0026amp;style=for-the-badge\u0026amp;logo=appveyor 变成如下的形式等等，其他的参考网站。 使用 DenverCoder1/custom-icon-badges 基于获取的 shields 的徽标进行进一步的自定义，得到更多样式，可以自己上传标志，或者打上更多标签。\n修改 shields 的 url 选择其中的各种 slug 和 log 去进一步自定义该徽标 例如下面这个徽标，可以基于其 example usage 修改其中的文本和 icon 部分即可得到类似的效果。同样结合 html 的样式和 href 使用更佳。\n\u0026lt;a href=\u0026#34;https://aikenh.cn\u0026#34;\u0026gt;\u0026lt;img alt=\u0026#34;github\u0026#34; title=\u0026#34;AikenD\u0026#34; src=\u0026#34;https://custom-icon-badges.demolab.com/badge/-aiken%20blog-palegreen?style=for-the-badge\u0026amp;logo=package\u0026amp;logoColor=black\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; 统计奖杯 统计奖杯 ryo-ma/github-profile-trophy 可以根据 Github 账号的 Commit 等信息来统计 Github 的活跃程度，并通过奖杯的方式呈现出来（账户较为活跃的就可以使用这个来展示）。\n[![trophy](https://github-profile-trophy.vercel.app/?username=AikenH)](https://github.com/ryo-ma/github-profile-trophy) 使用方法较为简单，只要修改提供链接的 username 改为自己的即可，当然也有一些包括设定 rank 或者显示特定奖杯之类的，可以在 readme 界面看看介绍，并进行自定义即可。\n其他 简单的 readme 生成工具：rahuldkjain/github-profile-readme-generator 可以借助这个生成工具得到部分产品图标。 Icons of bands，产品图标 svg 大全：simple icons ，获取不同的产品图标，可以在定制 widget 什么的时候使用。 ","permalink":"https://hugotest-phi.vercel.app/posts/githubprofile/","summary":"\u003cp\u003e\u003cstrong\u003eReference\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e本文介绍如何配置自己的 Github 的个人资料界面，同时会介绍相关美化个人资料的一些资源网站和项目，并简单介绍其用法。最终结果如下（还有许多优化的空间）：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230122113307.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230122113307.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230122113307.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"创建同名仓库\"\u003e创建同名仓库\u003c/h2\u003e\n\u003cp\u003eGithub 中创建用户名的同名仓库，该仓库的 README.md 将会在个人的资料页进行展示。(附上官方的说明如下)\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAikenH/AikenH is a special repository. Its \u003ccode\u003eREADME.md\u003c/code\u003e will appear on your public profile.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e创建该仓库之后，我们对 Readme 的改动将会实时的同步到我们的个人界面，后续我们就只需要专注于编写和修改该 Readme 即可。\u003c/p\u003e\n\u003ch2 id=\"相关资源推荐\"\u003e相关资源推荐\u003c/h2\u003e\n\u003cp\u003e由于大家的审美和风格不同，这里不做设计上的推荐，仅推荐一些用于美化个人界面的资源和部分项目的用法（以本人的 blog 为例）。\u003c/p\u003e\n\u003cp\u003e名字部分，简单文字转图片随便找一个\u003ca href=\"http://www.atoolbox.net/Tool.php?Id=723\" target=\"_blank\" rel=\"noopener\"\u003e工具箱\u003c/a\u003e\n或者网站生成即可，不在赘述；\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e这里是一个工具和推荐仓库的大全集\u003c/strong\u003e：\u003ca href=\"https://github.com/abhisheknaiidu/awesome-github-profile-readme#tools\" target=\"_blank\" rel=\"noopener\"\u003eabhisheknaiidu/awesome-github-profile-readme\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e这里是一些优秀的 \u003ca href=\"https://zzetao.github.io/awesome-github-profile/\" target=\"_blank\" rel=\"noopener\"\u003ereadme profile\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"动态字幕\"\u003e动态字幕\u003c/h2\u003e\n\u003cp\u003e介绍使用的动态字幕效果实现：\u003ca href=\"https://github.com/DenverCoder1/readme-typing-svg\" target=\"_blank\" rel=\"noopener\"\u003eDenverCoder1/readme-typing-svg\u003c/a\u003e\n，进入其 \u003ca href=\"https://readme-typing-svg.demolab.com/demo/\" target=\"_blank\" rel=\"noopener\"\u003eDemo Site\u003c/a\u003e\n，设定想要的样式和文字即可生成对应的 markdown 和 html 代码。\u003c/p\u003e","title":"Github Profile 个人主页"},{"content":"@AikenH 2022 Node-JS-Chapter1\n参考：包管理工具npm、yarn以及nvm简介及简单使用 Concept 概念 对 Node，NPM，JS，Yarn，NVM 的概念和作用进行一个辨析和介绍，了解各自的含义和职责，进而理解我们使用的到底是什么，环境怎么管理，怎么自定义和进行改动等。\nJS在1995年诞生，Nodejs在2009年诞生，在此之前JS只能在浏览器中使用（google开发的chrome的V8引擎），NodeJS（第三方作者想直接在计算机运行JS，让其脱离浏览器）相当于提供的一个JS的运行环境，用来支持JS的执行，也就是JS的一个runtime system。\n由此，JS除了web前端编程，又可以支持后台开发、GUI开发、APP开发和CLI工具开发\nNodejs和JS的概念已经在上述清楚了，这里说一下nodejs组成：\nV8引擎将JS编译成机器码，提高运行速度； 本地模块：使用C/C++实现的一些高性能开源库； 标准库：封装C/C++的一些本地模块的接口，转换为JS接口，就是Nodejs的标准库，其良好的设计也赋予Nodejs强大的生命力； NPM 是随NodeJS一起安装的包管理工具（提供下载，版本校验，兼容性校验等功能），就像 pip、conda帮助Nodejs管理并解决本地部署的问题。\n允许下载别人写好的第三方包到本地使用； 允许下载安装别人编写的命令行程序； 允许上传包或命令行程序给别人使用； Yarn：由Facebook、Google、Exponent 和Tilde联合推出的JS包管理工具，和NPM就像是pip和conda的关系，其仍然使用NPM的registry，不过提供了全新的CLI来进行管理（也就是管理包的代码和逻辑有区别）\nNVM：Conda的另一个功能，在同个电脑上管理多个Node版本；\nCLI（Command-line-interface），相当于没有UI界面的命令行程序；\nCnpm：为了解决国内链接Npm registry的困难，淘宝自己的npm镜像（不过现在没啥用了好像）；\nRuntime 什么是runtime：运行时（runtime）是什么意思 、Runtime system - Wikipedia 、Node.js是什么？运行时是什么 runtime主要有几种类型：\n「程序运行的时候」，即程序生命周期的一个阶段。也就是运行阶段。\n「运行时库」，支撑应用级语言（c，c++，Rust）的一些正常功能的lib，对部分“标准指令”进行包装，（标准库）优雅的映射到汇编。也就是程序运行的时候所需要依赖的库。 「运行时系统」某门语言的宿主环境：Node.js是一个JavaScript的运行时。运行时系统主要是一些高级语言的概念，可以理解成一个更大、更全的运行时库，低级语言由于强指定类型等原因，可直接直译成机器码，而依赖于编译的语言，就需要一个运行时系统来实现语言的运行。\nJAVA运行时是JRE（Java Runtime Environment），C#运行时是CLR，他们都需要在OS上单独安装，借由他们来执行相应语言的程序（编译出的字节码），而对于JS来说，JS引擎不带IO支持的虚拟机，因此需要浏览器和Node这样的「JS运行时」才能让他控制文件、网络、图形等。\n典型的高级语言的「运行时系统」需要如下的组件：\n一个解释执行字节码的虚拟机，多半得带个垃圾回收器。\n如果语言是源码解释执行，那么需要一个编译器前端做词法分析和语法分析。\n如果运行时支持 JIT 优化，那么还得藏着个编译器后端（动态生成机器码 ）。\nIO 相关能力，比如 Node.js 的 fs.readFile 之类。\n已经相当于一个复杂的基础软件系统了。\n**总结：**运行时就是，类似一些编好的dll、标准库、解释器等，支持JS运行的组件和工具的合集，被统称为运行时。\nNodejs \u0026amp; NPM 安装和配置 安装：windows 直接去 nodejs -\u0026gt; nodesource/distributions: NodeSource 官网下载安装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # debian(ubuntu) # 首先更新NOdejs的软件源，基于上述提供的网站中获取指定连接和更新方式。 curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - # 接着使用apt命令下载nodejs 和 npm sudo apt-get install npm, nodejs # 可能还需要安装一些c++依赖 sudo apt install build-essential -y # macos brew install node # 查看版本 npm -v node -V 更新npm版本\n1 sudo npm install npm -g NPM设置代理registry地址，使用国内镜像\n1 2 3 npm config set registry https://registry.npm.taobao.org # 使用下面的命令进行检查 npm config get registry 常用操作 1 2 3 4 5 6 7 8 9 10 11 12 13 npm install \u0026lt;package\u0026gt; # 本地安装 npm install \u0026lt;package\u0026gt; -g # 全局安装 # npm i 为 install的简写 # 卸载模块 npm uninstall \u0026lt;package\u0026gt; npm ls # 查看是否卸载成功,或者去/node_modules目录check # 搜索模块 npm search \u0026lt;package\u0026gt; # 更新模块 npm update \u0026lt;package\u0026gt; node重新安装依赖包\n1 2 3 4 rm -rv node_modules # del those files we downlaods rm package-lock.json # del the install info npm cache clear --force npm install npm 设置代理\n1 2 3 4 5 npm config set proxy=http://127.0.0.1:8890 # 取消 npm config delete proxy # 查看 npm config list Package.json npm将每个使用npm的工程都看成一个包，包的信息是通过package.json配置文件来描述的，可以手动创建，但是大多数时候是使用npm init创建（可以创建一个看看默认值）\npackage-lock.json 锁定具体版本\nnpm在安装包的时候，会记录安装包时候准确的依赖项（包含版本信息），若我们保留了该文件，在安装的时候会根据上面的准确版本进行安装，最大程度的避免了差异。\npackage.json文件最重要的作用，是记录当前工程的依赖\ndependencies：生产环境的依赖包 devDependencies：仅开发环境的依赖包 配置好依赖后，使用下面的命令即可安装依赖\n本地安装所有依赖 安装所有依赖 dependencies + devDependencies 1 npm i Install的时候添加参数，可将包添加到依赖项的package.json中\n安装依赖到生产环境 1 2 3 npm i \u0026lt;package\u0026gt; npm i --save \u0026lt;package\u0026gt; npm i -S \u0026lt;package\u0026gt; 安装依赖到开发环境 1 2 npm i --save-dev \u0026lt;package\u0026gt; npm i -D \u0026lt;package\u0026gt; NPM中包的安装路径 节选自参考链接Link 本地安装 npm install 安装到当前路径的node_modules中 全局安装添加-g参数 全局文件的安装地址在: npm root -g | npm config get prefix\nYARN YARN 相比NPM有以下的优点，但是npm6之后，npm和yarn非常接近，所以后续很多从yarn转回npm的\n1 2 3 4 5 6 7 8 9 - 使用扁平的目录结构 - 并行下载 - 使用本地缓存 - 控制台仅输出关键信息 - yarn-lock记录确切依赖 - 增加了某些功能强大的命令 - 让既有的命令更加语义化 - 安装的CLI工具可以使用yarn直接启动 - 将全局安装的目录当成普通的工程，生成package.json文件，便于全局安装移植 安装yarn 1 npm install -g yarn 1 yarn --version package管理 1 2 yarn install \u0026lt;package\u0026gt; yarn remove \u0026lt;package\u0026gt; NVM NVM 用来管理node版本，便于适应多个node环境，在之间进行切换。\n1 2 3 4 5 nvm -v # 查看版本 nvm list # 查看node版本号 nvm use \u0026lt;version\u0026gt; # 使用指定版本号的node nvm install \u0026lt;version\u0026gt; # 下载指定版本的node nvm uninstall \u0026lt;version\u0026gt; # 卸载指定版本的node 设置淘宝镜像\n1 2 nvm node_mirror https://npm.taobao.org/mirrors/node/ nvm npm_mirror https://npm.taobao.org/mirrors/npm/ ","permalink":"https://hugotest-phi.vercel.app/posts/nodes/","summary":"\u003cp\u003e@AikenH 2022 Node-JS-Chapter1\u003c/p\u003e\n\u003cp\u003e参考：\u003ca href=\"https://blog.csdn.net/Newbie___/article/details/104759861\" target=\"_blank\" rel=\"noopener\"\u003e包管理工具npm、yarn以及nvm简介及简单使用\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"concept-概念\"\u003eConcept 概念\u003c/h2\u003e\n\u003cp\u003e对 Node，NPM，JS，Yarn，NVM 的概念和作用进行一个辨析和介绍，了解各自的含义和职责，进而理解我们使用的到底是什么，环境怎么管理，怎么自定义和进行改动等。\u003c/p\u003e","title":"Nodejs、yarn、npm关系辨析"},{"content":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r@Aikenhong 2022 介绍基于Tdesign和Django的界面安装和前后端联调，ubuntu version，\n该文章首先介绍如何配置环境，后续基于现有项目来介绍如何从零来构建基本的网页和后端服务。\n基本信息 （已完成）下载编写好的网页压缩包：web-design，里面包含了vue和django模块。\n路径两种方式打开：\n（命令行） cd ~/workspace/web_design_group10/ （资源管理器）主目录下的workspace/web_design_group10 编辑代码方式：\n使用vscode打开该文件夹进行编辑 启动服务 （以下的操作都分别基于web_design_group10路径）完整的网页启动需要分别启动前后端的服务，并均保持开启状态，所以需要使用两个终端窗口来分别启动。\n前端服务：在view-design路径下使用命令:npm run dev，可参考VUE启动 后端服务：在vuebackend页面使用命令： 1 python manager.py runserver （python版本需要是3以上）\n数据库服务：数据库安装后好像是默认启动的，如果发现有数据库的错误，按照ubuntu 启动mysql执行。 在启动服务之前，有一些环境需要配置，接下来我们将描述初始的环境准备。\n环境配置（Ubuntu） 配置主要有几个部分组成：配置前端环境（vue、node）、配置数据库（mysql）、配置后端（python包），我们首先描述前端环境的配置。\n**特定项目迁移：**只需要安装node和NPM，然后再对应目录npm i即可\n**初始化一个项目：**安装完node、npm之后，安装vue和tdesign，参考对应的官方文档即可，（npm install）\n前端环境配置 前端项目基于NodeJS，所以我们需要首先安装Node和NPM，在Ubuntu中安装Node的命令如下：\n1 2 3 4 5 6 7 8 # 首先更新NOdejs的软件源，基于基于需要的版本修改其中的版本号 14/16 # 接着使用apt命令下载nodejs 和 npm sudo apt-get install npm, nodejs # 查看版本验证安装是否成功 node -V npm -V 接着对特定前端（NodeJS）项目安装依赖\n1 2 3 4 cd /web-design-group10/view-design # 执行如下命令可直接根据项目的进行package的安装 # npm install 可以简写为 npm i npm install 安装完基本依赖后，即可启动前端服务看看页面是否正常运行，默认的访问路径是localhost:3001\n1 2 3 # 启动前端项目在view-design目录下 npm run dev # 启动后可以看到对应的端口和ip（建议首先使用localhost对前后端进行调试） 启动服务后可以边修改页面边预览效果（感觉不对劲就手动重启下，有时候响应会出现问题）\nMySQL环境配置 由于Django（后面我们会讲）将诸多对于数据库，例如MySQL的操作都集成成了Python语句，所以对于MySQL配置的部分，我们只需要做如下的准备：\n安装MySQL -\u0026gt; 初始化MySQL（设置密码）-\u0026gt;为后端创建一个初始的数据库 -\u0026gt; 在DJango中做好对应的设置。\n在Ubuntu上安装mysql：\n1 2 3 # install mysql(in ubuntu) sudo apt-get install mysql-client sudo apt-get install mysql-server 初始化MySQL（设置密码）：\n1 2 # 进入mysql sudo mysql 进入mysql之后，通过设置基本的密码来初始化sql的服务（执行别的命令之前我们需要该密码）\n1 2 3 4 5 6 mysql\u0026gt; alter user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; indentify with mysql_native_password by \u0026#39;passwd@of@my\u0026#39;; # 退出mysql数据库，验证是否正确初始化 mysql\u0026gt; exit; ​\t上述命令中，密码的小引号不能省略\n接着验证密码：\n1 2 3 mysql -u root -p # 输入密码，如果正确的话会进入数据库，到这里已经可以了，我们开始创建后续django使用的数据库 # 通过show databases; 可以查看现在创建好的所有数据库 创建项目所需的数据库（建议和项目文件夹同名，方便记忆）\n1 2 3 4 5 6 7 8 9 10 11 12 # 创建数据库并设定utf8编码，避免编码问题 mysql\u0026gt; create database \u0026lt;project-name\u0026gt; character set utf8; # 使用show databass查看是否正确创建 mysql\u0026gt; show databases; # 使用use \u0026lt;database-name\u0026gt; 进入对应的数据库 mysql\u0026gt; use \u0026lt;databases-name\u0026gt;; # 使用show tables查看已经创建好的表格 mysql\u0026gt; show tables; 到这里对于数据库的配置就告一段落，后续只需要在Django中设置如下的内容即可：\n使用的数据库架构（mysql or else） 使用的具体数据库，（我们为后端创建的那个） 数据库的访问密码 之后就可以在Django的python代码中执行常见的数据库操作来进行响应的增删改查。\n参考链接：install 、刘江 Django环境配置（with mysql） Django 作为Python的一个库（Lib）安装过程实际上是配置一个python环境，这里主要考虑到结合mysql需要安装一些额外的库和设置，同样，会分成以下的几步：\n安装Django-\u0026gt;安装Django-Mysql需要的库-\u0026gt;建立Django和mysql连接（填写上面提到的密码等）-\u0026gt;初始化项目\n安装Django 1 2 # 如果没有pip的话试试pip3，如果是pip3安装的，最后启动服务的时候要记得用python3来启动 pip install django 安装mysqlclient 1 pip install mysqlclient 创建一个空的Django项目： （cd）移动到一个我们放置项目的空目录（忽略\u0026lt;\u0026gt;），就会创建一个my-project-name的项目：\n1 django-admin startproject \u0026lt;my-project-name\u0026gt; 其文件结构如下（具体作用解析：https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial01/）：\n1 2 3 4 5 6 7 8 mysite/ manage.py mysite/ __init__.py settings.py urls.py # 接口的路由管理,也就是我们的接口在哪边访问 asgi.py wsgi.py 创建一个具体的“APP”，又被称作应用，这里的应用和上面创建的项目的区别在于（摘自官网）：\n项目和应用有什么区别？应用是一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者小型的投票程序。项目则是一个网站使用的配置和应用的集合。项目可以包含很多个应用。应用可以被很多个项目使用。\n个人讲项目理解为项目，主要提供Django的基本功能和设置环境；应用则是我们进行具体功能开发的主要地方，比如我们这里创建一个webapi的应用，用来编写特定网站需要的所有接口：\n1 2 # 初始化APP python manager.py startapp webapi Django会创建路径如下：\n1 2 3 4 5 6 7 8 9 webapi/ __init__.py admin.py # 包含django管理界面的设置 apps.py # 包含webapi配置的设置 migrations/ __init__.py models.py # 定义数据库中的表 tests.py views.py # 定义API 创建完APP（应用后），我们需要在项目的设置中安装\n1 vim vuebackend/vuebackend/setting.py 找到INSTALLED_APPS字段，添加创建的APP，最终如下：\n1 2 3 4 5 6 7 8 9 10 INSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;corsheaders\u0026#39;, \u0026#39;webapi\u0026#39;, ] 启动项目 1 2 3 4 python manage.py runserver # 如果希望除了localhost都能访问启动的时候可以监听所有的ip # 然后在allow url中填上自己的ip python manager.py runserver 0.0.0.0:8000 安装其他依赖项（启动项目，缺啥就pip install啥，搞定后关掉） 如果不需要数据库的话到这里就已经可以了，如果需要数据库的话，我们继续往下看。\n建立和数据库的连接 1 vim vuebackend/vuebackend/setting.py ​\t修改其中的DATABASES字段如下：\n1 2 3 4 5 6 7 8 9 10 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;vuebackend\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;__\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;PORT\u0026#39;: \u0026#39;3306\u0026#39;, } } ENGINE，如果是mysql的引擎就填这个，别的数据去再去看，\nNAME：mysql中为后端创建的数据库的名称\nUSER：直接使用root用户，\nPASSWORD：我们初始化mysql时设置的密码\nHOST：127.0.0.1 指代本机\nPORT：3306为mysql默认的启动端口\n测试数据库功能 Django中model.py编写的内容，Django会用其自身的形式进行“包装”（封装），转换成对应的数据库操作，然后在数据库中执行对应的命令。（好像被称作ORM）\n而我们主要用到的功能是：创建类，会自动在数据库中生成表格，其中支持的数据类型可以在官网中找到参考 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from django.db import models # Create your models here. class Gamerecords(models.Model): \u0026#34;\u0026#34;\u0026#34; the table for saving abs and the create info \u0026#34;\u0026#34;\u0026#34; m_id = models.AutoField(primary_key=True) game_name = models.CharField(max_length = 150) author = models.CharField(max_length = 150) file_type = models.CharField(max_length = 150, default=\u0026#34;Java\u0026#34;) create_time = models.DateTimeField() # 对应python中的Datetime类型 定义之后，命令行执行命令，将这些字段映射成数据库中的一张表，下述命令执行数据库操作\n1 2 3 python manage.py makemigrations (应用名，选填) python manage.py migrate (应用名，选填) python manager.py runserver 启动服务 执行完后可以去mysql对应的数据库中，使用show tables查看是否新建表成功。\n然后照常启动后端服务。\n参考链接：offical with mysql 、simple start with mysql 配置跨域便于和vue项目链接：需要安装django-cors-headers模块，并在设置setting.py中导入 1 pip install django-cors-headers 然后在项目中添加模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # books_demo/settings.py INSTALLED_APPS = [ ... # demo \u0026#39;corsheaders\u0026#39;, ... ] MIDDLEWARE = [ \u0026#39;corsheaders.middleware.CorsMiddleware\u0026#39;, # 需注意与其他中间件顺序，这里放在最前面即可 ... ] # 支持跨域配置开始 CORS_ORIGIN_ALLOW_ALL = True CORS_ALLOW_CREDENTIALS = True 开发指南 开发界面会基于如下的几个部分进行描述：前端开发、后端开发、前后端联通，每一部分的开发会从一个空项目开始，以现有的代码为例，来介绍各个部分的开发和联通。最后给出一个从0开始设计前端模块、后端功能、前后端传输的Task（demo）。其中也会介绍最raw的debug方式。\n一些不错的参考链接：前后端从零开始构建流程demo，包含使用curl测试api 、也是前后端搭建的Demo VUE和Tdesign前端开发 前端部分由于个人能力有限，仅了解到代码结构的大体构筑，和如何修改，因此不做从零开始的参数，仅以自己的认知去介绍如何修改代码，以及各个模块的交互方式介绍。\n参考链接：页面外观配置 、vue中引入html界面 必看！！！核心配置，整体的文件逻辑 具体介绍模块：代码结构、路由结构（如何删除页面的路由，对应的页面在什么地方）、页面的简单设计逻辑、页面之间的跳转\n前端的代码我们基本上只关注src路径下的代码，所有的页面和逻辑基本都在其中：\n整体的架构参考上面的链接，我们主要关注的是以下几个文件夹：\npage: 存放所有的页面 router： 存放路由跳转逻辑，其中index.js中*定义了默认的主页，其他文件中，定义页面的具体url，参考链接 页面的组成 可以参考page中的每个文件夹，核心就是：每个index.vue是一个页面。\n每个页面基本有三个部分组成：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;tempalte\u0026gt; 样式布局，也就是基本的外观，按钮，乱七八糟的，去tdesign vue之类的网站上找模版，进行组合即可 \u0026lt;/tempalte\u0026gt; \u0026lt;script\u0026gt; export default{ data 初始化和设置各种变量 created 里面的函数在页面创建的时候执行 mounted 里面的函数在页面挂载时候执行 method 定义的各种奇奇怪怪的函数，与后端交互的函数， } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; 定义一些加粗之类的样式，用来对template的的基本组件进行加工 \u0026lt;/style\u0026gt; 其中script中各个部分里面放的函数在不同时候执行：生命周期可以参考https://juejin.cn/post/6874855535234170887，其实就是字面意思，在创建页面之前执行beforecreate啥的（大概意思，具体我也没有太了解）。\nmethod里面就是单纯的函数定义，我们的上传之类的交互代码可以放在这里，然后把函数：\n绑定到按下按钮等事件上或者 绑定到（放到）某些生命周期中，比如创建页面的时候执行一次，或者页面挂载的时候执行一次之类的 页面的跳转（结果页跳转之类） 我实现的**逻辑（Pipeline）**是这样的：\n（前置）跳转到的页面需要再router中注册过 -\u0026gt; 编写一个函数，按下以后跳转到对应的页面，并传递一个id-\u0026gt;跳转到的页面打开的时候读取id，读取数据。\nrouter的注册\n在router那个路径，我不确定是path还是name,还是重定向地址，反正调试的时候试试\n1 2 3 4 5 6 7 8 { \u0026#34;path\u0026#34;: \u0026#34;modelbase\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;modelbase\u0026#34;, \u0026#34;component\u0026#34;: () =\u0026gt; import(\u0026#34;@/pages/list/modelbase/index.vue\u0026#34;), \u0026#34;meta\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;上传模型\u0026#34; } }, 页面跳转的函数\nRouter.push就会跳转到对应的页面,name页面名字，query就是传递过去的参数\n参考commandtable.vue，row是列表中的参数，代表列表中的某一项，\n1 2 3 4 handleClickDetail( row ) { const m_id_detail = row[\u0026#39;row\u0026#39;].m_id; this.$router.push({ name: \u0026#39;modelbase\u0026#39;, query: { ids: m_id_detail } }); }, 跳转过去的页面加载参数\n根据传递过来的参数生成相应的数据用来展示，或者二次跳转？\n跳转过去的页面，在生成的生命周期中，使用whtch方法，route传递过来的参数以变化我们就执行下面的函数。\n1 2 3 4 5 6 7 8 created() { this.$watch(() =\u0026gt; this.$route.query, (to_params, old_params) =\u0026gt; { console.log(this.$route.query); this.gettaskinfo(); // your function here using the route.query中的参数 console.log(this.$route.query); }); }, 然后生成对应的报告之类的\n参考文献：详情页 关键词：vue详情页 商品页之类\n文件传输前端接口的编写 该部分的编写依托于elementui或者tdesign的upload组件封装\n其基本的编写逻辑如下：\naction中填写我们编写的后端接口url\nformatResponse中填写对后端返回值的格式处理，用以适应组件识别传输事件是否成功\n参考 suceess和fail事件的触发条件，用来编写format tdesign事件是在response中添加url信息和如果失败的话就用error字段传回失败原因 1 return {...res, url: xxx.xxx.xxx.xxx:xxxx, error : \u0026#34;why you fail\u0026#34;} 即可在可视化组件上绑定对应的文件上传\n静态HTML页面加载 再编写前端页面的时候，有时候需要处理后端生成的html页面，我们希望能够跳转到指定的html文件的。\n需要将HTML作为静态文件存储到VUE project中静态目录（public）中（防止VUE对HTML文件进行二次编译处理） 假如我们存储的目录为：public/result/index.html我们可以在vue中通过下列函数打开对应页面 函数如下:\n1 2 3 loadLocalHtml(){ windows.open(\u0026#39;/result/index.html\u0026#39;); } 如果需要灵活加载详情页面，我们可以根据传入的参数来确定最后存储的地址（或者在后端对文件进行移动）\n前后端的联通 同样也是在mehtod中定义一个访问接口的方法，然后在合适的时候调用这个访问接口的函数就行。放在下面的前后端联动的部分\nDjango后端开发 实现基础功能的话，后端的逻辑和实现相对较为简单，本文介绍：开发api的流程（将自己的功能嵌入）、提供对数据库进行增删改查的例子、提供文件传输api的例子。文件传输好像有更优的解法，后续进行更新\n后端开发Pipeline\n（optional）model.py设计数据表 -\u0026gt; view中设计api（数据获取，数据上传等任何功能）-\u0026gt;注册api到特定的url-\u0026gt;测试api-\u0026gt;done.\n如果有数据库需求才使用，可以简单的存储（用户，时间，存储html路径，语言类型，项目名称等） view中有特定的八股文，下面为会讲到特定的\u0026lt;func\u0026gt;占位部分，填入自己的功能，实现：**根据传来的数据或者GET请求，执行特定的操作，返回特定信息（不返回也行）**的流程即可。 将该域名注册个特定的api，便于访问该api 数据表设计 参考上述的例子（环境配置-Django-6数据库测试），在model.py文件中创建一个类，定义需要的表结构，然后执行两部数据库操作即可：\n下面给出一个Coverage-Test的上传信息类设计Demo：\n1 2 3 4 5 6 7 8 9 10 from django.db import models Class CoverageInfo(models.Model): m_id = models.AutoField(primary_key=True) task_name = models.CharField(max_length = 150, default = \u0026#34;coverage test\u0026#34;) author = models.CharField(max_length = 150, default = \u0026#34;anmous\u0026#34;) create_time = models.DateTimeField() lang_type = models.CharField(max_length = 150, default = \u0026#34;JAVA\u0026#34;) res_path = models.CharField(max_length = 1000, defailt = \u0026#34;~/workspace/coverage-res/author_default/\u0026#34;) code_path = models.CharField(max_length = 1000, default = \u0026#39;~/workspace/coverage-code/author_default/\u0026#39;) 该Table的处理逻辑如下：\ntask_name、author、lang_type交由前端用户填写，传递到后端； m_id为mysql自动递增的数据逻辑我们无需处理，create_time在后端接受请求的时候自动计算 res_path在执行完覆盖率测试后，将文件存储指定定地点，然后将该地点返回，将该地点存进数据库，这样我们就可以随时查询任一个记录的覆盖率结果。 将这些信息存入数据库，便于增删改查，文件和结果则存储本地。\nmysql中生成表\n1 2 python manage.py makemigrations python manage.py migrate API设计 主要从前端接受两种请求：GET、POST，然后基于这两种请求，我们实现对数据增删改查的操作，或者其他的特定操作。API的定义在views.py中完成。基础的范式如下：\n需要注意的是，前后端之间的数据传输，基本都是约定为JSON这种KEY-VALUE格式的，故而我们好像需要进行什么序列化反序列化的操作，来对信息进行解读（理论后续补充）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from django.http import JsonResponse from django.views.decorators.http import require_http_methods from django.core import serializers @require_http_methods([\u0026#39;GET\u0026#39;]) def get_games_index(request): response = {} try: # using get to get value from front ----\u0026gt; receive = {} reveive[\u0026#39;info1\u0026#39;] = request.GET.get(\u0026#39;info1\u0026#39;) ... # like that ， 应该也可以循环取出 # \u0026lt;----- using get to get value from front # your function here 「----------------- # 基于我们从前端获取到的数据，做任何事情，执行任何函数 # -------------- your function here 」 # 可以给前端返回一些数据 response[\u0026#39;res\u0026#39;] = ... 之类的,传过去之前要对数据进行序列话处理 # yourdata需要时{}存kv形式 response[\u0026#39;res\u0026#39;] = json.loads(serializers.serialize(\u0026#34;json\u0026#34;, yourdata)) response[\u0026#39;msg\u0026#39;] = \u0026#39;success\u0026#39; response[\u0026#39;error_num\u0026#39;] = 0 except Exception as e: response[\u0026#39;msg\u0026#39;] = str(e) response[\u0026#39;error_num\u0026#39;] = 1 return JsonResponse(response) （带文件的post会比较特殊，后面在例子里面单独讲）POST例子和GET例子主要的区别在于：获取传递过来的数据的方式不同，注意这里的JSON.loads。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @require_http_methods([\u0026#34;POST\u0026#34;]) def get_info_games(request): response = {} try: # 获取前端post过来的文件什么的 post_message = json.loads(request.body) # 获取前端post过来的参数什么的还是使用get reveive[\u0026#39;params\u0026#39;] = request.GET.get(\u0026#39;params\u0026#39;) games = json.loads(serializers.serialize(\u0026#34;json\u0026#34;, games)) response[\u0026#39;games\u0026#39;] = games response[\u0026#39;mag\u0026#39;] = \u0026#39;success\u0026#39; response[\u0026#39;error_num\u0026#39;] = 0 except Exception as e: response[\u0026#39;msg\u0026#39;] = str(e) response[\u0026#39;error_num\u0026#39;] = 1 return JsonResponse(response) 增删改查demo 以上述设计的coverage_test表格为例子，“增删改查”实际上都是对数据库进行的操作，因此实际上的操作范例都较为相似，下面废话不多说，直接给出demo进行讲解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 增：实际上就是获取数据（post），将数据存储进数据库中，所以我们首先使用post协议，在根据上述的八股文，用json.load(request.body)获取post传过来的数据，其表现为字典的形式。 # 由于文件传输的类型是2进制数据流，没办法用json load，所以和普通的post处理比较不同，我们后面讲，这里先讲基本的post。 from models import CoverageInfo @require_http_methods([\u0026#34;POST\u0026#34;]) def update_task(request): response = {} try: post_message = json.loads(request.body) # print(post_message) # 讲数据存进我们定义的类结构中。 tasks = CoverageInfo(task_name = post_message[\u0026#39;task_name\u0026#39;], author = post_message[\u0026#39;author\u0026#39;], lang_type = post_message[\u0026#39;lang_type\u0026#39;], create_time = datetime.datetime.now(), ) # 使用save命令将其存进数据库中 task.save() #可以返回一下我们存储起来的数据 response[\u0026#39;task\u0026#39;] = json.loads(serializers.serialize(\u0026#34;json\u0026#34;, games)) response[\u0026#39;mag\u0026#39;] = \u0026#39;success\u0026#39; response[\u0026#39;error_num\u0026#39;] = 0 except Exception as e: response[\u0026#39;msg\u0026#39;] = str(e) response[\u0026#39;error_num\u0026#39;] = 2 return JsonResponse(response) 删除/修改/查询，实际上是类似的，都是先找到然后再进行操作，这里一并讲了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 显示近期的5个task @require_http_methods([\u0026#39;GET\u0026#39;]) def recent_tasks(request): response = {} num_to_show = 5 try: # .objects.filter()会返回符合filter条件的所有记录，如果是空的就会返回所有 # 所以删，改，查，就是从前端传递一个id回来，然后我们用filter找到他，然后print、覆盖、删除。 tasks = CoverageInfo.objects.filter() response[\u0026#39;tasks\u0026#39;] = json.loads(serializers.serialize(\u0026#34;json\u0026#34;, models)) response[\u0026#39;tasks\u0026#39;] = response[\u0026#39;tasks\u0026#39;][-num_to_show:] # print(response[\u0026#39;models\u0026#39;]) response[\u0026#39;msg\u0026#39;] = \u0026#39;success\u0026#39; response[\u0026#39;error_num\u0026#39;] = 0 except Exception as e: response[\u0026#39;msg\u0026#39;] = str(e) response[\u0026#39;error_num\u0026#39;] = 1 return JsonResponse(response) 删、改、查，（使用get方法用参数来找到就行了）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @require_http_methods([\u0026#34;GET\u0026#34;]) def delete_models(request): response = {} try: get_id = request.GET.get(\u0026#34;ID\u0026#34;) # ID是在前端定义好的传回来的key，随便定啥都行 # 查询 results = CoverageInfo.objects.filter(m_id = get_id) # 删除 CoverageInfo.objects.filter(m_id=get_id).delete() # 修改（基于查询那一步） results.author = request.GET.get(\u0026#39;Author\u0026#39;) ... # 重复操作每一条属性 response[\u0026#39;mag\u0026#39;] = \u0026#39;success\u0026#39; response[\u0026#39;error_num\u0026#39;] = 0 except Exception as e: response[\u0026#39;msg\u0026#39;] = str(e) response[\u0026#39;error_num\u0026#39;] = 1 return JsonResponse(response) 文件接受API demo 由于我这边还没有完全掌握文件传输的方法，这里我的实现会和基本的post方法获取有一点区分，下面讲解文件传输的后端操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @require_http_methods([\u0026#39;POST\u0026#39;]) def accept_code_file(request): # 原版test_api response = {} # （存在本地）定义一个存储文件的基本地址，（本地先新建这个目录） base_path = \u0026#34;/data/home/metis/workspace/code_file\u0026#34; try: # 用作者名来管理文件的存储地址 author_name = request.GET.get(\u0026#39;author\u0026#39;) if not author_name: author_name = \u0026#39;tmp\u0026#39; # 把地址和提交者名拼起来，没有的话新建文件夹 real_path = os.path.join(base_path, author_name) if not os.path.exists(real_path): os.mkdir(real_path) # 循环存储传过来的所有文件 for filename, file in request.FILES.items(): print(filename, file) tmp = file.read() # 文件的二进制数据流，也就是实际要存下来的数据 newfilename = random_filename(file.name) # 可以对文件名进行简单的处理 final_path = os.path.join(real_path, newfilename) # 拼接地址 print(final_path) # 讲文件存起来(使用chunk便于大文件的断点续传，避免大文件传输出现问题) # (TBD) 测试验证是否正确 （可能需要使用request.FILES[\u0026#39;file\u0026#39;]替代后面的file.chunks） with open(final_path, \u0026#39;wb\u0026#39;) as f: for chunk in file.chunks(): f.write(chunk) # 小文件传输的例子 with open(final_path, \u0026#39;wb\u0026#39;) as f: f.save(tmp) # 获取代码的类型,执行对应的代码,生成html文件,返回文件的地址 lang_type = request.GET.get(\u0026#39;lang_type\u0026#39;) # 逻辑是这样，如果处理覆盖率的时间比较长，可能要在后台跑，这个研究下怎么处理。 # 关键词 Django后台、Django多线程、还没查好，先放一些参考资料，可能就是用一个线程来执行任务 # https://www.tioit.cc/index.php/archives/6/ # https://zhuaxia.xyz/detail/11847 html_path = coverage_test(final_path, lang_type) # 建立数据库词条，可以新增一条代码存储的路径(数据) tasks = CoverageInfo( task_name = request.GET.get(\u0026#39;task_name\u0026#39;), author = request.GET.get(\u0026#39;author\u0026#39;), lang_type = request.GET.get(\u0026#39;lang_type\u0026#39;), create_time = datetime.datetime.now(), res_path = request.GET.get(\u0026#39;html_path\u0026#39;), code_path = final_path, ) task.save() # 将词条存进数据库里。 response[\u0026#39;task\u0026#39;] = json.loads(serializers.serialize(\u0026#34;json\u0026#34;, tasks)) response[\u0026#39;msg\u0026#39;] = \u0026#39;success\u0026#39; response[\u0026#39;error_num\u0026#39;] = 0 except Exception as e: response[\u0026#39;msg\u0026#39;] = str(e) response[\u0026#39;error_num\u0026#39;] = 1 return JsonResponse(response) 注意pipeline写完接口后要去注册url。\nAPI注册 首先将我们的所有api都注册到/api/（可以自己改） 下面：在项目（vuebackend）的urls.py配置文件（这个可能是自己生成或者默认的）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026#34;\u0026#34;\u0026#34;vuebackend URL Configuration The `urlpatterns` list routes URLs to views. For more information please see: https://docs.djangoproject.com/en/3.2/topics/http/urls/ Examples: Function views 1. Add an import: from my_app import views 2. Add a URL to urlpatterns: path(\u0026#39;\u0026#39;, views.home, name=\u0026#39;home\u0026#39;) Class-based views 1. Add an import: from other_app.views import Home 2. Add a URL to urlpatterns: path(\u0026#39;\u0026#39;, Home.as_view(), name=\u0026#39;home\u0026#39;) Including another URLconf 1. Import the include() function: from django.urls import include, path 2. Add a URL to urlpatterns: path(\u0026#39;blog/\u0026#39;, include(\u0026#39;blog.urls\u0026#39;)) \u0026#34;\u0026#34;\u0026#34; from django.contrib import admin from django.urls import path, include import vueapi.urls urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;api/\u0026#39;, include(vueapi.urls)), # 改这里可以了（就初始化的时候改一下就行） ] 然后注册我们的每个API具体的地址/api/\u0026lt;specifal\u0026gt;中\n1 2 3 4 5 6 7 8 # from django.urls import path, re_path from django.urls import re_path from . import views urlpatterns = [ re_path(r\u0026#39;accept_code_file$\u0026#39;, views.accept_code_file), ] 注册完成后可以用curl命令测试api\n命令行使用curl命令测试API\n测试get 1 curl http://127.0.0.1:8000/api/\u0026lt;api_name\u0026gt;?\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;api\u0026gt; 填我们在django的后端中注册的名字、key-value的形式输入我们传入后端的数据。\n1 curl http://127.0.0.1:8000/api/accept_code_file?author=aiken\u0026amp;task_name=test 测试post 1 curl -d \u0026#34;Key=Value\u0026#34; \u0026#39;http://127.0.0.1:8000/api/accept_code_file?author=aiken7task_name=test\u0026#39; -d后面是post获取的\n？后面是get获取的\n前后端联动 该部分主要从这几个部分开始介绍：Get请求后端操作返回数据、Post传输数据给后端并接受返回值、Debug方式、具体demo（文件传输、数据的增删改查、最近的数据显示）。\n前后端进行接口的交互主要是前端基于axios 这个模块向后端发送请求的（文件传输我用的这个写法），在tdesign 中还封装了一种形式，好像也是基于axios封装的（其他的我都用的这种写法）\n这一部分方法都在method（）中定义，然后在需要的地方定义，通常为更新data中的数据，\n发起一个Get请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 getModelList() { this.$request .get(\u0026#39;http://9.134.13.0:8000/api/recent_models\u0026#39;) # url .then((res) =\u0026gt; { # 前端返回的数据在res中 const m_model_list = res.data.models; # 通过 res.data.\u0026lt;key\u0026gt;的方式取出数据，就是我们返回的一整个json 看前端的console.log打印出来的值，可以知道其是一个列表形式的，而我们返回值是列表中的list[i].field.将其存进临时的列表中 const m_list_test = []; for (let i = 0; i \u0026lt; m_model_list.length; ++i){ m_list_test.push(m_model_list[i].fields); } # this取全局变量，在data中定义好的，我们更新这个值用来渲染数据 this.model_list = m_list_test; console.log(this.model_list); }) .catch((e) =\u0026gt; { console.log(e) }); }, 发起一个POST请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 getGameInfo() { console.log(\u0026#34;start\u0026#34;) this.$request // 将上个路由界面穿过来的id作为参数，传到后端去，然后请求后端返回特定的数据 .post(\u0026#39;http://9.134.13.0:8000/api/get_info_games\u0026#39;, this.$route.query[\u0026#39;ids\u0026#39;]) .then((res) =\u0026gt; { const task_list = res.data.games[0].fields; console.log(JSON.stringify(res)); const m_list_res = Array(); // 赋值变量 for (var key in task_list) { m_list_res.push({ name: key, value: task_list[key], }) } console.log(m_list_res); // 赋值全局变量 this.baseInfoData = m_list_res; }) .catch((e) =\u0026gt; { console.log(e); }); }, 文件传输的特殊POST请求 普通的post\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 onSubmitPost() { console.log(\u0026#39;submit! post\u0026#39;); this.$request // 将全局参数中的formdata用post传递到后端，接受后端返回到信息 .post(\u0026#34;http://9.134.13.0:8000/api/create_battel\u0026#34;, this.formData) .then((res) =\u0026gt; { console.log(JSON.stringify(res)); console.log(\u0026#39;---------------------------\u0026#39;); console.log(JSON.stringify(this.formData)); }) .catch((e) =\u0026gt; { console.log(e); alert(\u0026#39; create battel fail\u0026#39;); }); } 对应页面跳转的post\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 submit_file(file) { console.log(file) // 获取文件到临时的变量formdatas中 let formdatas = new FormData() formdatas.append(\u0026#39;file\u0026#39;, file) console.log(this.formData.author) axios({ url: \u0026#39;http://9.134.13.0:8000/api/test_api\u0026#39;, method: \u0026#39;post\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;multipart/form-data\u0026#39; }, // data传递文件数据 params传递参数数据 data: formdatas, params: { \u0026#39;author\u0026#39;: this.formData.author }, }).then((res) =\u0026gt; { console.log(res) this.$message.success(`文件 ${file.name} 上传成功`); }).finally(() =\u0026gt; { // this.handleSuccess(); }); }, Debug 首先介绍简单的变更查看方式，方便知道别人在基础的项目上做了啥改动\n借助VsCode和Git，安装git，vscode，vscode的git插件\n初始化一个项目（无论是Django还是vue还是任何其他）\ngit init，git add，git commit 提交一次原始版本\n将别人的代码文件拖进来覆盖掉，即可在vscode边栏中的git项目管理中，看到与上次提交的不同，从而看出别人有多少改变，借助该工具也能轻松的还原回原始的样子。\n（该指令是基于git diff的，但是在命令行中没有那么易于查看，因此借助vscode，git diff也可以了解一下）\nnode重新安装依赖包\n1 2 3 4 rm -rv node_modules # del those files we downlaods rm package-lock.json # del the install info npm cache clear --force npm install NPM中包的安装路径\n节选自参考链接Link 本地安装 npm install 安装到当前路径的node_modules中 全局安装添加-g参数 全局文件的安装地址在: npm root -g ","permalink":"https://hugotest-phi.vercel.app/posts/custom_web/","summary":"\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"aikenhong_blog\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003cp\u003e@Aikenhong 2022 介绍基于Tdesign和Django的界面安装和前后端联调，ubuntu version，\u003c/p\u003e\n\u003cp\u003e该文章首先介绍如何配置环境，后续基于现有项目来介绍如何从零来构建基本的网页和后端服务。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"基本信息\"\u003e基本信息\u003c/h2\u003e\n\u003cp\u003e（已完成）下载编写好的网页压缩包：web-design，里面包含了vue和django模块。\u003c/p\u003e\n\u003cp\u003e路径两种方式打开：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e（命令行） \u003ccode\u003ecd ~/workspace/web_design_group10/\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e（资源管理器）主目录下的workspace/web_design_group10\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e编辑代码方式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e使用vscode打开该文件夹进行编辑\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"启动服务\"\u003e启动服务\u003c/h3\u003e\n\u003cp\u003e（以下的操作都分别基于web_design_group10路径）完整的网页启动需要分别启动前后端的服务，并均保持开启状态，所以需要使用两个终端窗口来分别启动。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e前端服务：在view-design路径下使用命令:\u003ccode\u003enpm run dev\u003c/code\u003e，可参考VUE启动\u003c/li\u003e\n\u003cli\u003e后端服务：在vuebackend页面使用命令：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epython manager.py runserver\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e（python版本需要是3以上）\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e数据库服务：数据库安装后好像是默认启动的，如果发现有数据库的错误，按照ubuntu 启动mysql执行。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在启动服务之前，有一些环境需要配置，接下来我们将描述初始的环境准备。\u003c/p\u003e\n\u003ch2 id=\"环境配置ubuntu\"\u003e环境配置（Ubuntu）\u003c/h2\u003e\n\u003cp\u003e配置主要有几个部分组成：配置前端环境（vue、node）、配置数据库（mysql）、配置后端（python包），我们首先描述前端环境的配置。\u003c/p\u003e\n\u003cp\u003e**特定项目迁移：**只需要安装node和NPM，然后再对应目录npm i即可\u003c/p\u003e\n\u003cp\u003e**初始化一个项目：**安装完node、npm之后，安装vue和tdesign，参考对应的官方文档即可，（npm install）\u003c/p\u003e\n\u003ch3 id=\"前端环境配置\"\u003e前端环境配置\u003c/h3\u003e\n\u003cp\u003e前端项目基于NodeJS，所以我们需要首先安装Node和NPM，在Ubuntu中安装Node的命令如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 首先更新NOdejs的软件源，基于基于需要的版本修改其中的版本号 14/16\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 接着使用apt命令下载nodejs 和 npm\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install npm, nodejs\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看版本验证安装是否成功\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enode -V\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm -V\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e接着对特定前端（NodeJS）项目安装依赖\u003c/p\u003e","title":"基于Vue和Django的前后端开发实践"},{"content":"基本Vue语法规则学习笔记，方便我们去自定义和看懂别人的网页代码。\n概念补充：\nDOM 超文本标记语言HTML查表 Attribute和\u0026lt;\u0026gt;协同使用，在其中定义括起来的“文本”的属性 Template Syntax vue的模版语法是基于HTML的，但是在底层机制中，会将模版编译成高度优化的JS代码，因此可以通过：\nHTML style 默认 JSX, 编写渲染函数而不使用模版，但是这样不会享受 VUE 自带的优化。 声明式渲染 Vue.js的核心是通过一个简洁且统一的模版来将声明式数据渲染进DOM的系统，换言之，也就是另一种形式的定义式。\n文本插值例子，html从变量中获取message\n1 2 3 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{message}} \u0026lt;/div\u0026gt; 1 2 3 4 5 6 var app = new Vue{{ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#34;hello vue!\u0026#34; } }} 元素绑定例子: 在页面上绑定一个函数（使用v-bind和span？），然后如文本插值的例子一般，只是将message绑定为函数like：message: '页面加载于' + new Date().toLocaleString()\n1 2 3 4 5 \u0026lt;div id=\u0026#34;app-2\u0026#34;\u0026gt; \u0026lt;span v-bind:title=\u0026#34;message\u0026#34;\u0026gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 此处的div是一个纯粹的容器，其通过id来指定内容的格式来自何处，从而调用定义的app2的DOM？\n带有v-前缀的属性为vue提供的特殊attribute，在这里的含义是将这个元素节点的title attribute和vue实例中的message（id指定？）保持一致。\n（结构绑定）条件语句，同样要通过div id来指定我们的vue实例，然后通过v-if来执行条件语句。\n1 2 3 \u0026lt;div id=\u0026#34;app-if\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;seen\u0026#34;\u0026gt;现在你看到我了\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 var app3 = new vue{{ el: \u0026#39;#app3\u0026#39;, data:{ seen: true } }} 循环语句：使用v-for来进行数组的循环从而渲染项目列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div id=\u0026#34;app-4\u0026#34;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; var app4 = new Vue({ el: \u0026#39;#app-4\u0026#39;, data: { todos: [ { text: \u0026#39;学习 JavaScript\u0026#39; }, { text: \u0026#39;学习 Vue\u0026#39; }, { text: \u0026#39;整个牛项目\u0026#39; } ] } }) 交互模块（包含用户交互处理），使用v-on可以添加时间监听器，结合bottom使用\n1 2 3 4 5 6 \u0026lt;div id=\u0026#34;app-5\u0026#34;\u0026gt; \u0026lt;p\u0026gt; {{message}} \u0026lt;/p\u0026gt; \u0026lt;buttom v-on:click=\u0026#34;reverseMessage\u0026#34;\u0026gt;反转消息\u0026lt;/buttom\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 var app5 = new Vue({ el: \u0026#39;#app-5\u0026#39;, data: { message: \u0026#39;Hello Vue.js!\u0026#39; }, methods: { reverseMessage: function () { this.message = this.message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) } } }) 上述事例也包含了vue中，如何定义一个函数，我们通过声明一个vue实例，然后在实例中的method即可构造函数。\n交互模块2：\u0026lt;input\u0026gt;为输入框like的东西，使用v-model可以将表单输入和我们的应用状态双向绑定，例如，同步进行修改，基于输入框修改显示的文本内容等。\nDraft 在这里把杂七杂八的知识都放进来，后面在进一步的整理，基于Vue的版本来测试我们的模块编写，在TDesign里面实现具体的功能，并设计和留出端口。\n","permalink":"https://hugotest-phi.vercel.app/posts/vue-chapter1/","summary":"\u003cp\u003e基本Vue语法规则学习笔记，方便我们去自定义和看懂别人的网页代码。\u003c/p\u003e\n\u003cp\u003e概念补充：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"\"\u003eDOM\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e超文本标记语言HTML\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p\" target=\"_blank\" rel=\"noopener\"\u003e查表\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003eAttribute和\u003ccode\u003e\u0026lt;\u0026gt;\u003c/code\u003e协同使用，在其中定义括起来的“文本”的属性\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"template-syntax\"\u003eTemplate Syntax\u003c/h2\u003e\n\u003cp\u003evue的模版语法是基于HTML的，但是在底层机制中，会将模版编译成高度优化的JS代码，因此可以通过：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHTML style 默认\u003c/li\u003e\n\u003cli\u003eJSX, 编写渲染函数而不使用模版，但是这样不会享受 VUE 自带的优化。\u003c/li\u003e\n\u003c/ul\u003e","title":"Vue Chapter1 基础语法"},{"content":"配置一台全新的 MacOs（M1）用于日常使用和编程开发，这里总结一下自己体验比较好的 APP 和开发工具。Let‘s Go\n系统基础设置 调转 F 区功能：在涉及到开发的时候，F 区很多情况下就会派上用场，因此这里简单介绍一下：\n系统设置里搜索\u0026quot;功能键\u0026quot; 在弹出页面中选择将 F 1 作为标准功能键勾选即可 触控板功能：特别是三指拖动功能一定要开启，用来拖放窗口和文件方便太多。\n系统偏好设置 -\u0026gt; 触控板 -\u0026gt; 三指点按查询 系统偏好设置 -\u0026gt; 辅助功能 -\u0026gt; 指针控制-\u0026gt; 触控板选项 -\u0026gt; 三指拖动 访达设置：\n首先在偏好设置中有以下的几个可以调整：\n通用 -\u0026gt; 开启新访达窗口时打开 高级 -\u0026gt; 显示文件拓展名 边栏 -\u0026gt; 选择自己想要的边栏 接着是在显示选线卡中，可以勾选：“显示路径栏”、“‘显示状态栏’”\n用 Raycast 替换 Spotlight MacOS 中的 Spotlight 是一个很棒的设计，在某些程度上弥补了其资源管理器和应用设计上的缺陷，提高了很大的便利性（Windows 上可以基于 PowerToy 来补全该功能），但是许多第三方的 Spotlight 都比官方好用，这里我推荐免费的 raycast。\nraycast 由于其插件支持的特性，能够玩出很多花样，同时其基本的功能也相当的强大，完全可以作为原生的上位替代，因此建议直接关闭原生。\n系统设置中搜索 spotlight-\u0026gt;键盘-\u0026gt;键盘快捷键 聚焦-\u0026gt;关闭 然后在 raycast 中将快捷键设置为 Command +SPC 即可，其也支持剪切板历史记录功能，因此后续没有推荐相关的应用了。\n将 Edge 设置为默认浏览器 虽然原生的 safari 有着不错的颜值，但是从外观，性能，功能，以及多设备协同中，我个人还是比较推崇 Edge，认为其在大部分平台目前都是我的第一选择。\nEdge -\u0026gt; 首选项 -\u0026gt; 默认浏览器 -\u0026gt; 设置为默认浏览器\n选择自己喜欢的壁纸 这里可以选择动态的壁纸，也就是随着时间变化的类型，其实只是一种特殊的文件格式，使用其作为壁纸就能实现对应的效果，所以我们下载好对应的动态壁纸格式就行：\nDynamic 1 Dynamic 2 由于 Mac 本身过硬的屏幕质量，其他的最好4 k 及以上的壁纸，效果会更好，这里给出一些壁纸下载的链接：\nMicrosoft Wallpaper Pixels Unsplash 软件安装和配置 首先来个省流总结图如下，个人必装的一些软件，大多都是无需什么配置开箱即用的，有一些需要个性化设置的后续可能会专门开文介绍下自己的方案。\nAPP Type Desc Recommend Clash X Proxy 开发环境配置的时候有一个总没错 🔥🔥🔥 Edge Browser 用微软账号同步多设备、OS；全面 🔥🔥🔥 搜狗输入法 sys-Enhance Macos 自带的实在是太难用了 🔥🔥🔥 Snipaste Screenshot 截图，置顶， 🔥 Xnip Screenshot 滚动截图 🔥 raycast sys-Enhance 替代原生的 Spotlight，插件支持，功能强大 🔥🔥🔥 Rectangle sys-Enhance 窗口排列和贴靠 🔥🔥🔥 AltTab sys-Enhance 支持 windows 的窗口切换，优化纯键盘体验 🔥🔥 KaraBiner external support 外接键盘的控制和自定义和热键 🔥🔥 BetterDisplay external support 外接显示器的全面控制 🔥🔥 MOS external support 外接鼠标的 Smooth Scroll 支持 🔥🔥 Hidden bar beautify 隐藏状态栏中不常用的 Icon 🔥 Top Notch beautify 全黑隐藏刘海 🔥 CheatSheet Tips 长按 Command 提示各个应用的快捷键 🔥 上面介绍的这些应用大多都是基于日常使用来介绍的，都是免费的软件，因此只要在 appstore 和官方网站进行下载即可，放心使用；\n开发和办公需求的一些软件可能会涉及到部分配置，因此会单独介绍（其中像 office、微信 这些基本都会装的常见软件就不再额外介绍。）\n其他开发软件安装 APP Type Desc Recommend VsCode Editor(Code) ∞ 💯 Xcode Editor(Code) ∞ 💯 Obsidian Editor(Markdown) W(Md), R(PDF), Manager 💯 Typora Editor(Markdown) Single Markdown File 😀 iterm 2 Terminal Simulator Best One in Mac 💯 HomeBrew CLI ∞ 💯 Beyond Compare Compare Not Free 😀 Office Office ∞ 💯 OneDrive Sync ∞ 💯 开发环境搭建 APPs Type Desc IMG KeyCastr Video Show Keyboard Input Cursor Pro Video Enhance and Hightlight Cursor Sidenote Note (Pay)like stickynote by in one side 键位映射 inspired by @devaslife : karabiner-elements \u0026ndash;cask;\n安装完成后，我们需要在系统里面启用一大堆安全和隐私权限后，就可以开始键盘映射，可以在其中的网站找到一些映射方案，并导入自己的机器中。\n找个时间来统一整理键盘映射 代理设置 修改为取消代理和设置代理的 Bash 脚本，便于切换。 首先介绍代理的安装，配置好了代理方便访问 github、homebrew 等，方便我们对环境进行配置和软件下载。\n系统代理我们使用ClashX Pro（Clash的Mac版本）进行配置，starlink推广警告。\nTerminal的代理配置，vim ~/.zshrc or vim ~/.bashrc，添加下面这段，端口7890为默认，可到clash客户端中查看\n1 2 3 export https_proxy=http://127.0.0.1:7890 export http_proxy=http://127.0.0.1:7890 # export all_proxy=sock5://127.0.0.1:7890 添加完成后，使用source ~/.zshrc 激活修改即可；\n有时候由于切换设置或者取消使用Clash，需要取消代理\n1 2 unset http_proxy unset https_proxy 可以简单的写一个代理设置的脚本来进行快速设置.\n1 2 3 4 5 6 7 8 9 10 11 12 function SetProxy(){ export http_proxy=http://127.0.0.1:7890 export https_proxy=https://127.0.0.1:7890 } function unsetProxy(){ unset http_proxy unset https_proxy } alias proxyon=SetProxy alias proxyoff=unsetProxy ","permalink":"https://hugotest-phi.vercel.app/posts/macos/","summary":"\u003cp\u003e配置一台全新的 MacOs（M1）用于日常使用和编程开发，这里总结一下自己体验比较好的 APP 和开发工具。Let‘s Go\u003c/p\u003e\n\u003ch2 id=\"系统基础设置\"\u003e系统基础设置\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e调转 F 区功能\u003c/strong\u003e：在涉及到开发的时候，F 区很多情况下就会派上用场，因此这里简单介绍一下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e系统设置里搜索\u0026quot;功能键\u0026quot;\u003c/li\u003e\n\u003cli\u003e在弹出页面中选择将 F 1 作为标准功能键勾选即可\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e触控板功能\u003c/strong\u003e：特别是三指拖动功能一定要开启，用来拖放窗口和文件方便太多。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e系统偏好设置 -\u0026gt; 触控板 -\u0026gt; 三指点按查询\u003c/li\u003e\n\u003cli\u003e系统偏好设置 -\u0026gt; 辅助功能 -\u0026gt; 指针控制-\u0026gt; 触控板选项 -\u0026gt; 三指拖动\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e访达设置：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e首先在偏好设置中有以下的几个可以调整：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通用 -\u0026gt; 开启新访达窗口时打开\u003c/li\u003e\n\u003cli\u003e高级 -\u0026gt; 显示文件拓展名\u003c/li\u003e\n\u003cli\u003e边栏 -\u0026gt; 选择自己想要的边栏\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e接着是在显示选线卡中，可以勾选：“显示路径栏”、“‘显示状态栏’”\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230402164844.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230402164844.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20230402164844.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Macos Configuration00 软件安装和基础配置"},{"content":"@Aiken 2022\nIf u want get detail params info go to: http://www.explainshell.com .\ntar 压缩命令 linux中主要使用tar来进行文件的打包和解压，如果需要处理zip文件需要额外的支持，在上一章节中已经提到了，该章节压缩文件部分主要介绍tar命令\n压缩文件（夹）\n1 2 tar -zcvf {final_name}.tgz {dir} --exclude={dir/sub_dire1} tar -cvf ... 解压文件（夹）\n1 2 tar -zxvf {tarfile}.tgz -C {指定目录} tar -xvf ... 批量解压tar 编写脚本批量解压tar文件到对应的文件夹中，这里主要的核心在于脚本的编写，而非tar的package\n1 2 3 4 5 6 # version 1 ez2understrand for i in `ls *.tar.gz` do mkdir /dir/${i/.tar.gz//} tar zxvf $i -C /dir/${i/.tar.gz//} done 也可以使用第二种方法：\n1 2 3 4 5 6 7 8 # version 2 try to use assignment method # 可以发现基本的操作是一样的，就是对应的定义的地方 # 可以考虑一下是如何使用echo和cut以及对应的-d 和 -f1是什么意思 for file in `ls *.tar` do todir=`echo $file | cut -d\u0026#34;.\u0026#34; -f1` mkdir $todir \u0026amp;\u0026amp; tar -xvf $file -C $todir done 参考资料：tar压缩解压缩命令详解 文件操作 cd 路径切换 cd means change directory 切换工作区路径，毋庸置疑是最常使用的指令，基础用法cd {path}\n返回上次目录\n1 2 cd - # - equal to $OLDPWD 推荐使用 zjump 能通过z指令快速定位目录，其通过frecency来管理地址优先级，能通过地址的简写，或者最终文件夹的名字快速跳转和定位。\ntouch 新建 1 2 touch {filename} mkdir {foldername} rm 删除 删除文件夹的时候需要-r指定递归删除，最好结合-v看看自己到底删了什么\n1 2 rm -{option} {filename} rm -{option}r {foldername} \u0026ldquo;rm -f\u0026rdquo; 强行删除，忽略不存在的文件，不提示确认。(force) \u0026ldquo;rm -i\u0026rdquo; 进行交互式删除，即删除时会提示确认。(interactive) \u0026ldquo;rm -r\u0026rdquo; 将参数中列出的全部目录和子目录进行递归删除。(recursive) \u0026ldquo;rm -v\u0026rdquo; 详细显示删除操作进行的步骤。(verbose)\n删除文件夹中的文件，但是不删除文件夹\n1 rm -rf {folder}/* mv 移动 mv 主要承担了以下两个职责：重命名、移动\n1 2 mv {fileA} {nameB} mv files dir/ 实际上name就代表了在系统中的position，所以当nameB可为地址，可以在移动的同时重命名。\n建议使用-i参数强制执行提示功能， 避免意外覆盖文件。\ncp 拷贝 1 2 # using cp to copy file cp dir1/filea dir2/filea.bak -i 使用cp -i 强制询问是否覆盖，避免不必要的版本损失 -R 递归复制目录 ln 软连接 Linux 软连接，类似windows系统中做快捷方式\n1 2 # 在target地址建立一个名为linkname的软连接，链接到source_dir ln -s source_dir/ target_dir/linkname 删除快捷方式只需要rm即可，切记！！不要-f -v -r。\n1 2 rm linkname # 删除软连接(注意后面千万不能有/) mv linknamea linknameb # 同理换名也是一样的 切换软连接连接的对象\n1 ln -snf {new source} {linkname} Search 搜索命令 FileType 文件类型查看 1 file my_file 可以查看符号连接的源目录\nList Files 列出文件 ls: list directory contents.\n1 ls -l -r -t -h -s -l: use a long listing format -s: print the allocated size of each file, in blocks -t: sort by time(modify, newest first) -h: human-readable -r: reverse order -a: show all files include those hide If we want to find file by \u0026ldquo;pattern\u0026rdquo;, we donot need grep we can do like this:\n1 2 ls *.md ls *todo* 列出文件，也可以使用tree dir/列出文件夹的层级结构。\n查看某个文件夹下文件或者文件夹的个数：参考资料 1 2 3 4 5 6 7 ls [dirname] -l| grep \u0026#34;^-\u0026#34; | wc -l # 1.查看某文件夹下文件的个数 ls [dirname] -lR| grep \u0026#34;^-\u0026#34;| wc -l # 2.包括子文件夹下的文件 ls [dirname] -l| grep \u0026#34;^d\u0026#34; | wc -l # 3.只查看文件夹 ls [dirname] -lR| grep \u0026#34;^d\u0026#34;| wc -l # 4. 包括子文件夹中的文件夹 # 通过管道查看 ll | wc -l Find Files 文件查找 find: search for files in a directory hierarchy\n1 2 find [path...] -name \u0026lt;pattern\u0026gt; # find file in this path by pattern Grep Content 格式匹配 Linux grep 命令用于查找文件里符合条件的字符串。\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。\n通过grep在命令行中筛选输出显示，只显示grep指定的部分。\n1 2 # 只显示其中包括str的部分 command | grep \u0026#39;str\u0026#39; 直接使用Grep搜索文档中的字符数据，\n1 2 grep [option] pattern [file] # 该命令会在输入或指定的文件中搜索包含匹配指定模式的支付的行。 Option:\n-v 反向搜索，搜索不匹配该模式的行 -n 显示所在的行的行号 -c 显示有多少匹配到了 -e 来指定多个匹配模式 grep -e p1 -e p2file1 -r 递归搜索 -i 忽略大小写 -I 忽略二进制文件 -w, word-regexp\n\u0026ldquo;或\u0026rdquo; 搜索：\n1 grep -E \u0026#34;optionA | optionB\u0026#34; * History Command 历史命令查询 HISTORY主要针对如何找到历史指令，如何重复执行某一行指令；\n1 2 3 4 5 6 7 # show the history command idx history 1262 btm # resume this command idx, it\u0026#39;ll get command by the idx !1262 btm CTRL+r : Reverse Cmd Searching\n命令行反向搜索模式，方便输入重复的指令和地址，其会根据当前的键入内容去匹配历史指令。\nCheck 系统状态查看 系统时间显示 date \u0026quot;+format\u0026quot; 通过在＋号的后面指定 format 来约束输出时间的样式，具体格式可以参考网站 网络状态 ifconfig 命令需要先安装 net-tools，直接使用 sudo apt-get install net-tools 安装\n1 ifconfig netstat 命令用于显示网络连接、路由表、接口状态等网络信息。\n1 netstat -i 显示网卡列表信息 -r 显示路由表信息 -l 列出正在监听的服务 -a 所有连接中的socket\n系统磁盘占用 查看文件夹和磁盘的空间占用：explain_shell du df 命令可以显示目前所有文件系统的可用空间和使用情形\n1 2 # 参数 -h 表示使用「Human-readable」的输出，也就是在档案系统大小使用 GB、MB 等易读的格式。 df -h du 查询文件或者当前文件夹的磁盘使用\n1 2 3 4 5 # 查询当前文件夹下面各个文件夹的大小： # 将深度改成n应该可以改变递归到子文件夹下的深度 du -h --max-depth=1 * # *代表的是当前文件目录 du -h --max-depth=1 [path] 查看当前目录下文件和文件夹的大小（定位哪里占用空间最大）：\n1 2 3 4 # 查看当前文件夹下所有文件夹的占用空间 du -sh * # 对应的查看指定文件夹大小的方式为： du -sh dir 系统内存占用 free 命令用于显示当前系统中的内存使用信息，使用 free -h 即可查看。\nWatch 监控 将watch加在前面可以监控一些信息的实时变化\n1 2 watch ps -aux watch nvidia-smi Cat File（more、less、nl） cat是显示文本文件中所有数据的得力工具，但是文件的文本会在显示器上一晃而过，难以控制后面的操作。\n1 cat file1 -n 给所有的行加上行号 -b 给非空行加上行号 -T 不显示制表符 more会显示文本文件的内容，但是会在每页数据之后停下来，使用spc/enter翻页，q退出\nless来自 less is more，是 more 的升级版，可以实现文件的前后移动和高级搜索功能。\nnl 命令式再 linux 中用来计算文件的行号，其会计算出每一个非空行（可以控制是否忽视）的行号，加在改行的前面输出改行，参考：每天一个linux命令(11)：nl命令 Head Doc（Tail） 1 2 3 4 tail -n 2 log_file tail -2 log_file # -n \u0026lt;N\u0026gt; 显示文件的后面N行 head -5 log_file 只显示命令行输出的前几条或者后面几条\n1 2 history | head -i histo | tail -i 实时查看正在写入的文件 -f\n1 tail -f file_inprocess.log ps 进程操作 ps 的英文全称为：process，主要用来查看系统中的进程状态，参数的主要参考资料：explain ps 1 2 ps -aux | grep {content} kill {PID} -a 显示所有进程（-e同上） -N 显示与指定参数不符的所有进程 -u 显示用户即 其他详细信息 -x 显示没有控制终端的进程 其他进程操作命令 pstree 命令则可以结合 ps 命令，可用树状图的形式显示进程之间的关系。 top 命令用于动态地监视进程的活动以及系统的负载 pidof 命令可以查看指定服务进程的 PID 号码 killall 复杂的服务进程可能会有多个 pid 进程号，killall 可以批量的终结指令 Sleep 暂停 sleep t引入一段时间的暂停\n","permalink":"https://hugotest-phi.vercel.app/posts/linux2/","summary":"\u003cp\u003e@Aiken 2022\u003c/p\u003e\n\u003cp\u003eIf u want get detail params info go to: \u003ca href=\"http://www.explainshell.com\" target=\"_blank\" rel=\"noopener\"\u003ehttp://www.explainshell.com\u003c/a\u003e\n.\u003c/p\u003e\n\u003ch2 id=\"tar-压缩命令\"\u003etar 压缩命令\u003c/h2\u003e\n\u003cp\u003elinux中主要使用tar来进行文件的打包和解压，如果需要处理zip文件需要额外的支持，在上一章节中已经提到了，该章节压缩文件部分主要介绍tar命令\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e压缩文件（夹）\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -zcvf \u003cspan class=\"o\"\u003e{\u003c/span\u003efinal_name\u003cspan class=\"o\"\u003e}\u003c/span\u003e.tgz \u003cspan class=\"o\"\u003e{\u003c/span\u003edir\u003cspan class=\"o\"\u003e}\u003c/span\u003e --exclude\u003cspan class=\"o\"\u003e={\u003c/span\u003edir/sub_dire1\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -cvf ...\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e解压文件（夹）\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -zxvf \u003cspan class=\"o\"\u003e{\u003c/span\u003etarfile\u003cspan class=\"o\"\u003e}\u003c/span\u003e.tgz -C \u003cspan class=\"o\"\u003e{\u003c/span\u003e指定目录\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -xvf ...\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"批量解压tar\"\u003e批量解压tar\u003c/h3\u003e\n\u003cp\u003e编写脚本批量解压tar文件到对应的文件夹中，这里主要的核心在于脚本的编写，而非tar的package\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# version 1 ez2understrand\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e i in \u003cspan class=\"sb\"\u003e`\u003c/span\u003els *.tar.gz\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    mkdir /dir/\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e/.tar.gz//\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    tar zxvf \u003cspan class=\"nv\"\u003e$i\u003c/span\u003e -C /dir/\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e/.tar.gz//\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e也可以使用第二种方法：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# version 2 try to use assignment method\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 可以发现基本的操作是一样的，就是对应的定义的地方\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 可以考虑一下是如何使用echo和cut以及对应的-d 和 -f1是什么意思\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e file in \u003cspan class=\"sb\"\u003e`\u003c/span\u003els *.tar\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nv\"\u003etodir\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"nv\"\u003e$file\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e cut -d\u003cspan class=\"s2\"\u003e\u0026#34;.\u0026#34;\u003c/span\u003e -f1\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    mkdir \u003cspan class=\"nv\"\u003e$todir\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e tar -xvf \u003cspan class=\"nv\"\u003e$file\u003c/span\u003e -C \u003cspan class=\"nv\"\u003e$todir\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e参考资料：\u003ca href=\"https://www.cnblogs.com/hhandbibi/p/7283862.html\" target=\"_blank\" rel=\"noopener\"\u003etar压缩解压缩命令详解\u003c/a\u003e\n\u003c/p\u003e","title":"Linux02 基础指令"},{"content":"学习 vimscript 理解原生 vim 的配置方法，Reference：\n\u0026ldquo;Five Minus Vimscript\u0026rdquo; Vimscript 五分钟入门 Variables let 命令用来给变量赋值 unset 用来删除一个变量；unset!删除变量，忽略变量不存在的提示 函数体外初始化的定义是全局变量，函数体内的是局部变量，但是我们可以用let来指定变量的作用域\ng:var - 全局\ra:var - 函数参数\rl:var - 函数局部变量\rb:var - buffer 局部变量\rw:var - window 局部变量\rt:var - tab 局部变量\rs:var - 当前脚本内可见的局部变量\rv:var - Vim 预定义的内部变量 可以用$name的模式来读取或者改写环境变量，同时用\u0026amp;option的方式读取vim内部设置的值。\n数据类型 number-}int, Float, String Funcref 函数引用，函数引用类型的变量名必须以大写字母开头\n1 2 :let Fun1 = function(\u0026#34;strlen\u0026#34;) :echo Myfunc(\u0026#39;foobar\u0026#39;) List有序列表\n1 2 3 4 5 :let mylist = [1, 2, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]] :echo mylist[0] 1 :echo mylist[2][0] a Dictionary 无序的kv容器\n1 2 3 4 :let mydict = { \u0026#34;blue\u0026#34;: \u0026#34;#0000ff\u0026#34;} :echo mydict[\u0026#34;blue\u0026#34;] :let mydcit.blue = \u0026#34;BLUE\u0026#34; 没有bool类型，除了0都是true；vim8.1 有boolean类型了。\n可以用type(varname)来取得变量的类型\n字符串比较 {string} == {string} 字符串相等 != {string} =~ {pattern} 匹配pattern {operator}# 匹配大小写 {operator}? 不匹配大小写 1 2 3 4 5 6 :function! TrueFalse(arg) : return a:arg? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34; :endfunction :echo TrueFalse(\u0026#34;X start\u0026#34; =~ \u0026#39;X$\u0026#39;) false 流程控制 条件判断：\n1 2 3 4 5 6 7 if {expression} ... elseif {expression} ... else ... endif 循环：\n1 2 3 4 for {var} in {list} continue break endfor for循环：\n1 2 3 for [var1, var2] in [[1,2], [3,4]] \u0026#34;on 1st loop var1 =1 ...\u0026#34; endfor while循环：\n1 2 while {expression} endwhile 异常捕获\n1 2 3 4 5 6 7 try ... catch {pattern (optinal)} finally ... endtry 函数 使用fucntion关键字定义一个函数，使用function!覆盖一个函数的定义，函数也有作用空间的约束，且函数名必须使用大写字母开头\n1 2 3 function! {Name}(args1, arg2, etc) {function body} endfunction delfunction {function} 删除函数\ncall {function}调用一个函数，函数调用前的call语句是必须的，除非在一个表达式里。\n有一种特殊的调用函数的方式，可以指明该函数作用的文本区域是从当前缓冲区的第几行到第几行，按照 “1,3call Foobar() ”的格式调用一个函数的话，该函数会在当前文件的第一行到第三行每一行执行一遍，再这个例子中，该函数总共被执行了三次。\n如果你在函数声明的参数列表后添加一个 range 关键字，那函数就只会被调用一次，这时两个名为 a:firstline 和 a:lastline 的特殊变量可以用在该函数内部使用。\n面向对象 Vim 没有原生的类的支持，但是你可以用字典模拟基本的类。为了定义一个类的方法，可以在函数声明时使用 dict 关键字来将内部字典暴露为 self 关键字：\n1 2 3 4 let MyClass = {\u0026#34;foo\u0026#34;: \u0026#34;Foo\u0026#34;} function MyClass.printFoo() dict echo self.foo endfunction 类的实现更类似于 singleton，为了在 VimScript 中创建类的实例，我们对字典使用 **deepcopy()**方法进行拷贝（实例化）：\n1 2 3 4 5 6 :let myinstance = deepcopy(MyClass) :call myinstance.printFoo() Foo :let myinstance.foo = \u0026#34;Bar\u0026#34; :call myinstance.printFoo() Bar Autocmd 自动命令 当事件发生时自动执行命令，一个比较常见的应用场景如：对不同的文件类型使用不同的缩进、折叠、制表方式。\n","permalink":"https://hugotest-phi.vercel.app/posts/vimscript_5minus/","summary":"\u003cp\u003e学习 vimscript 理解原生 vim 的配置方法，Reference：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://andrewscala.com/vimscript/\" target=\"_blank\" rel=\"noopener\"\u003e\u0026ldquo;Five Minus Vimscript\u0026rdquo;\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/37352209\" target=\"_blank\" rel=\"noopener\"\u003eVimscript 五分钟入门\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"转）vimscript in 5 minus"},{"content":"该文章将介绍 Python 中的单元测试之 Unittest 模块，及其在 VsCode 中的集成和使用，主要参考的链接有以下的三个：\nUnittest的基本用法 、Python官方文档 VsCode运行Unittest ，其对应 VsCode 侧边栏中的“测试”模块，该部分就由本文来自行补充 使用Unittest模拟input的输入 ，便于测试基于命令行输入的代码 基本用法 在工作区中定义示例函数如下，基于该函数进行Unittest的测试和演示：\n1 2 3 # we save this function in function_module.py def add_4_ut(a,b): return a+b 基本使用的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import unittest from function_module import add_4_ut # 使用TestCase基类构建测试样例和测试方法，运行的时候会对编写的所有测试方法进行测试 class TestAddFunction(unittest.TestCase): def test_ez(self): self.assertEqual(add_4_ut(3,5),8) def test_complex(self): self.assert(add_4_ut(1023,2032),3055) ... # using the main function buildin the unittest, to run all the method we define in the TestCale. if __name__ == \u0026#39;__main__\u0026#39;: unittest.main() 模拟命令行输入 使用unittest.mock的patch模块进行输入输出模块的模拟和测试，具体的使用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import unittest from unittest.mock import patch from function_count import entry_point # 使用TestCase基类构建测试样例和测试方法，运行的时候会对编写的所有测试方法进行测试 class TestAddFunction(unittest.TestCase): # 使用patch模块来替换默认模块中的input方法 @patch(\u0026#39;builtins.input\u0026#39;) def test_ez(self, mock_input): # 利用return_value来模拟输入模块的输入 mock_input.return_value = \u0026#34;1,2,3,4\u0026#34; self.assertEqual(entry_point(), 24) VsCode运行Unittest VsCode配置了python的测试框架，更好的支持测试进程的进行，通过以下的方式进行相应的设置：\n首先使用ctrl+shift+p调出命令行界面，输入python configure test，选择unittest，并选择放置test_xxx.py地址，以及测试文件的命名规则例如test_\u0026lt;name\u0026gt;.py的即可\n在对应路径下编写对应的测试文件，可以在测试文件中出现，快捷测试的按钮，以及测试后的结果：\n左侧的测试菜单也会显示当前路径下的所有测试方法，可以按照自己想要的方式进行测试。\n","permalink":"https://hugotest-phi.vercel.app/posts/unittest/","summary":"\u003cp\u003e该文章将介绍 Python 中的单元测试之 Unittest 模块，及其在 VsCode 中的集成和使用，主要参考的链接有以下的三个：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/sinat_38682860/article/details/102838668\" target=\"_blank\" rel=\"noopener\"\u003eUnittest的基本用法\u003c/a\u003e\n、\u003ca href=\"https://docs.python.org/zh-cn/3/library/unittest.html\" target=\"_blank\" rel=\"noopener\"\u003ePython官方文档\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/CloserSide/article/details/109175775\" target=\"_blank\" rel=\"noopener\"\u003eVsCode运行Unittest\u003c/a\u003e\n，其对应 VsCode 侧边栏中的“测试”模块，该部分就由本文来自行补充\u003c/li\u003e\n\u003cli\u003e使用Unittest\u003ca href=\"https://blog.csdn.net/weixin_44520259/article/details/107840219\" target=\"_blank\" rel=\"noopener\"\u003e模拟input的输入\u003c/a\u003e\n，便于测试基于命令行输入的代码\u003c/li\u003e\n\u003c/ol\u003e","title":"Python Unittest 单元测试的编写与执行"},{"content":"廖雪峰的SQL教程的学习笔记\nmySQL how to connect mysql? Using CMD(or MySQL Client) to carry out\n1 2 3 4 # local, default port is 3306 mysql -u root -p # remote mysql -h \u0026lt;ip\u0026gt; -u root -p root here is the \u0026lt;username\u0026gt;, we may using other name in specific situation.\nmysql实际上时MySQL的客户端，真正的MySQL服务器程序时mysqld在后台运行。\n如果希望借助可视化图形界面进行操作，可以使用MySQL Workbench 进行可视化的增删改查（底层还是基于sql的命令行指令进行）。\n数据库 运行MySQL的服务器可以同时创建多个数据库\n可以使用SHOW DATABASES;列出所有的数据库，其中information_schema、mysql、performance_schema和sys是系统库，不要去改动它们。其他的是用户创建的数据库。 新建数据库：CREATE DATABASE \u0026lt;database_name\u0026gt;; 删除数据库：DROP DATABASE;其中的数据将被完全删除 进入数据库（切换活动的数据库）:USE \u0026lt;database_name\u0026gt;;当我们切换到指定数据库的时候，我们才能对其进行操作 表 1 2 3 4 5 6 7 8 9 10 -- 列出所有表 SHOW TABLES； -- 查看表的结构 DESC \u0026lt;tables_name\u0026gt;; -- 查看创建表的语句 SHOW CREATE TABLE \u0026lt;tables_name\u0026gt;; -- 创建表 CREATE TABLE \u0026lt;tables_name\u0026gt;; -- 删除表 DROP TABLE \u0026lt;tables_name\u0026gt;; 如果要修改表的话，相对更为复杂一些，如果要为表增加一列birth,使用\n1 ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL; 名称后面指定类型和是否允许为NULL。\n修改特定列的名称和属性的话：\n1 ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL; 删除列使用：\n1 ALTER TABLE students DROP COLUMN birthday; 实用SQL语句 插入或替换 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句，这样就不必先查询，再决定是否先删除再插入：\n1 REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, \u0026#39;小明\u0026#39;, \u0026#39;F\u0026#39;, 99); 若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。\n插入或更新 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句：\n1 INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, \u0026#39;小明\u0026#39;, \u0026#39;F\u0026#39;, 99) ON DUPLICATE KEY UPDATE name=\u0026#39;小明\u0026#39;, gender=\u0026#39;F\u0026#39;, score=99; 若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。\n插入或忽略 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO ...语句：\n1 INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, \u0026#39;小明\u0026#39;, \u0026#39;F\u0026#39;, 99); 若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。\n快照 如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT：\n1 2 -- 对class_id=1的记录进行快照，并存储为新表students_of_class1: CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1; 新创建的表结构和SELECT使用的表结构完全一致。\n写入查询结果集 如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。\n例如，创建一个统计成绩的表statistics，记录各班的平均成绩：\n1 2 3 4 5 6 CREATE TABLE statistics ( id BIGINT NOT NULL AUTO_INCREMENT, class_id BIGINT NOT NULL, average DOUBLE NOT NULL, PRIMARY KEY (id) ); 然后，我们就可以用一条语句写入各班的平均成绩：\n1 INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id; 确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果：\n1 2 3 4 5 6 7 8 9 \u0026gt; SELECT * FROM statistics; +----+----------+--------------+ | id | class_id | average | +----+----------+--------------+ | 1 | 1 | 86.5 | | 2 | 2 | 73.666666666 | | 3 | 3 | 88.333333333 | +----+----------+--------------+ 3 rows in set (0.00 sec) 强制使用指定索引 在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。例如：\n1 \u0026gt; SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC; 指定索引的前提是索引idx_class_id必须存在。\n事务 在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：\n-- 从id=1的账户给id=2的账户转账100元\r-- 第一步：将id=1的A账户余额减去100\rUPDATE accounts SET balance = balance - 100 WHERE id = 1;\r-- 第二步：将id=2的B账户余额加上100\rUPDATE accounts SET balance = balance + 100 WHERE id = 2; 这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。\n这种把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。\n可见，数据库事务需要具有ACID四个特性\nA：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行； C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100； I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离； D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。 对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。\n要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务，例如，把上述的转账操作作为一个显式事务：\n1 2 3 4 BEGIN; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT; COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。\n有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：\n1 2 3 4 BEGIN; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; ROLLBACK; 对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。\nSQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：\nIsolation Level 脏读（Dirty Read） 不可重复读（Non Repeatable Read） 幻读（Phantom Read） Read Uncommitted Yes Yes Yes Read Committed - Yes Yes Repeatable Read - - Yes Serializable - - - 我们会依次介绍4种隔离级别的数据一致性问题。\n在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。 在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。 在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题，幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。 Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。\n虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。\n默认隔离级别 如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。\n","permalink":"https://hugotest-phi.vercel.app/posts/sql5/","summary":"\u003cp\u003e廖雪峰的SQL教程的学习笔记\u003c/p\u003e\n\u003ch2 id=\"mysql\"\u003emySQL\u003c/h2\u003e\n\u003cp\u003ehow to connect mysql? Using CMD(or MySQL Client) to carry out\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# local, default port is 3306\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emysql -u root -p\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# remote\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emysql -h \u0026lt;ip\u0026gt; -u root -p\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eroot here is the \u003ccode\u003e\u0026lt;username\u0026gt;\u003c/code\u003e, we may using other name in specific situation.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emysql\u003c/code\u003e实际上时MySQL的客户端，真正的MySQL服务器程序时\u003ccode\u003emysqld\u003c/code\u003e在后台运行。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003chr\u003e\n\u003cp\u003e如果希望借助可视化图形界面进行操作，可以使用\u003ca href=\"https://dev.mysql.com/downloads/workbench/\" target=\"_blank\" rel=\"noopener\"\u003eMySQL Workbench\u003c/a\u003e\n进行可视化的增删改查（底层还是基于sql的命令行指令进行）。\u003c/p\u003e\n\u003ch3 id=\"数据库\"\u003e数据库\u003c/h3\u003e\n\u003cp\u003e运行MySQL的服务器可以同时创建多个数据库\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可以使用\u003ccode\u003eSHOW DATABASES;\u003c/code\u003e列出所有的数据库，其中\u003ccode\u003einformation_schema\u003c/code\u003e、\u003ccode\u003emysql\u003c/code\u003e、\u003ccode\u003eperformance_schema\u003c/code\u003e和\u003ccode\u003esys\u003c/code\u003e是系统库，不要去改动它们。其他的是用户创建的数据库。\u003c/li\u003e\n\u003cli\u003e新建数据库：\u003ccode\u003eCREATE DATABASE \u0026lt;database_name\u0026gt;;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e删除数据库：\u003ccode\u003eDROP DATABASE;\u003c/code\u003e其中的数据将被完全删除\u003c/li\u003e\n\u003cli\u003e进入数据库（切换活动的数据库）:\u003ccode\u003eUSE \u0026lt;database_name\u0026gt;;\u003c/code\u003e当我们切换到指定数据库的时候，我们才能对其进行操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"表\"\u003e表\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- 列出所有表\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eSHOW\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eTABLES\u003c/span\u003e\u003cspan class=\"err\"\u003e；\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e-- 查看表的结构\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eDESC\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003etables_name\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e-- 查看创建表的语句\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eSHOW\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eCREATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eTABLE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003etables_name\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e-- 创建表\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eCREATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eTABLE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003etables_name\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e-- 删除表\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eDROP\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eTABLE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003etables_name\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果要修改表的话，相对更为复杂一些，如果要为表增加一列\u003ccode\u003ebirth\u003c/code\u003e,使用\u003c/p\u003e","title":"SQL Chapter5 mysql与事务"},{"content":"基本操作无非就是增删改查，查询在上一章Select已经学习完毕，而剩下的增、删、改对应的关键词分别是：\nINSERT：插入新纪录 UPDATE：更新现有记录 DELETE：删除已有记录 接下来具体讨论各种用法：\n插入 使用关键字INSERT进行数据和记录的插入，其基本语法如下：\n1 INSERT INTO \u0026lt;表名\u0026gt;(字段1,字段2,...) VALUES(值1，值2,...) 例如向students表中插入一条新数据，先列出需要添加数据的字段，然后按照字段的次序添加值\n1 2 -- 添加记录 INSERT INTO students (class_id, name, gender, score) value(2,\u0026#39;大牛\u0026#39;,\u0026#39;M\u0026#39;,80); 自增字段（id）或者其他有默认值的字段可以省略。其中需要注意的是：\n字段顺序不必和数据库表的字段顺序一致 但是值的顺序必须和字段顺序一致 同时插入多条记录的写法如下：\n1 2 3 INSERT INTO students (class_id, name, gender, score) VALUES (1, \u0026#39;大宝\u0026#39;, \u0026#39;M\u0026#39;, 87), (2, \u0026#39;二宝\u0026#39;, \u0026#39;M\u0026#39;, 81); 更新 使用关键字update更新数据表中的记录，其基本语法如下：\n1 UPDATE \u0026lt;表名\u0026gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; 前面填写修改后的值，通过WHERE选出我们需要修改的记录\n1 UPDATE students SET name=\u0026#39;大牛\u0026#39;, score=66 WHERE id=2 由于基于条件记录的特性，我们可以一次修改条件筛选出来的多个记录，同时可以在更新过程中使用表达式，\n1 UPDATE students SET score=score+10 WHERE score\u0026lt;80; 上式会将所有80分以下的同学的分数＋10分\n当没有使用WHERE的时候将会对表的整体进行更新，需要谨慎使用。\n在使用真实的MySQL这类关系数据库时，update会返回更新的行数以及WHERE条件匹配的行数。\n删除 删除显然使用的时DELETE语句，其基本语法如下：\n1 DELETE FROM \u0026lt;表名\u0026gt; WHERE ...; 例如：删除students表中id=1的记录\n1 DELETE FROM students WHERE id=1; 和更新类似，基于条件也可能一次删除多个记录，如果没有匹配就没有删除，不带条件的删除将会删除整个表格。\n在使用真实的MySQL这类关系数据库时，delete会返回删除的行数以及WHERE条件匹配的行数。\n","permalink":"https://hugotest-phi.vercel.app/posts/sql4/","summary":"\u003cp\u003e基本操作无非就是增删改查，查询在上一章Select已经学习完毕，而剩下的增、删、改对应的关键词分别是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eINSERT：插入新纪录\u003c/li\u003e\n\u003cli\u003eUPDATE：更新现有记录\u003c/li\u003e\n\u003cli\u003eDELETE：删除已有记录\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e接下来具体讨论各种用法：\u003c/p\u003e\n\u003ch2 id=\"插入\"\u003e插入\u003c/h2\u003e\n\u003cp\u003e使用关键字\u003ccode\u003eINSERT\u003c/code\u003e进行数据和记录的插入，其基本语法如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-SQL\" data-lang=\"SQL\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eINTO\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"err\"\u003e表名\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"err\"\u003e字段\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"err\"\u003e字段\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,...)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"err\"\u003e值\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"err\"\u003e，值\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,...)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e例如向\u003ccode\u003estudents\u003c/code\u003e表中插入一条新数据，先列出需要添加数据的字段，然后按照字段的次序添加值\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- 添加记录\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eINTO\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003estudents\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eclass_id\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003egender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003escore\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;大牛\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;M\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e80\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e自增字段（id）或者其他有默认值的字段可以省略。其中需要注意的是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e字段顺序不必和数据库表的字段顺序一致\u003c/li\u003e\n\u003cli\u003e但是值的顺序必须和字段顺序一致\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e同时\u003cstrong\u003e插入多条记录\u003c/strong\u003e的写法如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eINTO\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003estudents\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eclass_id\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003egender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003escore\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;大宝\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;M\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"mi\"\u003e87\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;二宝\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;M\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"mi\"\u003e81\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c!-- more --\u003e\r\n\u003ch2 id=\"更新\"\u003e更新\u003c/h2\u003e\n\u003cp\u003e使用关键字\u003ccode\u003eupdate\u003c/code\u003e更新数据表中的记录，其基本语法如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eUPDATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"err\"\u003e表名\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eSET\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e字段\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"err\"\u003e值\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e字段\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"err\"\u003e值\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e...\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eWHERE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e...;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e前面填写修改后的值，通过\u003ccode\u003eWHERE\u003c/code\u003e选出我们需要修改的记录\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eUPDATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003estudents\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eSET\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;大牛\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003escore\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e66\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eWHERE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e由于基于条件记录的特性，我们可以\u003cstrong\u003e一次\u003c/strong\u003e修改条件筛选出来的\u003cstrong\u003e多个记录\u003c/strong\u003e，同时可以在更新过程中使用表达式，\u003c/p\u003e","title":"SQL Chapter4  增删改相关操作"},{"content":"该章节介绍SQL中的查询命令，根据廖雪峰网站 进行一步步的测试和学习即可。\n其中–为sql语言中的注释符号。 关键词不区分大小写 基本查询 查询表中的所有数据主要使用关键词SELECT\n1 SELECT * FROM \u0026lt;表名\u0026gt; SELECT表明要执行查询 *代表“所有列” FROM表明要从哪个表查询 当指定特定列名的时候（也就是所谓的投影查询）格式如下：\n1 2 SELECT \u0026lt;KEY1\u0026gt;,\u0026lt;KEY2\u0026gt;, FROM \u0026lt;表名\u0026gt; -- 注释 此外，许多工具会使用SELECT 1;来测试数据库链接的有效性；SELECT 100+200也可以用来做简单的计算。\n条件查询 条件查询详细资料：sql ，通过官方网站可以找到更完整的条件语句和用法\n在SELECT命令中添加WHERE关键词进行条件查询\n1 2 3 SELECT * FROM \u0026lt;表名\u0026gt; WHERE \u0026lt;条件表达式\u0026gt; -- 一个典型的例子如下 SELECT * FROM students WHERE score\u0026gt;80 AND gender=\u0026#39;M\u0026#39; 在sql中主要的条件语句关键字为：AND，OR，NOT\n可以使用()来组合条件语句（3个或或者更多条件常用）\n1 SELECT * FROM students WHERE (score \u0026lt; 80 OR score \u0026gt; 90) AND gender = \u0026#39;M\u0026#39;; 如果不使用括号组合的话，就按照传统的条件语句的优先级来执行即NOT，AND，OR\n还有一些其他的规则如下\n条件 表达式举例1 表达式举例2 说明 = score=80 name=’abc‘ 字符串需要用单引号括起来 \u0026lt;\u0026gt;判断不相等 score\u0026lt;\u0026gt;80 name\u0026lt;\u0026gt;‘abc’ 使用LIKE判断相似 name LIKE ’ab%‘ name like ’%ab% %表示任意数量的任意字符 基于排序显示结果 使用SELECT查询时，结果通常按照id进行排序，也就是按照主键进行排序，这也是默认的做法，如果我们希望结果按照某些特定的条件来排序可以使用：ORDER BY语句。\n例如我们希望按照成绩从低到高显示结果：\n1 SELECT id, name, gender, score FROM students ORDER BY score; 从高到低的话则加入DESC关键词来使用倒序的输出，（默认的升序ASC可以省略）\n1 SELECT id, name, gender, score FROM students ORDER BY score DESC; 考虑到单项排序可能出现值相同的情况，可以加入第二关键词，当score相同的时候就用gender排序\n1 SELECT id, name, gender, score FROM students ORDER BY score DESC, gender; 如果在基于排序的情况下还要使用条件语句的话，需要将WHERE子句放在ORDER BY子句前面。\n1 2 3 4 SELECT id, name, gender, score FROM students WHERE class_id = 1 ORDER BY score DESC; 分页查询 使用SELECT查询时，如果结果数据量很大，一页显示的话数据量太大，我们最好分页显示，实现的代码如下：\n1 2 3 4 SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 100 OFFSET 0; LIMIT表示最多取几条，OFFSET表示从第几条开始，第二页就是`LIMIT 100, OFFSET 100.\nLIMIT总是设定为pageSize OFFSET计算公式为pageSize * (pageIndex-1) 如果OFFSET超过了最大的数量，会得到空的结果集，该命令可以简写为\n1 LIMIT 100,100 聚合查询 SQL提供了聚合函数来针对查询结果进一步的统计分析，使用聚合函数进行查询就是聚合查询，它可以快速的获得结果。\n比如计数，通过聚合函数就不需要一个个去数了\n1 SELECT COUNT(*) FROM students; COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)，因此我们应该给该参数设置一个名字（变量名）\n1 SELECT COUNT(*) num FROM students; 这样列名就是num了。\n此外聚合查询，支持WHERE等语句，还有其他的聚合函数如下（更多可以上官网等去查询）：\n函数 说明 SUM 合计值，必须为数值类型 AVG 平均值，必须为数值类型 MAX 计算某一列的最大值，字符类型会返回排序最后的 MIN 计算某一列的最大值，字符类型会返回排序最前的 要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL：\n分组聚合 如果我们要统计一班的学生数量，我们知道，可以用SELECT COUNT(*) num FROM students WHERE class_id = 1;。如果要继续统计二班、三班的学生数量，难道必须不断修改WHERE条件来执行SELECT语句吗？\n对于聚合查询，SQL还提供了“分组聚合”的功能。我们使用下列的聚合查询方法：\n1 SELECT COUNT(*) num FROM students GROUP BY class_id; 实现值和变量的相互对应，我们可以将二维表每行的名称加上：\n1 SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; 更进一步的，如果我们希望得到每个班的男女人数可以使用：\n1 SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender; 练习：\n查询查出每个班级的平均分：\n1 SELECT class_id, AVG(score) avgs FROM students GROUP BY class_id; 查出每个班级的男女生的平均分\n1 SELECT class_id, gender, AVG(score) avgs FROM students GROUP BY class_id, gender; 多表查询 由于不止存在一张表，当我们需要从多张表查询数据的时候，语法如下：\n1 SELECT * FROM students, classes; 查询结果会显示两张表的乘积，也就是暴力累加起来，具体而言：\n列数为两表的列数之和 行数为两表的行数之积 这种粗暴叠加，没有什么实际存在的意义，也容易产生列名歧义和数据爆炸。针对列名重复的问题，可以通过设置列名Alias来缓解：\n1 2 3 4 5 6 7 8 9 -- set alias: SELECT students.id sid, students.name, students.gender, students.score, classes.id cid, classes.name cname FROM students, classes; 为了简化该操作，避免大量的编写students和classes，sql存在如下的操作：\n1 2 3 4 5 6 7 8 9 -- set table alias as the same time SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cname FROM students s, classes c; 同样别名的设置不影响条件语句的使用。\n连接查询 内联 和多表查询相对应的，我们真正需要的是将主表中（部分）链接的次表数据链接到主表中，为此我们需要采用连接查询的内联语法将其中的数据取出来。具体的语法表示如下，主要包括：\n使用Alias避免重名（非必须） 定义所内联的表格inner join 选择内联的列on 1 2 3 4 select s.id, s.name, s.class_id, c.name class_name, s.gender, s.score from students s inner join classes c on s.class_id = c.id; 同样可以选择加入Where或者Order by字段。\n外联 1 2 3 4 SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s RIGHT OUTER JOIN classes c ON s.class_id = c.id; 有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：\nINNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。\nRIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。\nLEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL：\nFULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL：\n","permalink":"https://hugotest-phi.vercel.app/posts/sql3/","summary":"\u003cp\u003e该章节介绍SQL中的查询命令，根据\u003ca href=\"https://www.liaoxuefeng.com/wiki/1177760294764384/1179610888796448\" target=\"_blank\" rel=\"noopener\"\u003e廖雪峰网站\u003c/a\u003e\n进行一步步的测试和学习即可。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e其中\u003ccode\u003e–\u003c/code\u003e为sql语言中的注释符号。\u003c/li\u003e\n\u003cli\u003e关键词不区分大小写\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"基本查询\"\u003e基本查询\u003c/h2\u003e\n\u003cp\u003e查询表中的所有数据主要使用关键词\u003ccode\u003eSELECT\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"err\"\u003e表名\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSELECT\u003c/code\u003e表明要执行查询\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e代表“所有列”\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFROM\u003c/code\u003e表明要从哪个表查询\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当指定特定列名的时候（也就是所谓的\u003cstrong\u003e投影查询\u003c/strong\u003e）格式如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eKEY1\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eKEY2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"err\"\u003e表名\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e-- 注释\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e此外，许多工具会使用\u003ccode\u003eSELECT 1;\u003c/code\u003e来测试数据库链接的有效性；\u003ccode\u003eSELECT 100+200\u003c/code\u003e也可以用来做简单的计算。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"条件查询\"\u003e条件查询\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e条件查询详细资料\u003c/strong\u003e：\u003ca href=\"https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between\" target=\"_blank\" rel=\"noopener\"\u003esql\u003c/a\u003e\n，通过官方网站可以找到更完整的条件语句和用法\u003c/p\u003e\n\u003cp\u003e在\u003ccode\u003eSELECT\u003c/code\u003e命令中添加\u003ccode\u003eWHERE\u003c/code\u003e关键词进行条件查询\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"err\"\u003e表名\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eWHERE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"err\"\u003e条件表达式\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e-- 一个典型的例子如下\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003estudents\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eWHERE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003escore\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"mi\"\u003e80\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eAND\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003egender\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;M\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e在sql中主要的条件语句关键字为：\u003ccode\u003eAND\u003c/code\u003e，\u003ccode\u003eOR\u003c/code\u003e，\u003ccode\u003eNOT\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e可以使用\u003ccode\u003e()\u003c/code\u003e来组合条件语句（3个或或者更多条件常用）\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003estudents\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eWHERE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003escore\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"mi\"\u003e80\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eOR\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003escore\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"mi\"\u003e90\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eAND\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003egender\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;M\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果不使用括号组合的话，就按照传统的条件语句的优先级来执行即\u003ccode\u003eNOT\u003c/code\u003e，\u003ccode\u003eAND\u003c/code\u003e，\u003ccode\u003eOR\u003c/code\u003e\u003c/p\u003e","title":"SQL Chapter3 查询命令"},{"content":"本章节从MySQL的安装到基础使用，MySQL本身只是一个SQL接口，它内部还包含多种数据引擎，常用的包括：\nInnoDB：支持事务的数据库引擎（不知道选啥的时候选他就好） MyISAM：早期默认，不支持事务 接口和引擎的关系好比浏览器和浏览器引擎，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口，由于其开源，也衍生出了各种开源版本（包括针对各种云存储中托管数据库的版本等）\n安装MySQL Windows直接官网下载对应的版本就好了，Community Version 在该超链接进行下载，其他版本就按需下载，按需付费就行。\nLinux下载MySQL：\n1 sudo apt-get install mysql-server 验证是否下载安装完成：\n1 2 3 4 # 链接服务器 mysql # 登录服务器（需要输入口令） mysql -u root -p 成功链接后会变成mysql\u0026gt;，输入exit可以推出MySQL命令行，但是其将仍然在后台运行。\n关系模型 关系数据建立在关系模型之上，关系模型本质上就是若干个存储数据的二维表（Excel表），其中\n每一行称为记录（Record）：记录是一个逻辑意义上的数据 每一列成为字段（Column）：同一个表的每一行记录都拥有相同的若干字段，字段需要规定其数据类型，以及是否允许为Null（缺省值） 避免允许Null，不允许可简化查询条件，加快查询速度，也避免程序调用时需要处理Null\n关系数据的表和表之间的跳转可以建立“一对多”，“多对一”和“一对一的关系”，这样才能按照应用册灰姑娘徐的逻辑来组织和存储数据，通俗的讲 ：\n一个班级可以对应很多学生 多位学生对应同个班级 一个班级对应一个班主任 在关系数据库中，关系是通过主键和外键来维护的。\n主键 在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，students表的两行记录：\nid class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。\n而在关系表中，有个很重要的约束：任意两条记录不能重复，而不重复指的并非是两条记录不完全相同，而是，能够通过某个字段唯一区分出不同的记录，这个字段成为主键。\n也就是说，如果Name作为主键，那么我们不能存储同名的两个不同的同学。\n由于主键的该特性，通常将主键用来定位和记录，修改主键将造成较大影响，因此我们一般不对主键进行修改。为了避免修改主键，我们避免将主键设置为与任何业务相关的字段（例如身份证、手机等等），避免所有的更新换代和修改造成的不良影响。由此通常使用id来进行主键的存储。\n自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 大部分应用使用自增整数类型即可，BIGINT NOT NULL AUTO_INCREMENT类型。\nINT自增类型上限差不多是21亿，BIGINT自增类型最多约922亿亿\n联合主键 关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：\n没有必要的情况下，尽量不使用联合主键，其带来关系表的复杂度的上升。\n外键 以学生和班级的数据集为例对外键进行分析和介绍。\n主键唯一标识记录，我们可以在students中确认任意一个学生的记录，在Classes表中确定任何一个班级的位置等。而一个班级可以有多个学生，这种一对多关系，对应的表的映射的实现，我们需要在students表中加入class_id，让它的值与classes表中的某条记录相对应。\nid name other columns 1 一班 … 2 二班 … 这样就可以通过class_id定位出students和classes的对应关系，通过class_id字段，将students和classes表连接起来，这种列（字段）被称为外键。\n外键并不是通过列名实现的，而是通过定义外键约束实现的：\n1 2 3 4 ALTER TABLE students ADD CONSTRAINT fk_class_id FOREIGN KEY (class_id) REFERENCES classes (id); 其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。\n通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。\n由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。\n删除外键约束也是通过ALTER TABLE实现的：\n1 2 ALTER TABLE students DROP FOREIGN KEY fk_class_id; 多对多是通过一个中间表实现的。\n一对一还要建表是为了避免缺省值\n“关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。”\n索引 为了快速搜索数据，需要对（用于搜索的）特定关键词建立索引，通过索引进行预排序，帮助快速定位到符合条件的记录来加快查询速度。\n如果我们希望对学生的成绩score建立索引，方便对score进行快速查找：\n1 2 ALTER TABLE students ADD INDEX idx_score(score); 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：\n1 2 ALTER TABLE students ADD INDEX idx_name_score(score, name); 索引的效率取决于散列的程度，如果值越分散，索引效率越高，如果存在大量的重复值（像性别），创建索引就没有意义。\n优缺点 可以对同一张表建立多个索引，但是索引的建立会带来如下的优缺点：\n提高了查询效率 插入、更新、删除记录的时候需要更新，越多索引修改的速度就越慢 唯一索引 具有业务意义，如身份证之类的唯一标识，不适合作为主键，但是可以构建唯一索引，其具备最高的索引效率。\n1 2 ALTER TABLE students ADD UNIQUE INDEX uni_name(name); 也可以只对某一列添加一个唯一约束而不创建唯一索引：\n1 2 ALTER TABLE students ADD CONSTRAINT uni_name UNIQUE (name); 在这种情况下，没有建立索引，但是具备唯一性约束。\n","permalink":"https://hugotest-phi.vercel.app/posts/sql2/","summary":"\u003cp\u003e本章节从MySQL的安装到基础使用，\u003cstrong\u003eMySQL\u003c/strong\u003e本身只是一个SQL接口，它内部还包含多种数据引擎，常用的包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInnoDB：支持事务的数据库引擎（不知道选啥的时候选他就好）\u003c/li\u003e\n\u003cli\u003eMyISAM：早期默认，不支持事务\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e接口和引擎的关系好比浏览器和浏览器引擎，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口，由于其开源，也衍生出了各种开源版本（包括针对各种云存储中托管数据库的版本等）\u003c/p\u003e\n\u003ch2 id=\"安装mysql\"\u003e安装MySQL\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eWindows\u003c/strong\u003e直接官网下载对应的版本就好了，\u003ca href=\"https://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\"\u003eCommunity Version\u003c/a\u003e\n在该超链接进行下载，其他版本就按需下载，按需付费就行。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e\u003cstrong\u003eLinux\u003c/strong\u003e下载MySQL：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install mysql-server\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e验证是否下载安装完成：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 链接服务器\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emysql\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 登录服务器（需要输入口令）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emysql -u root -p \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e成功链接后会变成\u003ccode\u003emysql\u0026gt;\u003c/code\u003e，输入\u003ccode\u003eexit\u003c/code\u003e可以推出MySQL命令行，但是其将仍然在后台运行。\u003c/p\u003e\n\u003ch2 id=\"关系模型\"\u003e关系模型\u003c/h2\u003e\n\u003cp\u003e关系数据建立在关系模型之上，关系模型本质上就是若干个存储数据的二维表（Excel表），其中\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e每一行称为记录（Record）\u003c/strong\u003e：记录是一个逻辑意义上的数据\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e每一列成为字段（Column）\u003c/strong\u003e：同一个表的每一行记录都拥有相同的若干字段，字段需要规定其数据类型，以及是否允许为Null（缺省值）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e避免允许Null，不允许可简化查询条件，加快查询速度，也避免程序调用时需要处理Null\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e关系数据的\u003cstrong\u003e表和表之间的跳转\u003c/strong\u003e可以建立“一对多”，“多对一”和“一对一的关系”，这样才能按照应用册灰姑娘徐的逻辑来组织和存储数据，\u003ca href=\"https://www.liaoxuefeng.com/wiki/1177760294764384/1218728991649984\" target=\"_blank\" rel=\"noopener\"\u003e通俗的讲\u003c/a\u003e\n：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个班级可以对应很多学生\u003c/li\u003e\n\u003cli\u003e多位学生对应同个班级\u003c/li\u003e\n\u003cli\u003e一个班级对应一个班主任\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在关系数据库中，关系是通过\u003cstrong\u003e主键\u003c/strong\u003e和\u003cstrong\u003e外键\u003c/strong\u003e来维护的。\u003c/p\u003e\n\u003ch2 id=\"主键\"\u003e主键\u003c/h2\u003e\n\u003cp\u003e在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，\u003ccode\u003estudents\u003c/code\u003e表的两行记录：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eid\u003c/th\u003e\n          \u003cth\u003eclass_id\u003c/th\u003e\n          \u003cth\u003ename\u003c/th\u003e\n          \u003cth\u003egender\u003c/th\u003e\n          \u003cth\u003escore\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e小明\u003c/td\u003e\n          \u003ctd\u003eM\u003c/td\u003e\n          \u003ctd\u003e90\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e小红\u003c/td\u003e\n          \u003ctd\u003eF\u003c/td\u003e\n          \u003ctd\u003e95\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。\u003c/p\u003e\n\u003cp\u003e而在关系表中，有个很重要的约束：\u003cstrong\u003e任意两条记录不能重复\u003c/strong\u003e，而不重复指的并非是两条记录不完全相同，而是，能够通过某个字段唯一区分出不同的记录，这个字段成为主键。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e也就是说，如果Name作为主键，那么我们不能存储同名的两个不同的同学。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e由于主键的该特性，通常将主键用来定位和记录，修改主键将造成较大影响，因此我们一般不对主键进行修改。为了避免修改主键，我们避免将主键设置为与任何业务相关的字段（例如身份证、手机等等），避免所有的更新换代和修改造成的不良影响。由此通常使用id来进行主键的存储。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；\u003c/li\u003e\n\u003cli\u003e全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似\u003ccode\u003e8f55d96b-8acc-4636-8cb8-76bf8abc2f57\u003c/code\u003e。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e大部分应用使用自增整数类型即可，\u003ccode\u003eBIGINT NOT NULL AUTO_INCREMENT\u003c/code\u003e类型。\u003c/p\u003e","title":"SQL Chapter2 安装和基本概念"},{"content":"SQL相关参考资料：尊重一下菜鸟教程 ，该教程中的文档相对简练和入门，W3School 的资料好像就是菜鸟教程的；其次，廖雪峰 的SQL教程网站，也应该比较适合入门，对比后选择一个进行学习。\n围绕SQL是什么、有什么用、和怎么用来学习。\n利用廖雪峰的教程来进行学习，因为其具备在线运行和测试的功能。\nSQL是什么 SQL：Structured Query Language（结构化查询语言）用于访问和操作数据库系统：查询、添加、更新、删除、管理、维护。不同的数据库，都支持SQL。\n\u0026ldquo;SQL就是访问和处理关系数据库的计算机标准语言“，无论使用什么编程语言编写程序，当我们涉及到操作关系数据库之时，就需要使用SQL，其中，最流行的开源数据库为MySQL。\n同时，现今还存在非SQL的数据库，也就是NoSQL数据库，例如：MongoDB、Cassandra、Dynamo都属于非关系数据库。\n而SQL在当今仍然承担各种应用程序的核心数据存储，与NoSQL（作为SQL数据库的补充）相辅相成。\n虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。\n\u0026ldquo;现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。\u0026rdquo;\nSQL定义了这几种操作数据库的能力：\nDDL（Data Definition Language）：允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。 DML（Data Manipulation Language）：为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。 DQL（Data Query Language）：允许用户查询数据，这也是通常最频繁的数据库日常操作。 SQL的语法特点：\nSQL语言关键字不区分大小写！！！ 但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。\n数据库 为什么需要数据库 为什么需要数据库，实际上就是面对大量的数据储备，进行更有效的管理，实现\n统一数据格式（接口）管理，实现统一的读写文件和解析方法。 在数据库中快速查询并获取指定数据。 因此借由数据库来专门管理数据，统一结构（接口），读写，以及搜索流程。这样，当应用需要使用数据的时候，就可简化流程如图所示：\n数据库的数据架构 数据库按照数据架构来组织、存储和管理数据，主要有以下三种模型结构：\n层次模型 网状模型 关系模型 层次模型顾名思义是“上下级”的层次关系来组织数据的方式，类似树状结构：\n网状结构则是把每个数据节点和其他诸多节点进行链接，数据结构像是道路的网络。\n关系模型则是以矩阵的形式对数据进行存储，任何数据通过行列坐标来唯一确定。\n最终，基于关系模型的关系数据库成为了绝对的主流，因其使用和理解起来最为简单。其形式可理解为多元属性的笛卡尔集 ，也就是每条数据是由 n 元（n 个属性值）构成，而由这些数据的集合构成数据集，每个属性值也能对应更为详细的表。以班级为例，一个班级的学生可以用一个表格存起来，如下：\nID 姓名 班级 ID 性别 年龄 1 小明 201 M 9 2 小红 202 F 8 3 小军 202 M 8 4 小白 201 F 9 其中班级 ID 可对应另一个班级表：\nID 名称 班主任 201 二年级一班 王老师 202 二年级二班 李老师 通过给定一个班级名称，可以查到一条班级记录，根据班级ID，又可以查到多条学生记录，这样，二维表之间就通过ID映射建立了“一对多”关系。\n对于每个关系表，每一列除了需要定义名称之外，还需要指定数据类型，数据类型包括数值、字符串、时间等（具体建议查表 ）\n主流关系数据库 商用数据库，例如：Oracle，SQL Server，DB2等； 开源数据库，例如：MySQL，PostgreSQL等； 桌面数据库，以微软Access为代表，适合桌面应用程序使用； 嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。 ","permalink":"https://hugotest-phi.vercel.app/posts/sql1/","summary":"\u003cp\u003eSQL相关参考资料：尊重一下\u003ca href=\"https://www.runoob.com/sql/sql-tutorial.html\" target=\"_blank\" rel=\"noopener\"\u003e菜鸟教程\u003c/a\u003e\n ，该教程中的文档相对简练和入门，\u003ca href=\"https://www.w3school.com.cn/sql/sql_intro.asp\" target=\"_blank\" rel=\"noopener\"\u003eW3School\u003c/a\u003e\n的资料好像就是菜鸟教程的；其次，\u003ca href=\"https://www.liaoxuefeng.com/wiki/1177760294764384\" target=\"_blank\" rel=\"noopener\"\u003e廖雪峰\u003c/a\u003e\n的SQL教程网站，也应该比较适合入门，对比后选择一个进行学习。\u003c/p\u003e\n\u003cp\u003e围绕SQL是什么、有什么用、和怎么用来学习。\u003c/p\u003e\n\u003cp\u003e利用廖雪峰的教程来进行学习，因为其具备在线运行和测试的功能。\u003c/p\u003e\n\u003ch2 id=\"sql是什么\"\u003eSQL是什么\u003c/h2\u003e\n\u003cp\u003eSQL：Structured Query Language（结构化查询语言）用于访问和操作数据库系统：查询、添加、更新、删除、管理、维护。不同的数据库，都支持SQL。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;SQL就是访问和处理关系数据库的计算机标准语言“，无论使用什么编程语言编写程序，当我们涉及到\u003cstrong\u003e操作关系数据库\u003c/strong\u003e之时，就需要使用SQL，其中，最流行的开源数据库为MySQL。\u003c/p\u003e\n\u003cp\u003e同时，现今还存在非SQL的数据库，也就是NoSQL数据库，例如：MongoDB、Cassandra、Dynamo都属于非关系数据库。\u003c/p\u003e\n\u003cp\u003e而SQL在当今仍然承担各种应用程序的核心数据存储，与NoSQL（作为SQL数据库的补充）相辅相成。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cblockquote\u003e\n\u003cp\u003e虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u0026ldquo;现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003eSQL定义了这几种\u003cstrong\u003e操作数据库的能力：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDDL（Data Definition Language）：允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。\u003c/li\u003e\n\u003cli\u003eDML（Data Manipulation Language）：为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。\u003c/li\u003e\n\u003cli\u003eDQL（Data Query Language）：允许用户查询数据，这也是通常最频繁的数据库日常操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSQL的语法特点\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSQL语言关键字不区分大小写\u003c/strong\u003e！！！\n但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。\u003c/p\u003e\n\u003ch2 id=\"数据库\"\u003e数据库\u003c/h2\u003e\n\u003ch3 id=\"为什么需要数据库\"\u003e为什么需要数据库\u003c/h3\u003e\n\u003cp\u003e为什么需要数据库，实际上就是面对大量的数据储备，进行更有效的管理，实现\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e统一数据格式（接口）管理，实现统一的读写文件和解析方法。\u003c/li\u003e\n\u003cli\u003e在数据库中快速查询并获取指定数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因此借由数据库来专门管理数据，统一结构（接口），读写，以及搜索流程。这样，当应用需要使用数据的时候，就可简化流程如图所示：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/20220803124419.png\"\u003e\r\n    \u003cimg alt=\"database\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/20220803124419.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/20220803124419.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"database\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch3 id=\"数据库的数据架构\"\u003e数据库的数据架构\u003c/h3\u003e\n\u003cp\u003e数据库按照数据架构来组织、存储和管理数据，主要有以下三种模型结构：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e层次模型\u003c/li\u003e\n\u003cli\u003e网状模型\u003c/li\u003e\n\u003cli\u003e关系模型\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e层次模型顾名思义是“上下级”的层次关系来组织数据的方式，类似树状结构：\u003c/p\u003e","title":"SQL Chapter1 Introduce"},{"content":"在同一个局域网（像是链接同一个wifi的环境）中，设置共享的文件夹或者磁盘，可提升文件分享的效率和速度，特别适用于与女朋友合租、与兄弟合租的情景。\nWin 系统开放共享权限 Windows的设置首先要在控制面板中开启共享功能：\n针对专用网络开启\n为了信息和数据安全关闭来宾和公用，并开启加密\n基于该设置，在访问共享文件夹之时，需要输入账号和密码。\nWin 共享文件夹设置 直接使用默认的共享功能可以方便设置，但是存在可访问父级文件夹的 bug，建议设置好用户后使用。\n如果操作得当可以使用高级共享功能来创建更为安全的文件夹共享。\n使用高级共享中的设置来定义权限Everyone（是否允许修改等其他权限）\n至此，完成了文件夹和文件的共享设置，使用同样的设置，便可以在LAN中的其他设备访问开放共享的文件夹。\n共享用户创建 可以在默认的共享设置中设置权限的时候，选择设置新用户，跳过使用 Microsoft 账号，创建本地账号，后面共享链接的时候就可以用该账号登录了。\n然后选择管理其他账户 ，然后选择添加新用户-\u0026gt; 添加账户即可。\nLinux 共享文件夹设置 设置 Linux 的文件夹共享，安装对应的 Samba 来启动 SMB 文件共享（需要注意的是，这一步安装不能使用远程桌面进行）\n设置好对应的文件读写权限，同时使用下列命令设置好允许访问 smb 文件夹的用户：\n1 sudo smbpasswd -a \u0026lt;username\u0026gt; \u0026lt;username\u0026gt; 需要为 linux 的有效用户，设置好 SMB 账号密码即可开启完整的访问服务。\n各平台访问共享文件夹 windows 访问 使用以下的方式访问共享文件夹：\n\\\\192.168.31.108\\\\Folder 可以使用\\\\localhost在资源管理器中访问《网络》中《我的共享文件夹》，确保当前网络为专用的情况下，可以打开另外终端资源管理器中的《网络》来访问当前共享文件夹。\n经测试，文件访问和读取的速度较快，在带宽充足的情况下，能够取代 U 盘等进行文件的传输和共享，也能实现视频流的实时播放。\nios 访问 在默认的文件 APP 中，连接服务器，连接到 pc 的 ip 地址，用指定的账户登录即可。\nmac 访问 在访达中选择前往，然后选择连接服务器，然后选中局域网的 IP 并输入指定的账号密码即可登录。\nLinux 访问 linux开机挂载文件夹,Linux开机挂载windows共享文件夹_正妻空母加贺桑的博客-CSDN博客 【交互界面】方法 1：在 File Manager 里面选择 other Location 中的 Connect to Server，连接到 windows 的 SMB 服务器即可。\n【推荐】方法 2：使用手动挂载命令，将 windows 的共享文件夹挂载到指定目录下。\n1 sudo mount -t cifs //192.168.31.201/\u0026lt;share dir\u0026gt; \u0026lt;local-position\u0026gt; -o username=\u0026#39;username\u0026#39;,password=\u0026#39;passwd\u0026#39;,vers=2.0 【成功】方法 2.1：使用开机启动脚本 /etc/rc.local 开机执行上述脚本即可，Ubuntu 22.04 LTS 不用再自己写rc-local.service了-简易百科 (isolves.com) ，原本系统中没有 rc.local 文件，但是 Ubuntu 中已经无需自己编写，但是需要新建后赋予其执行权限\n1 sudo chmod +x /etc/rc.local 这里需要注意的是，编写挂载脚本的时候，因为树莓派在刚开机的时候挂载会失败，所以需要引入 sleep 一段时间。具体的操作流程如下：\n创建脚本文件 startup.sh 在任意位置，内容参考手动挂载命令，在这之前添加 sleep。 1 2 3 4 5 6 7 8 sleep 30 # 下面两者选一个用即可 # 选项1 使用方法2.手动挂载命令挂载 sudo mount -t cifs //192.168.31.201/\u0026lt;share dir\u0026gt; \u0026lt;local-position\u0026gt; -o username=\u0026#39;username\u0026#39;,password=\u0026#39;passwd\u0026#39;,vers=2.0 # 选项2 使用方法2.3 已经在fstab中加入挂载的命令 sudo mount -a 在 rc.local 的 exit0之前添加调用执行该脚本 1 2 3 4 5 ... ... sudo sh /\u0026lt;path-to-your-script\u0026gt;/startup.sh exit 0 如果失败了可以尝试 chmod +x startup.Sh 修改成可执行。\n【成功】方法 2.2：加入开机启动项 ，在 /etc/init.d 中编写需要开机启动的脚本，然后执行以下的命令加入开机启动中：\n1 sudo update-rc.d xxx.sh defaults 90 最后一个数字是脚本启动的顺序，数字越大，执行越晚，重启即可完成测试，以下命令可以查看全部服务列表：\n1 sudo service --status-all 卸载启动脚本的方法：\n1 sudo update-rc.d -f xxx.sh remove 【成功一半】方法 2.3：使用自动挂载命令，修改 fstab ，将以下的命令添加到该文件下面即可生效：\n1 //192.168.31.201/\u0026lt;share dir\u0026gt; /mnt/windows-share cifs username=\u0026#39;username\u0026#39;,password=\u0026#39;passwd\u0026#39; 0 0 如果要卸载网络共享目录使用以下命令：\n1 sudo umount \u0026lt;local-postion\u0026gt; 可以通过 df -h 查看挂载是否成功。\n【可选】方法 3: 要进入 smb 的命令操作空间\n1 2 # 安装Smbclient sudo apt-get install smbclinent 安装好后，就可以访问共享的文件夹，这样会进入 smb 的命令操作空间\n1 smbclient --user=share //192.168.31.198/share ","permalink":"https://hugotest-phi.vercel.app/posts/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB/","summary":"\u003cp\u003e在同一个局域网（像是链接同一个wifi的环境）中，设置共享的文件夹或者磁盘，可提升文件分享的效率和速度，特别适用于与女朋友合租、与兄弟合租的情景。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"win-系统开放共享权限\"\u003eWin 系统开放共享权限\u003c/h2\u003e\n\u003cp\u003eWindows的设置首先要在控制面板中开启共享功能：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220801160336296.png\"\u003e\r\n    \u003cimg alt=\"image-20220801160336296\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220801160336296.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220801160336296.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20220801160336296\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e针对专用网络开启\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220801161142132.png\"\u003e\r\n    \u003cimg alt=\"image-20220801161142132\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220801161142132.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220801161142132.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20220801161142132\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e为了信息和数据安全关闭来宾和公用，并开启加密\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220801161340594.png\"\u003e\r\n    \u003cimg alt=\"image-20220801161340594\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220801161340594.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220801161340594.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20220801161340594\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Windows Configuration03 LAN sharing"},{"content":"Config Windows Terminal in Win11 Install 安装 windows terminal 在 win11 已经自带，无需安装，如果需要安装的话在 Microsoft Store 下载即可，默认的 terminal 在中文环境中可能要搜索 windows 终端。\nBaisc 基础设置 新版的 Windows Terminal 有了图形化配置界面，因此配置简单和直观了不少，该部分就简要的介绍一下基础的设置。通过 Ctrl+, 或者下拉菜单可以打开设置页面。\n完成每一部分的修改后记得保存\n首先在默认的终端应用程序中选择 windows 终端，将其作为默认的终端模拟器（terminal simulator），启动的地方，可以设置默认的配置文件，这里后续会用到。\n接着交互选项卡中启用复制粘贴功能，该功能可以避免在和终端或者 WSL，vim 交互的时候一些复制粘贴的相关问题和配置，（记得点击保存）\n该选项卡中还有关闭多窗口时是否提示，可以按需关闭或开启。\n紧接着外观选项卡中打开亚克力材料，隐藏标题栏以及深色主题（个人觉得浅色主题和终端界面没法很好的融合在一起）\n然后可以为终端提供配色方案，结合后续会提到的透明窗格来使用，默认的配置文件中，我比较推荐 Tango Dark 和 One Half Dark 来搭配使用，但是默认的配置又以下的问题：\n图形化配置界面方便自定义但是不太方便导入他人的配置 默认的配置方案相对较少 因此我们还是使用 JSON 的方式来导入他人的配置文件，配置文件可以参考以下链接获取：\nWindows Terminal Themes \u0026gt;_TerminalSplash - Windows Terminal Themes 在设置界面的左下角打开 JSON 文件\n里面找到 scheme 部分，可以看到这里和我们上述链接获取到的格式是一致的，在这里添加配置。添加后可以看到主题就在配色方案中出现即可，后续在各个具体 terminal 的配置文件中进行设置。\nConfigs 配置文件设置 在配置文件下可以看到针对每一个 Shell（CMD、Poweshell、WSL） 都会有一套配置文件，如果全都分开设置的话非常的麻烦，因此除了独有设置（蓝框），像外观和一些基础的交互行为（红框），都通过默认值来进行统一管理。\n首先进入外观选项，主要需要设置的有以下的几项：配色方案、字体、光标形状、背景图像、不透明度和亚克力材料。\n配色方案根据上面我们导入的进行选择即可 字体选择 nerd font 可以解决终端中部分图标渲染不出来的问题 光标形状和背景图像按照自己的需求进行设置即可 推荐启用亚克力材料和不透明度（美化的灵魂） 接着进入高级选项，这里主要将铃声通知样式关闭，太吵了。\n独有配置部分我们以 WSL 为例说一下主要需要设置哪些，除了名称、图标等还可以设置以下的：\nCMD 和 PS 可以设置以管理员身份运行 WSL 之类的我们可以设置其中的启动目录 命令行部分即选择执行的是哪个 Shell 以及是否指定用户 针对一些平时用不到的可以从下拉菜单中隐藏。 Done for now\nConfig Terminal By Json（已废弃） 内测时期的 Terminal 需要通过 JSON 来进行配置，同时也不支持右键菜单中打开，因此有了这个配置，但是随着 terminal 图形化设置界面的完善，该部分配置已经废弃。\nInstall ：Windows Store\n添加 Terminal 到右键菜单：\n参考：Windows Terminal 完美配置 中的右键菜单部分：Install/uninstall scripts for Windows Terminal context menu items 注意，这里涉及到注册表修改的操作，所以我们需要在修改注册表之间建立注册表还原点。\nBasic Config：\n新版本的 Terminal 中大部分的配置都已经有了 UI 了，配置起来还是比较方便的，其实主要的配置直接在设置面板里设置就可以了。这里以早期版本的配置文件设置为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 { \u0026#34;$schema\u0026#34;: \u0026#34;https://aka.ms/terminal-profiles-schema\u0026#34;, \u0026#34;actions\u0026#34;: [ { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;copy\u0026#34;, \u0026#34;singleLine\u0026#34;: false }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+c\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;find\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+f\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;paste\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+v\u0026#34; }, { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;splitPane\u0026#34;, \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;alt+shift+d\u0026#34; } ], \u0026#34;alwaysShowTabs\u0026#34;: true, \u0026#34;copyFormatting\u0026#34;: \u0026#34;rtf\u0026#34;, \u0026#34;copyOnSelect\u0026#34;: false, \u0026#34;defaultProfile\u0026#34;: \u0026#34;{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}\u0026#34;, \u0026#34;initialCols\u0026#34;: 130, \u0026#34;initialRows\u0026#34;: 35, \u0026#34;launchMode\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34;: 0.69999999999999996, \u0026#34;closeOnExit\u0026#34;: \u0026#34;graceful\u0026#34;, \u0026#34;colorScheme\u0026#34;: \u0026#34;AdventureTime\u0026#34;, \u0026#34;font\u0026#34;: { \u0026#34;face\u0026#34;: \u0026#34;FiraCode Nerd Font\u0026#34; }, \u0026#34;historySize\u0026#34;: 9001, \u0026#34;padding\u0026#34;: \u0026#34;5, 5, 20, 25\u0026#34;, \u0026#34;snapOnInput\u0026#34;: true, \u0026#34;startingDirectory\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;useAcrylic\u0026#34;: true }, \u0026#34;list\u0026#34;: [ { \u0026#34;backgroundImage\u0026#34;: \u0026#34;C:\\\\Users\\\\Aiken\\\\Pictures\\\\Camera Roll\\\\a560083febb425e04ba0a86a7851c51dc2b417a4.png\u0026#34;, \u0026#34;backgroundImageOpacity\u0026#34;: 0.26000000000000001, \u0026#34;colorScheme\u0026#34;: \u0026#34;purplepeter\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe\u0026#34;, \u0026#34;font\u0026#34;: { \u0026#34;face\u0026#34;: \u0026#34;FiraCode Nerd Font Mono Retina\u0026#34; }, \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Windows PowerShell\u0026#34; }, { \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;CMD\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; }, { \u0026#34;colorScheme\u0026#34;: \u0026#34;Banana Blueberry\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;ssh root@202.117.43.196 -p 23076\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{44257ed0-90f8-41a1-bad0-2c637012ce40}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;icon\u0026#34;: \u0026#34;ms-appx:///ProfileIcons/{9acb9455-ca41-5af7-950f-6bca1bc9722f}.png\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;202.117.43.196\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;.\u0026#34; }, { \u0026#34;acrylicOpacity\u0026#34;: 0.68999999999999995, \u0026#34;antialiasingMode\u0026#34;: \u0026#34;cleartype\u0026#34;, \u0026#34;backgroundImage\u0026#34;: \u0026#34;desktopWallpaper\u0026#34;, \u0026#34;backgroundImageOpacity\u0026#34;: 0.20000000000000001, \u0026#34;colorScheme\u0026#34;: \u0026#34;purplepeter\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;wsl.exe ~\u0026#34;, \u0026#34;cursorShape\u0026#34;: \u0026#34;underscore\u0026#34;, \u0026#34;experimental.retroTerminalEffect\u0026#34;: false, \u0026#34;font\u0026#34;: { \u0026#34;face\u0026#34;: \u0026#34;FiraCode Nerd Font\u0026#34; }, \u0026#34;guid\u0026#34;: \u0026#34;{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;intenseTextStyle\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Linux20.04\u0026#34;, \u0026#34;padding\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34;, \u0026#34;startingDirectory\u0026#34;: null, \u0026#34;tabTitle\u0026#34;: null } ] }, \u0026#34;schemes\u0026#34;: [ { \u0026#34;background\u0026#34;: \u0026#34;#1F1D45\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#050404\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#0F4AC6\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#4E7CBF\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#1997C6\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#C8FAF4\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#9EFF6E\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#9B5953\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#FC5F5A\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#F6F5FB\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#EFC11A\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#70A598\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#F8DCC0\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#4AB118\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;AdventureTime\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#665993\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#BD0013\u0026#34;, \u0026#34;selectionBackground\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#F8DCC0\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#E7741E\u0026#34; }, ], \u0026#34;showTabsInTitlebar\u0026#34;: true, \u0026#34;tabWidthMode\u0026#34;: \u0026#34;titleLength\u0026#34;, \u0026#34;theme\u0026#34;: \u0026#34;dark\u0026#34;, \u0026#34;windowingBehavior\u0026#34;: \u0026#34;useAnyExisting\u0026#34; } ","permalink":"https://hugotest-phi.vercel.app/posts/windowsterminal/","summary":"\u003ch2 id=\"config-windows-terminal-in-win11\"\u003eConfig Windows Terminal in Win11\u003c/h2\u003e\n\u003ch3 id=\"install-安装\"\u003eInstall 安装\u003c/h3\u003e\n\u003cp\u003ewindows terminal 在 win11 已经自带，无需安装，如果需要安装的话在 Microsoft Store 下载即可，默认的 terminal 在中文环境中可能要搜索 windows 终端。\u003c/p\u003e\n\u003ch3 id=\"baisc-基础设置\"\u003eBaisc 基础设置\u003c/h3\u003e\n\u003cp\u003e新版的 Windows Terminal 有了图形化配置界面，因此配置简单和直观了不少，该部分就简要的介绍一下基础的设置。通过 Ctrl+,  或者下拉菜单可以打开设置页面。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e完成每一部分的修改后记得保存\u003c/strong\u003e\u003c/p\u003e","title":"Windows Configuration02 Terminal"},{"content":"“NAS本质上就是一个可以开启文件共享的具有大存储的系统：无论是Windows，Linux或其他一切可基于诸如SMB、Internet提供文件共享或访问功能的系统都可以作为NAS的系统使用。”\n不出意外，针对该应用场景，也有针对性的一些简化OS，故而在构建NAS之前，首先分析对NAS存储的需求，进而选择一个合适的系统去构建。\n个人NAS需求分析 就像NAS：Network Attached Storage所说，NAS最基本的需求是“存储”与“共享”（随时存取），实际也是一个私有网盘（支持更多功能？），本文便基于该脉络分析需求。\n存储/功能类型 使用场景说明 需求程度 图片、文件归档 存储，预览（基于AI识别分类，时间线，照片墙） - 大文件 内网快速传输 - 电影 流媒体服务器：多设备在线观看、封面集归纳和整理（PLEX） - 工作文档 历史版本，协作编辑 Option 下载功能 看到想看的电影的时候可以直接让他开始下载 - 支持docker扩充功能 可以使用Docker下载并部署一些其他的乱七八糟的功能 Core 在支持基本功能的基础之上，通过配置的选择来，尽量减少功耗，从而减少长时间启动带来的电费消耗，如果可以的话使用软件或者硬件来记录NAS每个月的耗电量。\n此外，还需要考虑数据的稳定性，好像叫做《阵列》？（后续进行补充了解）\n断电自动重启\n文件共享服务：SMB、FTP‘\n加密和数据安全性\n不需要显示器，只需要网络和SSH进行远程登陆和控制之类的。\nNAS-OS 主要的一些NAS系统有：FreeNas、nas4free（xigmaNAS）、unraid（收费）、TrueNas Scale/Core、omv、EasyNAS黑群晖\n基于完整OS搭建：\nDebian/Ubuntu（server）+（samba+syncthing+Docker） windows（server） 好像可以搭配软路由（OpenWrt）一起搭建家用存储系统。\n主要考虑Unraid、TrueNas、Omv，由于Unraid收费，考虑使用TrueNas、OMV是否足够满足需要，如果需要的话就不在考虑其他。\n基于Docker的软件部署 jellyfin或Plex进行视频资源管理 运行虚拟机基于黑群晖进行图像管理？ 下载工具 部署可于外网访问（虚拟内网构建 zerotier内网穿透？ 配置分析 实际上就是组装一台不带屏幕的电脑，故而基于现有的多余硬件来组建NAS。\n设备名称 预算-\u0026gt;具体型号 功率 FI？ 机箱 x √ 机箱风扇 x √ 内存 x √ CPU（带集显支持硬解）+自带散热 256-ssd（系统） 200-300 Hard-Drive（存储空间4T+4T+4T+4T） 1k 电源（基于设备需求进行购买） 仍需考虑的问题：\n机箱缺少侧板，且机箱过大，过于占地方，是否考虑重新购买小机箱，或者NAS专用机箱等。 考虑供电和放置的位置 数据安全（Raid） Reference 没那么靠谱 Some Function Support OS选择总说纷纭 5款NAS系统横评 NAS评价大全集 ","permalink":"https://hugotest-phi.vercel.app/posts/nas/","summary":"\u003cp\u003e“NAS本质上就是一个可以开启文件共享的具有大存储的系统：无论是Windows，Linux或其他一切可基于诸如SMB、Internet提供文件共享或访问功能的系统都可以作为NAS的系统使用。”\u003c/p\u003e\n\u003cp\u003e不出意外，针对该应用场景，也有针对性的一些简化OS，故而在构建NAS之前，首先分析对NAS存储的需求，进而选择一个合适的系统去构建。\u003c/p\u003e\n\u003ch2 id=\"个人nas需求分析\"\u003e个人NAS需求分析\u003c/h2\u003e\n\u003cp\u003e就像NAS：Network Attached Storage所说，NAS最基本的需求是“存储”与“共享”（随时存取），实际也是一个私有网盘（支持更多功能？），本文便基于该脉络分析需求。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e存储/功能类型\u003c/th\u003e\n          \u003cth\u003e使用场景说明\u003c/th\u003e\n          \u003cth\u003e需求程度\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e图片、文件归档\u003c/td\u003e\n          \u003ctd\u003e存储，预览（基于AI识别分类，时间线，照片墙）\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e大文件\u003c/td\u003e\n          \u003ctd\u003e内网快速传输\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e电影\u003c/td\u003e\n          \u003ctd\u003e流媒体服务器：多设备在线观看、封面集归纳和整理（PLEX）\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e工作文档\u003c/td\u003e\n          \u003ctd\u003e历史版本，协作编辑\u003c/td\u003e\n          \u003ctd\u003eOption\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e下载功能\u003c/td\u003e\n          \u003ctd\u003e看到想看的电影的时候可以直接让他开始下载\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e支持docker扩充功能\u003c/td\u003e\n          \u003ctd\u003e可以使用Docker下载并部署一些其他的乱七八糟的功能\u003c/td\u003e\n          \u003ctd\u003eCore\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e在支持基本功能的基础之上，通过配置的选择来，尽量减少功耗，从而减少长时间启动带来的电费消耗，如果可以的话使用软件或者硬件来记录NAS每个月的耗电量。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e此外，还需要考虑数据的稳定性，好像叫做《阵列》？（\u003cstrong\u003e后续进行补充了解\u003c/strong\u003e）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e断电自动重启\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e文件共享服务：SMB、FTP‘\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e加密和数据安全性\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不需要显示器，只需要网络和SSH进行远程登陆和控制之类的。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"nas-os\"\u003eNAS-OS\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e主要的一些NAS系统有：FreeNas、nas4free（xigmaNAS）、\u003cstrong\u003eunraid（收费）\u003c/strong\u003e、\u003cstrong\u003eTrueNas Scale/Core\u003c/strong\u003e、\u003cstrong\u003eomv\u003c/strong\u003e、EasyNAS黑群晖\u003c/p\u003e\n\u003cp\u003e基于完整OS搭建：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDebian/Ubuntu（server）+（samba+syncthing+Docker）\u003c/li\u003e\n\u003cli\u003ewindows（server）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e好像可以搭配软路由（OpenWrt）一起搭建家用存储系统。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e主要考虑Unraid、TrueNas、Omv，由于Unraid收费，考虑使用TrueNas、OMV是否足够满足需要，如果需要的话就不在考虑其他。\u003c/p\u003e\n\u003ch3 id=\"基于docker的软件部署\"\u003e基于Docker的软件部署\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ejellyfin或Plex进行视频资源管理\u003c/li\u003e\n\u003cli\u003e运行虚拟机基于黑群晖进行图像管理？\u003c/li\u003e\n\u003cli\u003e下载工具\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"部署可于外网访问虚拟内网构建\"\u003e部署可于外网访问（虚拟内网构建\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ezerotier内网穿透？\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"配置分析\"\u003e配置分析\u003c/h2\u003e\n\u003cp\u003e实际上就是组装一台不带屏幕的电脑，故而基于现有的多余硬件来组建NAS。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e设备名称\u003c/th\u003e\n          \u003cth\u003e预算-\u0026gt;具体型号\u003c/th\u003e\n          \u003cth\u003e功率\u003c/th\u003e\n          \u003cth\u003eFI？\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e机箱\u003c/td\u003e\n          \u003ctd\u003ex\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e机箱风扇\u003c/td\u003e\n          \u003ctd\u003ex\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e内存\u003c/td\u003e\n          \u003ctd\u003ex\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCPU（带集显支持硬解）+自带散热\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e256-ssd（系统）\u003c/td\u003e\n          \u003ctd\u003e200-300\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eHard-Drive（存储空间4T+4T+4T+4T）\u003c/td\u003e\n          \u003ctd\u003e1k\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e电源（基于设备需求进行购买）\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e仍需考虑\u003c/strong\u003e的问题：\u003c/p\u003e","title":"NAS"},{"content":"@Reference: Jack Cui | Github-Markov Junior | Wiki Markov algorithm 第一篇文章简要介绍了一下该编程语言能实现什么效果；第二个是官方repo，其文档和代码都有很强的借鉴意义；第三个是wikipedia对马尔可夫算法的解释，在该编程语言的实现中有重要的意义。\nmarkov algorithm 马尔可夫算法指的是字符串重写算法，其基本逻辑如下:\n自顶向下依次检查规则，看是否能在符号串中找到任何在箭头左边的字符串。 如果没有找到，停止执行算法。 如果找到一个或多个，把符号串中的最左匹配的文字替换为在第一个相应规则的箭头右边的字符串。 返回步骤1并继续。（如果应用的规则是终止规则，则停止执行算法。） [1] MarkovJunior Markov Junior是一种基于概率的编程语言，通过重写和传播规则（约束）来实现随机的生成和编写。最终对画布进行重写来实现随机的生成。\n如上图所示，基础规则的约束以上图所示的色块变换和Pattern决定，再基于马尔可夫算法的规则，从上到下的规则逐渐进行转化和重写，实现最终关卡和规则的生成。\n具体的例子如下，通过设定红色起点和颜色转换规则来进行全局的随机搜索实现色块的变化最后生成迷宫。\n最基本的规则如上图所示，更为复杂的规则和写法可以通过参考GIthub上面的样例并进行自我实现来学习一下。\n实现和测试 ","permalink":"https://hugotest-phi.vercel.app/posts/markovjunior/","summary":"\u003cp\u003e@Reference: \u003ca href=\"https://mp.weixin.qq.com/s?__biz=MzIxODg1OTk1MA==\u0026amp;mid=2247513354\u0026amp;idx=1\u0026amp;sn=28b5492cc0a86b04f0a0b975bf42568c\u0026amp;ascene=56\u0026amp;devicetype=iOS15.5\u0026amp;version=1800172f\u0026amp;nettype=WIFI\u0026amp;abtest_cookie=AAACAA%3D%3D\u0026amp;lang=zh_CN\u0026amp;fontScale=100\u0026amp;exportkey=ARSr9kinLTM%2B6fr7WYBKF%2FM%3D\u0026amp;pass_ticket=gK4kcTE5wfRRXzd0FMTJlg9zBNGh%2BZ5VoWQkUbqSJXykXGIdMXasyLJgUxII1IDt\u0026amp;wx_header=3\" target=\"_blank\" rel=\"noopener\"\u003eJack Cui\u003c/a\u003e\n | \u003ca href=\"https://github.com/mxgmn/MarkovJunior\" target=\"_blank\" rel=\"noopener\"\u003eGithub-Markov Junior\u003c/a\u003e\n | \u003ca href=\"https://github.com/mxgmn/MarkovJunior\" target=\"_blank\" rel=\"noopener\"\u003eWiki Markov algorithm\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e第一篇文章简要介绍了一下该编程语言能实现什么效果；第二个是官方repo，其文档和代码都有很强的借鉴意义；第三个是wikipedia对马尔可夫算法的解释，在该编程语言的实现中有重要的意义。\u003c/p\u003e\n\u003ch2 id=\"markov-algorithm\"\u003emarkov algorithm\u003c/h2\u003e\n\u003cp\u003e马尔可夫算法指的是字符串重写算法，其基本逻辑如下:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e自顶向下依次检查规则，看是否能在符号串中找到任何在箭头左边的字符串。\u003c/li\u003e\n\u003cli\u003e如果没有找到，停止执行算法。\u003c/li\u003e\n\u003cli\u003e如果找到一个或多个，把符号串中的最左匹配的文字替换为在第一个相应规则的箭头右边的字符串。\u003c/li\u003e\n\u003cli\u003e返回步骤1并继续。（如果应用的规则是终止规则，则停止执行算法。） [1]\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220710134410108.png\"\u003e\r\n    \u003cimg alt=\"image-20220710134410108\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220710134410108.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/image-20220710134410108.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20220710134410108\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"markovjunior\"\u003eMarkovJunior\u003c/h2\u003e\n\u003cp\u003eMarkov Junior是一种基于概率的编程语言，通过重写和传播规则（约束）来实现随机的生成和编写。最终对画布进行重写来实现随机的生成。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://github.com/mxgmn/MarkovJunior/raw/main/images/top-iso.gif\"\u003e\r\n    \u003cimg alt=\"sample\" loading=\"lazy\" src=\"https://github.com/mxgmn/MarkovJunior/raw/main/images/top-iso.gif\"class=\"responsive-image\" src=\"https://github.com/mxgmn/MarkovJunior/raw/main/images/top-iso.gif\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"sample\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Markov Junior"},{"content":"@Reference: Github-Mxgmn | zhihu 概念简介和复习 本质上该方法的底层思想就是条件概率的启发式随机生成算法。\n波函数坍塌 在介绍算法之前首先需要明确几个概念，第一个就是**“波函数坍塌”（名字的来源是量子力学中的概念），参考“薛定谔的猫”，可以理解成：在一系列的不确定像素（存在多种可能）的基础之上，通过确定的规则**、相关关系，随机的将所有的像素变成确定的状态。（可以通过给定种子来启动，也可以通过随机规则来启动），实现在一定规则或者模式下的随机生成。\n熵 熵作为热力学中，表示物理状态的参量，其含义在于表示物质的混乱程度（正相关）。在当前的场景下，使用信息熵（而非热熵）来衡量变量的不确定程度（完全随机，或者有限随机，或者二选一等等）。\n$$ H(X) = \\sum_{x\\in X}p(x)log p(x)\r$$\r式中描述的是信息熵的计算公式，在实际应用中，可以使用任何表示状态不确定程度的度量来进行一下的计算。\n算法原理-流程 动态地使可选的范围越来越小，直到最后整体都是确定的状态。而缩小范围的方法核心可以总结为（数独）：\n约束规则、状态传播、回溯\n从最小熵的单位开始坍缩，保证最小概率的坍缩失败，从而减少大量的回溯过程，来减少计算量。\n以地图生成为例：\n约束规则：（选择一个熵最小的slot开始）针对于每个slot的坍缩，是在ModuleSet（可选模块集合）中随机取一个概率最高的模块，进行合成，而这个概率受我们制定的规则，周边的Slot的状态影响。 状态传播：模块确定后就将该状态和规则传递到相邻的moduleset中，删除不匹配的模块等。 回溯：当坍缩陷入矛盾（与规则相互矛盾，坍缩失效），就对状态进行回溯（Backtrack）重新进行状态搜索和回溯。\nRead the input bitmap and count NxN patterns. (optional) Augment pattern data with rotations and reflections. Create an array with the dimensions of the output (called \u0026ldquo;wave\u0026rdquo; in the source). Each element of this array represents a state of an NxN region in the output. A state of an NxN region is a superposition of NxN patterns of the input with boolean coefficients (so a state of a pixel in the output is a superposition of input colors with real coefficients). False coefficient means that the corresponding pattern is forbidden, true coefficient means that the corresponding pattern is not yet forbidden. Initialize the wave in the completely unobserved state, i.e. with all the boolean coefficients being true. Repeat the following steps: Observation: Find a wave element with the minimal nonzero entropy. If there is no such elements (if all elements have zero or undefined entropy) then break the cycle (4) and go to step (5). Collapse this element into a definite state according to its coefficients and the distribution of NxN patterns in the input. Propagation: propagate information gained on the previous observation step. By now all the wave elements are either in a completely observed state (all the coefficients except one being zero) or in the contradictory state (all the coefficients being zero). In the first case return the output. In the second case finish the work without returning anything. Code 官方仓库中有诸多样例和各种代码版本的实现，可以参考并实现部分版本。\n样例解读 样例实现 ","permalink":"https://hugotest-phi.vercel.app/posts/wfc%E7%AE%97%E6%B3%95/","summary":"\u003cp\u003e@Reference: \u003ca href=\"https://github.com/mxgmn/WaveFunctionCollapse\" target=\"_blank\" rel=\"noopener\"\u003eGithub-Mxgmn\u003c/a\u003e\n | \u003ca href=\"https://zhuanlan.zhihu.com/p/66416593\" target=\"_blank\" rel=\"noopener\"\u003ezhihu\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"概念简介和复习\"\u003e概念简介和复习\u003c/h2\u003e\n\u003cp\u003e本质上该方法的底层思想就是条件概率的启发式随机生成算法。\u003c/p\u003e\n\u003ch3 id=\"波函数坍塌\"\u003e波函数坍塌\u003c/h3\u003e\n\u003cp\u003e在介绍算法之前首先需要明确几个概念，第一个就是**“波函数坍塌”\u003cstrong\u003e（名字的来源是量子力学中的概念），参考\u003c/strong\u003e“薛定谔的猫”\u003cstrong\u003e，可以理解成：在一系列的不确定像素（存在多种可能）的基础之上，通过\u003c/strong\u003e确定的规则**、\u003cstrong\u003e相关关系\u003c/strong\u003e，随机的将所有的像素变成确定的状态。（可以通过给定种子来启动，也可以通过随机规则来启动），实现在一定规则或者模式下的随机生成。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch3 id=\"熵\"\u003e熵\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e熵\u003c/strong\u003e作为热力学中，表示物理状态的参量，其含义在于表示物质的\u003cstrong\u003e混乱程度\u003c/strong\u003e（正相关）。在当前的场景下，使用信息熵（而非热熵）来衡量变量的\u003cstrong\u003e不确定程度\u003c/strong\u003e（完全随机，或者有限随机，或者二选一等等）。\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\nH(X) = \\sum_{x\\in X}p(x)log p(x)\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e式中描述的是信息熵的计算公式，在实际应用中，可以使用任何表示状态不确定程度的度量来进行一下的计算。\u003c/p\u003e\n\u003ch2 id=\"算法原理-流程\"\u003e算法原理-流程\u003c/h2\u003e\n\u003cp\u003e动态地使可选的范围越来越小，直到最后整体都是确定的状态。而缩小范围的方法核心可以总结为（数独）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e约束规则\u003c/strong\u003e、\u003cstrong\u003e状态传播\u003c/strong\u003e、\u003cstrong\u003e回溯\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e从最小熵的单位开始坍缩，保证最小概率的坍缩失败，从而\u003cstrong\u003e减少大量的回溯\u003c/strong\u003e过程，来减少计算量。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以\u003cstrong\u003e地图生成\u003c/strong\u003e为例：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e约束规则\u003c/strong\u003e：（选择一个熵最小的slot开始）针对于每个slot的坍缩，是在ModuleSet（可选模块集合）中随机取一个概率最高的模块，进行合成，而这个概率受我们制定的\u003cstrong\u003e规则\u003c/strong\u003e，\u003cstrong\u003e周边的Slot\u003c/strong\u003e的状态影响。\n\u003cstrong\u003e状态传播\u003c/strong\u003e：模块确定后就将该状态和规则传递到相邻的moduleset中，删除不匹配的模块等。\n\u003cstrong\u003e回溯\u003c/strong\u003e：当坍缩陷入矛盾（与规则相互矛盾，坍缩失效），就对状态进行回溯（Backtrack）重新进行状态搜索和回溯。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003col\u003e\n\u003cli\u003eRead the input bitmap and count NxN patterns.\n\u003col\u003e\n\u003cli\u003e(optional) Augment pattern data with rotations and reflections.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eCreate an array with the dimensions of the output (called \u0026ldquo;wave\u0026rdquo; in the source). Each element of this array represents a state of an NxN region in the output. A state of an NxN region is a superposition of NxN patterns of the input with boolean coefficients (so a state of a pixel in the output is a superposition of input colors with real coefficients). False coefficient means that the corresponding pattern is forbidden, true coefficient means that the corresponding pattern is not yet forbidden.\u003c/li\u003e\n\u003cli\u003eInitialize the wave in the completely unobserved state, i.e. with all the boolean coefficients being true.\u003c/li\u003e\n\u003cli\u003eRepeat the following steps:\n\u003col\u003e\n\u003cli\u003eObservation:\n\u003col\u003e\n\u003cli\u003eFind a wave element with the minimal nonzero entropy. If there is no such elements (if all elements have zero or undefined entropy) then break the cycle (4) and go to step (5).\u003c/li\u003e\n\u003cli\u003eCollapse this element into a definite state according to its coefficients and the distribution of NxN patterns in the input.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003ePropagation: propagate information gained on the previous observation step.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eBy now all the wave elements are either in a completely observed state (all the coefficients except one being zero) or in the contradictory state (all the coefficients being zero). In the first case return the output. In the second case finish the work without returning anything.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"code\"\u003eCode\u003c/h2\u003e\n\u003cp\u003e官方仓库中有诸多样例和各种代码版本的实现，可以参考并实现部分版本。\u003c/p\u003e","title":"Wave Function Collapse"},{"content":"Star this Project in Github after u decide to use it.\nDownload \u0026amp; Install Firstly, Cpy z.sh to the path u want make this script can be recognizabled by your shell like zsh, bash.\n1 2 cd ~ wget https://raw.githubusercontent.com/rupa/z/master/z.sh Secondly, add . ~/z.sh to the end of your .zshrc ，u can use following cmd also\n1 2 3 echo \u0026#34;. ~/z.sh\u0026#34; \u0026gt;\u0026gt; ~/.zshrc # then using this to check tail -n 5 ~/.zshrc Fi, activate it.\n1 source ~/.zshrc Usage and Description 以以下的目录为例：the/path/to/UniFramwork，演示该jumper的使用方式。我们首先需要进入（cd）过对应的目录，z将会记录看，并计算相应的权重，通过其维护的List来进行快速跳转，在完成记录后，我们即可用下面跳转到项目文件夹：\n1 2 3 z uni z un ..... 于我而言，我认为其核心的优势在于，可在任何目录进行跳转 至目标目录，同时尽量的简短需要键入的文本.\nUpdate ref: zsh-z , 目前 z 可以直接作为 zsh 的 plugin 配置\nFI ","permalink":"https://hugotest-phi.vercel.app/posts/linux_cli_z/","summary":"\u003cp\u003eStar this \u003ca href=\"https://github.com/rupa/z\" target=\"_blank\" rel=\"noopener\"\u003eProject\u003c/a\u003e\n in Github after u decide to use it.\u003c/p\u003e\n\u003ch2 id=\"download--install\"\u003eDownload \u0026amp; Install\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eFirstly\u003c/strong\u003e, Cpy \u003ccode\u003ez.sh\u003c/code\u003e to the path u want make this script can be \u003cstrong\u003erecognizabled by your shell\u003c/strong\u003e like zsh, bash.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget https://raw.githubusercontent.com/rupa/z/master/z.sh\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eSecondly\u003c/strong\u003e, add \u003ccode\u003e. ~/z.sh\u003c/code\u003e  to the end of your \u003ccode\u003e.zshrc\u003c/code\u003e ，u can use following cmd also\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;. ~/z.sh\u0026#34;\u003c/span\u003e \u0026gt;\u0026gt; ~/.zshrc\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# then using this to check \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etail -n \u003cspan class=\"m\"\u003e5\u003c/span\u003e ~/.zshrc\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eFi\u003c/strong\u003e, activate it.\u003c/p\u003e","title":"Using Z Jumper in CLI"},{"content":"Hexo和Gitee一致，都是由Markdown文件为基础，构建的博客，编写Markdown本身无需多言，由于Hexo并非笔者的首选笔记管理方式，故而再其他地方构建和编写文件是常态，该Blog主要是利用其他工具来方便Hexo博文的编写（Header）\n默认的是 hexo new [layout] title 可简写为 hexo n [layout] title，其中布局应该是在博客目录中定义，该命令也局限于博客的对应目录。\npost(默认)、draft、page\n除了默认的方法，本篇将介绍Obsidian、VsCode-like、Vim自动添加Header的方式，用以方便随时随地的编写博文。\n同时为了方便已有笔记迁移，本文也编写了Python脚本，CPY后为Target Dir的版本自动添加Header，但是其中对应的Catagories最好还是手动修改一下。\nObsidian 通过template插件，按照对应主题的Header样式添加，可以去官方文档中找对应的语法和说明。从而构建自己的Template\nWorkflow：插件市场添加Template -\u0026gt; 设置指定Template文件夹 -\u0026gt; 按照语法编写Template文件 -\u0026gt; 使用快捷键插入模板\n由于这一块没有什么存在歧义的操作，就不赘述，唯一需要注意的是语法，简单参考一下官方的Example 即可，无需过于深入\n本文使用的是Live my Life的Hexo-Theme，模板文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- title: \u0026lt;% tp.file.title %\u0026gt; catalog: true data: \u0026lt;% tp.date.now(\u0026#34;YYYY-MM-DD HH:mm:ss\u0026#34;) %\u0026gt; subtitle: lang: cn header-img: /img/header_img/lml_bg1.jpg tag: - categories: - mathjax: true sticky: 22 --- 实际上各个模块的操作思想都是一致的Snippet方案。\nVim/Nvim 通过Vimscript设置或者Lua的设置文件，令Vim，Neovim再新建.md的同时，为其添加默认Header。Lua实际上调用的是Vimscript的接口，这里仅给出.lua版本，相应的转换不在赘言。\n配置NeoVim中的 ~/.config/nvim/lua/basic/config.lua\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 vim.cmd(\u0026#39;autocmd BufNewFile *.md,*.sh,*.cpp,*.py,*.lua exec \u0026#34;:lua set_title()\u0026#34;\u0026#39;) function set_title() filetype = vim.fn.expand(\u0026#34;%:e\u0026#34;) -- set title for markdown if filetype == \u0026#34;md\u0026#34; then vim.fn.setline(\u0026#34;1\u0026#34;, \u0026#34;--- \u0026#34; .. vim.fn.expand(\u0026#34;%\u0026#34;)) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;), \u0026#34;\u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+1, \u0026#34;Author: AikenHong \u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+2, \u0026#34;Mail: h.aiken.970@gmail.com \u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+3, \u0026#34;Date: \u0026#34; .. os.date(\u0026#34;%Y-%m-%d %H:%M:%S \u0026#34;)) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+4, \u0026#34;Desc: \u0026#34;)](\u0026lt;vim.fn.setline(\u0026#34;1\u0026#34;, \u0026#34;---\u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;), \u0026#34;title: \u0026#34; .. vim.fn.expand(\u0026#34;%\u0026#34;)) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+1, \u0026#34;catalog: true\u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+2, \u0026#34;subtitle: \u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+3, \u0026#34;date: \u0026#34; .. os.date(\u0026#34;%Y-%m-%d %H:%M:%S \u0026#34;)) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+4, \u0026#34;lang: cn\u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+5, \u0026#34;header-img: /img/header_img/lml_bg1.jpg\u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+6, \u0026#34;tag: \u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+7, \u0026#34;- \u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+8, \u0026#34;categories: \u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+9, \u0026#34;- \u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+10, \u0026#34;mathjax: true\u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+11, \u0026#34;sticky: \u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+12, \u0026#34;\u0026#34;) vim.fn.append(vim.fn.line(\u0026#34;.\u0026#34;)+13, \u0026#34;---\u0026#34;)\u0026gt;) end end 这样当我们用nvim newblog.md的时候，会自动添加上Header。\nVscode 使用Snippet插件添加代码片段，等待补充。\nConvert md2Blogs 使用Python脚本为原有.md 批量添加Header，缺点是不太灵活，但是用于初始化还是能省不少事。如果原本按照Tag，或者Categories进行文件夹归类的话，倒是能起到不错的初始化效果。\nShut Out and Show my Code：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # define the path of saving and the target path. # Specific for windows or Linux version yourself def get_all_blogs(path): # get all blog path. dirs = os.listdir(BlogPath) blogs = [] for blog_dir in dirs: if blog_dir not in [\u0026#39;.obsidian\u0026#39;,\u0026#39;_book\u0026#39;, \u0026#39;Day Planners\u0026#39;, \u0026#39;node_module\u0026#39;,\u0026#39;Draft\u0026#39;]: tmpdir = os.path.join(BlogPath, blog_dir) blogs += glob.glob(tmpdir + \u0026#39;/*.md\u0026#39;) # del using _ replace space of filename. for blog in blogs: if \u0026#39; \u0026#39; in blog: blog = blog.replace(\u0026#39; \u0026#39;, \u0026#39;_\u0026#39;) print(blog) return blogs 获取文件后我们需要得到文件的一些基本属性，用于Header中对应值的填充\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # TODO: get the basic info of each blog # title(name of files) \\ catalog: true \\ data: create time \\ subtitle: desc \\ lang cn\\en # header-img: we can create a loop to generate this part. # tags, categories, mathjax. def change_realtime(timestamp): time_struct = time.localtime(timestamp) return time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, time_struct) def get_attribute(blog, verbose=False): attr = {} # get timestamp. create_time = os.path.getctime(blog) modify_time = os.path.getmtime(blog) attr[\u0026#39;data\u0026#39;] = change_realtime(create_time) attr[\u0026#39;m_data\u0026#39;] = change_realtime(modify_time) # get tags and categories. tags = blog.split(\u0026#39;\\\\\u0026#39;)[-2] attr[\u0026#39;tags\u0026#39;] = tags attr[\u0026#39;categories\u0026#39;] = tags # get title. with open(blog, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as f: lines = f.readlines() title = lines[0].strip().split(\u0026#39;#\u0026#39;)[1] attr[\u0026#39;title\u0026#39;] = title # default attr attr[\u0026#39;lang\u0026#39;] = \u0026#39;cn\u0026#39; # verbose: if verbose: print(blog, \u0026#39;\\n\u0026#39;, attr) return attr 为了不意外损坏源文件，同时保持源文件的结构、组织和属性等等，我们Cpy并只对副本进行操作，cpy的同时转移文件路径到所需地点。\n1 2 3 4 5 def cpy_files(blog,target): \u0026#34;\u0026#34;\u0026#34;cpy files to the target path\u0026#34;\u0026#34;\u0026#34; filename = os.path.basename(blog) os.system(\u0026#39;cp \u0026#39; + blog + \u0026#39; \u0026#39; + target + filename) return target + filename 在获取完基本属性和转移后，我们需要开始对文件进行添加header的处理,在这里我们添加了一个Loop为Blog设置不同的背景图片，根据自己有多少图片进行自定义设置吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def add_header(blog,index=0,attr=None): \u0026#34;\u0026#34;\u0026#34;add default header for each files\u0026#34;\u0026#34;\u0026#34; header_imgs = [\u0026#34;\u0026#34;,1, 2, 3, 4,5] with open(blog, \u0026#34;r+\u0026#34;, encoding=\u0026#39;UTF-8\u0026#39;) as f: old = f.read() f.seek(0) f.write(\u0026#34;---\\n\u0026#34;) f.write(\u0026#34;title: \u0026#34; + attr[\u0026#39;title\u0026#39;] + \u0026#34;\\n\u0026#34;) f.write(\u0026#34;catalog: true\\n\u0026#34;) f.write(\u0026#34;date: \u0026#34; + attr[\u0026#39;data\u0026#39;] + \u0026#34;\\n\u0026#34;) f.write(\u0026#34;subtitle: \\n\u0026#34;) f.write(\u0026#34;lang: \u0026#34; + attr[\u0026#39;lang\u0026#39;] + \u0026#34;\\n\u0026#34;) f.write(\u0026#34;header-img: \u0026#34; + \u0026#39;/img/header_img/lml_bg{}.jpg\u0026#39;.format(index%6) + \u0026#34;\\n\u0026#34;) f.write(\u0026#34;tags: \u0026#34; + \u0026#34;\\n\u0026#34;) f.write(\u0026#34;- \u0026#34; + attr[\u0026#39;tags\u0026#39;] + \u0026#34;\\n\u0026#34;) f.write(\u0026#34;categories: \u0026#34; + \u0026#34;\\n\u0026#34;) f.write(\u0026#34;- \u0026#34; + attr[\u0026#39;categories\u0026#39;] + \u0026#34;\\n\u0026#34;) f.write(\u0026#34;---\\n\u0026#34;) f.write(old) return 然后就是执行文件夹的批量处理了。可以添加args便于对多个文件夹进行处理，或者控制只变换单个文件等，应该需求不大，且代码比较简单，这里就暂时不贴出了。\n1 2 3 4 5 6 7 8 9 10 def dir_process(): blogs = get_all_blogs(BlogPath) for i,blog in enumerate(blogs): b_attr = get_attribute(blog) new_blog = cpy_files(blog, TargetPath) add_header(new_blog, index=i, attr=b_attr) if __name__ == \u0026#39;__main__\u0026#39;: dir_process() print(\u0026#39;Done!\u0026#39;) ","permalink":"https://hugotest-phi.vercel.app/posts/hexo_write/","summary":"\u003cp\u003eHexo和Gitee一致，都是由Markdown文件为基础，构建的博客，编写Markdown本身无需多言，由于Hexo并非笔者的首选笔记管理方式，故而再其他地方构建和编写文件是常态，该Blog主要是利用其他工具来方便Hexo博文的编写（Header）\u003c/p\u003e\n\u003cp\u003e默认的是 \u003ccode\u003ehexo new [layout] title\u003c/code\u003e 可简写为 \u003ccode\u003ehexo n [layout] title\u003c/code\u003e，其中布局应该是在博客目录中定义，该命令也局限于博客的对应目录。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003epost(默认)、draft、page\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e除了默认的方法，本篇将介绍Obsidian、VsCode-like、Vim自动添加Header的方式，用以方便随时随地的编写博文。\u003c/p\u003e\n\u003cp\u003e同时为了方便已有笔记迁移，本文也编写了Python脚本，CPY后为Target Dir的版本自动添加Header，但是其中对应的Catagories最好还是手动修改一下。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"obsidian\"\u003eObsidian\u003c/h2\u003e\n\u003cp\u003e通过\u003cstrong\u003etemplate\u003c/strong\u003e插件，按照对应主题的Header样式添加，可以去官方文档中找对应的语法和说明。从而构建自己的Template\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWorkflow\u003c/strong\u003e：插件市场添加Template -\u0026gt; 设置指定Template文件夹 -\u0026gt; 按照语法编写Template文件 -\u0026gt; 使用快捷键插入模板\u003c/p\u003e\n\u003cp\u003e由于这一块没有什么存在歧义的操作，就不赘述，唯一需要注意的是语法，简单参考一下\u003ca href=\"https://silentvoid13.github.io/Templater/\" target=\"_blank\" rel=\"noopener\"\u003e官方的Example\u003c/a\u003e\n即可，无需过于深入\u003c/p\u003e\n\u003cp\u003e本文使用的是Live my Life的Hexo-Theme，模板文件如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e---\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003etitle\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;%\u003c/span\u003e \u003cspan class=\"nx\"\u003etp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003efile\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003etitle\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ecatalog\u003c/span\u003e: \u003cspan class=\"kt\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;%\u003c/span\u003e \u003cspan class=\"nx\"\u003etp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003edate\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;YYYY-MM-DD HH:mm:ss\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003esubtitle\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003elang\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003ecn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003eheader\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eimg\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"err\"\u003e/img/header_img/lml_bg1.jpg\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003etag\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ecategories\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003emathjax\u003c/span\u003e: \u003cspan class=\"kt\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003esticky\u003c/span\u003e: \u003cspan class=\"kt\"\u003e22\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e---\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e实际上各个模块的操作思想都是一致的Snippet方案。\u003c/p\u003e","title":"Hexo Write"},{"content":"该文档主要目的是用于测试Latex语法对应前端的渲染能力，主要用于测试Hexo站点是否能正常渲染Latex。\nExample1: 2 inline in one sentence.\nWhen $a \\ne 0$ , there are two solutions to $(ax^2 + bx + c = 0)$ and they are\n$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. $$\rExample2: Matrix Example\n$$ \\begin{bmatrix} 1\u0026x\u0026x^2\\\\ 1\u0026y\u0026y^2\\\\ 1\u0026z\u0026z^2 \\end{bmatrix}\r\\\\\r\\begin{bmatrix} 1\u0026x\u0026x^2\\\\\\\\ 1\u0026y\u0026y^2\\\\\\\\ 1\u0026z\u0026z^2 \\end{bmatrix}\r\\\\\rvmatrix ||、Bmatrix{}、pmatrix()\r$$\rExample3: the Conditional Formula\n$$ f(x)=\r\\begin{cases}\r0\u0026 \\text{x=0}\\\\\\\\\r1\u0026 \\text{x!=0}\r\\end{cases}\r$$\rExample4: Sprcial Symboy\n$$ \\lim_{\\alpha \\rightarrow +\\infty} \\frac{1}{\\alpha(\\beta+1)}\r$$\rExample5: Complex Function Which Occurs Error in Much Situation\n$$ \\begin{gathered}\r\\mathcal{L}_{POD-final} = \\frac{\\lambda_c}{L-1}\\sum_{l=1}^{L-1} \\mathcal{L}_{POD-spatial}(f_l^{t-1}(x),f_l^t(x)) + \\\\\r\\lambda_f \\mathcal{L}_{POD-flat}(f_l^{t-1}(x),f_l^t(x))\r\\end{gathered}\r$$\rExample6：Mathbb、Text、etc\u0026hellip;\n$$ \\mathcal{L}_{\\text {POD-pixel }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C} \\sum_{w=1}^{W} \\sum_{h=1}^{H}\\left\\|\\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2}\r$$\rExample7: Multiple Lines of Loss in Incremental Learning\n$$ \\begin{gathered}\r\\mathcal{L}_{\\text {POD-channel }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{w=1}^{W} \\sum_{h=1}^{H}\\left\\|\\sum_{c=1}^{C} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{c=1}^{C} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2} \\\\\r\\mathcal{L}_{\\text {POD-gap }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C}\\left\\|\\sum_{w=1}^{W} \\sum_{h=1}^{H} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{w=1}^{W} \\sum_{h=1}^{H} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2} \\\\\r\\mathcal{L}_{\\text {POD-width }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C} \\sum_{h=1}^{H}\\left\\|\\sum_{w=1}^{W} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{w=1}^{W} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2}\r\\end{gathered}\r$$\r如果这些都能正确渲染的话，基本整个文档中的Latex基本渲染应该都没问题，用该文档能验证当前本地渲染的版本是否是正确的。\n","permalink":"https://hugotest-phi.vercel.app/posts/latex_testing/","summary":"\u003cp\u003e该文档主要目的是用于测试Latex语法对应前端的渲染能力，主要用于测试Hexo站点是否能正常渲染Latex。\u003c/p\u003e\n\u003cp\u003eExample1: 2 inline in one sentence.\u003c/p\u003e\n\u003cp\u003eWhen $a \\ne 0$ , there are two solutions to $(ax^2 + bx + c = 0)$ and they are\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. $$\r\n\u003c/div\u003e\r\n\u003cp\u003eExample2: Matrix Example\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\n\\begin{bmatrix} 1\u0026x\u0026x^2\\\\ 1\u0026y\u0026y^2\\\\ 1\u0026z\u0026z^2 \\end{bmatrix}\r\n\\\\\r\n\\begin{bmatrix} 1\u0026x\u0026x^2\\\\\\\\ 1\u0026y\u0026y^2\\\\\\\\ 1\u0026z\u0026z^2 \\end{bmatrix}\r\n\\\\\r\nvmatrix ||、Bmatrix{}、pmatrix()\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003eExample3: the Conditional Formula\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\nf(x)=\r\n\\begin{cases}\r\n0\u0026 \\text{x=0}\\\\\\\\\r\n1\u0026 \\text{x!=0}\r\n\\end{cases}\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003eExample4: Sprcial Symboy\u003c/p\u003e","title":"Latex tesing"},{"content":"该文档用以，记录自己（外行）利用Hexo建立Blog的过程，将原本用Gitbook构建的笔记转移到Hexo中，同时购买域名并部署其上。网页部署于Github Page 。以Live my Live主题为例。\n腾讯云和Github Page的操作和理解在现有的一些博客中过时了，或者说存在一些问题，后续会对此进行简单的讲解。同时大部分博客都是使用NexT主题进行配置，这里采用的是Live My Life主题，该博文介绍自己的粗浅理解，也为自己后续的工作进行一定的参考。\n还存在一些没有解决的问题：\n对主题切换和主题配置和全局配置的的深入理解（Live my Life主题覆盖了很多默认配置） 前端代码的理解，自定义Layout，超链接，图标等 深入理解插件的应用和自定义 推送网站到baidu和google（Option）（没有计划） 之后有时间的话可以去研究一下：\n关键词：Hexo_Livemylive、Github Page、腾讯云（Domain、DNS、SSL）\nEnvironment 需要准备的环境如下：本地Node（NPM），Page部署Git（SSH），可在Windows，Linux，WSL2中部署均可，但需要注意的是，如果在WSL2中进行部署，生成速度与部署速度会明显慢于宿主机。\n首先安装NodeJS、NPM、Git并验证是否成功安装，根据Linux和Windows不同环境进行安装，可以去官网了解相关的安装步骤，或者参考Gitee和Github的两篇博文。\n为了更好的编写笔记，最好配置一个图床，图床的配置可以使用Github、Gitee或者腾讯云的COS服务，相关的配置可以参考LInk 1 2 3 git version node -v npm -v 安装Hexo\n1 2 3 4 npm install -g hexo-cli # 查看Hexo的版本 hexo -v Initialize Blog 对博客目录初始化：hexo init blog，blog为空的话初始化当前文件夹，初始化后基本结构如下：\n1 2 3 4 5 6 7 8 9 . ├── _config.yml # 网站的全局配置信息，在此配置大部分的参数。 ├── package.json # 定义Hexo，以及对应安装的依赖的版本等 ├── node_module: # Hexo安装插件的位置 ├── scaffolds # 页面模版文件夹 ├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹 | ├── _drafts # 草稿文件 | └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 有了初始化的目录后，就可以参考相关主题的官方介绍页面进行对应的 配置，不同的主题可能有不同的配置方法。接下来我们会以《Live my life》 主题为例。\n后续基于别的主题对文件配置有了更深入的理解后，会对配置部分进行更新说明，或另开一贴。\nGithub 本文使用Github Page构建自己的静态站点，用于部署自己的网页。GitHub只能使用一个同名仓库托管一个静态站点：aikenh.github.io，但是可以在此站之上，使用其他仓库构建子域名如: aikenh.github.io/Docs\nGit和Github仓库和链接的初始化参见GitWorkflow ；对应的io，可以通过建立【UserName】.github.io为名的Repo，并在Setting-\u0026gt; Code and automation -\u0026gt; Page中选择对应的Branch作为Source.\n完成后如图所示，后续设置好域名解析服务后后可在Custom domain中设置你的自定义域名，github.io将自动转换成该域名，会在域名解析部分详细介绍\n创建完该网站Github的初始部分差不多完成。\nConfig-livemylife 本章节的基本操作均针对_config.yml进行。\n基于我的理解，为了便于多主题的配置和切换，在主Config.yml 中应该尽量不参与特定主题的设置，而在Theme/SpecificTheme/_config.yml中为每个主题定制基本的配置为好。但目前只用过这个主题，就以此为例。\n更多的设置去主题的readme中查看和设置。\n初始化主题：设置主题的基本需求，并基于此安装相关依赖\n1 2 3 4 5 6 cd blog rm -rf scaffolds source themes _config.landscape.yml _config.yml package.json yarn.lock #just keep node_modules git clone https://github.com/V-Vincen/hexo-theme-livemylife.git mv hexo-theme-livemylife/* ./ rm -rf hexo-theme-livemylife npm install 设置主题：修改配置中的theme值\n1 2 3 4 5 theme: livemylife themecolor: enable: true mode: light 完成了基础设置后，可以直接在本地运行博客，查看效果，方便后续调试后部署，具体命令如下\n1 2 3 hexo cl \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo s -p your-port # default port is 4000 hexo g \u0026amp;\u0026amp; hexo s Basic Configs 使用自己的信息修改配置文件的对应选项，以下介绍一些基本属性配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # header title: My_Blog subtitle: some description of u or ur site author: NickName timezone: # url url: http://aikenh.cn # note: 不要忘了修改source文件中的CNAME root: permalink: :lang/:title/ # 子页面的链接形式 # site setting SEOTitle: Names Blog # 标签栏显示的标题 email： description: \u0026#34;Development Documentation\u0026#34; keyword: \u0026#34;name,Name,blog,Blog\u0026#34; header-img: img/header_img/bg_img.jpg # 标题图像的存储路径，Source为根路径 favicon: img/avatar/f_img.png # 标签栏显示的图像 # 暂时不使用签名 signature: false signature-img: _ 不使用Internationalization 设置，关掉选项：\n1 2 langselect: enable: false 该选项会关闭生成语言选择按钮。\nEffects custom 该部分控制页面的特效设置。主要包括关闭线段背景，线段背景消耗CPU的同时还会遮挡文字，故而关闭；鼠标点击特效mouseclick关闭，在界面使用的时候异常选中的问题以及遮挡的问题。\n1 2 3 4 5 6 7 8 9 10 wave: true # false can not disable this, should del content and color alse mouseclick: enable: false content: color: ribbonDynamic: true bglinecanvas: false Sidebar \u0026amp; SNS 启用侧边栏放置相关的个人信息，SNS的设置实际上也与该部分相关，会显示在头像的下方。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 sidebar: true # whether or not using Sidebar. sidebar-about-description: \u0026#34;making trash\u0026#34; sidebar-avatar: img/avatar/samura.jpg # use absolute URL, seeing it\u0026#39;s used in both `/` and `/about/` widgets: - visitor # busuanzi: https://busuanzi.ibruce.info/ - featured-tags - short-about - recent-posts - friends-blog - archive - category # widget behavior 设置相关的Archieve侧边部件 ## Archive archive_type: \u0026#39;monthly\u0026#39; show_count: true ## Featured Tags featured-tags: true # whether or not using Feature-Tags featured-condition-size: 0 # A tag will be featured if the size of it is more than this condition value ## Friends 友站设置 friends: [ { title: \u0026#34;GitBook\u0026#34;, href: \u0026#34;https://Name.github.io/Docs\u0026#34; }, { title: \u0026#34;Hexo\u0026#34;, href: \u0026#34;https://hexo.io/\u0026#34; }] # SNS Settings just enable what u want. RSS: false github_username: yourAccount twitter_username: yourAccount # instagram_username: # facebook_username: yourAccount # linkedin_username: yourAccount zhihu_username: yourAccount weibo_username: numid of weibo in url Layout Custom 修改一些页面布局，除了一些基础设置，还有还有一些对应的标签问题。\n1 2 3 4 5 6 7 8 9 10 11 12 # top scroll progress scroll: true # make article sticky top: true # count word for each doc wordcount: true # show tag of each article home_posts_tag: true # anchorjs 设置锚点 anchorjs: true socialshare: true viewer: true 页面的Newer Posts和Old Posts在theme中，根据不同的语言选项去修改即可。 页面背景在博文中通过Header（Meta-data）设置，批量转化的时候可以通过代码循环生成，后续进行转化的时候最好依靠随机数指定。\nGithub Page 安装部署插件如下：\n1 npm install hexo-deployer-git --save 实际上就是将public 文件夹push到对应仓库的指定分支，有插件能够直接执行该操作，在config中执行如下设置：\n1 2 3 4 deploy: type: git repo: https://github.com/\u0026lt;yourAccount\u0026gt;/\u0026lt;repo\u0026gt; # or https://gitee.com/\u0026lt;yourAccount\u0026gt;/\u0026lt;repo\u0026gt; branch: \u0026lt;your-branch\u0026gt; 之后执行 hexo d即可\nMathjax（TB fix） 用于下一次验证的策略：手动添加MathJa支持而不基于Kramed ，基于此思想迁移到Mathjax3 ，也避免了Kramed和Prismjs的冲突。\n支持公式的方式主要有以下 的几种思路，该设置实际上主要是和Next主题相关，包括Katex等\n该主题目前使用的是Mathjax + kramed + it的方式。\n官方描述对应的Latex支持, 该部分目前的渲染效果处于玄学状态，有时候能用，有时候针对一些语法会出现渲染错误，但是并不能很好的定位到错误的原因。现象如下：\n缩略图中出现正常的渲染，而在正文中只显示公式 部分语法可以正常渲染，稍微复杂一点的无法渲染，且原因不定。 目前猜测可能与Package有一定的关系，在对hexo-renderer-marked等Package进行操作后，可能就会恢复正常。\n当前情况下在Windows清除，在WSL2中执行Hexo命令好像就可以，非常的玄学。\n目前按照主题 的方式（默认已配置好），后续如果效果仍然不稳定，可能会对渲染的方式进行改动。比如利用math的jax支持 ，或者基于pandoc 的方式把。后续再出现问题的话对比一下。\n利用pandoc可以完美的显示所有的LaTex，但是原有设置下Archive主页的归档信息消失： 基于karmx等的数学公式无法完美显示，问题有些严重，所以最终还是换了 其中的一些语义冲突修改 倒是在新版本中，好像影响不是很明显，可能更多的是与marked的冲突，但是我们使用的是别的渲染引擎\nCDN的设置：可能需要自动添加文件末尾 ，CDN可以自己去找一找了，把后面的对其就行\n在 ~/blog/_config.yml 文件（注意，是 Hexo 博客文件夹根目录中的 /_config.yml 而不是主题目录下的 /themes/next/_config.yml）中增加 MathJax 的支持，并手动设置下面的 src（这一步很重要，使用默认的 src 会导致数学表达式渲染显示失败。这里的关键是 src 中的 ?config=TeX-MML-AM_CHTML 这个字段）\nPandoc MathJax + PanDoc + it的解决方案，最好部署在自己的服务器上，部署在Github上有一些折磨, Pandoc需要使用CI或者Action去部署，等熟悉了再采用该方法把。\npandoc 需要本机中首先安装 pandoc ，各平台参考官方链接进行安装即可。\n1 2 npm uninstall hexo-renderer-kramed --save npm install hexo-renderer-pandoc -- save （非正常方式）对于Archive的问题只需要修改一下生成Archive的路径即可，即通过修改config的生成archive和archive的路径\n具体的对pandoc的配置可以参考：[Link1](https://feigeek.com/posts/b1bbb984 . html)，对其一些bug的修复则用Link2 ，但是暂时作为可选项，新版的好像已经没有问题。\n目前配置如下（有一些不对的冗余存在）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 mathjax: enable: true mhchem: false katex: enable: false copy_tex: false pandoc: extensions: - \u0026#39;+hard_line_breaks\u0026#39; - \u0026#39;+emoji\u0026#39; - \u0026#39;-implicit_figures\u0026#39; Prismjs 在Hexo6.0之前 还是需要借助插件的，但是根据官方说明 ，在6.0之后官方已经添加了Prismjs的支持，disable Hightlight，Enable prismjs后，基于preprocess模式\n1 2 3 4 5 6 7 8 9 10 11 12 13 highlight: enable: false line_number: true auto_detect: true tab_replace: wrap: true hljs: false prismjs: enable: true preprocess: true line_number: true tab_replace: \u0026#39;\u0026#39; 在对应的Theme/specific theme/layout/_partial/head.ejs中添加需要的css样式。\n1 2 3 4 5 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-lucario.min.css\u0026#34;\u0026gt; ... \u0026lt;\\header\u0026gt; 对应的样式可以在github prismjs 中查看，其对应的cdn则按照此链接 查询，虽然不懂得javascript，但是我寻思下载到本地也是一样的，按照其他对应的prismjs-hexo-Blog中的处理即可。\n1 2 3 4 5 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/js/prism/prism.css\u0026#34;\u0026gt; ... \u0026lt;\\header\u0026gt; 之后应该就可以正常使用\nPassword 4 Blog 利用插件对特定的文章进行加密，使得特定的文章的查看需要输入密码。\n安装插件：\n1 npm install --save hexo-blog-encrypt 快速使用: 只需要在文章的Meta信息中添加Password字段即可\n1 2 3 4 5 --- password: test --- 也可进行全局加密设置：参考Password Domain Setup 腾讯云注册：首先获取一个免费的域名或是去腾讯云 /阿里云购买一个域名，（实名制-\u0026gt;付钱-\u0026gt;审核备案）\nDNS Setting DNS解析：在购买域名的提供商为域名添加解析，以腾讯云为例：\n（不推荐）如果想要使用ipv4，ipv6进行dns解析的话可以搜索Github Page的IP，或者\n1 ping username.github.io （推荐）在域名注册控制台 选择对应的域名解析 主机记录：@、www分别注册一次，分别用于https://yourdomain和 https:// www. yourdomain的解析。\n记录类型：由于同个网站的CNAME和AAAA会发生冲突，这里建议使用CNAME类型，并在后续的\n记录值: 中填写自己的username.github.io 后面有免费的SSL记得勾选，等待审核即可。\nDeploy it Hexo部署：\n本地部署和服务启动不需要d（eploy）执行到前面即可在指定的端口查看本地的部署效果了。远程部署实际上就是git Push -f 到远程仓库的指定分支，完成前面github page的设置可以使用hexo -d 进行部署。\n1 2 3 4 5 6 hexo cl hexo g hexo s hexo d hexo cl \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo s \u0026amp;\u0026amp; hexo d Github绑定：\n在站点的source目录下创建CNAME并添加域名\n1 echo \u0026#34;yourDomain\u0026#34; \u0026gt;\u0026gt; CNAME 在Github-\u0026gt; Repo -\u0026gt; Settting -\u0026gt; Page —\u0026gt; Custom Domain 中填写域名并保存，等待解析完成后，即可。\n参考资料：Link1 、Link2 Themes Switch 主题之间的切换应该和我预想的一致，下载主题到对应的Theme文件夹，在最外层的_Config中切换，但是由于我们的初始主题Live my LIfe极度依赖默认_config.yml，而非自身目录下的配置文件。故而有以下的几点工作\nCompatibility Check： config setting，plugin version and dependencies conflics Dir structure： check the consistency of the dir tree structure Find themes u like: latex-support，post-style，archive，tag，Difficulty，Long-Time-Support\u0026hellip; 以下这些是一些初步筛选出来的觉得还可以的主题，之后可以切换看看：\n画廊 Miccall主页为画廊的基本样式，有对应的图库功能，作为图片和效果展示的话可能还不错，post页面和标签等页面较为一般。 三钻主题 ，亮色惊艳，暗色太花，设计难度和修改难度估计较大，Archive为时间轴模式，大爱，可以的话看看怎么将LivemyLife的Archive也变为这种样式。正文的效果以及对应的TOC 极简程序员博客 ，简洁美但是稍微有点太简洁，Archive界面好像崩了 闪耀狐 ，LTS，分类的雷达图，标签的热力图大爱，想办法搞到自己的主题里，功能较为全面和完善，如果想要自定义或者添加一些功能，完全可以参考这个主题。 Find More 官方主题游廊 当前对各方各面的概念还不是太理解，后面考虑对网页构建的底层，以及其他的相关知识进行进一步的了解，方便自己对网站进行更进一步的自定义。\nPublic 站点提交，通过将自己的网页提交给搜索引擎，使得自己的文章能够被搜索到，目前暂时先不考虑Public，所以这里先行占位，功能暂时不进行支持。\n主要参考Link1 ，初步计划使用sitemap进行站点提交，由于baidusitemap存在较多冲突考虑先不启用。后续进行继续实验。\nReference 基础+百度网站提交 | 基础解读 | Official SIte ： 介绍默认_config文件的配置信息 简单修改 livemylife主题的一些简单修改 知乎教程 可以添加网易云音乐的外链，同时有我们需要的自定义社交网络按钮的部分（基于Next）去看看用的是什么插件，怎么嵌入。 zhihu2 ，基本同上，但是多了一些其他的自定义的 大小写的改变不会git推送，导致发生404 错误 ","permalink":"https://hugotest-phi.vercel.app/posts/hexo_build/","summary":"\u003cp\u003e该文档用以，记录自己（外行）利用Hexo建立Blog的过程，将原本用Gitbook构建的笔记转移到Hexo中，同时购买域名并部署其上。网页部署于\u003ca href=\"AikenH.cn\"\u003eGithub Page\u003c/a\u003e\n。以Live my Live主题为例。\u003c/p\u003e\n\u003cp\u003e腾讯云和Github Page的操作和理解在现有的一些博客中过时了，或者说存在一些问题，后续会对此进行简单的讲解。同时大部分博客都是使用NexT主题进行配置，这里采用的是Live My Life主题，该博文介绍自己的粗浅理解，也为自己后续的工作进行一定的参考。\u003c/p\u003e\n\u003cp\u003e还存在一些\u003cstrong\u003e没有解决\u003c/strong\u003e的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对主题切换和主题配置和全局配置的的深入理解（Live my Life主题覆盖了很多默认配置）\u003c/li\u003e\n\u003cli\u003e前端代码的理解，\u003cstrong\u003e自定义Layout\u003c/strong\u003e，超链接，图标等\u003c/li\u003e\n\u003cli\u003e深入理解插件的应用和自定义\u003c/li\u003e\n\u003cli\u003e推送网站到baidu和google（Option）（没有计划）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e之后有时间的话可以去研究一下：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e关键词\u003c/strong\u003e：Hexo_Livemylive、Github Page、腾讯云（Domain、DNS、SSL）\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"environment\"\u003eEnvironment\u003c/h2\u003e\n\u003cp\u003e需要准备的环境如下：本地Node（NPM），Page部署Git（SSH），可在Windows，Linux，WSL2中部署均可，但需要注意的是，如果在WSL2中进行部署，生成速度与部署速度会明显慢于宿主机。\u003c/p\u003e\n\u003cp\u003e首先安装NodeJS、NPM、Git并验证是否成功安装，根据Linux和Windows不同环境进行安装，可以去官网了解相关的安装步骤，或者参考Gitee和Github的两篇博文。\u003c/p\u003e\n\u003cp\u003e为了更好的编写笔记，最好配置一个图床，图床的配置可以使用Github、Gitee或者腾讯云的COS服务，相关的配置可以参考\u003ca href=\"https://aikenh.cn/en/PicBed/\" target=\"_blank\" rel=\"noopener\"\u003eLInk\u003c/a\u003e\n\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit version\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enode -v\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm -v\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e安装Hexo\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm install -g hexo-cli\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看Hexo的版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehexo -v\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"initialize\"\u003eInitialize\u003c/h2\u003e\n\u003ch3 id=\"blog\"\u003eBlog\u003c/h3\u003e\n\u003cp\u003e对博客目录初始化：\u003ccode\u003ehexo init blog\u003c/code\u003e，blog为空的话初始化当前文件夹，初始化后基本结构如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── _config.yml \u003cspan class=\"c1\"\u003e# 网站的全局配置信息，在此配置大部分的参数。 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── package.json \u003cspan class=\"c1\"\u003e# 定义Hexo，以及对应安装的依赖的版本等\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── node_module: \u003cspan class=\"c1\"\u003e# Hexo安装插件的位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── scaffolds \u003cspan class=\"c1\"\u003e# 页面模版文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── \u003cspan class=\"nb\"\u003esource\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   ├── _drafts \u003cspan class=\"c1\"\u003e# 草稿文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   └── _posts \u003cspan class=\"c1\"\u003e# 文章Markdowm文件 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e└── themes  \u003cspan class=\"c1\"\u003e# 主题文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e有了初始化的目录后，就可以参考相关主题的官方介绍页面进行对应的 配置，不同的主题可能有不同的配置方法。接下来我们会以\u003ca href=\"https://github.com/V-Vincen/hexo-theme-livemylife/blob/master/README_CN.md\" target=\"_blank\" rel=\"noopener\"\u003e《Live my life》\u003c/a\u003e\n主题为例。\u003c/p\u003e","title":"Hexo Build"},{"content":"Chose Your Dotfile to start the vim\n1 vim -u {path to your .vimrc} Recorder of Vim This Chapter mainly introduces the Recorder in vim,Which is used to do some repeated operations.This function is also called a macro.\nfor more information try :help recording\nRegisters(related with recording) This section will introduce related concept/function of recording function. Which help us to understand how this works, and what we should pay attention to it.\nregister of vim: register is a superset of macro, it contains more function. In this part we should know, register can store some string or operations to help subsequent use.\nStatus: Using :registers or :reg to check those we have registered, or add the registers\u0026rsquo;s name behind to show those u\u0026rsquo;re interested in.\n1 2 3 4 5 :reg a b c --- Registers --- \u0026#34;a register a content \u0026#34;b register b content \u0026#34;c register c content Lifecycle The information in registers will not disappear with the window closed. But maybe with the system-level\u0026rsquo;s open-close. we should test this!!! So we can store some snippet,pwd,etc.\nPick There are many registers like 0~9,a~z,unnamed,etc. 0~9 are the default registers for many operations like del,copy,command,etc.\nSo for recording, we better using a~z. And It should be noted that the upper version A~Z means add operations to an existing command.\u0026lsquo;a~z\u0026rsquo; is to overwrite it.\nModified Besides the A~Z works like append in python. There are several way to modify the registers; Like:\n1 2 3 4 5 # using \u0026#39;w\u0026#39; as an example of reg. :let @w=\u0026#39;\u0026lt;what command u want\u0026gt;\u0026#39; # general version is: (ignore the []) :let @[reg u want to modify]=\u0026#39;[what command u want]\u0026#39; TODO: we should write a indipendent chapter for the registers in vim.\nUsage This section shows the Usage of Recording. And we will continue to collect some good examples. Then put it below.\nChange to Normal mode and pressed \u0026ldquo;q\u0026rdquo; Chose reg u want (a~z normally) to start record a macro { operations u want to be recorde } -\u0026gt;in non-insert mode\u0026lt;- pressed \u0026ldquo;q\u0026rdquo; to end recording Using \u0026ldquo;@+reg\u0026rdquo; to repeat this operations/macro 10@+reg to repeat this macro 10times Example1 setting the pwd/useid of server.\nExample2 fill up some sheet infomation.\nReferences recording\nofficial doc : :help recording registers in vim registers in vim2 how to use recording in vim ","permalink":"https://hugotest-phi.vercel.app/posts/vimoperation/","summary":"\u003cp\u003e\u003cstrong\u003eChose Your Dotfile to start the vim\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evim -u \u003cspan class=\"o\"\u003e{\u003c/span\u003epath to your .vimrc\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"recorder-of-vim\"\u003eRecorder of Vim\u003c/h2\u003e\n\u003cp\u003eThis Chapter mainly introduces the \u003cstrong\u003eRecorder\u003c/strong\u003e in vim,Which is used to do some \u003cstrong\u003erepeated\u003c/strong\u003e operations.This function is also called a \u003cstrong\u003emacro\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003efor more information try \u003ccode\u003e:help recording\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"registersrelated-with-recording\"\u003eRegisters(related with recording)\u003c/h3\u003e\n\u003cp\u003eThis section will introduce related \u003cstrong\u003econcept/function\u003c/strong\u003e of recording function. Which help us to understand how this works, and what we should pay attention to it.\u003c/p\u003e","title":"Vim 01 Recorder"},{"content":"@Aiken 2020 first write，2021 modify\nMainly using picgo-core(command line) to setting picbed，and we can update the setting method\nGithub 使用PicGo-Core（command line）设置github图床，自动转义url 插入自动复制图片，使用git上传github 基本部署 在偏好设置中的图像，进行如下设置👇： 下载或更新PicGo-Cord(command line) 接着去Github中建立一个Repo：UserName/RepoName，用以存放图片（Public），简单的用readme初始建立即可。\n在Github的setting - developer setting-personal access tokens中新建token，指定简单的repo权限，并记录个人的token（只显示一次） Attention： 忘记记录的话，在token中也是通过update token（好像是这个名，获取新的值的）\n用Typora打开配置文件设置，或者使用命令行进行配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;picBed\u0026#34;: { \u0026#34;github\u0026#34;: { \u0026#34;repo\u0026#34;: \u0026#34;UserName/RepoName\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;your github token here\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;img/\u0026#34;, \u0026#34;customUrl\u0026#34;: \u0026#34;https://raw.githubusercontent.com/UserName/RepoName/master\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;master\u0026#34; }, \u0026#34;current\u0026#34;: \u0026#34;github\u0026#34;, \u0026#34;uploader\u0026#34;: \u0026#34;github\u0026#34; }, \u0026#34;picgoPlugins\u0026#34;: {} } 点击验证图片上传选项，进行测试，成功即可 存在问题 用Github做图床的话，上传不是十分的稳定（可能需要依赖科学上网技术。请八仙过海，各显神通）。可以用其他的服务器作图床，大体过程应该也差不多，后续个人有更换的话在进行补充。\n在其他的pc上可以使用相同的token进行复用，但是在进行测试的时候要记得将repo中的两张测试图片删除，不然可能会导致验证失败的问题。 PicGo With Obsidian etc. 这种方法可能是最稳健的泛化能力也最强，再很多编辑器类似的地方都能用，但是前提就是我们进行笔记撰写的时候要把picgo的客户端打开。\n安装picgo客户端，（在其中安装你对应图床的插件） 和上述描述的一样再gitee或者github中设置相应的图床token等，并在软件中填写对应的token picgo设置中，打开server即可 再Obsidian中安装插件 image auto upload plugin 并在其中设置本地ip:port即可 COS in tencent-cloud 相关网站：Tencent-Cloud-Cos 参考资料：Create-Tencent-Cloud-Cos , Setting-Your-PicGoApp 创建存储桶 Create Store-Bucket(Private write Public read) -\u0026gt;\nCreate A sub-User(which only got access for the cos R/W) -\u0026gt;\nQcloudCOSFullAccess, Pic Below to add the access\ngenerate a private_token -\u0026gt;\ntoken manage\ncp SecretID,SecretKey,Main_Account_ID,name_of_bucket to PicGo\nthe area in the second figure\nPicgo 设置 进入腾讯云的对象存储页面： 存储桶列表中可以看到存储桶名称，即Bucket 所属地域，也就是设定存储区域如：ap-guangzhou 右上角的用户信息中点击访问管理进入到用户界面 用户-\u0026gt; 子用户可以看到账号 ID：即Appid 点击子账户进入详情页-\u0026gt;API 密钥 SecretId SecretKey 设置完成即可。 Gitee（防盗链事件后抛弃） 因为gitee是国内的github，服务器比较稳定，所以我们也可以使用gitee作为我们更为稳定的图床；\n两个链接合起来才是好用的，都有一些冗余：\nTypora+picgo-core+gitee PicGo-core+Gitee+Typora gitee基本部署 安装Node，npm；\n安装picgo-core的命令行命令：\n1 npm install picgo -g 安装gitee的插件： 1 2 picgo install super-prefix picgo install gitee-uploader 配置Gitee Repo 初始化一个repo，保存URL中的User/repo，不要轻信标题，因为有昵称机制。\n在个人资料中初始化个人的Token，勾选projects选项即可;\n设置配置文件 基于picgo的命令，会自动的更新Json文件，我们不许需要\n1 2 3 4 5 6 7 8 9 10 picgo set uploader # up to the command hint, we input those messages 1.按上下键找到gitee，回车 2.repo：用户名/仓库名 （打开自己的仓库，浏览器里的网址username/reponame） 3.token：刚才生成的token 4.path:路径，写仓库的名字就是reponame 5.custompath:不用填，回车 6.customURL:不用填，回车 # finish setting process picgo use uploader ","permalink":"https://hugotest-phi.vercel.app/posts/picbed/","summary":"\u003cp\u003e@Aiken 2020 first write，2021 modify\u003c/p\u003e\n\u003cp\u003eMainly using picgo-core(command line) to setting picbed，and we can update the setting method\u003c/p\u003e\n\u003ch2 id=\"github\"\u003eGithub\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#Pic-Bed\"\u003e使用PicGo-Core（command line）设置github图床，自动转义url\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#Git\"\u003e插入自动复制图片，使用git上传github\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"基本部署\"\u003e基本部署\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e在偏好设置中的图像，进行如下设置👇： 下载或更新PicGo-Cord(command line)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20200512160643588.png\"\u003e\r\n    \u003cimg alt=\"image-20200512160643588\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20200512160643588.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20200512160643588.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20200512160643588\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003e接着去Github中建立一个Repo：UserName/RepoName，用以存放图片（Public），简单的用readme初始建立即可。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在Github的setting - developer setting-personal access tokens中新建token，指定简单的repo权限，并记录个人的token（只显示一次）\n\u003cstrong\u003eAttention：\u003c/strong\u003e 忘记记录的话，在token中也是通过update token（好像是这个名，获取新的值的）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e用Typora打开配置文件设置，或者使用命令行进行配置\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"nt\"\u003e\u0026#34;picBed\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e           \u003cspan class=\"nt\"\u003e\u0026#34;github\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             \u003cspan class=\"nt\"\u003e\u0026#34;repo\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;UserName/RepoName\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             \u003cspan class=\"nt\"\u003e\u0026#34;token\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;your github token here\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             \u003cspan class=\"nt\"\u003e\u0026#34;path\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;img/\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             \u003cspan class=\"nt\"\u003e\u0026#34;customUrl\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;https://raw.githubusercontent.com/UserName/RepoName/master\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             \u003cspan class=\"nt\"\u003e\u0026#34;branch\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;master\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e           \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e           \u003cspan class=\"nt\"\u003e\u0026#34;current\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;github\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e           \u003cspan class=\"nt\"\u003e\u0026#34;uploader\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;github\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         \u003cspan class=\"nt\"\u003e\u0026#34;picgoPlugins\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c!-- more --\u003e\r\n\u003col start=\"5\"\u003e\n\u003cli\u003e点击验证图片上传选项，进行测试，成功即可\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"存在问题\"\u003e存在问题\u003c/h3\u003e\n\u003cp\u003e用Github做图床的话，上传不是十分的稳定（可能需要依赖科学上网技术。请八仙过海，各显神通）。可以用其他的服务器作图床，大体过程应该也差不多，后续个人有更换的话在进行补充。\u003c/p\u003e","title":"PicBed Setting for note and blog"},{"content":"@Langs: python, torch @reference: d2l-pytorch，transfer_torch This Note focus on the code part. 模型微调和模型预训练，在Pytorch中的使用方式对比汇总。\nHow to Design the Fine Tune 这一部分主要集中于我们对于微调任务的拆解，有几种不同的预训练和微调的方式，在不同的情景下，对应的参数应该怎么设置和调整是问题的重点。\n基于这种Transfer的策略，我们能够学习到一个更通用，泛化能力更强，有助于识别边缘，色彩，等等有助于下游任务的通用特征提取。\n在Transfer任务中，有几种不同的调整方式：\n固定Bakcbone，只训练Classifier 同步微调网络 区分学习率，微调Backbone，训练Classifirer 为了实现这几种不同的Transfer方式，需要用到以下的几种方式：梯度截断，lr区分设置等。\nCode Part 不同lr设置 微调Backbone，训练Classifier作为最经典的Transfer设定，在Code上也较为复杂，所以我们首先举个这种例子。\n相关的文档可以参考：torch.optim 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # get dataset train_img = torchvision.datasets.ImageFolder(os.path.join(data_dir, \u0026#39;train\u0026#39;)) # get new model pretrained_new = model.expand_dim(dim=out_dim,re_init=True) # pre train it 定义一个用于微调的函数 # pytorch可以通过字典的形式来区分对设置lr def train_fine_tuning(net, learning_rate, batch_size=128, num_epoch=5, diff_lr=True): # set dataloader train_iter = torch.utils.Dataloader(train_img, batch_size=batch_size, shuffle=True) test_iter = ... # set loss loss = nn.CrossEntropyLoss(reduction=\u0026#39;none\u0026#39;) # set diff lr for diff part of it if diff_lr: params_1x = [param for name, param in net.name_parameters() if name not in [\u0026#34;fc.weight\u0026#34;, \u0026#34;fc.bias\u0026#34;]] trainer = torch.optim.SGD([{\u0026#39;params\u0026#39;: params_1x}, {\u0026#39;params\u0026#39;: net.fc.parameters(), \u0026#39;lr\u0026#39;: learning_rate *10}], lr=learning_rate, weight_decay=0.001 ) else: trainer = torch.optim.SGD(net.parameters(), lr=learning_rate, weight_decay=0.001) 同时不用担心，scheduler可以将我们的两组lr同时进行更新，可以基于下面的代码进行测试\n1 2 3 4 5 6 7 8 9 optimizer = torch.optim.SGD([{\u0026#39;params\u0026#39;: [torch.rand((2,2), requires_grad=True)]}, {\u0026#39;params\u0026#39;: [torch.rand((2,2), requires_grad=True)],\u0026#39;lr\u0026#39;: 0.01}], lr=0.1, momentum=0.9) scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=1, gamma=0.1, verbose=False) for epoch in range(1,10): scheduler.step() print(\u0026#39;Epoch-{0} lr: {1}\u0026#39;.format(epoch, optimizer.param_groups[0][\u0026#39;lr\u0026#39;])) print(\u0026#39;Epoch-{0} lr: {1}\u0026#39;.format(epoch, optimizer.param_groups[1][\u0026#39;lr\u0026#39;])) 梯度截断 PyTorch Docs 保留Backbone，训练Classifier，截断网络向Backbone的回传，设置学习率仅训练分类器。\n表面上写的梯度截断，实际上我们需要做的就是不让优化器优化模型即可，不需要截断梯度的运算，也就是在optim的参数种不添加其他部分的网络即可,\n也就是反向一下上面的params_1x即可，然后添加对应的参数。\n还有另一种方式，也是官方的实现，也就是使用require_grad来对不需要进行梯度计算的单元进行覆盖设置。 具体的代码可以参考如下：\n1 2 3 4 5 6 for name, params in model.name_parameters(): if name not in[\u0026#39;fc.weight\u0026#39;, \u0026#39;fc.bias\u0026#39;]: params.require_grad = False parameters = [p for p in model.parameters() if p.require_grad] assert len(parameters) == 2 加载部分模型 在自监督学习中，只加载Backbone或者只加载Classifier的情况是非常常见的，这就需要我们仅仅加载部分的参数，为了实现该目标，我们可以按照如下的方式进行操作\n1 2 3 4 5 6 7 8 9 # 读取训练好的模型参数，获取当前模型的字典 ckpt = torch.load(pretrain_opt[\u0026#39;pth\u0026#39;])[\u0026#39;model\u0026#39;] model_dict = model.state_dict() # 获取特定的‘key’将该字典用来更新模型的参数 pretrain_dict = {k:v for k,v in ckpt.items() if \u0026#39;backbone\u0026#39; in k and \u0026#39;fc\u0026#39; not in k} # 更新模型的dict后进行载入 model_dict.update(pretrain_dict) model.load_state_dict(model_dict) 函数中的update需要参数的key和模型中的字典完全匹配，结构相同也不行，因此，在这里还会遇到一个另外的问题就是，模型名称失配问题。\n而为了解决这个问题，最简单直接的方法就是，修改对应的key，最内层基本都是一致的，名称上的区别只在于，我们外层的结构不同。\n1 pre_projector_dict = {k.replace(\u0026#39;classifier.\u0026#39;, \u0026#39;\u0026#39;):v for k,v in ckpt.items() if \u0026#39;classifier\u0026#39; in k} 由此便可以完成对部分模型的加载和匹配。\n","permalink":"https://hugotest-phi.vercel.app/posts/finetune/","summary":"\u003cp\u003e@Langs: python, torch\n@reference: d2l-pytorch，\u003ca href=\"https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html\" target=\"_blank\" rel=\"noopener\"\u003etransfer_torch\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003eThis Note focus on the code part.\n模型微调和模型预训练，在Pytorch中的使用方式对比汇总。\u003c/p\u003e\n\u003ch2 id=\"how-to-design-the-fine-tune\"\u003eHow to Design the Fine Tune\u003c/h2\u003e\n\u003cp\u003e这一部分主要集中于我们对于微调任务的拆解，有几种不同的预训练和微调的方式，在不同的情景下，对应的参数应该怎么设置和调整是问题的重点。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211205143153.png\"\u003e\r\n    \u003cimg alt=\"WorkFlow\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211205143153.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211205143153.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"WorkFlow\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e基于这种Transfer的策略，我们能够学习到一个更通用，泛化能力更强，有助于识别边缘，色彩，等等有助于下游任务的通用特征提取。\u003c/p\u003e\n\u003cp\u003e在Transfer任务中，有几种不同的调整方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e固定Bakcbone，只训练Classifier\u003c/li\u003e\n\u003cli\u003e同步微调网络\u003c/li\u003e\n\u003cli\u003e区分学习率，微调Backbone，训练Classifirer\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e为了实现这几种不同的Transfer方式，需要用到以下的几种方式：梯度截断，lr区分设置等。\u003c/p\u003e\n\u003ch2 id=\"code-part\"\u003eCode Part\u003c/h2\u003e\n\u003ch3 id=\"不同lr设置\"\u003e不同lr设置\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e微调Backbone，训练Classifier\u003c/strong\u003e作为最经典的Transfer设定，在Code上也较为复杂，所以我们首先举个这种例子。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e相关的文档可以参考：\u003ca href=\"https://pytorch-cn.readthedocs.io/zh/latest/package_references/torch-optim/\" target=\"_blank\" rel=\"noopener\"\u003etorch.optim\u003c/a\u003e\n\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# get dataset\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003etrain_img\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorchvision\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edatasets\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eImageFolder\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epath\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata_dir\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;train\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# get new model\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003epretrained_new\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emodel\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eexpand_dim\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edim\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eout_dim\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ere_init\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"kc\"\u003eTrue\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# pre train it 定义一个用于微调的函数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# pytorch可以通过字典的形式来区分对设置lr\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003etrain_fine_tuning\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enet\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elearning_rate\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebatch_size\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e128\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enum_epoch\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ediff_lr\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"kc\"\u003eTrue\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"c1\"\u003e# set dataloader\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003etrain_iter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eutils\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDataloader\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etrain_img\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebatch_size\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ebatch_size\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eshuffle\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"kc\"\u003eTrue\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003etest_iter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"c1\"\u003e# set loss\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003eloss\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enn\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCrossEntropyLoss\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ereduction\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;none\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"c1\"\u003e# set diff lr for diff part of it \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ediff_lr\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"n\"\u003eparams_1x\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eparam\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eparam\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003enet\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ename_parameters\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e \u003cspan class=\"ow\"\u003enot\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;fc.weight\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;fc.bias\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"n\"\u003etrainer\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoptim\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSGD\u003c/span\u003e\u003cspan class=\"p\"\u003e([{\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;params\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eparams_1x\u003c/span\u003e\u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\t\t\t  \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;params\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003enet\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efc\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eparameters\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\t\t\t  \u003cspan class=\"s1\"\u003e\u0026#39;lr\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003elearning_rate\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e}],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\t\t\t  \u003cspan class=\"n\"\u003elr\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003elearning_rate\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eweight_decay\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.001\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\t\t\t \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"n\"\u003etrainer\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoptim\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSGD\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enet\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eparameters\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"n\"\u003elr\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003elearning_rate\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eweight_decay\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.001\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e同时不用担心，scheduler可以将我们的两组lr同时进行更新，可以基于下面的代码进行测试\u003c/p\u003e","title":"Fine Tuning"},{"content":"参考文献：稀土掘金 | ProGit2\nGIT 与 SVN 的区别 SVN 是集中式版本控制系统，其所有的版本管理都是集中在某个中央服务器，因此，在干活的时候，首先都需要从中央服务器中获取最新的版本，修改后将版本推送到中央服务器，因此大多数场景下需要进行联网使用。可能会更依托于相应的图形化客户端来进行同步和版本管理，便于管理美术资源等等。\nGIT 是分布式版本管理系统，每个人的电脑就是一个完整的版本库，可以进行独立的版本管理，多人协作可能依托于 github 之类的中继节点，将修改同步给对方，解决冲突。\nInit 初始化 包含 ssh 的详细指令在 ssh 的文档中，这边只介绍设置完这一系列操作之后的 git 初始化，主要是初始化 ssh，并将私钥放到 github 或者 gitee 的账户中。\n1 2 3 4 5 6 7 8 9 10 git config --global user.name \u0026#34;YourName\u0026#34; git config --global user.email \u0026#34;YourEmailAdress\u0026#34; # 查看相关的配置信息 git config --list # 设置CRLF和LF的相关转换 第一条在提交的时候自动抓换位LF，迁出转换为CRLF # 第二条拒绝混合换行符的提交 git config --global core.autocrlf true git config --global core.safecrlf true Github 设置 官方文档介绍的一些权限错误的地址：\u0026lt; https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey\u003e 将本机的 ssh 公钥(public)放到 GITHUB 账户下的 ssh 管理地址，执行测试\n1 ssh -T git@github.com 没有问题的话就可以直接进行 clone，之类的 git 操作了\n1 2 # 小trick，不拉取历史的commit git clone --depth=1 REPO_ADRESS Gitignore 文件编写 参考文件：【 Git忽略提交规则 】【 gitignore 各语言模版 】\n首先创建对应的 .gitignore 文件，根据自己的需求编写内容，这里也推荐通过 VsCode 的插件或者使用上述仓库中对应语言的模版文件来创建初始化 ignore 文件，会包含一些常用的通常无需上传的本地配置或者本地缓存等内容；\n1 touch .gitignore 在覆盖了这些通用的忽略项后，可以根据项目情况添加特有的路径，通常主要包括以下的几类：\n大文件：如自用的测试数据等 敏感配置文件：包含了敏感信息的配置项等（这里建议考虑使用 env 等，或者上传对应的 default 文件） 日志文件 设置 Git 的代理 设置全局代理使用如下的方式：\n1 2 git config --global http.proxy 127.0.0.1:1080 git config --global https.proxy 127.0.0.1:1080 同理取消全局代理如下\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy 常用指令与架构介绍 Git 整体的使用架构如下图所示 ，一般而言开发者在工作区进行当前修改，将需要同步或者发布的修改内容通过暂存区存储到本地 \u0026amp; 远程仓库中，结合远程仓库的协作特性和分支功能，可以实现同个项目的多人同步分离开发，同时开发多种功能等。\n因此 Git 或者 Svn 等 CLI 的使用技能，在公司中或者在项目参与中是相当重要的，建议每个人程序开发者都能对其有一定的了解。\n下面是一些基本的命令使用，其中许多命令都有一些额外的参数可供使用，如果经常使用 Git 建议可以简单阅读一下 ProGit。\n这里会简单记录一些命令，其中那些在 git 使用中会有所提示的命令就不再赘述，例如 pull 别的分支的时候取消 merge 到当前分支的 git merge \u0026ndash;abort 之类就会有所提示。\n普通 command 分支 command 创建本地 repo git init 创建/显示分支 git branch name 工作区状态 git status 切换分支 git checkout [branch] 添加到暂存区 git add /. 切换 git checkout -b name 暂存区到本地 git commit -m ‘mesg’ 合并分支 git merge branch 日志 git log (–oneline) 删除分支 git branch -d 拉取远程库 git pull / git fetch 推送本地分支 git push origin branch 克隆远程库 git clone 撤销 标签 撤销工作区修改 git checkout – file-name 创建标签 git tag tag-name 撤销暂存区修改 git reset HEAD file-name 显示所有标签 git tag 撤销本地库修改 git reset –hard commitID 删除标签 git tag -d tag 远程 储藏 · 同步本地库和 git remote add origin xx@y repo 保存现场 git stash 远程库 git push -u origin master 恢复现场 git stash pop Commit 规范和相关命令 commit 命令实现将\u0026quot;将暂存区的文件以特定的注释提交到仓库中\u0026quot;，提交的 Message 建议建立统一的规范，这样可以方便后续使用 log 查阅的时候定位到特定修改的 commit。\nMessage Standard 标准提交内容 本人推荐的 Commit Message 格式如下，该格式并非是一成不变的，可以根据仓库中存放的项目类型来灵活变更 Tag 的数量和内容。\n1 git commit -m \u0026#34;[tag1(modify scope)] [tag2(modify type)]: excatly modify info\u0026#34; Tag1 (modify scope): 说明修改的内容，泛一些例如修改代码 code，资源 res，细一些则例如修改的文件夹 tool、util Tag2（modify type）：说明修改的类型，主要有：Feat、Fix、Refactor、Style、Test、Docs、Merge，如果修改的是资源等文件可以忽略。 Modify info：修改的详细信息，说明修改的目的和修改的内容即可 例如以下的几个写法：\n1 2 3 git commit -m \u0026#34;[res]: add presonal conf file\u0026#34; git commit -m \u0026#34;[code-util][Feat]: add function to parser conf file\u0026#34; git commit -m \u0026#34;[code \u0026amp; res][Feat \u0026amp; Fix]: add function for merge conf, fix bug on parser conf, add my conf resource\u0026#34; 该部分没有什么硬性要求，只需要自己能够清晰的看懂自己的 commit 且具备一致性即可。\nExtra Operation 撤销、重写、合并 有时候针对已经提交的 Commit 不满意，或者有一些新的更改需要添加到上一次的 Commit 中，可以参考下面的操作。\n撤销 Commit 或者重写 Commit Message\n1 2 git reset --soft HEAD^ # 撤销当前commit git commit --amend # 重写当前commit 合并多次 Commit：通过 rebase 命令来进行 merge，该命令通过整理多次的 Commit 来使得整个提交历史更为整洁有序，但是需要额外的精力去整理就是。具体的操作流程如下：\n首先查看 commit 的 hash 1 git log 找到需要修改的 commit 的前一个 commit 的 ID 1 2 3 4 5 # 找到需要合并的最早commit的上一个的ID git rebase -i \u0026lt;ID\u0026gt; # 也可以使用以下命令合并header往前多少n次的commit git rebase -i HEAD~n square：将该次 commit 和上一次 commit 合并 pick：保留该次 commit 通过修改 commit 提交界面的 square 和 pick 即可实现多次 commit 的合并。\nHistory 历史查看 查看当前分支的提交历史只需要通过 git log 即可看到基本的提交信息，这里简要介绍一些参数来帮助更清晰的定位 commit\ngit log -p -{n}: 参数 -p 以 diff 的形式在显示基本提交信息的基础上还显示该提交的具体修改内容，由于内容较多；可以通过 -{n} 仅显示最近 n 次提交的内容 git log --stat ：参数 --stat 显示每次提交的统计信息，包含修改的文件以及对该文件修改的行数的统计信息 git log --graph： 参数 --graph 会使用简单的 ASCII 图像来可视化提交之间的分支关系，也就是 vscode 中 gitgraph 的命令行版本，可以帮助了解提交之间的合并和起始提交等信息 此外还有诸如 --pretty 等参数可以自定义 log 显示的具体格式，需要的话可以参阅 progit 或者官方文档进行了解。\nAdd 一些额外操作 Add 命令主要将修改的内容提交到暂存区，不仅可以作为我们一次次的中间存储节点，也是为后续的提交做缓冲，但是难免会遇到以下的情况：\n提交错文件或者修改了结构需要将一个或者多个文件从暂存区中撤退出来； 清除工作区中不需要提交的临时文件 如果是撤销所有提交的文件：\n1 git reset HEAD . 撤销特定文件的提交\n1 git reset HEAD \u0026lt;file\u0026gt; 以上两个命令不需要记录，只需要使用 git status 查看当前状态的时候会有提示。\n清除工作区中不需要提交的临时文件，可以使用以下的命令\n1 2 git clean -nf # 查看会被清除的未追踪文件 git clean -f # 清除未追踪的文件 如果涉及到文件夹可以添加参数 d\n1 2 git clean -ndf # 查看会被清除的未追踪文件和文件夹 git clean -fd # 实际执行清除指令 其中-n 参数为查看而不实际执行的参数，避免文件的误删。具体可以通过 git help clean 查看。\nCherryPick 挑选 Commit 仅简要介绍其作用，详细使用等后续有使用场景再来补充。\nGit CherryPick 命令实现从别的分支挑选某个 Commit 的修改合并到当前分支中，该命令在一些提交数少的分支中，可以代替 merge，实现一个更为线性整洁的 Master 分支。\n可以结合 Rebase 合并提交使用，由此得到一个更为干净的提交历史。\n暂存区 \u0026amp; Stash 暂存区指的是 git add. 后存储到的区域，用来作为本地和仓库之间的缓存。\n暂存区处理 清除暂存区某个文件的指令（通常是为了修改.gitignore）的时候执行\n1 git rm -r --cache filename 看暂存区有什么文件\n1 2 git ls-files git status stash 区域使用 是一个特殊的区域，本地的 git 存储区，一般来说使用场景较少，例如以下的场景。\n本地改了代码，但是突然有个人过来问你另一个分支的问题，同时这个时候你在实现某个功能，实现一半，又不想提交到 Git 仓库中，那么你就可以考虑使用 git stash save \u0026quot;临时存一下\u0026quot;，这个时候它就会帮你存到这个储存区，你去其他分支做完事情回来，再 git stash pop就好了。\n主要使用的就是以下的几个命令：\ngit stash save \u0026quot;message\u0026quot; 将当前的修改暂存 git stash list 查看暂存了哪些修改 git pop 默认使用存储的堆栈中的第一个 stash git stash apply stash@{n} 使用第 n+1 个 stash，n 从 0 开始。 一般建议是不要使用太多的 stash，这样一个 save 和一个 pop 命令就可以 handle 。\n如果 pop 操作导致冲突，希望撤销 git stash pop 行为，可以使用 git reset --hard 回退当前修改，该操作会保留 pop 出来的修改仍然在 stash 中。\n一些 Git 工作流介绍 使用 Git Rebase 保持简洁的 History 参考资料： 优雅且安全的使用 GitRebase 前文已经介绍过了 git rebase 用于合并 merge 的功能，这里主要介绍的是 git rebase 在分支合并中的作用，何时在分支管理中使用 git rebase 取代 git merge 来进行分支合并。\ngit merge 是一种非破坏性的操作，当我们使用 git merge 进行分支合并的时候，会提供一个新的 commit ，其内容为两个分支的合并提交，这也是与 rebase 最大的区别。\nrebase 正如其单词所言，re-base，重构我们的 base，我们可以使用下面的命令将 master 分之合并到我们的 dev 分支中：\n1 2 git checkout dev git rebase master 这会将我们的 dev 分支的新增内容移动到 master 分支之后，相当于重新构建了 dev 分支上的每个 commit，将其在新的 master 之后再合入。\n使用这种方式的话，项目的历史记录会更为线性，会使得分支的提交历史更加整洁，没有不必要的合并提交，考虑到可能在开发过程中我们可能会多次需要更新 master 分支的内容，这样能让我们的更新更加容易追溯和复原。\n此外正如合并多次 commit 的操作，使用 -i 可以开启 rebase 的交互模式，交互模式中我们就可以将多次提交浓缩为单次提交(squash)，或者合并某两个连续的提交(fixup)。\ntips: 如果需要一次性将从 master 分出来的 dev 上的第一个提交到最后一个 dev 上的提交合并，避免用 Head~n 去数，或者手动去找对应的 commitID，也可以用 git merge-base dev master 代替，这里的 master 就是你的切出 dev 的原始分支，不一定是 master。\n但是由于 rebase 操作是一个破坏性的操作，会修改我们之前的每次原始提交，因此在使用的时候需要慎重，遵循 rebase 使用的法则：永远不要再公共分支上使用它，在公共分支使用会导致所有人的原始 master 和远端无法对齐，导致一系列问题。\n但是如果别人同样在远程开发 dev 分支，我们 fetch 后同样可以考虑使用 merge 或者 rebase 更新 dev 分支本身，因为这只影响了我们 local 端的后续提交。BTW，git pull --rebase 可以强制使用 rebase 的方式来集成远程分支。\n最终开发完成后，使用 rebase 更新分支上 master 的内容，再去 master 上 merge，会产生最好的线性历史记录，也确保不会影响他人的开发：\n1 2 3 4 5 git checkout dev git rebase master git checkout master git merge dev git push origin master:master 如果不确定 rebase 的使用是否正确，可以复制一个临时分支来执行 rebase，如果不小心搞乱了，还可以有原始的分支来复原。\n使用 Git Merge \u0026ndash;squash 保持简洁 History 除了上述使用 rebase 将分支上的 commit 逐个移动到 master 分支之后，进而维持 master 上的线性提交历史，上述还提到可以使用 rebase 合并多次 commit 后进行提交，但由于 rebase 本身会改变开发分支，所以实际上更推荐仅在 Merge 的时候进行分支上的 commit 合并（例如开发分支上的 commit 较为随意的情况），这种情况下可以在 rebase 的时候使用-i 操作或者使用 git merge --squash {branch} 进行 merge\n远程协作 考虑多用户，多分支的在线场景，如何有效的 Pull \u0026amp; Push.\n在本地仓库切换默认提交用户 在多用户的终端场景，推送前记得切换相关的用户设置。\n1 2 git config --local user.name \u0026#34;YourName\u0026#34; git config --local user.emali \u0026#34;YourEmail\u0026#34; 推送、拉取远程分支 1 2 3 # 冒号前本地，冒号后远程， git push origin local_branch:remote_branch git pull origin remote_branch:local_branch 仅 Clone 指定分支 1 git clone -b {branch} {rep} 拉取代码解决冲突 git fetch 实际上 pull = fetch + merge，可以解决完冲突再进行代码提交，相对 pull 更安全，结合 Vscode 中的 Gitgraph 等，用于解决冲突和验证修改方面更为安全简单。\n1 2 3 git fetch git log -p FETCH_HEAD git merge FETCH_HEAD 通过使用 Stash 的方式，同样可以避免再拉取远程代码的时候不覆盖本地的代码，灵活选用吧，一般情况下使用 fetch 已经足够。\n一些工具 一些好用的 CLI（命令行工具）和 VsCode 插件推荐：\nLazygit （命令行工具，带一个比较酷炫的 GUI） Gitlens（VsCode）：在编辑界面显示每行代码的提交者，丰富 github 的 git 拓展选项 Gitgraph（VsCode）：方便查看每次 commit 的修改内容，用对比窗口显示，便于发现冲突解决和修改内容 Beyond Compare（差异对比工具）：类似 diff 命令，非常好用的对比和修改不同版本的文件，文件夹之间的差异。 Win Merge （差异对比工具）： BC 的免费替代品，基本上是足够使用的。 还有一些诸如 tortoise 和 github 客户端等图形界面也可供尝试 Troubleshooting 从 Commit 中删除大文件 避免.git 目录占用过多存储，这一部分写的有点小瑕疵，到时候就看超链接\n郑宇 ；主要是要将大文件排除追踪，在 push 之前都还是比较好解决的，但是如果已经提交上去了就稍微比较麻烦，尝试将其中的大文件删掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 1. 运行gc，生成pack文件`–prune = now` 表示对所有的文件都做修剪 git gc --prune=now # 2. 找出最大的k个文件，以3为例 git verify -pack -v .git/objects/pack/*.idx |sort -k -3 -n |tail -3 # bug: cannot open ///bad .. # 可能是由于地址出错了，修改地址，如下是查看地址的代码 find .git/objects/ -type -f # 3. 查看那些大文件究竟是谁，按照上一步输出的hash value 进行搜索，（不用全长） git rev-list --objects --all |grep \u0026lt;hashvalue\u0026gt; # 4. 移除对该文件的追踪引用 git filter-branch --force --index-filter \u0026#34;git rm --cache --ignore-unmatch \u0026#39;\u0026lt;FILENAME HERER\u0026gt;\u0026#39;\u0026#34; --prune-empty --tag-name-filter cat -- --all # 5. 进行repack git for-each-ref --format=\u0026#39;delete %(refname)\u0026#39; refs/original | git update-ref --stdin git reflog expire --expire=now --all git gc --prune=now # 6. 查看pack的空间使用情况 git count-objects -v # 7. 强制推送重构大文件 git push origin local-b:remote-b --force 连接问题 openssl error 10054 1 git config --global http.postBuffer 524288000 time out port443 just wait for some time，应该是代理的问题，不行就使用国行版 github 把\nserver certificate verification failed. CAfile 使用github.com.cnpmjs.org国内镜像站的时候，可能会出现权限的问题，这种情况下就要对 git 的证书验证命令做调整，有两种策略，执行其中一种：\n1 git config --global http.sshverify false 1 2 # carry out in the export GIT_SSL_NO_VERIFY=1 之后我们就可以正常的使用镜像站对原有的 repo 进行更新和拉取了，比如说 omz update.\nToBeContinue Git Rebase专题：GIt Merge和Git Rebase的区别 Git Reset 和 Git Cherrypick 专题：紧急修复 Git tag 专题开发标签 ","permalink":"https://hugotest-phi.vercel.app/posts/git_manual1/","summary":"\u003cp\u003e参考文献：\u003ca href=\"https://juejin.cn/post/7131713973572861966\" target=\"_blank\" rel=\"noopener\"\u003e稀土掘金\u003c/a\u003e\n | ProGit2\u003c/p\u003e\n\u003ch2 id=\"git-与-svn-的区别\"\u003eGIT 与 SVN 的区别\u003c/h2\u003e\n\u003cp\u003eSVN 是集中式版本控制系统，其所有的版本管理都是集中在某个中央服务器，因此，在干活的时候，首先都需要从中央服务器中获取最新的版本，修改后将版本推送到中央服务器，因此大多数场景下需要进行联网使用。可能会更依托于相应的图形化客户端来进行同步和版本管理，便于管理美术资源等等。\u003c/p\u003e\n\u003cp\u003eGIT 是分布式版本管理系统，每个人的电脑就是一个完整的版本库，可以进行独立的版本管理，多人协作可能依托于 github 之类的中继节点，将修改同步给对方，解决冲突。\u003c/p\u003e\n\u003ch2 id=\"init-初始化\"\u003eInit 初始化\u003c/h2\u003e\n\u003cp\u003e包含 ssh 的详细指令在 ssh 的文档中，这边只介绍设置完这一系列操作之后的 git 初始化，主要是初始化 ssh，并将私钥放到 github 或者 gitee 的账户中。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global user.name \u003cspan class=\"s2\"\u003e\u0026#34;YourName\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global user.email \u003cspan class=\"s2\"\u003e\u0026#34;YourEmailAdress\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看相关的配置信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --list\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 设置CRLF和LF的相关转换 第一条在提交的时候自动抓换位LF，迁出转换为CRLF\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 第二条拒绝混合换行符的提交\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global core.autocrlf \u003cspan class=\"nb\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global core.safecrlf \u003cspan class=\"nb\"\u003etrue\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"github-设置\"\u003eGithub 设置\u003c/h3\u003e\n\u003cp\u003e官方文档介绍的一些权限错误的地址：\u0026lt; \u003ca href=\"https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey%3e\" target=\"_blank\" rel=\"noopener\"\u003ehttps://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey\u003e\u003c/a\u003e\n\u003c/p\u003e","title":"Git 01 入门与常用操作"},{"content":"@aikenhong 2022\n当我们需要在Server之间进行，或者Server和WSL之间进行文件的传输，以及文件夹的同步的时候，如果要打开Xftp之类的软件进行，有繁琐的操作中转，或者说目录较为庞杂的时候，也显得有些麻烦。\n于是我们可能希望使用脚本，来实现更便捷，同时也能设置定时功能，使得操作简单便捷，经过简单的调研，我们目前尝试使用以下几种方法，并取得了成功。\nRsync 同步目录 rsync是借助ssh服务进行的文件传输，为了使用起来方便，我们首先需要配置免密登录，在服务器之间传输SSH密钥，参考[[Envs/SSH]]\n此后我们便可以编写同步脚本来同步远程的目录和本地目录，当然也可以执行反向的命令，\n1 rsync -azP --delete -e \u0026#39;ssh -p port\u0026#39; --progress --stats --exclude \u0026#34;big Files or sth\u0026#34; user@ip:source_path target_path \u0026gt;transfer.log 根据progress和stats我们记录传输过程中的日志，并输出到transfer.log，同时使用exclude排除大文件，避免传输过慢。\na: 归档文件模式（保留文件的时间戳等），保括了r的递归 z: 使用压缩文件传输 P: 支持断点续传 delete: 会删除目标文件中多出来的东西，保持同步，使得成为远程的镜像，但是有时候我们可能不需要这点，避免同步损毁\n参考：\nUbuntu使用Rsync远程备份 阮一峰的rsync详细讲解 SCP传输特定文件 Linux scp文件传输命令用于Linux之间复制文件和目录，全称“secure copy”，基于SSH进行的安全的远程文件拷贝命令\n1 2 model=\u0026#39;local file\u0026#39; scp -P port $model user@remote_ip:remote_folder 菜鸟教程scp参数介绍 出现问题：permission denied：使用chmod 修改远程文件夹权限，774 or 777\nCrontab定时执行脚本 实际上本篇章应该在后续移动到Linux笔记中，是一个定期执行程序的命令，我们可以通过这个命令来定期执行我们的脚本\n1 2 3 4 5 6 7 crontab -l crontab -e sudo nvim /etc/rsyslog.d/50-default.conf 开启cron.log 重启相关服务 sudo service rsyslog restart sudo service cron restart 编辑定时设置：\n1 30 10 * * * path/file.sh \u0026gt;\u0026gt; logfile.log 修改要调用的sh文件的权限\n1 sudo chmod 777 file.sh 菜鸟教程 SZ、RZ传输文件 sz、rz命令是Linux、Unix与Windows进行ZModem文件传输的命令；\n安装lrzsz：\n1 sudo apt-get install lrzsz sz： sent zmodern 从服务器传输文件到的本地 rz：reveice 从windows传递文件到Linux服务器 ","permalink":"https://hugotest-phi.vercel.app/posts/transfer-sync-files/","summary":"\u003cp\u003e@aikenhong 2022\u003c/p\u003e\n\u003cp\u003e当我们需要在Server之间进行，或者Server和WSL之间进行文件的传输，以及文件夹的同步的时候，如果要打开Xftp之类的软件进行，有繁琐的操作中转，或者说目录较为庞杂的时候，也显得有些麻烦。\u003c/p\u003e\n\u003cp\u003e于是我们可能希望使用脚本，来实现更便捷，同时也能设置定时功能，使得操作简单便捷，经过简单的调研，我们目前尝试使用以下几种方法，并取得了成功。\u003c/p\u003e\n\u003ch2 id=\"rsync-同步目录\"\u003eRsync 同步目录\u003c/h2\u003e\n\u003cp\u003ersync是借助ssh服务进行的文件传输，为了使用起来方便，我们首先需要配置免密登录，在服务器之间传输SSH密钥，参考[[Envs/SSH]]\u003c/p\u003e\n\u003cp\u003e此后我们便可以编写同步脚本来同步远程的目录和本地目录，当然也可以执行反向的命令，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ersync -azP --delete -e \u003cspan class=\"s1\"\u003e\u0026#39;ssh -p port\u0026#39;\u003c/span\u003e --progress --stats --exclude \u003cspan class=\"s2\"\u003e\u0026#34;big Files or sth\u0026#34;\u003c/span\u003e user@ip:source_path target_path \u0026gt;transfer.log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e根据progress和stats我们记录传输过程中的日志，并输出到transfer.log，同时使用exclude排除大文件，避免传输过慢。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ea: 归档文件模式（保留文件的时间戳等），保括了r的递归\nz: 使用压缩文件传输\nP: 支持断点续传\ndelete: 会删除目标文件中多出来的东西，保持同步，使得成为远程的镜像，但是有时候我们可能不需要这点，避免同步损毁\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e参考：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://cloud.tencent.com/developer/article/1490094?from=article.detail.1813628\" target=\"_blank\" rel=\"noopener\"\u003eUbuntu使用Rsync远程备份\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.ruanyifeng.com/blog/2020/08/rsync.html\" target=\"_blank\" rel=\"noopener\"\u003e阮一峰的rsync详细讲解\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"scp传输特定文件\"\u003eSCP传输特定文件\u003c/h2\u003e\n\u003cp\u003eLinux scp文件传输命令用于Linux之间复制文件和目录，全称“secure copy”，基于SSH进行的安全的远程文件拷贝命令\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003emodel\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;local file\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003escp -P port \u003cspan class=\"nv\"\u003e$model\u003c/span\u003e user@remote_ip:remote_folder\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://www.runoob.com/linux/linux-comm-scp.html\" target=\"_blank\" rel=\"noopener\"\u003e菜鸟教程scp参数介绍\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e出现问题：permission denied：使用chmod 修改远程文件夹权限，774 or 777\u003c/p\u003e\n\u003ch2 id=\"crontab定时执行脚本\"\u003eCrontab定时执行脚本\u003c/h2\u003e\n\u003cp\u003e实际上本篇章应该在后续移动到Linux笔记中，是一个定期执行程序的命令，我们可以通过这个命令来定期执行我们的脚本\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecrontab -l \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecrontab -e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo nvim /etc/rsyslog.d/50-default.conf 开启cron.log\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e重启相关服务\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo service rsyslog restart\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo service cron restart\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e编辑定时设置：\u003c/p\u003e","title":"Linux 文件传输和同步"},{"content":"@AikenHong 2022\n[[Draft/IL 总结]]: Thx 2 wyz to provide some clus for learnning Incremental Learning.\nIn this Doc, we may add some related knowledge distill works which is used to design our Incremental Structure. 在这个文档中，我们可能还会添加一些知识蒸馏的相关工作的文献，这些实际上对于我的增量学习架构有一个比较大的启发\nDER SPPR 没有 get 到方法到底是怎么做的 Introduction 👿 在很多视觉应用中，需要在保留旧知识的基础上学习新知识，==举个例子==，理想的情况是，我们可以保留之前学习的参数，而不发生==灾难性遗忘==，或者我们基于之前的数据进行协同训练，灾难性遗忘是 IL 中最核心的问题。\nIncremental 的基本过程可以表示如下[4]： 我们将模型可以划分为以下的两个部分[1]：backbone 和 classifier 从 LWF 中我们可以知道经典的 Paradigm，主要有下面的三种来对 $\\theta _S$ 和 $\\theta_o$ 来进行更新：\n仅重新训练分类器：仅更新 $\\theta_o$ 微调特征提取器，重新训练分类器 联合训练 基于蒸馏架构的方法 这一系列的方法实际上是 IL 最经典的发展路线，实际上从初始的蒸馏架构开始，最后逐渐的发展到结合回放的策略中，我认为结合rehearsal才是该类方法最后的归宿，所以我将基于蒸馏正则化的 Pod 和 LWF 也放到了这一部分。\nMotivation 《Learning without Forgetting》LWF 主要带来的就是将 KD 损失引入 Joint Training 的范式，也就是我们印象中最原始的增量学习的途径，利用 expand_dim 训练最后输出的新的节点，但是这个范式是不需要旧数据。\n$$ Loss = L_{CE} + L_{KD}\r$$\r这里的蒸馏使用的是最终的 pred 输出，后续对于蒸馏损失的有 KDC 的变体，根据新旧样本的比例来赋予权重，考虑模型优化的权重。\n$$ Loss = \\lambda L_{CE} + (1-\\lambda) L_{KD}\r$$\r其中 $\\lambda^2 = \\frac{|C_{old}|}{|C_{old}|+ |C_{new}|}$\n这就是最经典的 Incremental Learning 的范式，我们首先继承一部分分类器的参数，然后通过这个损失对整个框架进行协同训练。\n引入旧样例 《ICaRL: Incremental Classifier and Representation Learning》在 LWF 基础上引入部分旧数据来避免灾难遗忘的问题\n基于特征提取器对新旧数据的训练集提取==平均特征向量==（Kmeans + KNN） 基于最近邻均值分类算法 NME 计算出新旧数据的预测值 计算 LWF 的经典损失，优化模型 本文的亮点主要在于引入了旧的数据进行复习（有一个比较好的数据选取策略），以及最后使用的不是全连接层而是最近邻分类器来作为预测。（Will This Get Better？）\n后续在 ==《End-to-End Incremental Learning》== 中，将最近邻分类器替换成分类层，其动机就是对 ICaRL 进行优化。\nmemory 保存旧样本 -\u0026gt; CE+KD -\u0026gt; reBalance + Fine-tune\n由于数据量上的有偏，导致分类器会严重有偏与 New-Classes，但是我认为这个可能是对于场景设定的不同，加入新的需求和发现少量的数据两者是一个比较大的不同。\n这里的 样本选择策略 可能在后续会比较有用。\n在 ICaRL 中选择的是最确信的样本来 rehearsal，也就是使用特征中心的 KNN 方法来选取样本。 而在==《Rainbow Memory》==[8]中则是选择最难的样本，其 motivation 是选择最接近判别界样本 RM 的最终实现的思路是通过 Data Augmentation 对样本进行变化，将不同 Augmentaion 后的预测的偏差（不确定程度）来衡量一个样本是 Hard or Simple Task，基于这种方式来选择 Hard-Task（Uncertainty）\n具体而言，标签为 c 的样本，经过 perturbed 后，被网络预测为 c 类的次数越多，则不确定性越弱。\n优化分类器 由于新类的大量数据带来的偏差，==《Large Sacale Incremental Learning》== 试图解决这个问题\n将训练集划分一个 rebalance 的 dataset 作为验证集，并用该数据集训练一个 Bias Correction Layer 得到修正的参数， 该层的输出如下，实际上就是一个线性回归层，只有两个参数\n$$ q_{k}=\\left\\{\\begin{array}{lr}\ro_{k} \u0026 1 \\leq k \\leq n \\\\\r\\alpha o_{k}+\\beta \u0026 n+1 \\leq k \\leq n+m\r\\end{array}\\right.\r$$\r训练该层的时候固定 CLF 和 BB，使用 CE 损失即可，但是模型在大数据集上的表现更佳，在 cifar100 的小数据集上表现一般。\n另外还有借助 Long-Tailed 中的策略，从 $||W||$ 的角度矫正偏差的文章 ==《Learning a Unified Classifier Incrementally via Rebalancing》==\n动机是由于：1）imbalance：new classes 的权重的大小远远高于 old classes 的权重。2）特征与 old classes 的权重关系没有保留。3）一些 new classes 的权重与 old classes 的权重相近（容易混淆的类别），导致歧义性。\n引入了 Cosine Normalization 分类器，实际上就是进分类器之前进行正则化，加入 Margin 损失（可以参考人脸比对的 Cosine Face 之类的）最终损失为：\n$$ L=\\frac{1}{|\\mathcal{N}|} \\sum_{x \\in \\mathcal{N}}\\left(L_{\\mathrm{ce}}(x)+\\lambda L_{\\mathrm{dis}}^{\\mathrm{G}}(x)\\right)+\\frac{1}{\\left|\\mathcal{N}_{\\mathrm{o}}\\right|} \\sum_{x \\in \\mathcal{N}_{\\mathrm{o}}} L_{\\mathrm{mr}}(x)\r$$\r更简单的有==《Maintaining discrimination and fairness in class incremental learning》==，通过对于分类器中的新旧模型的**weight **做 Rescale 使其再 W 上达成一致来维持一个较好的效果\n$$ \\begin{gathered}\rW = (W_{old},W_{new}) ; Norm_{old} = (||W_1||, ···, ||W_{c^b_{old}}) \\\\\r\\gamma = \\frac{Mean(Norm_{old})}{Mean(Norm_{new}} \\\\\r\\hat{W}_{new} = \\gamma · W_{new} \\\\\r\\end{gathered}\r$$\r优化特征提取器 其实Incremental现阶段的任务也倾向于使用两阶段的架构，基于这样的架构，我们首先提名最重要的就是基于SCL的这篇文章[9],这篇文章主要的思路是：\nSCL+projector（Train）+NCM（Test）\r训练的Batch就是普通的Memory+New，但是值得一提的是，这篇文章对Memory的数据选取做了消融实验，得到了这样的结果：\n随机选取Memory的效果\u0026gt;GSS（NIPS2019）和ASER（AAAI2021），是一个令人惊讶的结果.\n而类似的，也有使用图像旋转的SSL（缓解ce带来的特征bias）+CE结合Prototype（rehearsal避免遗忘）+ KDLoss的研究[14]，证明了结合类似的自监督任务能够有效缓解特征之间的重叠。\n使用的SSL任务是常见的Rotate Loss, KD是和上一轮的模型做约束。\n$$ L_{t,total} = L_{t,ce} + \\lambda L_{t,protoAug} + \\gamma L_{t,kd}\r$$\r同样的C2OL[15] 这篇方法，就用最基本的对比学习的损失来研究该方法对于IL的实用性，也发现了基于CL学出来的特征确实更适合用在蒸馏的任务之上，验证了我们的猜想。\n优化损失设计 《PODNet Pooled Outputs Distillation for Small-Tasks Incremental Learning》基于样本回放的方法，改进 KD，定义了 Pooled Output Distillation。\nspatial-based distillation-loss，基于空间的蒸馏损失，改进蒸馏方法 representation comprising multiplt proxy vectors，代理向量改进了分类器 ==part1 Update KD Loss==\nPooling 简略图\r假设： $\\hat{y} = g(f(x))$ 为分类过程，其中 $f(x)$ 代表特征提取过程。 POD 算法则为，不仅将蒸馏应用到特征提取的最终输出，还将其用于 $f(x)$ 的中间过程的输出\n$$ f^t(x) = f^t_L .. ·f^t_l .. ·f^t_1(x)\r$$\r中的每一层（如下式）都作为中间的结果，用来做 KD，上标 t 表示 task，下标则表示模型第几层。\n$$ h^t_{l,c,w,h} = f^t_l(·)\r$$\r对该输出的各层执行各种级别的 POD 蒸馏，作为我们的监督来实现对灾难性遗忘的避免：\n$$ \\mathcal{L}_{\\text {POD-pixel }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C} \\sum_{w=1}^{W} \\sum_{h=1}^{H}\\left\\|\\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2}\r$$\r显然 pixel 级别对于模型的约束是最强的\n$$ \\begin{gathered}\r\\mathcal{L}_{\\text {POD-channel }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{w=1}^{W} \\sum_{h=1}^{H}\\left\\|\\sum_{c=1}^{C} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{c=1}^{C} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2} \\\\\r\\mathcal{L}_{\\text {POD-gap }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C}\\left\\|\\sum_{w=1}^{W} \\sum_{h=1}^{H} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{w=1}^{W} \\sum_{h=1}^{H} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2} \\\\\r\\mathcal{L}_{\\text {POD-width }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\sum_{c=1}^{C} \\sum_{h=1}^{H}\\left\\|\\sum_{w=1}^{W} \\mathbf{h}_{\\ell, c, w, h}^{t-1}-\\sum_{w=1}^{W} \\mathbf{h}_{\\ell, c, w, h}^{t}\\right\\|^{2}\r\\end{gathered}\r$$\rpixel 级别的蒸馏对于模型限制比较严格，其他级别的对于模型限制相对较松，需要一个权衡，作者最终选用的是 Spatial 级别的蒸馏，相当于 width 和 height 层面蒸馏 loss 之和\n$$ \\mathcal{L}_{\\text {POD-spatial }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)=\\mathcal{L}_{\\text {POD-width }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)+\\mathcal{L}_{\\text {POD-height }}\\left(\\mathbf{h}_{\\ell}^{t-1}, \\mathbf{h}_{\\ell}^{t}\\right)\r$$\r特征提取模型最终的特征则使用 pixel 级别的蒸馏：\n$$ \\mathcal{L}_{POD-flat}(h^{t-1},h^t) = ||h^{t-1} - h^t||^2\r$$\r将这些蒸馏损失整合起来取代原本的 KD-Loss，再加上我们的 CE 即可：\n$$ \\begin{gathered}\r\\mathcal{L}_{POD-final} = \\frac{\\lambda_c}{L-1}\\sum_{l=1}^{L-1} \\mathcal{L}_{POD-spatial}(f_l^{t-1}(x),f_l^t(x)) + \\\\\r\\lambda_f \\mathcal{L}_{POD-flat}(f_l^{t-1}(x),f_l^t(x))\r\\end{gathered}\r$$\r==Part2 Local Similarity Classifier==\n第一个改进点就是将 Loss 修正为 Cosine 的形式UCiR，实际上就是使用的归一化后的 FC 层，但是如果只使用一个 Cos 相似度，好像多样化的需求无法满足，需要类似一个多头的机制\n和 LT 的地方一样，IL 近年来的主要架构也是两部分进行分离的，所以我们可以考虑从我们的角度来实现类似 POD-Loss 的架构维持，也就是一定程度上为我们的 SSL-SCL 架构的可行性提供了一定的信心。\n该方法迄今为止还是很多增量任务的榜单前几，该方法的蒸馏性能也被验证为有效，但是实际上将该方法用于模型中需要增加大量的特征输出模块，整体架构上修改起来可能会较为复杂。\n基于模型结构的方法 这一部分不是我研究的重点，可以看到有一部分设计的拓张模型或者，堆叠模型，用额外的结构来承载对应的新类的研究，可能考虑到一部分参数公用然后实行协同判断的策略把。\n或者是其他的图模型，拓扑结构（神经气体网络）等等的方法，拓扑结构等方法可能户籍是未来的一个方向。\n特征网络堆叠 DER 特征网络堆叠的方法 其他方法 EWC ：这类方法一般是对网络中每个参数的重要性进行评估，根据每个参数的重要性，调整梯度信息更新参数。 其他问题 这里会收集一部分 IL 中存在的一些现象或者问题\n新类优于旧类 模型倾向于时间上接近的模型有更高的敏感度，这可能是训练的过程决定的，也可能是由于再新类的训练上新类的权重要明显高于旧类，导致的某种数据不均衡的现象。\n此外在传统的设定中，新类的数据量会大大的大于旧类\nFew-Shot Incremental Few-Shot 的增量情景更贴切于我的场景假设，在这种假设的背景之下，增量学习也会面临一些新的困难，这个篇章中我们可能会简要的总结一些方法对抗小样本和灾难性遗忘的思路和策略。\n小样本的类别原型不稳定 容易和旧类别混淆 在进行总结的同时，我们的调研方向也会有所侧重，比如基于拓扑的神经气体网络方法，我们可能暂时不那么关心（精力有限）\n拓扑结构方法 《Few-Shot Class-Incremental Learning》[10] SPPR 《Self-Promoted Prototype Refinement for Few-Shot Class-Incremental Learning》这篇文章的主要贡献有以下的两点：\n提出了 RESS（随机 episode 选择策略）通过强制特征自适应于各种随机模拟的增量过程来增强特征表示的可扩展性。 引入了一种自提升的原型细化机制(SPPR)，利用新类样本和旧类 prototype 表示之间的关系矩阵来更新现有的 prototypical RESS 实际上应该是类比 Meta Learning 提出的一种训练策略 SPPR 是本文的核心，为了保持旧类之间的依赖和新类置假你都区分度，要对新类的原型进行提炼 理论上讲 SPPR 更新的应该是模型的参数，但是在代码中我暂时没有找到对应的实现的地方\nso we drop this method which is not match our structure\nEvolved classifier 由于数据量少的这个特点，我们解耦 BB 和 CLF，每次增量任务只更新分类器。\n该文章[12]在多个数据集上实现了 SOTA，提出了 CEC（Continually Evolved Classifier），将图模型用在分类器上，它的分类器是一个无参数的 class mean classifier（听起来像 NCM）；\n实际上就是在一个较优的特征空间的基础上调整我们的决策边界的一个策略，该方法引入了图注意力模型（GAT），该方法有一个特性是：\n增加节点而不改变其他的节点， 利用拓扑关系，链接关系的不变性，利于保留旧知识 $$ w_{new} = w_{old} + (\\sum^{w_n}_k=1a_{jk}U_{w_k})\r$$\r使用 GAT 获得线性变换矩阵和注意力系数来更新模型的权重。\n此外提供了一种旋转增强的新型策略，效果特别好==pseudo incremental learning==，可能和 GAT 的一些特性有关，结合 GAT 效果提升巨大，要警惕这种方法是通用的还是特异性的。最好是看看有没有原理分析。\nCEBN 采用三阶段的方式来实现小样本的增量学习，根据上述的任务划分图来确定不同的实验阶段：\n用大量数据训练基准的分类模型，使用的就是 base class 学习 novel class 防止灾难性遗忘，只使用新类数据（修正 CE 考虑小样本问题）（使用参数来正则防止 BB 灾难遗忘） 混合数据进行训练，这个时候使用一个 balance 的数据集，比如说做多次增量的话，在最后一次使用 balance replay 即可。 第二阶段的损失是这里的关键，基于 CEBN 修改 CE，为啥我看不出区别，我感觉实际上就是 CE，只是虽然只用新数据训练，但是分类器是完整的罢了，其实就是 CE：\n$$ CE_{BN}(x) = \\sum_{C_N}y_iln(\\frac{exp(o_i)}{\\sum_{C_N} exp(o_j) + \\sum_{C_B}(o_k)})\r$$\r正则项则通过对前后的 Backbone 进行约束得到：\n$$ L_2^{WC} = \\sum||\\theta_1 - \\theta_2||^2\r$$\r最终整合起来的损失如下：\n$$ Loss = L_2^{WC} + \\lambda CE_{BN}\r$$\rReferences 📚Awesom Incremental Learning Collections | 🌤️Paper w Code Incremental Learning Learning without Forgetting | ZHIHU | ECCV2016 iCaRL Incremental Classifier and Representation Learning | CnBlog ， ZhiHu | CVPR2017 Ene-to-End Incremental Learning | ECCV2018 ⭐ PODNet Pooled Outputs Distillation for Small-Tasks Incremental Learning | ECCV2020 | CSDN Large Sacale Incremental Learning | CVPR2019 | CSDN Learning a Unified Classifier Incrementally via Rebalancing | CVPR2019 | Maintaining discrimination and fairness in class incremental learning | CVPR2020 Rainbow Memory: Continual Learning with a Memory of Diverse Samples | CVPR2021 | CSDN Supervised Contrastive Replay: Revisiting the Nearest Class Mean Classifier in Online Class-Incremental Continual Learning | CVPR2021 | CSDN Few-Shot Class-Incremental Learning | CVPR2020 | CSDN Self-Promoted Prototype Refinement for Few-Shot Class-Incremental Learning | CVPR2021 | CSDN Few Shot Incremental Learning with Continually Evolved Classifiers | CVPR2021 | Generalized and Incremental Few-Shot Learning by Explicit Learning and Calibration without Forgetting | ICCV2021 | CSDN Prototype Augmentation and Self-Supervision for Incremental Learning | CVPR2021 | ZHIHU Contrastive Continual Learning | ICCV2022 | CSDN 一些总结笔记\nClassic Incremental Papers Background and Dilemma Online Continual Learning An Empirical Survey | 2021 | Notion 这篇综述给人的感觉比较一般把，或者可能是总结文档里没有写出比较关键的一些看法和证据。感觉不是特别推荐阅读。 Incremental Learning in 20-21 | 下面的图也来自这篇文章 to be placed in the right place 将一些新的研究先放在这里，到时候看看要组织到笔记的那一部分。\nclass-Incremental learning via Dual Augmentation 该文章认为，类增量学习中灾难性遗忘可以被总结为两个方面带来的：特征表示上的偏差和分类器上的偏差。\n增量过程中如果不对特征提取器进行适应，则对新特征的提取能力不够；如果进行适应则会产生灾难性的遗忘 分类器如果不进行更新，会和新的特征表示不适应，而由于没有旧类的数据，就没有更新旧类的方向 解决的思路是：\n训练的阶段做mixup来做混合类的学习，通过这种预先训练，来帮助模型得到一个较为稳定的表征。 分类上将历史数据的均值和方差记录下来，对模型更新的时候，通过分布信息生成语义特征维持决策边界，防止对旧类分成新类。 第二部分具体细节的实现上还不是很清晰，后续可以看代码，但是目前来看不是我们需要的。\nLooking back on learned experiences for class/task incremental learning 主要贡献：无数据的增量学习，支持经验重放，不需要平行网络输出蒸馏监督。\nkd使用的是最小欧拉距离：L2范数的平方作为损失。\nOvercoming Catastrophic Forgetting in Incremental Few-Shot Learning by Finding Flat Minima CSDN 在基础模型训练阶段，企图找到一个损失的下降平坦点而不是简单的一个极小值，平坦极小值的模型的鲁棒性能会比普通的模型优异一些，具体对于平坦点的定义可以参见下面的这张图：\n这种平坦点的研究，实际上和NotZeroLoss的设定具有相当的相似性，帮助模型学习到一个更加稳定的解，而该解在后续进行增量学习的过程中，会减少对应的灾难性遗忘的现象。\nDistilling causal effect of data in class-incremental learning 也是通过因果分析来筹建分类结果，通过TDE的方式消除类别偏差，这一部分实际上和我们的Causal模块和统计均值模块应该是起到了相同的作用，这里暂时不深入进行解读。\n==the two below== is important for our research:\nDo not Forget to Attend to Uncertainty while Mitigating Catastrophic Forgetting Papers using attention and the bayes formula to calculate the Uncertainty or something else.\nContinual Learning in the Teacher-Student Setup: Impact of Task Similarity Papers do a lot for the loss, which we should pay attention for it.\n","permalink":"https://hugotest-phi.vercel.app/posts/il-collection/","summary":"\u003cp\u003e@AikenHong 2022\u003c/p\u003e\n\u003cp\u003e[[Draft/IL 总结]]: Thx 2 wyz to provide some clus for learnning Incremental Learning.\u003c/p\u003e\n\u003cp\u003eIn this Doc, we may add some related knowledge distill works which is used to design our Incremental Structure.\n在这个文档中，我们可能还会添加一些知识蒸馏的相关工作的文献，这些实际上对于我的增量学习架构有一个比较大的启发\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/weixin_36474809/article/details/116176371\" target=\"_blank\" rel=\"noopener\"\u003eDER\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003eSPPR 没有 get 到方法到底是怎么做的\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction-\"\u003eIntroduction 👿\u003c/h2\u003e\n\u003cp\u003e在很多视觉应用中，需要在保留旧知识的基础上学习新知识，==举个例子==，理想的情况是，我们可以保留之前学习的参数，而不发生==灾难性遗忘==，或者我们基于之前的数据进行协同训练，灾难性遗忘是 IL 中最核心的问题。\u003c/p\u003e\n\u003cp\u003eIncremental 的基本过程可以表示如下\u003csub\u003e[4]\u003c/sub\u003e：\n\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/20220106101003.png\"\u003e\r\n    \u003cimg alt=\"dsa\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/20220106101003.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/20220106101003.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"dsa\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"IL Collection"},{"content":": hammer: 王耀智\nRegularization 系列方法 这类方法旨在添加一些正则化损失来解决 catastrophic forgetting 的问题。\nWeight Regularization 这类方法一般是对网络中每个参数的重要性进行评估，根据每个参数的重要性和梯度信息更新参数。\n典型的文章为 EWC .\nPS: 这类文章我也没有读过。\nData Regularization 这类方法专注于记住特征表示，通常是结合 Hinton 的知识蒸馏损失函数使得模型记住旧类别的知识，解决 catastrophic forgetting。\n推荐以下几篇文章：\nLwF(Learning without forgetting)，这篇文章在我看来是增量学习的开山之作，第一次给增量学习找到了一个比较好的方向，也是第一次将知识蒸馏应用到增量学习上； PODNet CVPR2020 ，这篇文章最大的贡献在我看来是设计了一个全新的蒸馏损失函数，最终结果也是达到了当时的sota，甚至目前也是几个榜单的sota。 Rehearsal 系列方法 这类方法主要的想法是使用一些旧类别的数据，在新类别到来时使用新旧数据一起训练模型，根据旧类别数据的真假分为以下两种方法。\nPseudo rehearsal 这类方法通常是在学习旧类别的同时，训练一个生成模型，可以生成旧的类别数据，在新类别数据到来时，生成相当数量的旧类别数据，一起训练新模型。\n这里推荐一篇文章：Continual learning with deep generative replay。\nPS：这个小类别的论文我也没有太关注，个人不是很推荐这类方法。\nSave real data 这类方法是开辟一个内存空间，空间中保存旧类别的少部分训练数据，在新类别到来时，使用内存空间的数据与新数据共同学习，按照对空间的使用方法不同可分为：\nExemplar Rehearsal 这类方法是将新旧数据混合，共同作为训练数据，一起训练模型，使得模型能够保持旧类别的知识。\n但是在训练过程中新旧数据的类别数量是不均衡的，这也催生了我下面会说到的一大类解决方法。\n这种方法推荐的论文是 iCaRL，这篇论文是 exemplar rehearsal 的开山之作，第一次提出了内存空间这个概念，也提出了一个非常有效的内存选择策略(herb)，并且也是第一个使用特征作为分类依据的方法，我个人认为是继 LwF 之后又一个将 IL 推到一个新的高度的方法。\nGradient Rectification 这类方法我称之为 Gradient Rectification，其主要思路是模型每次更新的梯度由 shared gradient 和 task-specific gradient 组成。分别代表所有类别的共性信息和某一个类别的特性信息，在新类别学习时借助内存空间中的数据获得旧类别的两项梯度，在更新时对梯度进行修正，力求做到不增加共享梯度代表的损失，尽量减少类别特定梯度代表的损失。\n这类方法的论文推荐是 CVPR 2021 的 Layerwise optimization by gradient decomposition for continual learning，还有其前身作 GEM。\nStruture Base Methods 这类方法旨在设计一些新的结构或者更改结构以适应 IL 的实验设置，具体也分为两类：\nSpecial Architecture 这类方法设计一些特殊的模型或者拓展模型来适应 IL。\n推荐几篇文章：\nLifelong learning with dynamically expandable network. Adaptive Aggregation Networks for Class-Incremental Learning Violent Stacking 这类方法是每次 task 训练一个特征提取器，然后将其与之前的堆叠，最后进行剪枝操作，减少模型参数。\n这类方法目前只有一篇文章，CVPR 2021 的 DER，也是达到了部分 sota。\nClassifier Rectification 这类方法很大程度上是为了解决上面提到的数据不均衡提出的，主要是对训练完成后的模型的 FC 层进行修正。\n这类方法的思路通常比较简单，但是非常有效。\n推荐以下几篇文章：\nBiC: Large scale incremental learning Maintaining discrimination and fairness in class incremental learning Others Combine SSL Combine Meta-learning Define New Problem(Few-shot IL) Application in other tasks, like object detection ","permalink":"https://hugotest-phi.vercel.app/posts/il-wyz/","summary":"\u003cp\u003e: hammer: 王耀智\u003c/p\u003e\n\u003ch2 id=\"regularization-系列方法\"\u003eRegularization 系列方法\u003c/h2\u003e\n\u003cp\u003e这类方法旨在添加一些正则化损失来解决 \u003ccode\u003ecatastrophic forgetting\u003c/code\u003e 的问题。\u003c/p\u003e\n\u003ch3 id=\"weight-regularization\"\u003eWeight Regularization\u003c/h3\u003e\n\u003cp\u003e这类方法一般是对网络中每个参数的重要性进行评估，根据每个参数的重要性和梯度信息更新参数。\u003c/p\u003e\n\u003cp\u003e典型的文章为 \u003ca href=\"https://www.pnas.org/content/pnas/114/13/3521.full.pdf\" target=\"_blank\" rel=\"noopener\"\u003eEWC\u003c/a\u003e\n .\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ePS: 这类文章我也没有读过。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"data-regularization\"\u003eData Regularization\u003c/h3\u003e\n\u003cp\u003e这类方法专注于记住特征表示，通常是结合 Hinton 的知识蒸馏损失函数使得模型记住旧类别的知识，解决 catastrophic forgetting。\u003c/p\u003e\n\u003cp\u003e推荐以下几篇文章：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLwF\u003c/code\u003e(Learning without forgetting)，这篇文章在我看来是增量学习的开山之作，第一次给增量学习找到了一个比较好的方向，也是第一次将知识蒸馏应用到增量学习上；\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://arxiv.org/abs/2004.13513\" target=\"_blank\" rel=\"noopener\"\u003ePODNet CVPR2020\u003c/a\u003e\n ，这篇文章最大的贡献在我看来是设计了一个全新的蒸馏损失函数，最终结果也是达到了当时的sota，甚至目前也是几个榜单的sota。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"rehearsal-系列方法\"\u003eRehearsal 系列方法\u003c/h2\u003e\n\u003cp\u003e这类方法主要的想法是使用一些旧类别的数据，在新类别到来时使用新旧数据一起训练模型，根据旧类别数据的真假分为以下两种方法。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch3 id=\"pseudo-rehearsal\"\u003ePseudo rehearsal\u003c/h3\u003e\n\u003cp\u003e这类方法通常是在学习旧类别的同时，训练一个生成模型，可以生成旧的类别数据，在新类别数据到来时，生成相当数量的旧类别数据，一起训练新模型。\u003c/p\u003e\n\u003cp\u003e这里推荐一篇文章：Continual learning with deep generative replay。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ePS：这个小类别的论文我也没有太关注，个人不是很推荐这类方法。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"save-real-data\"\u003eSave real data\u003c/h3\u003e\n\u003cp\u003e这类方法是开辟一个内存空间，空间中保存旧类别的少部分训练数据，在新类别到来时，使用内存空间的数据与新数据共同学习，按照对空间的使用方法不同可分为：\u003c/p\u003e\n\u003ch4 id=\"exemplar-rehearsal\"\u003eExemplar Rehearsal\u003c/h4\u003e\n\u003cp\u003e这类方法是将新旧数据混合，共同作为训练数据，一起训练模型，使得模型能够保持旧类别的知识。\u003c/p\u003e\n\u003cp\u003e但是在训练过程中新旧数据的类别数量是不均衡的，这也催生了我下面会说到的一大类解决方法。\u003c/p\u003e\n\u003cp\u003e这种方法推荐的论文是 \u003ccode\u003eiCaRL\u003c/code\u003e，这篇论文是 exemplar rehearsal 的开山之作，第一次提出了内存空间这个概念，也提出了一个非常有效的内存选择策略(herb)，并且也是第一个使用特征作为分类依据的方法，我个人认为是继 LwF 之后又一个将 IL 推到一个新的高度的方法。\u003c/p\u003e\n\u003ch4 id=\"gradient-rectification\"\u003eGradient Rectification\u003c/h4\u003e\n\u003cp\u003e这类方法我称之为 Gradient Rectification，其主要思路是模型每次更新的梯度由 shared gradient 和 task-specific gradient 组成。分别代表所有类别的共性信息和某一个类别的特性信息，在新类别学习时借助内存空间中的数据获得旧类别的两项梯度，在更新时对梯度进行修正，力求做到不增加共享梯度代表的损失，尽量减少类别特定梯度代表的损失。\u003c/p\u003e","title":"WYZ-IL-Collection"},{"content":"LT-Collections @AikenHong 2021\nCode of must of those methods We will analysis those tricks on LT situation, and Analysis why it works. 在进行LT矫正的任务中，有几种常见的trick在各种模型中被使用，我们会对这几种不同的trick进行介绍和分析。\n其实在数据量少这一方面LT和Few-Shot是有一定的OverLap的,可以参考以下那边的思路perhaps\nIntroduction 通常情况下这种严重的类别不平衡问题会使得模型严重过拟合于头部，而在尾部欠拟合\n首先介绍 bag of tricks 这篇论文中总结了一些常用的Trick，并组合出了最佳的一套trick\n经过该文实验总结，Trick组合应该是[1]`：\n在前几个epoch应用input mixup数据增强，然后后面fine-tuning; (基于CAM的)重采样来重新训练分类器; 实际上就是MixUp + Two-Stage的策略，后续对Mix-up这个策略带来的作用要进行补充了解一下\nRebalance 对于ReBalance的方法，实际上就是从 data和 update两个角度来缓解Unbalance本身，通过从数据量上达到重新均衡，或者基于Loss使得bp过程中赋予Tail更高的权重来达到优化过程的平衡。\n前者称为rebalance，后者则为reweight.\nreweighting 这一部分在实际设计上的体现主要是通过对Loss的重新构造而成，通过对Loss的构造来实现区分的BP权重.\n代价敏感softmax交叉熵损失CS_CE: 在ce前乘最小训练图像数目与每个类别图像数目的比值，相当于更注重少类样本 $$ \\mathcal{L}_{CS\\_CE}(\\mathbf{z}, c)=-\\frac{n_{\\min }}{n_{c}} \\log \\left(\\frac{\\exp \\left(z_{c}\\right)}{\\sum_{i=1}^{C} \\exp \\left(z_{i}\\right)}\\right)\r$$\rFocal Loss：设置 $\\alpha$ 和 $\\beta$ 来控制少数类和难分类别对损失的贡献： $$ \\mathcal{L}_{\\text {Focal }}(\\mathbf{z}, c)=-\\sum_{i=1}^{C}\\left(1-p_{i}^{t}\\right)^{\\gamma} \\log \\left(p_{i}^{t}\\right) $$\r类别平衡损失：就是在基本的损失（CE，FOCAL）前加入一个衡量权重，其中 $\\beta$ 是一个超参数，来衡量有效的信息 $$ \\mathcal{L}_{CB\\_Focal}(\\mathbf{z}, c)=-\\frac{1-\\beta}{1-\\beta^{n_{c}}} \\sum_{i=1}^{C}\\left(1-p_{i}^{t}\\right)^{\\gamma} \\log \\left(p_{i}^{t}\\right) $$\rLogit Abjustment[3]: $$ \\ell(y, f(x))=\\alpha_{y} \\cdot \\log \\left[1+\\sum_{y^{\\prime} \\neq y} e^{\\Delta_{y y^{\\prime}}} \\cdot e^{\\left(f_{y^{\\prime}}(x)-f_{y}(x)\\right)}\\right] $$\rrebalance 实际上就是对少类或者多类的数据重新做均衡，方法的本质差别一般都不是特别大\n随机过采样：随即重复少数类别的样本来使得样本均衡 随机降采样：随机删除多数类别的样本使得样本均衡 样本平衡采样：应该值得就是1-2 IB-Sampling 类别平均采样: 对类别进行统一采样，每个类别被采样的概率都一样(Q=0)，然后从每个类别中有放回的随机采样实例，从而构建平衡的数据集 $$ p_j = \\frac{n_j^q}{\\sum_{i=1}^C n_i^q} $$\r平方根采样(Q=0.5) 逐步平衡采样：先对多个epoch进行实例平衡采样（上式q=1，也就是没有任何平衡操作的采样），然后再剩下的epoches中进行类别平衡采样。这种采样方式需要设置一个超参数来调整从哪一个epoch开始变换采样方式。也可以使用更软的阈值，即随着epoch的增加来逐渐调整实例平衡采样（IB）和类别平衡采样所占的比例，如下面公式所示。 $$ P_j^{PB} (t) = (1-\\frac{t}{T})P_j^{IB} + \\frac{t}{T}P_j^{CB}\r$$\rtwo-stage 在Unbalanced的Data上Pretrain一个特征提取器，然后再rebalance（IB，CB）的数据集上对Classifier进行重新训练（调整），（and | or）对齐，校准（disalign，causal）来提升LT的性能的方法\nmotivation 但是这些rebalance的方法通常会带来以下两个问题[2]：\nrebalance之后分类器会倾向于分类正确的尾部样本，导致对于头部有一定的bad influence（欠拟合），对尾部过拟合 rebalance方法会显著的促进分类器的学习，但是会损害深度特征的表示能力，如上图所示，分类器学到的分界面更好，但是特征的表示却更加的松散了 我认为rebalance的策略确实会使得Clf学的更好的分界面，减少偏向性，但是不至于在尾部过拟合，这一部分分析最重要的应该是rebalance对于特征空间的Bad Influence，这可能就是Two Stage的来源。\n于是作者为其设计了一些消融实验：CE指的是长尾，RW，RS指的是使用的rebalance的数据。\n可以发现在Backbone上使用Unbalance的数据而在Clf上使用Resampler的数据效果是最好的，这种two-stage的解耦两阶段的训练策略展现了一个有希望的结果。\n这种两阶段的方式，我认为在第二阶段的时候也要对特征进行微调来适应当前的分布，不过很多的方法都是直接只对分类器进行调整，我们可以对两种方式进行测试\n下图显示了fix-two-stage和baseline对比[5] 下图展示了理想的two-stage结果与显示方法之间的距离[5] cls-bound是再fix特征后，用完全均衡的数据集训练分类器得到的结果，由此带入第二张图的绿色的线，可以知道，现有长尾方法的性能瓶颈（未使用two-stage），仍然在特征空间中的有偏差的决策边界。 基于这些分析,我们认为，在得到一个强有力的特征表示后，我们可以将问题归化到分类器上，基于这点假设，我们可以结合我们的自监督模块来对该方法进行归化。\nBBN structure Share Weight of Backbone，Using diff dataset to get diff feature. Then we using $\\alpha$ to Combine the logits and calculate the loss.\n$$ z = \\alpha * W_c^T * f_c + (1-\\alpha) * W_\\gamma^T * f_\\gamma\r$$\r$$ L = \\alpha * l(softmax(z),y_c) + (1-\\alpha) *l(softmax(z),y_\\gamma)\r$$\r在上述的流程图中W代表的是两个不一样的数据优化器，基于这样的设置最终就能区分两部分的优化。\n但是这个方法为我们带来的最大的启发还是在于区分两阶段中学习的重点，backbone需要在一个unblance的条件下学习一个更为通用的表征，而Cls需要矫正偏差。不平衡的情况下可能能学到一个很好的通用表征，这一点就是我们使用自监督的一个重要原因。\nDecoupling ==Train BB and Fixed then Train CLF== 此外坐着发现全连接的weight和norm和对应类别的样本数正相关，所以在第二部最后将分类器改为归一化的分类器，文中的两种设计是：\n$\\overline{W_i}=\\frac{w_i}{\\lVert W_i \\rVert^T}$ $\\overline{W_i}=\\frac{w_i}{f_i}$ 其中2利用fixed第一步分类权重 $w_i$ ,对每个类学习了一个加权参数 $f_i$\nbetter-calibration 但是这种两阶段的方式也不是没有代价的，他会带来比较严重的校准错误(Calibration)，也就是我们预测的概率和实际的相似度之间的一致性。\n（BTW评估校准错误的指标 $ECE=\\sum_{b=1}^B\\frac{|S_b|}{N} |acc(S_b) - conf(S_b)|$ ，将数据分为b组，S_b是落入b区间的样本集合)\n本文主要测试了MixUP在两阶段训练中的作用，以及提出了：\n标签感知平滑损失，实际上就是cb_ce的半泛化形式： $$ \\begin{gathered}\rl(\\boldsymbol{q}, \\boldsymbol{p})=-\\sum_{i=1}^{K} \\boldsymbol{q}_{i} \\log \\boldsymbol{p}_{i} \\\\\r\\boldsymbol{q}_{i}= \\begin{cases}1-\\epsilon_{y}=1-f\\left(N_{y}\\right), \u0026 i=y \\\\\r\\frac{\\epsilon_{y}}{K-1}=\\frac{f\\left(N_{y}\\right)}{K-1}, \u0026 \\text { Otherwise }\\end{cases}\r\\end{gathered} $$\r$\\epsilon_y$ 是y(gt)的一个小平滑因子,数目与类别的样本数有关，并提出了几种函数形式，来优化这个损失 2. BN的移位学习，由于两阶段的数据集不一致，所以normalize的参数是需要学习变化的（均值和方差）\n具体的数学分析和推导，后续根据论文理解了再来补充\nDisAlign 基于上述对于方法的分析，该文章着重于对于分类器进行校准，具体的思路是基于利于平衡预测的类别分布来对分类器的输出进行匹配，矫正；简单的说利用类别先验和输入数据学习类别的决策边界。 具体由两部分构成(重构预测的概率输出，建立理想分布，使用KL散度计算损失)\n自适应配准函数 $$ \\begin{gathered}\rs_{j}=\\alpha_{j} \\cdot z_{j}^{o}+\\beta_{j}, \\quad \\forall j \\in \\mathcal{C} \\\\\r\\hat{z}_{j}=\\sigma(\\mathbf{x}) \\cdot s_{j}+(1-\\sigma(\\mathbf{x})) \\cdot z_{j}^{o} \\\\\r=\\left(1+\\sigma(\\mathbf{x}) \\alpha_{j}\\right) \\cdot z_{j}^{o}+\\sigma(\\mathbf{x}) \\cdot \\beta_{j} \\\\\rp_{m}(y=j \\mid \\mathbf{x})=\\frac{\\exp \\left(\\hat{z}_{j}\\right)}{\\sum_{k=1}^{C} \\exp \\left(\\hat{z}_{k}\\right)}\r\\end{gathered} $$\r广义重加权校准 理想的分布的计算方法如下，定义说的不是很好，最好还是参考一下代码 $$ \\begin{gathered}\rp_{r}\\left(y=c \\mid \\mathbf{x}_{i}\\right)=w_{c} \\cdot \\delta_{c}\\left(y_{i}\\right), \\quad \\forall c \\in \\mathcal{C} \\\\\rw_{c}=\\frac{\\left(1 / r_{c}\\right)^{\\rho}}{\\sum_{k=1}^{K}\\left(1 / r_{k}\\right)^{\\rho}}, \\quad \\forall c \\in \\mathcal{C}\r\\end{gathered} $$\r最终的损失计算方程如下：\n$$ \\begin{aligned}\r\\mathcal{L} \u0026=\\mathbb{E}_{\\mathcal{D}_{t r}}\\left[\\mathcal{K} \\mathcal{L}\\left(p_{r}(y \\mid \\mathbf{x}) \\| p_{m}(y \\mid \\mathbf{x})\\right)\\right] \\\\\r\u0026 \\approx-\\frac{1}{N} \\sum_{i=1}^{N}\\left[\\sum_{y \\in \\mathcal{C}} p_{r}\\left(y \\mid \\mathbf{x}_{i}\\right) \\log \\left(p_{m}\\left(y \\mid \\mathbf{x}_{i}\\right)\\right)\\right]+C\r\\end{aligned}\r$$\r==训练的具体策略== 1）在第一阶段，在不平衡数据集上使用实例平衡 ( instance-balanced ) 采样策略实现特征提取器和原始分类头的联合学习。此时由于不平衡的数据分布，学习到的原始分类头是严重有偏的。\n2）在第二阶段，我们在特征提取器参数固定不变的情况下关注分类头以调整决策边界，引入了自适应配准函数 ( adaptive calibration function ) 和广义重加权 ( generalized re-weight ) 策略来配准各类概率。\nCaucal Analysis 基于two-stage的这种现象，然后分析机器和人学习的区别，认为带来偏差的元凶在于Optim优化算法，为此，该文章构建因果图，从而去除在模型更新过程中由动量带来的偏差效应。\n\"keep good and remove bad momentum\"[7]\r$v_t = \\mu · v_{t-1} + g_t$ , $\\theta = \\theta_{t-1} - lr · v_t$\n要调用这个方法的话，我们就需要\n将训练的CLF修改成Multi-Head并Normlize，参考Decouple. 训练过程中统计移动平局特征 $\\overline{x}$ ，将其单位方向看成头部倾向. 测试的过程中修正logits即可 具体公式参考对应的解析和代码实现;\n和自监督结合的话，只需要在微调的阶段进行统计和修正即可，毕竟是一个一阶段的方式。\nContrastive 这一部分考虑一些和对比学习，或者说自监督学习耦合的方法来进行分析。\n为何将这两者放到同一个章节中？ 因为这两者企图从表征的层面，为LT任务，带来增益，得到一个可分的特征空间基于良好的特征表达，进而解耦的来训练一个更好的CLF。\n如果我们假设我们能得到一个高维线性可分的特征空间，对于长尾的样本带来的训练偏差（决策面偏差）是否可以通过对于特定类别的Margin-Like的Loss设置，达到一个类似Balance的效果，这一点上实际上可能和Align和校正的思想有点相似。但是我们是为了让分类器空间中的分界面在小样本的束缚下变得更加的合理。\n从分界面的角度看LT的情况：（上面是普通CE，下面是Contrastive Learning） 在数据量出现较大的差异的情况下，由于蓝色的数目更多更杂，所以实际上分界面可能会沿着蓝色数据的边界做切分（overfit），在这种Class-Level的过拟合下，就会导致对于少数类别的分类结果很差。\n而下方的对比学习就是一样的解决方案，他试图将同一类的数据聚拢在一起，将不同类的距离尽可能的拉远，这样会使得在空间中的决策面更加的鲁棒也已于区分，虽然可能会一定程度上减少蓝色的表现，但是红色的表现会因此大大的提升。\nhybird contrastive 该文章[9]的基本架构上实际上参考的就是BBN的epoch-params在two-stage中集成 supervised contrasive Loss，具体框架可以看下面这图： 他的设计思想很容易从这张图中领会，损失函数的表达显然如下\n$$ L_{hybird} = \\alpha · L_{SCL}(B_{SC}) + (1-\\alpha) · L_{ce}(B_{CE})\r$$\r在这里要注意SC和自监督中使用的区别在于，自监督学习的过程中没有标签，所以只能将自己作为Positive，而在SC的时候，同类的样本之间应该都作为Positive\n$$ \\mathcal{L}_{S C L}\\left(\\mathbf{z}_{i}\\right)=\\frac{-1}{\\left|\\left\\{\\mathbf{z}_{i}^{+}\\right\\}\\right|} \\sum_{\\mathbf{z}_{j} \\in\\left\\{\\mathbf{z}_{i}^{+}\\right\\}} \\log \\frac{\\exp \\left(\\mathbf{z}_{i} \\cdot \\mathbf{z}_{j} / \\tau\\right)}{\\sum_{\\mathbf{z}_{k}, k \\neq i} \\exp \\left(\\mathbf{z}_{i} \\cdot \\mathbf{z}_{k} / \\tau\\right)}\r$$\r鉴于SC的计算复杂度要和整个Epoch的数据进行对比，需要大量的显存空间，在这方面作者将其改进为PSC，其实也就是将每个class计算一个prototype，然后基于原型去计算这个相似性损失\n$$ \\mathcal{L}_{P S C}\\left(\\mathbf{z}_{i}\\right)=-\\log \\frac{\\exp \\left(\\mathbf{z}_{i} \\cdot \\mathbf{p}_{y_{i}} / \\tau\\right)}{\\sum_{j=1, j \\neq y_{i}}^{C} \\exp \\left(\\mathbf{z}_{i} \\cdot \\mathbf{p}_{j} / \\tau\\right)}\r$$\r在这里这个Prototypical需要正则化到单位元中，这样能快速计算相似性损失，也不会需要大量的现存。\n可以参考的点主要就在于损失的设计和框架上的这种分epoch机制了，但是基于自监督的方式的话，可能不是很用的上这一点，但是我们可以考虑怎么结合这个loss去做对应的分类器。\nThe value of labels 这一篇文章是将自监督学习和半监督学习应用到长尾分布的问题上，文章对应的仓库中可以get预训练模型和很多对应的数据，同时验证了下面两种策略都可以大大提升模型的效果，包括和之前的各种策略进行耦合。\n半监督：利用更多的无标注数据 自监督：不利用任何其他数据，使用长尾分布的数据进行自监督训练 后续的实验过程中我可能也会遵循该设计，或者使用的是全数据的自监督预训练。\n考虑尾部标签本身的意义，想要利用尾部的标签信息，又不受偏差的影响，实际上就是使用自监督进行预训练，然后后面使用各种方法兼容的一个策略。 MixUp in LT 将MixUP应用在LT中，试图\u0026quot;以使其具有更高的泛化性，以及降低模型本身的置信度\u0026quot;[4], 经过实验表明，仅在Stage1使用MixUP，在Stage2的第二阶段使用几个epoch的Mixup的效果可能会更好。\n在这里可能也要考虑一下CutMix方法\nConclusion 实验结果汇总 基于BackBone对这些方法的实验结果( $Top1 Acc$ )进行汇总，作为我们后续研究的参照：在进行实验的时候，我们需要首先调整好BenchMark，基于Benchmark做的改进才能和对应的方法进行对比。\n整理原则：\n对应的论文则由该论文本身为主，后续和LT的仓库进行对比分析； 最主要需要对比的应该是ce情况下的指标，这是我们最重要的，当这个指标对齐后，我们就可以和这些方法同台竞技了。 Dataset -\u0026gt; LT-Cifar-100 \u0026lt;- -\u0026gt; LT-CIfar10 \u0026lt;- Backbone Factor(Exp) 100 50 10 100 50 10 ResNet32 RESULT - - - - - - CE 38.32 43.85 55.71 70.36 74.81 86.39 - Focal Loss 38.4 44.3 56.8 70.4 76.7 86.7 - MixUp 39.5 45.0 58.0 73.1 77.8 87.1 - CB Loss 39.6 45.2 58.0 74.6 79.3 87.1 - BAGS-After 47.83 51.69 - 73.59 79.03 - - SSL-Uniform 40.40 45.04 57.07 73.50 78.20 87.72 SSL-Balanced 43.06 47.09 58.06 76.53 80.4 87.72 LDAM 42.0 46.6 58.7 77.0 81.0 88.2 - BBN 42.56 47.07 59.12 79.82 82.18 88.32 - Causal 44.1 50.3 59.6 80.6 83.6 88.5 - Reference 阅读过程中还看到一些什么BAGS，进行数据分组的方法，这个方法肯定不会在我们的框架中使用，但是我们可以分析一下这种分组训练为什么会对长尾的场景存在差异。\n⭐\u0026ldquo;Bag of Tricks for LT Visual Recognition with Deep Convolutional Neural Network\u0026rdquo; ZHIHU ⭐\u0026ldquo;BBN: Bilateral-Branch Network with Cumulative Learning for Long-Tailed Visual Recognition\u0026rdquo; ZHIHU CVPR20 ❓\u0026ldquo;Long-Tail Learning via Logit Abjustment\u0026rdquo; ICLR 20 zhihu1 | zhihu2 \u0026ldquo;Improving Calibration for Long-Tailed Recognition\u0026rdquo; CVPR21 zhihu ⭐\u0026ldquo;Distribution Alignment: A Unified Framework for Long-tail Visual Recognition\u0026rdquo; CVPR21 zhihu | zhihu2 \u0026ldquo;Decoupling Representation and Classifier for Long-Tailed Recognition\u0026rdquo; ICLR20 \u0026ldquo;Long-Tailed Classification by Keeping the Good and Removing the Bad Momentum Causal Effect\u0026rdquo; NIPS20 | zhihu \u0026ldquo;Rethinking the Value of Labels for Improving Class-Imbalanced Learning\u0026rdquo; NIPS20| zhihu \u0026ldquo;Contrastive Learning based Hybrid Networks for Long-Tailed Image Classification\u0026rdquo; CVPR21 zhihu 总结性串讲：\nLT-Classification ","permalink":"https://hugotest-phi.vercel.app/posts/lt-collection/","summary":"\u003ch1 id=\"lt-collections\"\u003eLT-Collections\u003c/h1\u003e\n\u003cp\u003e@AikenHong 2021\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/mitming/OpenLT\" target=\"_blank\" rel=\"noopener\"\u003eCode of must of those methods\u003c/a\u003e\n\nWe will analysis those tricks on LT situation, and Analysis why it works.\n在进行LT矫正的任务中，有几种常见的trick在各种模型中被使用，我们会对这几种不同的trick进行介绍和分析。\u003c/p\u003e\n\u003cp\u003e其实在数据量少这一方面LT和Few-Shot是有一定的OverLap的,可以参考以下那边的思路perhaps\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211217165531.png\"\u003e\r\n    \u003cimg alt=\"LT\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211217165531.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211217165531.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"LT\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\n通常情况下这种严重的类别不平衡问题会使得模型严重过拟合于头部，而在尾部欠拟合\u003c/p\u003e\n\u003cp\u003e首先介绍 \u003ca href=\"https://zhuanlan.zhihu.com/p/416315017\" target=\"_blank\" rel=\"noopener\"\u003ebag of tricks\u003c/a\u003e\n 这篇论文中总结了一些常用的Trick，并组合出了最佳的一套trick\u003c/p\u003e\n\u003cp\u003e经过该文实验总结，Trick组合应该是\u003csub\u003e[1]`\u003c/sub\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在前几个epoch应用input mixup数据增强，然后后面fine-tuning;\u003c/li\u003e\n\u003cli\u003e(基于CAM的)重采样来重新训练分类器;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e实际上就是MixUp + Two-Stage的策略，后续对\u003cstrong\u003eMix-up\u003c/strong\u003e这个策略带来的作用要进行补充了解一下\u003c/p\u003e\n\u003ch2 id=\"rebalance\"\u003eRebalance\u003c/h2\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e对于ReBalance的方法，实际上就是从 \u003ccode\u003edata\u003c/code\u003e和 \u003ccode\u003eupdate\u003c/code\u003e两个角度来缓解Unbalance本身，通过从数据量上达到重新均衡，或者基于Loss使得bp过程中赋予Tail更高的权重来达到优化过程的平衡。\u003c/p\u003e","title":"LT Collection"},{"content":"@AikenHong 2021\nNoise Contrastive Estimation Loss = NCE Loss 噪声对比估计损失，这里的Noise实际上就是Negative Samples. 该损失被广泛的用于对比学习的任务，而对比学习广泛的作为自监督学习的无监督子任务用来训练一个良好的特征提取器，于是对于对比学习的目标和效用的理解十分关键。\nWhat\u0026rsquo;s NCE Loss 在介绍NCE之前我们可以将其和CE进行一个简单的对比，虽然名称上不是同一个CE，但是在数学表达上却有很相近的地方（softmax-kind of loss）\n首先softmax，他保证所有的值加起来为一，结合onehot的ce，实际上j==gt的情况下外层+log也就是ceLoss，也就是 $logSoftmax$\n$$ S_j = \\frac{e^{a_j}}{\\sum_{k=1}^N e^{a_k}}\r$$\r然后看infoNCE，基础的对比学习损失可以写成：\n$$ L_{contrast} = \\mathbb{E}[-\\log\\frac{e^{f_x^T f_y/T}}{e^{f_x^T f_y/T} + \\sum_i e^{f_x^T f_{y_-^i}/T}}]\r$$\r其中 $f_x^T f_y^T$ 为 $sim(x,y)$ 时即转化为带 $T$ 的NCE，即InforNCE.\n分子是正例对的相似度，分母是正例对+所有负例对的相似度，最小化infoNCE loss，就是去最大化分子的同时最小化分母，也就是最大化正例对的相似度，最小化负例对的相似度。\n从该形式上看，和soft的CE形式上是统一的，当我们把分母看作概率和自身以及和其他的相似性，这样和NCE在形式上和简化后的CE实现了统一。\n但是我不认为这和label smooth 后的CE有相关性，而是和原始的CE经由One-hot简化后结构上有相似性。\nHow it Works NCE的思想是拉近相似的样本，推开不相近的样本，从而学习到一个好的语义表示空间，这一点上实际上和度量学习的思想是一样的，只是对比学习通常作用在无监督或者自监督的语境中，度量学习这是有监督的。\n考虑之前人脸匹配的研究，使用 \u0026ldquo;Alignment and Uniformity on the Hypersphere\u0026quot;中的Alignment and Uniformity，就是一个更好理解他的角度\n$$ \\begin{gathered}\rL_{\\text {contrast }}=\\mathbb{E}\\left[-\\log \\frac{e^{f_{x}^{T} f_{y} / \\tau}}{e^{f_{x}^{T} f_{y} / \\tau}+\\sum_{i} e^{T_{x}^{T} f_{y_{i}}^{-} / \\tau}}\\right] \\\\\r=\\mathbb{E}\\left[-f_{x}^{T} f_{y} / \\tau\\right]+\\mathbb{E}\\left[\\log \\left(e^{f_{x}^{T} f_{y} / \\tau}+\\sum_{i} e^{f_{x}^{T} f_{y_{i}^{-} / \\tau}}\\right)\\right] \\\\\r\\mathbb{P}\\left[\\left(f_{x}=f_{y}\\right)\\right]=1 \\underbrace{\\mathbb{E}\\left[-f_{x}^{T} f_{y} / \\tau\\right]}_{\\text {positive alignment }}+\\underbrace{\\mathbb{E}\\left[\\log \\left(e^{1 / \\tau}+\\sum_{i} e^{f_{x}^{T} f_{y_{i}}-/ \\tau}\\right)\\right]}_{\\text {uniformity }}\r\\end{gathered}\r$$\r公式经过上面的推导就可以看成下的两个部分，其中alignment只与positive pair有关，相反Uniformity只与negative pair相关，希望所有的点都能尽可能的分布在uni hypersphere上。\n这样均匀的分布有利于聚类并且线性可分，且经过实验证实无监督对比学习确实能得到强判别力的特征。\nAlignment：指的是相似的例子，也就是正例，映射到单位超球面后，应该有接近的特征，也就是在超球面上距离比较近；\nUniformity：指的是系统应该倾向于在特征里保留尽可能多的信息，这等价于使得映射到单位超球面的特征，尽可能均匀的分布在球面上，分布的越均匀，意味着保留的信息越充分。分布均匀意味着两两有差异，也意味着各自保有独有信息，这代表信息保留充分。\n参考Label Smooth中Soft Label的定义，当我们将特征拉到超球面上均匀分布的时候，特征之间相对的距离关系，远近是否应该保留真实分布中的相似性和度量分布？NCE Loss是否能保留这种关系呢？\n这种额外的Info可能能够对于后续的蒸馏学习有一个比较大的影响\nWith Self-Supervised Learning 自监督学习最重要的就是下游任务的设计，一般分成两种：\n生成式模型：Encode-Decode架构，让输入输出尽可能的相似，或者是后续进化的MIM架构，挖空并还原空中的内容，并在Transformer架构中取代判别式模型方法称为主流。 判别式模型：通过Encoder编码，通过对比学习分析相似性来建立对比损失，自从MoCo出来后判别式模型在一定时间内成为主流。 避免退化解形成 InfoNCE的两部分在理论上是缺一不可的，如果没有Alignment，就无法聚类，如果没有Uniformly，容易使得所有的输入输出又相同的表示，也就是形成退化解。\n参考 Article 对几种自监督的方法解决退化解的方式进行了简要的分析。\n实验中的设置问题 zhihu 对比学习中一般选择一个batch中的其他样本作为负例，如果负例中又很相似的样本怎么办？\n在无监督无标注的情况下，这样的伪负例，其实是不可避免的，首先可以想到的方式是去扩大语料库，去加大batch size，以降低batch训练中采样到伪负例的概率，减少它的影响。\n另外，神经网络是有一定容错能力的，像伪标签方法就是一个很好的印证，但前提是错误标签数据或伪负例占较小的比例。\n也可以考虑使用监督的对比学习方法\n对比学习的infoNCE loss 中的温度系数t的作用是什么？[1]\n温度系数的作用是调节对困难样本的关注程度：越小的温度系数越关注于将本样本和最相似的困难样本分开，去得到更均匀的表示。然而困难样本往往是与本样本相似程度较高的，很多困难负样本其实是潜在的正样本，过分强迫与困难样本分开会破坏学到的潜在语义结构，因此，温度系数不能过小 考虑两个极端情况，温度系数趋向于0时，对比损失退化为只关注最困难的负样本的损失函数；当温度系数趋向于无穷大时，对比损失对所有负样本都一视同仁，失去了困难样本关注的特性。\n也可以用另一个角度理解：\n可以把不同的负样本想像成同极点电荷在不同距离处的受力情况，距离越近的点电荷受到的库伦斥力更大，而距离越远的点电荷受到的斥力越小。 对比损失中，越近的负例受到的斥力越大，具体的表现就是对应的负梯度值越大[4]。这种性质更有利于形成在超球面均匀分布的特征。\n对照公式去理解：\n$$ L_{i}=-\\log \\left(e^{S\\left(z_{i}, z_{i}^{+}\\right) / \\tau} / \\sum_{j=0}^{K} e^{S\\left(z_{i}, _{j}\\right) / \\tau}\\right)\r$$\r当温度系数很小时，越相似也即越困难的负例，对应的坟墓就会越大，在分母叠加项中所占的比重就会越大，对整体loss的影响就会越大，具体的表现就是对应的负梯度值越大\n当然，这仅仅是提供了一种定性的认识，定量的认识和推导可以参见博客zhihu with supervised learning ZHIHU 借鉴了contrastive的设计在监督信息的基础上对其进行改造，设计一个用于监督学习的对比损失。这一点也可以解决我们问题设置中的第一个问题，但是为此也只能在监督的情况下使用。\n$$ \\mathcal{L}_{i}^{s u p}=\\frac{-1}{2 N_{\\tilde{y}_{i}}-1} \\sum_{j=1}^{2 N} 1_{i \\neq j} \\cdot 1_{\\bar{y}_{i}=\\bar{y}_{j}} \\cdot \\log \\frac{\\exp \\left(z_{i} \\cdot z_{j} / \\tau\\right)}{\\sum_{k=1}^{2 N} 1_{i \\neq k} \\cdot \\exp \\left(z_{i} \\cdot z_{k} / \\tau\\right)}\r$$\r其实也就是当标签相同的时候都当作正例，其他时候都是负例，也就是修改了原本状态下positive的情况。\n在训练的过程中，该方法和two-stage会使用同样的策略，也就是在第一阶段使用SCL训练Backbone，在第二阶段固定representation的参数，并只对clf的参数进行训练。\nCode Part understand the code ；Offical Code ；\n如果我们需要理解这串代码如何使用，我们需要阅读官方源码中的数据使用模式，我们需要使用图像的两组不同增强，计算对应的特征，然后整合到n_views维度，再将其传入该损失。 后续我们可以基于NXTent Loss函数来简化和改写该损失，目前我们只需要对其加入Normalization就可以暂时进行使用了，第一步我们使用大的batchsize来代替2Augs，如果效果不好的话可以测试2Augs是否会有更好的增益 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 import torch import torch.nn as nn class SupConLoss(nn.Module): \u0026#34;\u0026#34;\u0026#34;Supervised Contrastive Learning: https://arxiv.org/pdf/2004.11362.pdf. It also supports the unsupervised contrastive loss in SimCLR\u0026#34;\u0026#34;\u0026#34; def __init__(self, temperature=0.07, contrast_mode=\u0026#39;all\u0026#39;, base_temperature=0.07): super(SupConLoss, self).__init__() self.temperature = temperature self.contrast_mode = contrast_mode self.base_temperature = base_temperature def forward(self, features, labels=None, mask=None): \u0026#34;\u0026#34;\u0026#34;Compute loss for model. If both `labels` and `mask` are None, it degenerates to SimCLR unsupervised loss: https://arxiv.org/pdf/2002.05709.pdf Args: features: hidden vector of shape [bsz, n_views, ...]. labels: ground truth of shape [bsz]. mask: contrastive mask of shape [bsz, bsz], mask_{i,j}=1 if sample j has the same class as sample i. Can be asymmetric. Returns: A loss scalar. \u0026#34;\u0026#34;\u0026#34; device = (torch.device(\u0026#39;cuda\u0026#39;) if features.is_cuda else torch.device(\u0026#39;cpu\u0026#39;)) if len(features.shape) \u0026lt; 3: raise ValueError(\u0026#39;`features` needs to be [bsz, n_views, ...],\u0026#39; \u0026#39;at least 3 dimensions are required\u0026#39;) if len(features.shape) \u0026gt; 3: features = features.view(features.shape[0], features.shape[1], -1) batch_size = features.shape[0] if labels is not None and mask is not None: raise ValueError(\u0026#39;Cannot define both `labels` and `mask`\u0026#39;) elif labels is None and mask is None: mask = torch.eye(batch_size, dtype=torch.float32).to(device) elif labels is not None: labels = labels.contiguous().view(-1, 1) if labels.shape[0] != batch_size: raise ValueError(\u0026#39;Num of labels does not match num of features\u0026#39;) mask = torch.eq(labels, labels.T).float().to(device) else: mask = mask.float().to(device) contrast_count = features.shape[1] contrast_feature = torch.cat(torch.unbind(features, dim=1), dim=0) if self.contrast_mode == \u0026#39;one\u0026#39;: anchor_feature = features[:, 0] anchor_count = 1 elif self.contrast_mode == \u0026#39;all\u0026#39;: anchor_feature = contrast_feature anchor_count = contrast_count else: raise ValueError(\u0026#39;Unknown mode: {}\u0026#39;.format(self.contrast_mode)) # compute logits anchor_dot_contrast = torch.div( torch.matmul(anchor_feature, contrast_feature.T), self.temperature) # for numerical stability logits_max, _ = torch.max(anchor_dot_contrast, dim=1, keepdim=True) logits = anchor_dot_contrast - logits_max.detach() # tile mask mask = mask.repeat(anchor_count, contrast_count) # mask-out self-contrast cases logits_mask = torch.scatter( torch.ones_like(mask), 1, torch.arange(batch_size * anchor_count).view(-1, 1).to(device), 0 ) mask = mask * logits_mask # compute log_prob exp_logits = torch.exp(logits) * logits_mask log_prob = logits - torch.log(exp_logits.sum(1, keepdim=True)) # compute mean of log-likelihood over positive mean_log_prob_pos = (mask * log_prob).sum(1) / mask.sum(1) # loss loss = - (self.temperature / self.base_temperature) * mean_log_prob_pos loss = loss.view(anchor_count, batch_size).mean() return loss with ArcFace 对比学习损失我们知道其目的是为了，拉近相似样本之间的距离，并尽量的将不同的类别之间的样本区分，而这和进行人脸识别中的 $ArcFace Loss$ 系列的Softmax Loss有着相同的目的。\n那么这两种方法之间是否能够相互借鉴，或者说是否NCE本身在自监督学习任务上就更优于ArcFace?（是否会过度关注细节，无法关注到相应的整体架构） 或者说在后续的分类器训练过程中，这样是否能够帮助我们使用聚类的方式进行分类？（结合epoch-control的那种方法）进行fine-tuning等等\nreference “Understanding the Behaviour of Contrastive Loss” CVPR2021 Analysis The InfoNCE-Loss ","permalink":"https://hugotest-phi.vercel.app/posts/loss-nce/","summary":"\u003cp\u003e@AikenHong 2021\u003c/p\u003e\n\u003cp\u003eNoise Contrastive Estimation Loss = NCE Loss 噪声对比估计损失，这里的Noise实际上就是Negative Samples.\n该损失被广泛的用于对比学习的任务，而对比学习广泛的作为自监督学习的无监督子任务用来训练一个良好的特征提取器，于是对于对比学习的目标和效用的理解十分关键。\u003c/p\u003e\n\u003ch2 id=\"whats-nce-loss\"\u003eWhat\u0026rsquo;s NCE Loss\u003c/h2\u003e\n\u003cp\u003e在介绍NCE之前我们可以将其和CE进行一个简单的对比，虽然名称上不是同一个CE，但是在数学表达上却有很相近的地方（softmax-kind of loss）\u003c/p\u003e\n\u003cp\u003e首先softmax，他保证所有的值加起来为一，结合onehot的ce，实际上\u003ccode\u003ej==gt\u003c/code\u003e的情况下外层+log也就是ceLoss，也就是 $logSoftmax$\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\nS_j = \\frac{e^{a_j}}{\\sum_{k=1}^N e^{a_k}}\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e然后看infoNCE，基础的对比学习损失可以写成：\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\nL_{contrast} = \\mathbb{E}[-\\log\\frac{e^{f_x^T f_y/T}}{e^{f_x^T f_y/T} + \\sum_i e^{f_x^T f_{y_-^i}/T}}]\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e其中 $f_x^T f_y^T$ 为 $sim(x,y)$ 时即转化为带 $T$ 的NCE，即InforNCE.\u003c/p\u003e\n\u003cp\u003e分子是正例对的相似度，分母是正例对+所有负例对的相似度，最小化infoNCE loss，就是去最大化分子的同时最小化分母，也就是最大化正例对的相似度，最小化负例对的相似度。\u003c/p\u003e\n\u003cp\u003e从该形式上看，和soft的CE形式上是统一的，当我们把分母看作概率和自身以及和其他的相似性，这样和NCE在形式上和简化后的CE实现了统一。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e但是我不认为这和label smooth 后的CE有相关性，而是和原始的CE经由One-hot简化后结构上有相似性。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"how-it-works\"\u003eHow it Works\u003c/h2\u003e\n\u003cp\u003eNCE的思想是\u003cstrong\u003e拉近相似的样本，推开不相近的样本\u003c/strong\u003e，从而学习到一个好的\u003cstrong\u003e语义表示空间\u003c/strong\u003e，这一点上实际上和度量学习的思想是一样的，只是对比学习通常作用在无监督或者自监督的语境中，度量学习这是有监督的。\u003c/p\u003e\n\u003cp\u003e考虑之前人脸匹配的研究，使用 \u0026ldquo;Alignment and Uniformity on the Hypersphere\u0026quot;中的Alignment and Uniformity，就是一个更好理解他的角度\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cdiv\u003e\r\n$$ \r\n\\begin{gathered}\r\nL_{\\text {contrast }}=\\mathbb{E}\\left[-\\log \\frac{e^{f_{x}^{T} f_{y} / \\tau}}{e^{f_{x}^{T} f_{y} / \\tau}+\\sum_{i} e^{T_{x}^{T} f_{y_{i}}^{-} / \\tau}}\\right] \\\\\r\n=\\mathbb{E}\\left[-f_{x}^{T} f_{y} / \\tau\\right]+\\mathbb{E}\\left[\\log \\left(e^{f_{x}^{T} f_{y} / \\tau}+\\sum_{i} e^{f_{x}^{T} f_{y_{i}^{-} / \\tau}}\\right)\\right] \\\\\r\n\\mathbb{P}\\left[\\left(f_{x}=f_{y}\\right)\\right]=1 \\underbrace{\\mathbb{E}\\left[-f_{x}^{T} f_{y} / \\tau\\right]}_{\\text {positive alignment }}+\\underbrace{\\mathbb{E}\\left[\\log \\left(e^{1 / \\tau}+\\sum_{i} e^{f_{x}^{T} f_{y_{i}}-/ \\tau}\\right)\\right]}_{\\text {uniformity }}\r\n\\end{gathered}\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e公式经过上面的推导就可以看成下的两个部分，其中\u003cstrong\u003ealignment\u003c/strong\u003e只与\u003cstrong\u003epositive pair\u003c/strong\u003e有关，相反\u003cstrong\u003eUniformity\u003c/strong\u003e只与\u003cstrong\u003enegative pair\u003c/strong\u003e相关，希望所有的点都能尽可能的分布在uni hypersphere上。\u003c/p\u003e","title":"Loss-NCE"},{"content":"@AikenHong 2021 @topic\nsmooth label (inception v2) when does label smoothing help (nips 2019) sharpen in semi-supervised in the future offical code github 不是一个通用的方法，在很多的任务上反而会导致掉点的现象，可以简单分析一下，汲取一下思想和Sharpen做对比，在这篇文章中，我们可以结合之前的人脸对比损失来进行分析。\nWhat\u0026rsquo;s the smooth label 首先介绍在图像分类任务中对logits和Hard label做ce得到我们的损失，可以表现为如下的形式：\n$$ Loss = -\\sum^{K}_{i=1}p_i \\log(q_i)\r$$\r由于我们的标签是一个hard label，实际上可以转化成一个one-hot，即\n$$ \\begin{equation}\rp_i = \\left\\{\r\\begin{array}{c1}\r1 \u0026 i==gt \\\\\r0 \u0026 i!=gt \\\\\r\\end{array} \\right.\r\\end{equation}\r$$\r而soft label实际上做的是将 1的位置变为 $1-\\alpha$ ，其他位置设置为 $\\alpha/(K-1)$ ，然后再去求CE，\nHinton论文中给出该损失对特征分布的作用测试图： Pros and Cons why does label smoothing help 校准性：模型预测的分数能不能同时表征其置信度\nLS可以提高模型的泛化性，同时还能提高模型的校准性（model calibration） 在模型蒸馏中，如果我们的teacher model是由LS训练的，Teacher的效果更好，但是Student的性能会变差，这是因为LS的作用是将相同类别的example聚类到更加紧促的cluster中，但是这也导致了，不同样本之间的相似性信息的损失，从而影响了蒸馏的效果 此外模型的校准性能，通常可以使用T系数来进行优化，Temprature scaling（TS）可以有效的降低ECE（expected calibration error）\n（TS就是在计算cross entropy之前把模型的输出除以超参T，然后再参与cross entropy的计算，比较典型的应用就是在蒸馏中对teacher模型 soft label 处理）\nHow it work 从特征输出的信息来看，启用了LS（loss smooth）的特征的Feature Norm比没有启用小得多，特征空间减小的话，实际上就是降低softmax中的s值（长度，还有另一个指标是角度）\n==较低的s值==会有这样的几个作用：\nsoftmax prob的最大值降低，这样我们就可以永远在线性优化区，几乎不存在平滑区域，这样样本向中心的聚拢程度会更高 s过小的话，对于人脸匹配（往往设置较大的s），为了有更宽广的判别面，使得精度更高，对应于Hard Sample（Task）也是一样的到理道理，就会起到反作用。 Label Smoothing起到的作用实际上是抑制了feature norm，此时softmax prob永远无法达到设定的 $1-\\alpha/k-1$ ，loss曲面上不再存在平缓区域，处处都有较大的梯度指向各个类中心，所以特征会更加聚拢。而之所以人脸上不work，是因为我们通常会使用固定的s，此时Label Smoothing无法控制feature norm，只能控制角度，就会起到反向优化的作用\nFeature Norm BTW：对比损失可以分为alignment和uniformity部分\n第一部分和正样例有关，第二部分仅和负样例有关，作用是远近。\nWith the Sharpen Label Sharpen实际上是和Smooth相反的过程, Sharpen使用的场景可能相对较少, 比如我们希望能最小化熵损失(Like Semi-Supervised), 让输出模型的置信度更高, 或者让分界面更加分明的情况.\n$$ Sharpen(p, T)_i= \\frac {p_i^{1/T}} {\\sum_{j=1}^L p_i^{1/T}}\r$$\r当T-\u0026gt;0的时候,标签将趋向于ont-hot(Dirac)\n而当我们去做FIL任务的时候, 我们拥有的标签实际上应该是One-Hot的, 所以我们需要分析是否需要对其去做smooth, 还是说我们结合SCL的特性, 用One-Hot这种Sharpen的标签去学一个更好的分界面.\nreference ⁉️理解的是错的，从NCE角度 参考个人对NCE的理解[[Papers/Loss-NCE]]\n可以结合里面的人脸对比损失的softmax basic | translate | better translate ","permalink":"https://hugotest-phi.vercel.app/posts/loss-smoothsharpen/","summary":"\u003cp\u003e@AikenHong 2021\n@topic\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esmooth label (inception v2)\u003c/li\u003e\n\u003cli\u003ewhen does label smoothing help (nips 2019)\u003c/li\u003e\n\u003cli\u003esharpen in semi-supervised in the future\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/seominseok0429/label-smoothing-visualization-pytorch?utm_source=catalyzex.com\" target=\"_blank\" rel=\"noopener\"\u003eoffical code github\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不是一个通用的方法，在很多的任务上反而会导致掉点的现象，可以简单分析一下，汲取一下思想和Sharpen做对比，在这篇文章中，我们可以结合之前的人脸对比损失来进行分析。\u003c/p\u003e\n\u003ch2 id=\"whats-the-smooth-label\"\u003eWhat\u0026rsquo;s the smooth label\u003c/h2\u003e\n\u003cp\u003e首先介绍在图像分类任务中对logits和Hard label做ce得到我们的损失，可以表现为如下的形式：\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\nLoss = -\\sum^{K}_{i=1}p_i \\log(q_i)\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e由于我们的标签是一个hard label，实际上可以转化成一个one-hot，即\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\n\\begin{equation}\r\np_i = \\left\\{\r\n\\begin{array}{c1}\r\n1 \u0026 i==gt \\\\\r\n0 \u0026 i!=gt \\\\\r\n\\end{array} \\right.\r\n\\end{equation}\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e而soft label实际上做的是将 1的位置变为 $1-\\alpha$ ，其他位置设置为 $\\alpha/(K-1)$ ，然后再去求CE，\u003c/p\u003e\n\u003cp\u003eHinton论文中给出该损失对特征分布的作用测试图：\n\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211216194040.png\"\u003e\r\n    \u003cimg loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211216194040.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211216194040.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Loss-Smooth(Sharpen)"},{"content":"@Aiken 2020，\n主要针对神经网络的训练过程中的一些基础策略的调整，比如当训练的曲线出现一定的问题的时候，我们应该怎么去调整我们训练过程中的策略。\n参数调整过程中最重要的就是优化器（优化或者说是下降算法）和学习率（优化算法的核心参数），此外像是数据增强策略还是Normalization策略，都能极大的影响一个模型的好坏。\n优化器 Some Material 实际上虽然有很多的优化算法，但是到最后最常用的还是 SGD+Mon 和 Adam两种：\nAdam主要的有事在于自适应学习率，他对我们设计的学习率实际上没有那么敏感，但是在具体实验中往往不会有调的好的SGD那么好，只是在SGD的参数调整中会比较费劲。\n但是有了根据patient调整lr的scheduler后，我们基本上可以使用SGD做一个较为简单的调整，只要设计好初始的lr的实验以及用来调整学习率的参数值。\n学习率 $\\omega^{n} \\leftarrow \\omega^{n}-\\eta \\frac{\\partial L}{\\partial \\omega^{n}}$ 其中的权重就是学习率lr，\n==Basic==\n学习率大 学习率小 学习速度 快 慢 使用情景 刚开始训练时 一定的次数过后 副作用 1. Loss爆炸 2.振荡 1.过拟合 2.收敛速度慢 学习率的基本设置 在训练过程中，一般根据训练轮数设置动态变化的学习率。\n刚开始训练时：学习率以 0.01 ~ 0.001 为宜。 一定轮数过后：逐渐减缓。 接近训练结束：学习速率的衰减应该在100倍以上。 Note： 如果是 迁移学习 ，由于模型已在原始数据上收敛，此时应设置较小学习率 (≤10−4) 在新数据上进行 微调 。\n学习率变化方法 ==warm up==\nwarm up为什么有用 warm up衰减策略与上述的策略有些不同，它是先从一个极低的学习率开始增加，增加到某一个值后再逐渐减少, 这点上倒是和Cosine Anneal LR有一定的相似之处，将这两种结合起来是一种常见的训练策略：\n这样训练模型更加稳定，因为在刚开始时模型的参数都是随机初始化的，此时如果学习率应该取小一点，这样就不会使模型一下子跑偏。\n而这样的跑偏对于大模型而言，可能是导致很严重的影响，后面收敛了也可能不会达到最佳的效果，一开始的跑偏，可能会造成准确率在后面的严重结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # MultiStepLR without warm up scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, \\ milestones=args.milestones, gamma=0.1) # warm_up_with_multistep_lr warm_up_with_multistep_lr = lambda epoch: epoch / args.warm_up_epochs if \\ epoch \u0026lt;= args.warm_up_epochs else 0.1**len([m for m in args.milestones if m \u0026lt;= epoch]) scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda=warm_up_with_multistep_lr) # warm_up_with_cosine_lr warm_up_with_cosine_lr = lambda epoch: epoch / args.warm_up_epochs if \\ epoch \u0026lt;= args.warm_up_epochs else 0.5 *\\ ( math.cos((epoch - args.warm_up_epochs) /(args.epochs - args.warm_up_epochs) * math.pi) + 1) scheduler = torch.optim.lr_scheduler.LambdaLR( optimizer, lr_lambda=warm_up_with_cosine_lr) ==Scheduler Setting：==\n分组的学习率也能通过scheduler进行学习率的更新，可以放心使用。\n轮数减缓 指数减缓 分数减缓 step decay exponential decay 1/t1/t decay 每N轮学习率减半 学习率按训练轮数增长指数插值递减 lrt=lr0/(1+kt)，k 控制减缓幅度，t 为训练轮数 Pytorch的Scheduler pytorch中提供了很多scheduler的方法，其中用的最多的可能还是multistep，考虑到后续可能会用到基于指标调整的学习率，这里特别提一个cosine的学习率调整策略，它的学习率呈现的是一种周期变化的样子。\n==Custom Scheduler==\nPytorch为可能的自定义提供了一个方便的Scheduler接口，ReduceLROnPlateau，通过step 调用指标的变化，进行学习率的调整，极其方便。\n1 2 3 4 5 scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=\u0026#39;max\u0026#39;, factor=0.1, patience=10, verbose=False, threshold=1e-4, threshold_model=\u0026#39;rel\u0026#39;, cooldown=0, min_lr=1e-8) scheduler.step(acc) 基本的参数包括：\nmode 很好理解，max（acc），min（loss）值 factor 学习率下降的参数 patience 多少次没有变化就调整 cooldown 调整后多久的冷却期 threshold，threshold_model 调整我们的动态上下限 threshold (float) – Threshold for measuring the new optimum, to only focus on significant changes. Default: 1e-4.\nthreshold_mode (str) – One of rel, abs. In rel mode, dynamic_threshold = best * ( 1 + threshold ) in ‘max’ mode or best * ( 1 - threshold ) in min mode. In abs mode, dynamic_threshold = best + threshold in max mode or best - threshold in min mode. Default: ‘rel’.\n分析学习率的大小 在训练过程中可视化Loss下降曲线是相当重要的，那么针对Loss出现异常的情况我们应该怎么样去调整使得Loss逐步趋于正常呢？\n曲线 初始时 上扬 [红线]：（直接起飞梯度爆炸） 初始 学习率过大 导致 振荡，应减小学习率，并从头开始训练 。\n曲线 初始时 强势下降 没多久 归于水平 [紫线]： Solution：后期学习率过大导致无法拟合，应减小学习率，并重新训练后几轮 。\n曲线 全程缓慢 [黄线]： Solution：初始 学习率过小 导致收敛慢，应增大学习率，并从头开始训练 。\n过拟合欠拟合现象 过拟合-\u0026gt;各种泛化能力差的现象在这里我个人对这个现象的定义为以下的几种：\n训练阶段的准确率和验证/测试阶段的准确率相差大 训练过程和验证过程中的损失下降不一致，验证集中的准确率没有随着训练提升 典型的过拟合导致这样的现象 下面整理一下李沐对该部分的讲解 bug部分可能是由于增强做的过高或者问题太难, 但是在正常的表现下也不应该出现这种问题, 误差应该是差不多的.\n上面的这张图片也说明了, 我们模型和问题的难度是需要相互匹配的, 如果不匹配就会出现各种各样的问题, 模型的复杂度, 通常可以从可学习参数的数来进行简单的判断的.\n过拟合问题定义和分析 定义：模型对于训练集的假设过度严格，导致对训练集的数据拟合的“很好”，但是在测试验证集中效果不理想。可能会出现的典型现象如下：\n验证损失先下降后上升 训练集和测试集稳定后的准确率相差很大 下面这张图, 显示的是模型的复杂度和相应的泛化和训练误差之间的关系, 在训练的时候复杂度还是需要自我调整.\n收敛过快泛化能力差 过拟合的一种衍生问题，当模型在训练集中快速收敛，在这种情况下可能会陷入极小值，由于损失太小，模型参数难以跳出极小值点，这种情况下，如果不加以约束会影响泛化能力，可以考虑使用，\nflood 方法来设计我们的loss（效果未知，作为一种策略把，保证模型能够有一定量的损失，同时希望验证集上的损失能够下降到一个平缓的地方，来保证泛化能力） 产生的原因分析 训练数据样本单一，数据量不足 噪声干扰过大：失去了真实的输入输出之间的关系 模型的复杂度太高，足够死记硬背所有训练集的数据，导致不知道变通 数据的复杂度分析: 大部分情况下进行数据的对比还是一个比较直观的情况, 其实可以从这几个方面进行比较\n数据集的样本数, 类别 数据集的分辨率 数据的时空结构和多样性 常见的解决方式 :zap:添加正则化L1，L2（weight decay），\nweight decay等权重下降的方法，需要熟练掌握在pytorch上的设置\n:zap:降低模型的复杂度，对应模型的设计和问题的规模需要更好的分析。\n:zap:数据增强，使得数据的多样化指标进一步上升\n:zap:Dropout，Early Stop\nBatchNormalization\n集成学习方法，通过对多个模型进行集成来降低单一模型的过拟合风险\n图像增强 这里我们为图像增强另外开一个文档，图像增强的内容实际上可以考虑《数字图像处理》的这样一门课。\n自监督学习和对比学习 (qq.com) 文中提到对准确率提升最多的一些增强方式是如下的三种：\nCrop，Resize ，Flip Colour Distortion Gaussian Blur 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from torchvision import transforms # Size used in SimCLR size = 224 crop_resize_flip = transforms.Compose([transforms.RandomResizedCrop(size, scale=(0.08, 1.0), ratio=(3/4, 4/3)), transforms.RandomHorizontalFlip(p=0.5)]) # Higher means stronger s = 1.0 # 0.8*s and 0.2*s are from the paper colour_jitter = transforms.ColorJitter(brightness=0.8*s, contrast=0.8*s, saturation=0.8*s, hue=0.2*s) colour_jitter = transforms.RandomApply([colour_jitter], p=0.8) colour_distortion = transforms.Compose([colour_jitter, transforms.RandomGrayscale(p=0.2)]) kernel_size = int(0.1*size) # The size of the kernel must be odd kernel_size = kernel_size if kernel_size%2 == 1 else kernel_size+1 gaussian_blur = transforms.GaussianBlur(kernel_size, sigma=(0.1, 2.0)) gaussian_blur = transforms.RandomApply([gaussian_blur], p=0.5) augment = transforms.Compose([crop_resize_flip, colour_distortion, gaussian_blur]) 早停法 MicroSoft Ai 教程 ES 因为准确率都不再提高了，损失值反而上升了，再继续训练也是无益的，只会浪费训练的时间。那么该做法的一个重点便是怎样才认为验证集不再提高了呢？并不是说准确率一降下来便认为不再提高了，因为可能在这个Epoch上，准确率降低了，但是随后的Epoch准确率又升高了，所以不能根据一两次的连续降低就判断不再提高。\n对模型进行训练的过程即是对模型的参数进行学习更新的过程，这个参数学习的过程往往会用到一些迭代方法，如梯度下降（Gradient descent）学习算法。Early stopping便是一种迭代次数截断的方法来防止过拟合的方法，即在模型对训练数据集迭代收敛之前停止迭代来防止过拟合。\n更好的一个方式应该是使用一个类来进行计数\n1 2 3 4 5 6 7 8 9 10 class TrainingTrace(): def __init__(self, need_earlystop=False, patience=10, mode=\u0026#39;max\u0026#39;): self.early_stop = need_earlystop self.patience = patience self.patience_count = 0 self.last_vid_metrric = float(\u0026#39;inf\u0026#39;) if model ==\u0026#39;min\u0026#39; else float(\u0026#39;-inf\u0026#39;) self.compare = new_min if model == \u0026#39;min\u0026#39; else new_max def step(self, value): 在得到早停的迭代次数和权重矩阵参数后，后续有几种方法可以选择。\n彻底停止 就是啥也不做了，最多再重复几次早停的试验，看看是不是稳定，然后就使用做为训练结果。\n再次训练 由于第一次早停是通过验证集计算loss值来实现的，所以这次不再分训练集和验证集，记住了早停时的迭代次数，可以重新初始化权重矩阵参数，使用所有数据再次训练，然后到达第一次的时停止。\n但是由于样本多了，更新批次也会变多，所以可以比较两种策略：\n总迭代次数epoch保持不变 2) 总更新梯度的次数保持不变 优点：使用更多的样本可以达到更好的泛化能力。\n缺点：需要重新花时间训练。\n继续训练 得到后，用全部训练数据（不再分训练集和验证集），在此基础上继续训练若干轮，并且继续用以前的验证集来监控损失函数值，如果能得到比以前更低的损失值，将会是比较理想的情况。\n优点：可以避免重新训练的成本。\n缺点：有可能不能达到目的，损失值降不到理想位置，从而不能终止训练。\n效率优化 and there are some tips in this article , we should read and learn about it\n这一部分希望通过trick或者对应的一些代码技巧，优化训练过程中带来的资源占用和损耗，进一步提升训练时效性和资源上的有效利用\n1 2 3 4 5 6 7 # making relu inplace will save memory def inplace_relu(m): classname = m.__class__.__name__ if classname.find(\u0026#39;ReLU\u0026#39;) != -1: m.inplace=True # we need to learn this function model.apply(inplace_relu) relu(inplace = True)\nrapidAI Thanks to Nvidia, we could using np, spicy, pandas, sklearn on CUDA, which is much more faster. Achieve this by those repo: cuml for sklearn, cupy for numpy and spicy, cudf for dataframe and so on.\n借助这几个仓库的文档, 我们可以学习如何调用这些库去加速和实现我们的代码.\n在这里要注意的是, 使用这几个仓库的同时会引入更多的数据类型, 以及设备存储情况, 我们要在必要的时候对数据的存储位置进行分析和迁移.\n过于频繁的数据移动可能反而会减慢运行速度, 但是如果是后续不需要的数据我们可以进行迁移.\nInstall\n如果版本和torch的匹配(old version) 10.2 可以通过以下的命令安装cuml, 但是要注意panda版本 == 1.3.0, 首先对panda版本进行修改, 这种时候可能使用pip结合conda是一个更好的选择 如果版本不匹配, 我们可以首先配置rapidai的环境, 在安装pytorch即可, 或者使用nvidia发布的相同cuda版本的pytorch. torch.Cuda.AMP 使用Torch自带的AMP取代APEX的AMP进行优化，在\u0026gt;=1.6的情况下，Torch已经自动支持了AMP混合, 而且事实证明在大多数情况下, Torch对amp的支持相比APEX来说要更加稳定和性能友好。\n使用方法： 较为简单，只需要在训练的主流程中进行如下的嵌入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from torch.cuda.amp import autocast, GradScaler # 在训练最开始的阶段实例化一个GradScaler对象 scaler = GradScaler() for i in epochs: for j in iterators: ... # model and loss with autocast(): out = model(input) loss = loss_fn(output, target) # and change the update and backward phas # 放大loss scaler.scale(loss).backward() # 对inf和nan进行判断，没有问题的话就进行step scaler.step(optimizer) # 是否对scaler进行更新 scaler.update() APEX_显存优化 this session is write for the nvidia module APEX which can save a lot of memory and accelerate the training speed. we should learn how to use it .\n通过APEX好像能优化接近50%的显存，而且在修改原框架代码中的要求很小，所以在这里有必要通过APEX去优化我们的框架\n理论参考：基于Apex的混合精度加速 ；\n其中opt_level分别表示：O0纯FP32，O1混合精度训练，O2几乎FP16除了BN，O3纯FP16很不稳定，但是速度最快\n安装：\n验证cuda版本，验证torch的cuda版本\n1 2 3 4 5 nvcc -V # nvcc 很可能会找不到命令，去如下路径搜索是否cuda正确安装 cd /usr/local/cuda*/bin # 其中若有nvcc命令的话可以直接执行 nvcc -V 1 2 import torch print(torch.version.cuda) 安装apex\n1 2 3 git clone https://github.com/NVIDIA/apex cd apex pip install -v --no-cache-dir --global-option=\u0026#34;--cpp_ext\u0026#34; --global-option=\u0026#34;--cuda_ext\u0026#34; ./ import验证安装成功\n1 import apex 使用：\n参考官方示例，我们可以知道APEX的使用场景主要集中在几个部分：\nmodel,optimizer,loss upgrade and parallel\n故而我们对原始代码修改或添加如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from apex import amp from apex.parallel import DistributedDataParallel model = resnet() optimizer = torch.optim.SGD(model.parameters(),lr=1e-3) # MODEL PART: after model and optimizer design model, optimizer = amp.initialize(model, optimizer, opt_level = \u0026#34;O1\u0026#34;) # DISTRIBUTION PART: # replace nn.parallel.DistributedDataParallel() model = DistributedDataParallel(model) # LOSS PART: # replace the loss BP process # loss.backward() with amp.scale_loss(loss, optimizer) as scaled_loss: scaled_loss.backward() optimizer.step() 此外，如果我们希望使用APEX在训练过程中执行resume的话，我们还需要对代码做如下的添加\nNote that we recommend restoring the model using the same opt_level. Also note that we recommend calling the load_state_dict methods after amp.initialize.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Save checkpoint checkpoint = { \u0026#39;model\u0026#39;: model.state_dict(), \u0026#39;optimizer\u0026#39;: optimizer.state_dict(), \u0026#39;amp\u0026#39;: amp.state_dict() } torch.save(checkpoint, \u0026#39;amp_checkpoint.pt\u0026#39;) ... # Restore model = ... optimizer = ... checkpoint = torch.load(\u0026#39;amp_checkpoint.pt\u0026#39;) model, optimizer = amp.initialize(model, optimizer, opt_level=opt_level) model.load_state_dict(checkpoint[\u0026#39;model\u0026#39;]) optimizer.load_state_dict(checkpoint[\u0026#39;optimizer\u0026#39;]) amp.load_state_dict(checkpoint[\u0026#39;amp\u0026#39;]) # Continue training ... 安装过程中遇到了很多的问题：\nBuild error \u0026ldquo;fatal error: ATen/cuda/CUDAGraphsUtils.cuh: No such file or directory\u0026rdquo; · Issue #1043 · NVIDIA/apex (github.com) 1 2 # rollback apex to the previous commit git reset --hard 3fe10b5597ba14a748ebb271a6ab97c09c5701ac cc1plus: warning: command line option \u0026lsquo;-Wstrict-prototypes\u0026rsquo; is valid for C/ObjC but not for C++\n1 2 pip install -U cpython # this method is not useful command \u0026lsquo;gcc\u0026rsquo; failed with exit status 1\n1 git checkout f3a960f80244cf9e80558ab30f7f7e8cbf03c0a0 限制网络的输出范围 实际上，这一部分的应用就属于激活函数的数学理念问题了，我们倘若需要将网络的输出限制在一定的范围内，除了自己编写相关的数据处理手段之外，激活函数实际上有一部分原因就是为了这点设置的。\n神经网络基于对非线性运算的需要，引入了激活函数，强化了网络的学习能力； 同时神经网络对于输出有所要求（很多时候是以一种概率表达的方式输出的）所以就会需要softmax（0，1同时sum==1）之类的函数，可以将分类器的原始输出映射为概率。 Sigmoid tanh之类的将输出限制在（0，1），但是并没有对加和有要求，这里可以做一个区分https://www.cnblogs.com/jins-note/p/12528412.html区分sigmoid（多分类）和Softmax（单分类） Softmax和tanh可能会出现梯度消失的问题，ReLU将输出限制在（0，1） 一部分激活函数的特点 所以很显然，我们可以通过对于相应的激活函数的应用，来限制我们的网络输出范围。\n","permalink":"https://hugotest-phi.vercel.app/posts/nerualnetworktraining/","summary":"\u003cp\u003e@Aiken 2020，\u003c/p\u003e\n\u003cp\u003e主要针对神经网络的训练过程中的一些基础策略的调整，比如当训练的曲线出现一定的问题的时候，我们应该怎么去调整我们训练过程中的策略。\u003c/p\u003e\n\u003cp\u003e参数调整过程中最重要的就是优化器（优化或者说是下降算法）和学习率（优化算法的核心参数），此外像是数据增强策略还是Normalization策略，都能极大的影响一个模型的好坏。\u003c/p\u003e\n\u003ch2 id=\"优化器\"\u003e优化器\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://wizardforcel.gitbooks.io/learn-dl-with-pytorch-liaoxingyu/content/\" target=\"_blank\" rel=\"noopener\"\u003eSome Material\u003c/a\u003e\n\n实际上虽然有很多的优化算法，但是到最后最常用的还是 SGD+Mon 和 Adam两种：\u003c/p\u003e\n\u003cp\u003eAdam主要的有事在于自适应学习率，他对我们设计的学习率实际上没有那么敏感，但是在具体实验中往往不会有调的好的SGD那么好，只是在SGD的参数调整中会比较费劲。\u003c/p\u003e\n\u003cp\u003e但是有了根据patient调整lr的scheduler后，我们基本上可以使用SGD做一个较为简单的调整，只要设计好初始的lr的实验以及用来调整学习率的参数值。\u003c/p\u003e\n\u003ch2 id=\"学习率\"\u003e学习率\u003c/h2\u003e\n\u003cp\u003e$\\omega^{n} \\leftarrow \\omega^{n}-\\eta \\frac{\\partial L}{\\partial \\omega^{n}}$ 其中的权重就是学习率lr，\u003c/p\u003e\n\u003cp\u003e==Basic==\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c/th\u003e\n          \u003cth\u003e学习率大\u003c/th\u003e\n          \u003cth\u003e学习率小\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e学习速度\u003c/td\u003e\n          \u003ctd\u003e快\u003c/td\u003e\n          \u003ctd\u003e慢\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e使用情景\u003c/td\u003e\n          \u003ctd\u003e刚开始训练时\u003c/td\u003e\n          \u003ctd\u003e一定的次数过后\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e副作用\u003c/td\u003e\n          \u003ctd\u003e1. Loss爆炸 2.振荡\u003c/td\u003e\n          \u003ctd\u003e1.过拟合 2.收敛速度慢\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"学习率的基本设置\"\u003e学习率的基本设置\u003c/h3\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e在训练过程中，一般根据训练轮数设置动态变化的学习率。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e刚开始训练时：学习率以 0.01 ~ 0.001 为宜。\u003c/li\u003e\n\u003cli\u003e一定轮数过后：逐渐减缓。\u003c/li\u003e\n\u003cli\u003e接近训练结束：学习速率的衰减应该在100倍以上。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNote：\u003c/strong\u003e\n如果是 \u003cstrong\u003e迁移学习\u003c/strong\u003e ，由于模型已在原始数据上收敛，此时应设置较小学习率 (≤10−4) 在新数据上进行 \u003cstrong\u003e微调\u003c/strong\u003e 。\u003c/p\u003e\n\u003ch3 id=\"学习率变化方法\"\u003e学习率变化方法\u003c/h3\u003e\n\u003cp\u003e==warm up==\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.zhihu.com/question/338066667/answer/771252708\" target=\"_blank\" rel=\"noopener\"\u003ewarm up为什么有用\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003ewarm up衰减策略与上述的策略有些不同，它是先从一个极低的学习率开始增加，增加到某一个值后再逐渐减少, 这点上倒是和Cosine Anneal LR有一定的相似之处，将这两种结合起来是一种常见的训练策略：\u003c/p\u003e\n\u003cp\u003e这样训练模型更加稳定，因为在刚开始时模型的参数都是随机初始化的，此时如果学习率应该取小一点，这样就不会使模型一下子跑偏。\u003c/p\u003e\n\u003cp\u003e而这样的跑偏对于\u003cstrong\u003e大模型\u003c/strong\u003e而言，可能是导致很严重的影响，后面收敛了也可能不会达到最佳的效果，一开始的跑偏，可能会造成准确率在后面的严重结果。\n\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211216001833.png\"\u003e\r\n    \u003cimg alt=\"warmup\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211216001833.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211216001833.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"warmup\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Training Strategy"},{"content":"Basic Part基础设定部分 @AikenH 2020 + 2021\nthis part is about pytorch basic unit, help me to code deep learning better.\nTensor张量计算 两个tensor的数乘 计算两个tensor的矩阵乘法，注意其中的batch要相互对应，如果不考虑batch，就是另一个函数\n1 2 3 4 5 6 7 8 9 10 11 12 # 简单的分析一下算法的逻辑 # 这是割裂出来batch的矩阵相乘形式 batch1 = torch.randn(10,3,4) batch2 = torch.randn(10,4,5) out = torch.bmm(batch1, batch2) out.size() \u0026#39;\u0026#39;\u0026#39;output ans is torch.size([10,3,5])\u0026#39;\u0026#39;\u0026#39; # 按位相乘 res = torch.mul(batch1,batch2) view和permute的使用实际上都是不改变原值，要用赋值的方式去做，主要是使用方式要对，一个是按照顺序去做。\n张量命名 1 2 3 4 NCHW = [‘N’, ‘C’, ‘H’, ‘W’] images = torch.randn(32, 3, 56, 56, names=NCHW) images.sum(\u0026#39;C\u0026#39;) images.select(\u0026#39;C\u0026#39;, index=0) 类型转换 1 2 3 4 5 6 7 8 9 10 11 12 # tensor 与 nd.array进行互换 ndarray = tensor.cpu().numpy() tensor = torch.from_numpy(ndarray).float() # tensor与PIL.IMAGE进行互换 image = torchvision.transforms.functional.to_pil_image(tensor) path = r\u0026#39;./figure.jpg\u0026#39; tensor = torchvision.transforms.functional.to_tensor(PIL.Image.open(path)) # np.ndarray 与 PIL.Image的互换 image = PIL.Image.fromarray(nd.array.astype(np.uint8)) ndarray = np.asarray(PIL.Image.open(path)) 维度堆叠 Stack，普通的维度堆叠的测试代码如下\n测试代码如下，实际上dim=0就是基本的堆起来，dim=1就是按照行来堆，dim=2就是按照列来堆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 a = torch.arange(1,10).reshape(3,3) b = torch.arange(10,100,10).reshape(3,3) c = torch.arange(100,1000,100).reshape(3,3) print(\u0026#39;-----------------a----------------\u0026#39;) print(a) print(\u0026#39;-----------------b----------------\u0026#39;) print(b) print(\u0026#39;-----------------c----------------\u0026#39;) print(c) print(\u0026#39;-----------------dim =0----------------\u0026#39;) d = torch.stack((a,b,c),dim = 0) print(d.shape) print(\u0026#39;the value of d:- {}\u0026#39;.format(d[2,1,0])) print(d) # 也就是说，把单个当成整体直接从上往下堆叠 # 以x[:][:]为构成单元 print(\u0026#39;-----------------dim =1----------------\u0026#39;) d = torch.stack((a,b,c),dim = 1) print(d.shape) print(\u0026#39;the value of d:- {}\u0026#39;.format(d[1,2,2])) print(d) # 将每个的第一个维度，按次序纳出来，同value的堆在一起 # for example：[a[i][:],b[i][:],c[i][:] ]组成新的单元块 # 不，另一种理解，以x[i][:] 为单元 print(\u0026#39;-----------------dim =2----------------\u0026#39;) d = torch.stack((a,b,c),dim = 2) print(d.shape) print(\u0026#39;the value of d:- {}\u0026#39;.format(d[1,2,1])) print(d) # 相应的以x[i][j]为单元构成 list的情况下的维度堆叠测试代码如下\n相应的测试代码如下，实际上一般是按照dim=1来进行堆叠\n1 2 3 4 5 6 7 8 A = torch.randn([3,4,2]) B = [A[:,i] for i in range(A.size(1))] # 这样生成的是一个list,按照我们index的排序 print(A) print(B) C = torch.stack(B,dim=1) print(\u0026#39;---------------------result-----------------------\u0026#39;) print(C) Cat\n实际上应该也是类似的堆叠思路\n基本的张量函数 torch.split() 划分tensor\ntorch.randperm进行list的乱序处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 和shuffle区分，这是另一种乱序的操作 # cat操作 a = [] for i in range(3): a.append(torch.tensor([i,i])) all_inputs = torch.cat(a) # randperm的效果 test1 idx = torch.randperm(all_inputs.size(0)) print(idx) a1, b = all_inputs, all_inputs[idx] print(a1,b) # test2 ， print(\u0026#39;-------------------------\u0026#39;) # randperm 进行list的shuffle tensor_a = torch.randint(0,10,[8]) print(\u0026#39;origin version \u0026#39;, tensor_a) idx = torch.randperm(tensor_a.size(0)) print(\u0026#39;shuffle idx \u0026#39;, idx) tensor_b = tensor_a[idx] print(\u0026#39;after operation \u0026#39;, tensor_b) .fill_()按照输入的值对张量进行填充\n选取划窗 nn.unfold拆解卷积中的划窗步骤\n1 2 3 4 5 6 7 8 import torch inputs = torch.randn(1,3,224,224) unfold = torch.nn.Unfold(4,stride=4) output = unfold(inputs) # res output output.size() $ [1,4,3136] # 3136 = (224/4) * (224/4) Torch环境设置 pytorch中的随机种子初始化 yTorch 和 Python的随机数生成器就算随机种子一样也不会产生一样的结果。\n我们可以这样来设置Pytorch的随机数种子：（通常和GPU一起使用）\n1 torch.manual_seed(seed) nn.parameter() Main idea：parameter的作用，主要是将参数和model绑定在一起，我们就知道这个模型中，可能需要训练的参数有哪些，可以需要进行训练的参数加进去，但是当我们想要freeze it的时候就使用detach或者直接修改require_grad来让参数不在接受训练就好了， require_grad是其中的一个属性。可以结合上面的代码分析。 tensor变量是不可训练的，只有修改成parameter才能进行训练。 自带的网络结构中的一些weight和bias应该都是parameter的变量 nn.Softmax中的dim 其实没那么复杂，就和数据的维度是一样的，我们需要把那一个维度的数据之后的数据全部加起来处理就用哪个维度去做。\nIMAGE = N* DATA，dim=1 说明dim = 0 的Channel 是需要被排外的。也就是我们的softmax是基于data进行的。可以找寻源码进行进一步分析解释。\n测试、验证模块 基本编写 model.eval()和model.train()的区别 通常在模型测试的时候会执行model.eval()切换模型的状态，而在训练的时候会执行model.train()，model在这两个状态下的区别主要有：\n在train状态下会启用BN和Dropout，而在eval不启用这两个模块；\n启用BN指的是：用到每一个Batch数据的均值和方差；不启用则指的是使用整体的均值和方差（同时停止更新mean和var） 而对于Dropout来说：启用的时候指的是会随机进行dropout，而关闭的话就会用到全部的网络链接 with torch.no_grad() 上下文管理器，wrap起来的部分不会track grade\n主要用于停止autograd模块的工作，被with包裹起来的部分会停止梯度的更新，得到进一步的加速把，因为我们实际上在验证的时候不会执行step()等操作，所以能够节省计算模型梯度的时间。\n模型的保存和读取专题 @Aiken 2020\n基于onenote笔记，我们知道关键在于如何自由的读取模型中的参数，并选择性的取出来。\npytorch 模型部分参数的加载_LXX516的博客-CSDN博客_pytorch 加载部分参数 1 2 3 4 5 6 7 8 9 10 11 # 至少基于这样的方式我们能把模型中参数的string取出来。 pretrained_dict=torch.load(model_weight) model_dict=myNet.state_dict() # 1. filter out unnecessary keys pretrained_dict = {k: v for k, v in pretrained_dict.items() if k in model_dict} # 2. overwrite entries in the existing state dict model_dict.update(pretrained_dict) myNet.load_state_dict(model_dict) GPU相关的设置 @written by Aiken, 2020 this document is about Pytorch‘s CUDA, \u0026amp; GPU setting.\n查看GPU状态 设置默认GPU设备 一般使用GPU之前，我们需要知道系统中有多少GPU设备，因为默认的GPU设备是0，而且，大家一般都直接使用这张卡，所以我们如果只使用单卡的话，切换一下默认的GPU设备，能够避免一定的冲突。\n1 2 3 4 # 查看GPU使用状态 $ nvidia-smi # or $ gpustat [--watch] 设备基本信息 查看是否存在GPU，数量，类型\n1 2 3 4 5 import torch # 查看是否存在GPU，数量，类型 torch.cuda.is_available() torch.cuda.device_count() torch.cuda.get_device_name(0) 查看指定的GPU的容量和名称\n1 2 torch.cuda.get_device_capability(device) torch.cuda.get_device_name(device) 设置当前系统的默认gpu_devices，推荐使用os来设置（实际上是命令行中的操作）实际上是系统设定针对当前进程的可见GPU，其他的GPU会对当前的程序隐藏，所以默认的0\n1 2 os.environ[\u0026#39;CUDA_VISIBLE_DEVICES\u0026#39;] = \u0026#34;id\u0026#34; #推荐用法 # 可以在vscode的launch.json中设置env 注意事项：该命令需要在所有调用了CUDA的代码、子程序之前，包括import，所以很多代码的import都是在main()中的。\nGPU使用率优化（注意事项） 缓存爆炸问题 GPU使用途中需要注意的地方，在每次iteration之后记得清除在GPU中占用的memory，cache等，不然有时候会导致缓存和内存的递增和爆炸。\n具体操作：\n1 2 torch.cuda.empty_cache() # after every iteration 运行效率优化 cudnn.benchmark、pytorch论坛 pytorch中文网 、zhihu究极分析文 基本使用思路：\n在程序的开始，让cudnn花费一点额外的时间，找到适用于当前配置的最佳算法，从而优化运行效率。\n注意事项：\n但是如果我们的input_size在每个iteration都存在变化的话，那么每一个iteration都要执行一次搜索，反而得不偿失。\n具体操作\n1 torch.backends.cudnn.benchmark = true 设置使用GPU的方式 设置相应的随机种子 1 2 3 4 torch.cuda.empty_cache() # part2 设置随机种子 torch.cuda.manual_seed(seed) torch.cuda.manual_seed_all(seed) CUDA转换 使用.cuda()来对模型，数据，Loss进行赋值，或者使用to_devices()来设置到相应的GPU设备\n将模型转化到cuda中要在优化器的建立之前执行，因为optimizer是对于模型建立的，对模型执行cuda后已经和原本的参数和模型都不是同一个了，所以一定要在建立优化器之前就对模型进行Cuda 的转化。\n是否要对loss转换到CUDA，取决于一下的两种情况：\n损失函数是Functional：这样的话只要传入的参数是CUDA的就会再CUDA上计算 损失函数是Class with params：如果类内有参数的话，也要转换到CUDA才能一起在CUDA上计算 1 2 3 4 5 if torch.cuda.is_available(): try: loss = loss.cuda() except AttributeError: print(\u0026#39;the loss is not cuda-able {}\u0026#39;.format(type(loss))) 多GPU并行 主要使用的命令nn.DataParallel()\n1 2 model = nn.DataParaller(model,device_ids=None) # 如果不设定id的话，应该是自动指定全部可见的GPU的 CPU 偶然会由于pin_memory 的设置来致使CPU的不正常运行（满载等等），并非总是这样。\n核心和线程数设置 限制或增加pytorch的线程个数！指定核数或者满核运行Pytorch！！！_lei_qi的博客-CSDN博客 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import os from multiprocessing import cpu_count # 设置环境变量来控制线程多发的情况 cpu_num = cpu_count() # 核心代码 os.environ[\u0026#39;OMP_NUM_THREADS\u0026#39;] = str(cpu_num) # 下面这些应该是不一定药有 os.environ [\u0026#39;OPENBLAS_NUM_THREADS\u0026#39;] = str(cpu_num) os.environ [\u0026#39;MKL_NUM_THREADS\u0026#39;] = str(cpu_num) os.environ [\u0026#39;VECLIB_MAXIMUM_THREADS\u0026#39;] = str(cpu_num) os.environ [\u0026#39;NUMEXPR_NUM_THREADS\u0026#39;] = str(cpu_num) # 从其他资料中可以感觉这条代码应该是和核心代码一样的功能，所以两个写一个应该就可以了 torch.set_num_threds(cpu_num) 网络定义模块 数据定义模块 利用TorchVision读取本地数据 torchvision.datasets.imagefolder() 这个函数实际上能代替我们之前写的函数，但是由于自己写的有一部分统一规则可以使得我们的自定义程度很高，所以目前我们在绝大多数情况下不使用该方法来进行替代。\n但是由于是一个重要的函数，我们在这里还是介绍一下该工具的使用方式：\ntorch 自定义Dataset后的使用 自定义dataset的继承以及后续调用需要注意的是不能忘记将其转换成dataloaer，然后进行iter命令的执行。 也可以用enumerate函数来进行调用，就是记得调用的格式是什么就好 可以参考basicunit中的对shuffle的认知对该函数进行进一步的理解。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 定义dataset的部分 class RL_AET_Dataset(torch.utils.data.Dataset): def __init__(self): super(RL_AET_Dataset,self).__init__() pass def __len__(self): pass def __getitem(self): pass # 声明和构建部分 要记得使用dataloader train_l_dataset = RL_AET_Dataset(x_l, y_l, args) train_l_dataloader =torch.utils.data.DataLoader(train_l_dataset,batch_size=args[\u0026#39;b_s\u0026#39;],shuffle=True,num_workers=args[\u0026#39;num_workers\u0026#39;],drop_last=True,pin_memory=True) #调用迭代部分 labeled_loader = iter(train_l_dataloader) #all_label_info = [*next(labeled_loader)] Dataloader中的transformer（）： 疑惑解答 用compose集成的所有transform，都会应用，有个to_tensor，切to_tensor会自动转换PIL中的channel和数值范围。\ncompose中的变换组合的顺序关系\nPIL处理的图像变换（比如数据增强之类的方法） to_tensor() 处理tensor的方法：normalize 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 data_transforms = transforms.Compose([ transforms.RandomResizedCrop(224), transforms.RandomHorizontalFlip(). transforms.ToTensor(), transforms.Normalize([a,b,c],[A,B,C])]) # 然后直接加入dataset中的参数，或者是我们自定义的部分 # 在dataset中的写法如下，我们可以在自己的dataset中进行定义 if self.transformer is not None: img = self.transform(img) # 具体的源码细节表现如下 for t in self.transforms: img = t(img) return img Dataloader中的参数 shuffle机制\n主要解决问题：\n是否每次调用的时候都进行随机的操作，还是只有在初始化的时候才进行随机 两种不同使用Dataloader的方式是否会对shuffle的方式进行区分 结论：\n每次对dataloader进行重新调用（重新放到enumerate），或者重新定义iter，都会重新进行shuffle。 num_worker\n参考资料1 参考资料2：pytorch中文文档👇\nnum_workers (int, optional) – 用多少个子进程加载数据。0表示数据将在主进程中加载(默认: 0) 用num_worker个子进程加载数据，所以能够将数据在主进程展示还没有调用到该数据之前就将后续的数据存入RAM，所以在数据读取上会比较快，但是占用的RAM和CPU资源会比较大。\nsamples:\ntorch.utils.data - PyTorch 1.9.0 documentation 一文弄懂Pytorch的DataLoader, DataSet, Sampler之间的关系 官方的解释是：\nsampler (Sampler or Iterable, optional) – defines the strategy to draw samples from the dataset. Can be any Iterable with len implemented. If specified, shuffle must not be specified.\n定义从数据集（还是最开始的哪个数据集，不能是额外的数据集）中提取样本的策略：是否能通过该Method去实现Hard-Task或者像Meta-Task一样的采样过程呢？从Meta-Transfer-Learning中看来是可以的，可以学习一下它的写法。\ncollate_fn() collate_fn的作用就是将一个batch的数据进行合并操作。默认的collate_fn是将img和label分别合并成imgs和labels，所以如果你的__getitem__方法只是返回 img, label,那么你可以使用默认的collate_fn方法, 但是如果你每次读取的数据有img, box, label等等，那么你就需要自定义collate_fn来将对应的数据合并成一个batch数据，这样方便后续的训练步骤。\n编写collate_fn可以参考qidong的文章主要是接受数据和标签列表，将其整合成一个矩阵的形式; 如果对传参有需求,可以参考lambda的形式或者是类定义的形式去传入 1 2 3 4 5 6 7 8 9 10 11 dataload = DataLoader(dataset, lambda x: collate_fn(x, **params)) class collater(): def __init__(**params): self.params = ... def __call(self,datas): # make it a batch in this function, then we will instance this class ... def _helpful_fn(self): ... using collate_fn, we can augment the dataset more flexible.\n编写模型 模型基本单元 nn.conv2D：\nkernel_size[1]应该指的是卷积核的宽（不一定都是正方形的） 模型参数共享： pytorch：对比clone、detach以及copy_等张量复制操作 1 2 3 # 假设有modela和modelb，我们需要在进行下降的时候执行参数统一， for a_para,b_para in zip(modela.parameters(),modelb.parameters()): b_para.data.copy_(a_para.data) 网络定义的方式对比分析 @Aiken 2021 主要对比的是ModuleList和Sequtial\n**结论：**通常使用的话，这里我个人推荐使用的是sequtial结合collection中的orderdict来构建的方法，这个方法集成了内部的forward，同时通过``orderdict`也能给print带来更好的可视化效果。\n但是还是有一些特殊的使用场景我们会用到ModuleList\n详解PyTorch中的ModuleList和Sequential 主要区别：\nnn.Sequential内部实现了forward函数，因此可以不用写forward函数。而nn.ModuleList则没有实现内部forward函数。\nnn.Sequential可以使用OrderedDict对每层进行命名，上面已经阐述过了；\nnn.Sequential里面的模块按照顺序进行排列的，所以必须确保前一个模块的输出大小和下一个模块的输入大小是一致的。而nn.ModuleList 并没有定义一个网络，它只是将不同的模块储存在一起，这些模块之间并没有什么先后顺序可言。网络的执行顺序按照我们在forward中怎么编写来决定的\n有的时候网络中有很多相似或者重复的层，我们一般会考虑用 for 循环来创建它们，而不是一行一行地写，这种时候就使用ModuleList：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class net4(nn.Module): def __init__(self): super(net4, self).__init__() layers = [nn.Linear(10, 10) for i in range(5)] self.linears = nn.ModuleList(layers) def forward(self, x): for layer in self.linears: x = layer(x) return x net = net4() print(net) # net4( # (linears): ModuleList( # (0): Linear(in_features=10, out_features=10, bias=True) # (1): Linear(in_features=10, out_features=10, bias=True) # (2): Linear(in_features=10, out_features=10, bias=True) # ) # ) 基本使用：\nnn.sequential\n可以通过list和*以及add moudle来进行迭代的定义，同时这种定义方式，会方便我们的重复注册\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from collections import OrderedDict class net_seq(nn.Module): def __init__(self): super(net_seq, self).__init__() self.seq = nn.Sequential(OrderedDict([ (\u0026#39;conv1\u0026#39;, nn.Conv2d(1,20,5)), (\u0026#39;relu1\u0026#39;, nn.ReLU()), (\u0026#39;conv2\u0026#39;, nn.Conv2d(20,64,5)), (\u0026#39;relu2\u0026#39;, nn.ReLU()) ])) def forward(self, x): return self.seq(x) net_seq = net_seq() print(net_seq) #net_seq( # (seq): Sequential( # (conv1): Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) # (relu1): ReLU() # (conv2): Conv2d(20, 64, kernel_size=(5, 5), stride=(1, 1)) # (relu2): ReLU() # ) #) nn.ModuleList:与python自带的List不同的地方在于他会自动将网络注册到Parameter中，成为网络，但是需要自己去编写forward过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class net_modlist(nn.Module): def __init__(self): super(net_modlist, self).__init__() self.modlist = nn.ModuleList([ nn.Conv2d(1, 20, 5), nn.ReLU(), nn.Conv2d(20, 64, 5), nn.ReLU() ]) def forward(self, x): for m in self.modlist: x = m(x) return x net_modlist = net_modlist() print(net_modlist) #net_modlist( # (modlist): ModuleList( # (0): Conv2d(1, 20, kernel_size=(5, 5), stride=(1, 1)) # (1): ReLU() # (2): Conv2d(20, 64, kernel_size=(5, 5), stride=(1, 1)) # (3): ReLU() # ) #) for param in net_modlist.parameters(): print(type(param.data), param.size()) #\u0026lt;class \u0026#39;torch.Tensor\u0026#39;\u0026gt; torch.Size([20, 1, 5, 5]) #\u0026lt;class \u0026#39;torch.Tensor\u0026#39;\u0026gt; torch.Size([20]) #\u0026lt;class \u0026#39;torch.Tensor\u0026#39;\u0026gt; torch.Size([64, 20, 5, 5]) #\u0026lt;class \u0026#39;torch.Tensor\u0026#39;\u0026gt; torch.Size([64]) Detach \u0026amp; detach_ 这个模块在后续进行pretrain或者transfer的时候应该会经常被用到，所以这种方法还是需要熟练掌握的\n详细的分析介绍 detach是产生一组不需要下降的“Copy”：如果要修改原值的话就要进行赋值操作。\ndetach_则是修改本身参数的属性（require_gradetc.）执行函数就能将参数修改为不需要下降的情况，不需要执行赋值处理。\n模型调用的Tips 使用list进行多模型的混合调用\n由于python默认的是引用赋值，也就是浅拷贝的方式？ 通过list来进行模型的批量构建，通过list来将模型整合起来，是不会使用额外的存储空间的，它们指向同一个地址。基于这样的假设，我们可以基于list来简化代码，通过LOOP来执行，相关的调用操作，比如生成器或者预测之类的，来简化代码结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 model1 = AET_model(3,4,5,**kwargs) model2 = AET_model(3,4,5,**kwargs) model_list = [model1,model2] if id(model1)==id(model2): print(\u0026#39;the address of those model is same, so donot need extra space\u0026#39;) # 具体可以简化什么类型的操作： optimizer_list = [] for _, models_t in enumerate(model_list): optimizer_list.append(optim.SGD( models_t.parameters(), lr,mom，wd)) optimizer1 = _[0] optimizer2 = _[1] # like this Warm-up factor 对于这一部分的概念我还是有些不了解，是否和冷启动和热启动的概念是相关的，如果不是的话，顺便就学习一下冷启动和热启动的概念。\n具体解析：\nneural network - What does \u0026ldquo;learning rate warm-up\u0026rdquo; mean? - Stack Overflow 关于warm_up学习率_云中寻雾的博客-CSDN博客 pytorch学习率调整方法（warm up） ，label smooth、apex混合精度训练、梯度累加_xys430381_1的专栏-CSDN博客 神经网络中 warmup 策略为什么有效；有什么理论解释么？ Weight decay（L2） 实际上就是对权重进行L2正则化，让权重衰减到更小的值，在一定程度上减少模型的过拟合问题，所以权重衰减实际上也叫L2正则化。\n具体的数学推导后续将集成到GoodNote笔记上，将正则化单独作为一个模块去整理。\n权重衰减（L2正则化）的作用\n作用： 权重衰减（L2正则化）可以避免模型过拟合问题。\n思考： L2正则化项有让w变小的效果，但是为什么w变小可以防止过拟合呢？\n原理： （1）从模型的复杂度上解释：更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合更好（这个法则也叫做奥卡姆剃刀），而在实际应用中，也验证了这一点，L2正则化的效果往往好于未经正则化的效果。（2）从数学方面的解释：过拟合的时候，拟合函数的系数往往非常大，为什么？如下图所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。而正则化是通过约束参数的范数使其不要太大，所以可以在一定程度上减少过拟合情况。\nimage-20201205175236273\n内容来自： 正则化方法：L1和L2 regularization、数据集扩增、dropout Learning Rate Decay 当我们选择了一个合适的lr，但是损失训练到一定程度以后就不再下降了，就在一个区间中来回动荡，可能是出现了一下的问题：\nimage-20201205175605729\n对这种问题的解决就是通过学习率衰减来实现的：将学习率随着训练的进行来进行衰减，这个方法就比较直观了。具体的方法描述可以在 ../project_note/训练参数调整策略.md中找到。\n也可以参考如下连接：详细理解pytorch的六种学习率pytorch 损失函数 nn中自带的Loss Function比如说MSE之类的，计算出来的值本身就已经对batch取了平均值，同时我们进行交叉熵的计算的时候，我们不需要实现对他进行softmax，因为再CE中已经集成了softmax的操作。\nCrossEntropy交叉熵 这里会介绍一下Pytorch中的CE损失的具体实现的方法，这里给出三种方式的对比。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import torch # initial data and calculate method input_x = torch.randn((4,5)) label = torch.tensor((1,2,3,4)) cri = torch.nn.CrossEntropyLoss() nll_f = torch.nn.NLLLoss() # output softmax and logsoftmax and pred softamx_x = torch.softmax(input_x,dim=1) logsoftmax_x = torch.log(softamx_x) print(\u0026#34;softamx_x \\n\u0026#34;, softamx_x) print(\u0026#34;pre_res \\n\u0026#34;, softamx_x.argmax(axis=1)) print(\u0026#34;log_softamx_x \\n\u0026#34;, logsoftmax_x) # calculate official ce and NLL print(\u0026#34;torch ce \\n\u0026#34;,cri(input_x,label)) print(\u0026#34;nll_cal \\n\u0026#34;, nll_f(logsoftmax_x,label)) # calculate the manual ce loss we cal res = [-logsoftmax_x[i][label[i]] for i in range(len(label))] print(\u0026#34;manual cal \\n\u0026#34;,sum(res)/len(label)) 可以发现三种方式计算出来的损失是一样的，这就说明了我们在计算的时候要记住，ce中是自己集成了softmax的操作，同时在Nll中是存在了取negative的操作的。按照这个操作手册去实现自己相应的损失函数设计\n优化器设计 这一部分主要添加一些常见的优化器参数的设置包括SGD和Adam的对应设置，主要介绍一下设置Adam 实际上Adam的设置对于学习率来说没有那么敏感，但是我们还是要了解参数的意思才知道怎么去设置该优化器\n模型参数初始化和架构查看方法 实际上对参数初始化也就是需要对整体的架构进行遍历，所以这两个会归为一个子课题\n参数的初始化方法只要使用如下的方式，无论我们采取那种定义的方式，，都能遍历到其中所包含的所有网络层\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 如果直接在网络定义的时候直接进行初始化 for m in self.modules(): if isinstance(m,nn.Conv2d): nn.init.kaiming_normal_(m.weight,mode=\u0026#39;fan_out\u0026#39;) if isinstance(m,nn.BatchNorm2d): nn.init.constant_(m.weight,1) nn.init.constant_(m.bias,1) # 如果是在模型定义的外部的话 for layer in model.modules(): if isinstance(layer, torch.nn.Conv2d): torch.nn.init.kaiming_normal_(layer.weight,mode=\u0026#39;fan_out\u0026#39;, nonlinearity=\u0026#39;relu\u0026#39;) if layer.bias isnotNone: torch.nn.init.constant_(layer.bias, val=0.0) elif isinstance(layer, torch.nn.BatchNorm2d): torch.nn.init.constant_(layer.weight, val=1.0) torch.nn.init.constant_(layer.bias, val=0.0) elif isinstance(layer, torch.nn.Linear): torch.nn.init.xavier_normal_(layer.weight) if layer.bias isnotNone: torch.nn.init.constant_(layer.bias, val=0.0) layer.weight = torch.nn.Parameter(tensor) # 也可以使用其他的方法比如parameters，children children、modules、parameters： model.modules会遍历model中所有的子层，而children只会遍历当前层，也就是最外层的情况，所以如果要进行参数的初始化的话，最好是用类内或者类外的两种方法来实现初始化\nparameter返回的是模型的所有参数，所以初始化最好使用的是``modules`，而parameter一般用来初始化参数\n用numel与parameters计算参数的个数\n1 2 3 4 5 6 7 8 9 10 #可以简洁的写成下面的形式 #numel()函数本身的作用是返回数组中元素的个数 def count_parameters(model): return sum(P.numel() for P in model.parameters() if P.requires_grad) #帮助理解的结构形式可以表达如下： def count_parameters(model): for p in model.parameters(): if p.requires_grad: ans += p.numel() 初始化原则：（继续调研） pytorch中的参数初始化方法总结_ys1305的博客-CSDN博客_pytorch 参数初始化 Batch-Normalization：Batch Normalization详解 - shine-lee - 博客园 (cnblogs.com) conv：kaming_normal_ fc：constan_,xvaier bn：normal_\\constant| 典型的参数初始化方法 EnAET中可以看到参考的源码如下，需要注意的是，BN中只有两个参数，所以不需要进行参数的初始化，或者直接置0、1即可.\n1 2 3 4 5 6 7 8 9 10 11 for m in self.modules(): if isinstance(m,nn.Conv2d): # 计算参数 n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels m.weight.data.normal_(0,math.sqrt(2. / n)) elif isinstance(m,nn.BatchNorm2d): m.weight.data.fill_(1) m.bias.data.zero_() elif isinstance(m, nn.Linear): nn.init.xavier_normal_(m.weight.data) # what\u0026#39;s this method m.bias.data.zero_() 数据类型和维度 在算法编写的过程中，数据的类型和维度的对齐和channel是很重要的，在这里也很容易出现很多的bug，在这里做一个信息的汇总\n输入数据的通道 结论：pytorch网络输入图片的shape要求通道是channel_first（通道在前）的，所以如果我们的图片不是这样的话，我们就需要执行相应的变化。\nTODO：整理各种数据读取方式读入的channel first 或是 last : skimage,PIL,numpy\n整理相应的各种数据类型进行transpose（numpy）的方式\n1 2 3 4 # 也可以使用view函数，但是相应的，view需要计算出各个维度相应的数值 # view（）直接使用的时候不改变原值的大小，permute也不改变，使用的方法不同而已 if img.shape[-1] == 3: img = img.permute(0,3,1,2) 标签的形式转换one-hot 进行训练之前要将数据转化为onehot的形式，才能输入训练，而且一般因为是batch_size的形式，所以我们需要转化为矩阵形式的onehot，不能用单个label的转化方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def make_onehot_single(num,index): \u0026#39;\u0026#39;\u0026#39;根据类别数量和index生成single，onehot\u0026#39;\u0026#39;\u0026#39; # BTW：scatter方法也能生成one-hot onehot = torch.zeros(num) onehot[index] = 1.0 return onehot # 主要是下面这种方法需要掌握， def make_onehot_array(width,target): \u0026#39;\u0026#39;\u0026#39;根据label生成onehot矩阵。 width：类别数 target：具体的labeldata\u0026#39;\u0026#39;\u0026#39; try: length = len(target.view(-1,1)) except ValueError: print(\u0026#39;the type of target is {} \u0026#39;.format(type(target))) print(target) raise Exception(\u0026#39;break down\u0026#39;) onehot = torch.zeros(length, width).scatter_(1,target.view(-1,1),1) return onehot Visualize 可视化部分 Tensorboard in Pytorch @Aiken H 2021 review 之前这一部分的projection和model都没有成功显示，这次在新框架中展示一下。\nVisualizing Models, Data, and Training with TensorBoard - PyTorch Tutorials 1.8.1+cu102 documentation 详解PyTorch项目使用TensorboardX进行训练可视化_浅度寺-CSDN博客_tensorboardx 使用 TensorBoard 可视化模型，数据和训练 (apachecn.org) 在pytorch教程中的Projection可以结合后续输出的Feature使用来分析相应的聚类和分类可靠性\n可以尝试使用，教程写的很简单易懂。\nHistogram 直方图参数统计 一般来说用来统计模型中间的一些参数的分布情况，具体的使用在训练的epoch之间，和val是一个比较类似的机制，具体的代码样例如下：\n1 2 3 4 5 6 # visualize those parameter as historgram # we can add other model here if i % 10 == 0: for name,param in self.main_model.named_parameters(): self.writer.add_histogram(\u0026#39;main_model\u0026#39;+name,param.clone().cpu().data.numpy(),i) pass Embedding Projection @Aiken H 2021 这一部分可能才是神经网络的特征分布的可视化图。\n下面这个是Google的Embedding Projection，需要上传.tsv保存的数据，但是实际上就是Tensorboard上也有集成的功能\nEmbedding projector - visualization of high-dimensional data Visualizing Data using the Embedding Projector in TensorBoard PR_CURVE 这里会贴上pr_curve中需要的参数和我们这边编写的示例代码\nAdd_TEXT 换行失效问题, 这是因为在Tensorboard中这一部分使用的是Markdown的格式, 所以在这里我们在换行符\\n之前, 需要保留两个空格才能实现真正的换行\nADD_Figure 有时候我们会发现我们编写的figure在step中没有全部现实出来, 这是我们可以通过启动命令来展示所有的图片\n1 2 --samples_per_plugin images=9999 # 999 \u0026gt; the num you want to displ 可视化神经网络热力图（CAM） @Aiken2020 为了便于查看神经网络的输出，对于图像的哪一部分更加的侧重，也就是指导网络进行分类的主要是图像的哪些区域，（相应的也可以按照类似的方法查看Attention Network的效果把），就想着可视化一下CAM。看指导分类的高响应区域是否落在核心区域。\n参考链接：\nCAM Pytorch 算法原理 其计算方法如下图所示。对于一个CNN模型，对其最后一个featuremap做全局平均池化（GAP）计算各通道均值，然后通过FC层等映射到class score，找出argmax，计算最大的那一类的输出相对于最后一个featuremap的梯度（实际上就是最后一个map中哪些对于分类的变化其更大的作用，也就是类似权重的机制），再把这个梯度可视化到原图上即可。直观来说，就是看一下网络抽取到的高层特征的哪部分对最终的classifier影响更大。\nQuote: 找到了一篇基于Keras的CAM实现，感谢：\nhttps://blog.csdn.net/Einstellung/article/details/82858974 但是我还是习惯用Pytorch一点，所以参考着改了一版Pytorch的实现。其中，有一个地方困扰了一下，因为Pytorch的自动求导机制，一般只会保存函数值对输入的导数值，而中间变量的导数值都没有保留，而此处我们需要计算输出层相对于最后一个feature map梯度，所以参考https://blog.csdn.net/qq_27061325/article/details/84728539解决了该问题。\n代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import os from PIL import Image import torch import numpy as np import cv2 import matplotlib.pyplot as plt def draw_CAM(model, img_path, save_path, transform=None, visual_heatmap=False): \u0026#39;\u0026#39;\u0026#39; 绘制 Class Activation Map :param model: 加载好权重的Pytorch model :param img_path: 测试图片路径 :param save_path: CAM结果保存路径 :param transform: 输入图像预处理方法 :param visual_heatmap: 是否可视化原始heatmap（调用matplotlib） :return: \u0026#39;\u0026#39;\u0026#39; # 图像加载\u0026amp;预处理 img = Image.open(img_path).convert(\u0026#39;RGB\u0026#39;) if transform: img = transform(img) img = img.unsqueeze(0) # 获取模型输出的feature/score model.eval() features = model.features(img) output = model.classifier(features) # 为了能读取到中间梯度定义的辅助函数 def extract(g): global features_grad features_grad = g # 预测得分最高的那一类对应的输出score pred = torch.argmax(output).item() pred_class = output[:, pred] features.register_hook(extract) pred_class.backward() # 计算梯度 grads = features_grad # 获取梯度 pooled_grads = torch.nn.functional.adaptive_avg_pool2d(grads, (1, 1)) # 此处batch size默认为1，所以去掉了第0维（batch size维） pooled_grads = pooled_grads[0] features = features[0] # 512是最后一层feature的通道数 for i in range(512): features[i, ...] *= pooled_grads[i, ...] # 以下部分同Keras版实现 heatmap = features.detach().numpy() heatmap = np.mean(heatmap, axis=0) heatmap = np.maximum(heatmap, 0) heatmap /= np.max(heatmap) # 可视化原始热力图 if visual_heatmap: plt.matshow(heatmap) plt.show() img = cv2.imread(img_path) # 用cv2加载原始图像 heatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0])) # 将热力图的大小调整为与原始图像相同 heatmap = np.uint8(255 * heatmap) # 将热力图转换为RGB格式 heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET) # 将热力图应用于原始图像 superimposed_img = heatmap * 0.4 + img # 这里的0.4是热力图强度因子 cv2.imwrite(save_path, superimposed_img) # 将图像保存到硬盘 BUGs 如果想要展示出所有step的图片, 我们可以在命令行里执行tensoroard的时候执行下列命令.\n1 tensorboard --logdir log/cifar100_resnet18 --samples_per_plugin images=999999 DEBUG 1.ImportError: cannot import name \u0026lsquo;PILLOW_VERSION\u0026rsquo; PIL版本过高，换低就可以，他不配是一个棘手的问题\npip install Pillow==6.2.2 --user\n2.模型参数\u0026amp;计算量统计 and Debug输出 用来计算模型构建中网络的参数，空间大小，MAdd，FLOPs等指标，count_params很好写，然后剩下的计算我们交给两个第三方的库来实现：torchstat,thop 1 2 from torchstat import stat stat(model,(3,224,224)) #that‘s all using it in the eval stage 也可以使用torchsummary来查看各层输出的数据的维度数目 1 2 from torchsummary import summary summary(model.cuda(),input_size=(3,224,224),batch_size=1) 相应的Debug还可以使用torchsnooper进行：变量的类型和维度追踪这个模块通过@xxxx修饰器的方法调用在指定的method前面，能够在训练过程中输出一些参数值的类型和数值变化的较为详细的信息。个人理解的最佳使用环境是，用于调试或者监控类型之间的错误。 1 2 3 # 这个package如果没记错的话好像是使用装饰器的方法去进行测试 @... method() 3.PyTorch加载预训练模型 具体错误：在于模型Dict中的Key和预训练model中的Key不对应，无法匹配。\n1 Unexpected key(s) in state_dict: \u0026#34;module.features. ...\u0026#34;.，Expected \u0026#34;.features....\u0026#34; 问题分析：\nsituation1：可以看到前面多了module这个str，这一般是由于其中一方使用了多GPU训练后直接保存的，也就是DataParallel模式下导致的不匹配问题。\nsolution1： 参考资料 load模型后去掉多余的参数在事先的时候发现这个方法还是存在问题的，并不是简单的dict封装的结构，所以没法这样简单的进行赋值处理:x:\n用空白代替module，暂时还没尝试，但是我觉得会遇到和第一个一样的问题:x:\n:zap:最简单的方法：加载模型后将模型进行DataParallel，再进行数据的转化，将数据进行并行化。具体的操作如下\n1 2 3 model.cuda() # 将ids设置成拥有的GPU即可，但是不知道单GPU的情况可不可以实现这种情况 model = nn.DataParallel(model, device_ids=None) Situation2： 保存模型格式为.pth.tar，无法载入训练好的模型\nSolution2：\n原因是因为被保存的模型是在高版本的pytorch下实现的，但是再低版本中读取的模型是.pth格式的，就会出现版本冲突。 解决方法如下👇：\n1 2 3 # 在高版本的环境中load model，然后再重新保存，保存的时候添加参数，使得保存成旧版本即可 torch.save(checkpoint,save_path,_use_new_zipfile_serialization=False) # DONE xxx is a zip archive(did you mean to use torch.jit.load()?)\n使用低版本的Torch去Load高版本（\u0026gt;1.6）保存的模型（.pth.tar）遇到的问题,\n这种错误，主要是模型的版本冲突。\n解决办法：在高版本的环境中，重新load模型，然后直接save，在保存的时候添加参数\ntorch.save(model.state_dict(),model_path,_use_new_zipfile_serialization=False)\n就可以保存成.pth的模型，也能在低版本的torch环境中使用了\n4.some of the strides of a given numpy array are negative. ver：torch1.2 这个问题可能会在后续的版本中被优化。\nSituation：\nhttps://www.cnblogs.com/devilmaycry812839668/p/13761613.html 问题出现在flat操作中，反向切片[::-1]会导致数据存储在内存上不连续，在旧版本中无法实现，对这样数据进行存储。 Solution1: 所以在执倒排切片的时候执行，img2 = np.ascontiguousarray(img) 使得数据在内存空间上连续。\nSolution2:\n或者执行倒排切片的时候，直接return img.copy()\n5.读取loader的时候图像的大小不一 使用Crop对图像进行处理的时候，不注意的话就是会出现这样的问题，图像的size随机改变，导致的输出不统一。也可能是Crop函数写的有问题。\nbug info如下\n1 $ RuntimeError: invalid argument 0: Sizes of tensors must match except in dimension 0. Got 182 and 360 in dimension 2 Solution：\nresize，spp，padding，adaptiveMaxPooling（自适应的pooling，pooling到指定的size（channel除外））\n6.bus error dataloader num_worker 原因暂时还不是太清楚，但是我们可以把num_worker设置为0 来解决这个问题.jpg\n7.bus error：insufficient shared memory（shm） 这种原因通常会在docker环境中出现，由于未指定shm容量大小，比如ipc=host之类的命令，就会导致docker的shm只有64m，于是在运行的时候就会出问题。这种情况下只能重新run docker（目前只找到了这个方法）。\n如果要妥协的话，就只能试着减小batch_size。但是随着模型的设计上，这其实不是一个可以逃避的问题，也会增加莫须有的其他成本，所以。\n8.训练过程中Cache和Memory的占用逐渐升高 主要的体现是：逐渐升高这一点，而不是稳定的情况；\n有点玄学，但是在这种情况下，我们在每个iteration结束的时候使用清楚显存的函数，竟然就能进行控制了，虽然我不知道为啥清楚显存的函数会顺便连内存中的cache也一起清除了，但是就是，学。\n1 torch.cuda.empty_cache() 9.梯度爆炸问题，算法没有学习效果 梯度爆炸问题，分析可能出现存在的问题：\n某一部分的学习参数可能的lr过高，权重过高，导致误差快速传播。 问题的复杂度过高，算法overpower了把。 针对于第一点的话，我们参考工程笔记中的学习率调整策略即可。\n如果是问题的复杂度过高，那么可能是问题对于我们的模型来说已经overpower的，我们可能需要去加深网络的层数，或者对网络进行进一步的设计和对数据的分析问题。\n10.类型转换问题汇总 比如scatter_需要将数据从int32的格式转换成int64，我们要掌握一下在Pytorch中进行数据类型转换的技巧。\nExpected object of scalar type Float but got scalar type Double for argument #2 \u0026rsquo;target\u0026rsquo; 数据类型不匹配，一个是np.float32,另一个是64 参考解决方案：重要 Expected object of scalar type Long but got scalar type Float for argument 希望得到的是Long型标量数据，但是得到了Float型的数据（实际上可能是我们进行测试的时候使用了小数带来的，但是我们也能将其转化就是了）\n1 2 Longtensor() type(torch.longtensor) RuntimeError: Input type (torch.cuda.FloatTensor) and weight type (torch.DoubleTensor) should be the same RuntimeError: Input type (torch.cuda.ByteTensor) and weight type (torch.cuda.FloatTensor) should be the same问题实际上都是和权重的数据类型不匹配，需要将字节型或者是FLoat型向Weight的数据类型转换，但是可能这里的问题实际上出现在就是我们导入的数据类型是不正确的。还是使用type()命令来进行数据类型的转换，但是关键还是：检查输入数据的类型以及数值范围，同时看看在进行dataloader的时候有没有指定to_tensor的变换等等\n参考资料链接 进行数据转换的几种方式\n使用函数tensor1.type_as(tensor2)将1的数据类型转换成2的数据类型。\n1 2 3 tensor_1 = torch.FloatTensor(5) tensor_2 = torch.IntTensor([10, 20]) tensor_1 = tensor_1.type_as(tensor_2) tensor.type(torch.IntTensor)\ntensor.long(),tensor.char(),tensor.int(),tensor.byte(),tensor.double()\ntenosr.to(torch.long)\n11.数据维度不对应问题汇总 multi-target not supported at问题实际上可以翻译成：维度上和交叉熵损失函数的需求不对应。在使用交叉熵损失函数的时候，target的形状应该是和label的形状一致或者是只有batchsize这一个维度的。如果target是这样的【batchszie，1】就会出现上述的错误\n1 使用squeeze（）函数降低维度 12.取出具体数值时候的问题 **RuntimeError: Can\u0026rsquo;t call numpy() on Variable that requires grad. Use var.detach().numpy()**对于输出的结果要转换成具体的数值的时候，如果我们后续还需要这个数值的梯度，就不能转换到cpu后再转换到numpy,就好比说，我们要取出Loss的时候，我们可以直接使用item()取出具体的数值，而不需要转到CPU上 13.CPU占用99% 问题描述：使用torch自带的dataset中的cifar10的时候，在每个epoch结束的时候，CPU占用率高达99%，并不随着num_workder而改变，问题可能由于pytorch开辟了太多的线程\nwindows10下pytorch的GPU利用率低，占用率低_stay_zezo的博客-CSDN博客 可能是由于GPU运算太快了，启用了多线程进行加载数据，这种时候启用pin_memory=true 能起到一定的作用把，加快一点数据读取。\n最终解决方案 ：pin-memory=false 反正原因很神奇，但是最终就是因为这个解决的，可能是因为memory超了，所以每次都需要重新empty_cache 重新装进页，所以反而加重了CPU的负担\n14. 预测值全为0，模型收敛到奇怪的地方，损失保持一致（全均等） 这种情况通常是由于模型设计中存在一点问题：\n比如这次是由于模型中fc后面添加了relu，这样导致输出的负值全被抑制了，导致学习出现了严重的错误后果。\n15.模型部分： 训练中模型准确率不上升 由于框架已经验证过是可以进行正常训练的，在这种情况下出现模型的准确率不上升可能是由于模型本身设计（内部代码编写）上的问题。\n16. On entry to SGEMM parameter number 8 had an illegal value Tracing failed sanity checks! Graphs differed across invocations!\nfc的问题，输入fc和对应的网络输入层不一致，检查阶段数目和feature输出的特征维度\n17. CUDA error: device-side assert triggered CUDA kernel errors might be asynchronously reported at some other API call 这个问题的出现的根本原因在于：\n维度不匹配：标签的dimension 超出了全连接层最后输出的dimension，这一部分错误的触发，和Loss的计算，Acc的计算，有着强烈的相关关系。\n为了解决这个问题，我们在训练相关的验证和训练环节，需要保持训练数据集和验证数据集在类别数目上的一致性，而在我们需要对数据集外的数据进行测试的时候，我们避免进行Loss的计算，在对Acc进行计算的时候，也尽量避免Torch中的自有库，避免产生该类的问题/\nRuntimeError the derivative for target is not implemented 问题通常出现在损失计算的过程中，这个错误是由于我们在损失中的第二项 targets不应该有梯度，但是在这个地方却存在梯度导致的.\n在这里我们可以通过仅仅取出 tensor的data或者使用detachandcopy来进行数值的传递\nOnly Tensors created explicitly by the user (graph leaves) support the deepcopy protocol at the moment 该错误是由deepcopy和require_grad, require_fn同时构成, 如果我们对一个需要计算梯度的非叶子节点进行deepcopy就会触发这个错误。\n如果我们需要对这个数据进行存储的话，我们可以执行\n1 save = copy.deepcopy(feature.data.cpu().numpy()) ","permalink":"https://hugotest-phi.vercel.app/posts/pytorch/","summary":"\u003ch1 id=\"basic-part基础设定部分\"\u003eBasic Part基础设定部分\u003c/h1\u003e\n\u003cp\u003e@AikenH 2020 + 2021\u003c/p\u003e\n\u003cp\u003ethis part is about pytorch basic unit, help me to code deep learning better.\u003c/p\u003e\n\u003ch2 id=\"tensor张量计算\"\u003eTensor张量计算\u003c/h2\u003e\n\u003ch3 id=\"两个tensor的数乘\"\u003e两个tensor的数乘\u003c/h3\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e计算两个tensor的矩阵乘法，注意其中的batch要相互对应，如果不考虑batch，就是另一个函数\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 简单的分析一下算法的逻辑\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 这是割裂出来batch的矩阵相乘形式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ebatch1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erandn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ebatch2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erandn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eout\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebmm\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebatch1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebatch2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u0026#39;output ans is\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003etorch.size([10,3,5])\u0026#39;\u0026#39;\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 按位相乘\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eres\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emul\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebatch1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ebatch2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eview和permute\u003c/strong\u003e的使用实际上都是不改变原值，要用赋值的方式去做，主要是使用方式要对，一个是按照顺序去做。\u003c/p\u003e\n\u003ch3 id=\"张量命名\"\u003e张量命名\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eNCHW\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"err\"\u003e‘\u003c/span\u003e\u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"err\"\u003e’\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"err\"\u003e‘\u003c/span\u003e\u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"err\"\u003e’\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"err\"\u003e‘\u003c/span\u003e\u003cspan class=\"n\"\u003eH\u003c/span\u003e\u003cspan class=\"err\"\u003e’\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"err\"\u003e‘\u003c/span\u003e\u003cspan class=\"n\"\u003eW\u003c/span\u003e\u003cspan class=\"err\"\u003e’\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eimages\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erandn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e56\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e56\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enames\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eNCHW\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eimages\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;C\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eimages\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eselect\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;C\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"类型转换\"\u003e类型转换\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# tensor 与 nd.array进行互换\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003endarray\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etensor\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enumpy\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003etensor\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efrom_numpy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003endarray\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efloat\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# tensor与PIL.IMAGE进行互换\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eimage\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorchvision\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etransforms\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efunctional\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eto_pil_image\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etensor\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003epath\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"sa\"\u003er\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;./figure.jpg\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003etensor\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorchvision\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etransforms\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efunctional\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eto_tensor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePIL\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eImage\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eopen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epath\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# np.ndarray 与 PIL.Image的互换\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eimage\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ePIL\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eImage\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromarray\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003end\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003earray\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eastype\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enp\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003euint8\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003endarray\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enp\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003easarray\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePIL\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eImage\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eopen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epath\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"维度堆叠\"\u003e维度堆叠\u003c/h3\u003e\n\u003cp\u003eStack，\u003cstrong\u003e普通的维度堆叠的测试代码如下\u003c/strong\u003e\u003c/p\u003e","title":"PyTorch Handbook 00 （Archive）"},{"content":"Loss :Why Zero Loss？ @Comments: ICML2020 《Do We Need Zero Training Loss After Achieving Zero Training Error》\n@Noteby：AikenHong2021\n如何解决训练损失下降，但是验证损失上升的问题（过拟合like）的问题，该文章实际上可以作为我们损失设计中的一个trick，只需要简单的一行代码，来提升代码的泛化能力；\n这张图体现了本文的灵魂（思路），主要体现在我们在算法趋于稳定后继续训练可能验证损失会反而上升；\n所以本文提出了一种flooding方法，当我们training loss 大于阈值的时候我们使其正常下降，当低于阈值的时候，flooding的设计会反过来使得梯度上升，让训练损失保持在flooding附近，让模型持续进行random walk，希望模型最终能优化到一个平坦的损失区域，这样发现test loss进一步的进行下降。\n理解：\n当我们的训练损失低到一定的程度，然后随着lr的下降，模型会很难跳出当前的极小值，这种情况下我们的泛化能力也会被限制住，采用这种方法在牺牲测试精度的同时能提升算法的泛化能力。\n损失公式表示如下\n$$ \\widetilde{J}(\\theta) = |J(\\theta) - b| +b\r$$\r具体的代码表示只需要添加一层：\n1 2 3 4 5 b = the flood num new_loss = (loss - b).abs() + b optimizer.zero_grad() new_loss.backward() optimizer.step() 损失中怎么设置b值\n摘自知乎回答，我觉得这种方式说好也好，说不好也不好，算是一种治标不治本的trick把，通过这种方式可以勉强缓解那种代码陷入极小值无法调整的情况，但是实际上算法原理并不是一个很solid的\n看了下评论，不少人关心b值应该如何设置，首先论文给出说法是b做为超参数需要在一定范围内遍历选优，对于b得取值范围文中也仅有一个限定是：b值要小于测试损失，这个范围显然太宽泛了。也有人说应该在Validation Error 开始上升的时候，设置b值在此附近，进行flooding，因为此处说明已经开始过拟合，避免在错误方向上渐行渐远。个人觉得有道理，但是在自己的本地任务上尝试下来发现，通常来说b值需要设置成比\u0026quot;Validation Error 开始上升\u0026quot;的值更小，1/2处甚至更小，结果更优；想下来原因应该是：Validation Error开始上升的原因不仅仅使说明过拟合情况的发生，还有可能是验证机和训练集不满足独立同分布（这种情况更见），当原因是后者时，往往需要沿着梯度下降方向继续学习，也是解释通了实际使用种为何b值要设置的更小。\n和参数正则化之间的差异在哪里。\n","permalink":"https://hugotest-phi.vercel.app/posts/loss-whyzero/","summary":"\u003ch1 id=\"loss-why-zero-loss\"\u003eLoss :Why Zero Loss？\u003c/h1\u003e\n\u003cp\u003e@Comments: ICML2020 《Do We Need Zero Training Loss After Achieving Zero Training Error》\u003c/p\u003e\n\u003cp\u003e@Noteby：AikenHong2021\u003c/p\u003e\n\u003cp\u003e如何解决训练损失下降，但是验证损失上升的问题（过拟合like）的问题，该文章实际上可以作为我们损失设计中的一个trick，只需要简单的一行代码，来提升代码的泛化能力；\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211026211602.png\"\u003e\r\n    \u003cimg alt=\"img\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211026211602.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211026211602.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"img\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e这张图体现了本文的灵魂（思路），主要体现在我们在算法趋于稳定后继续训练可能验证损失会反而上升；\u003c/p\u003e\n\u003cp\u003e所以本文提出了一种flooding方法，当我们training loss 大于阈值的时候我们使其正常下降，当低于阈值的时候，flooding的设计会反过来使得梯度上升，让训练损失保持在flooding附近，让模型持续进行random walk，希望模型最终能优化到一个平坦的损失区域，这样发现test loss进一步的进行下降。\u003c/p\u003e\n\u003cp\u003e理解：\u003c/p\u003e\n\u003cp\u003e当我们的训练损失低到一定的程度，然后随着lr的下降，模型会很难跳出当前的极小值，这种情况下我们的泛化能力也会被限制住，采用这种方法在牺牲测试精度的同时能提升算法的泛化能力。\u003c/p\u003e\n\u003cp\u003e损失公式表示如下\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\n\\widetilde{J}(\\theta) = |J(\\theta) - b| +b\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211027104636.jpg\"\u003e\r\n    \u003cimg alt=\"v2-084a8f00d7349a94540fc7ad3a9433b0_r\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211027104636.jpg\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211027104636.jpg\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"v2-084a8f00d7349a94540fc7ad3a9433b0_r\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Loss-WhyZero"},{"content":"记录各种排序操作，暂时不补充最基础的排序方式和理论，只记录排序算法的拓展应用。\n在理论分析的部分主要使用cpp进行撰写，而在具体使用的时候，目前会主要按照python来进行编写，这主要是面向的场景不同决定的。\n基础的排序理论，包括快排等等算法的分析在另一篇文章中记录（当初实习准备的时候有整理过，后续重新整理出来）\n排序算法和理论 placeholder\n排序算法应用 placeholder\n同步排序 常用于Machine Learning中，将数据集中的数据和标签进行同步排序，避免打乱其中的对应关系。\n使用numpy的 argsort功能来进行排序：\n1 2 3 idx = np.argsort(labels) labels = labels[idx] datas = datas[idx,...] 使用sort中的args: key来进行同步排序，选出一个作为依据, 但是这种方式不支持存在np的情况，因为np无法建立hash，除非我们转化成tuple再转回来。\n1 2 3 4 5 # 默认按照第0维度进行排序 lables, datas = [list(x) for x in zip(*sorted(zip(labels, datas)))] # 若要指定特定维度 from operator import itemgetter datas, labels = [list(x) for x in zip(*sorted(zip(datas, labels), key=itemgetter(1)))] 额外介绍我的愚蠢实现思路：\n用 $index/length$ 作为小数位添加到 $labelList$ 上 $SORT$ 排序列表，分离并复原Index 基于Index对列表进行排序赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def sort_dataset(dataset): # the num_new_class can be calculate by some formula, but in this part make it HARD # sort those data and label which make it easier to del class. num_data = len(dataset) up_limit = pow(10, len(str(num_data))) index = [index /up_limit for index in num_data] # using this mark to sort the data for i, _ in enumerate(dataset.targets): dataset.targets[i] += index[i] dataset.targets.sort() # get the new order new_order = [target - int(target) for target in dataset.targets] * up_limit dataset.targets = [int(target) for target in dataset.targets] # it\u0026#39;s necessary for us to swith to list or not? dataset.data = list(np.array(dataset.data)[new_order]) return None ","permalink":"https://hugotest-phi.vercel.app/posts/sorttrick/","summary":"\u003cp\u003e记录各种排序操作，暂时不补充最基础的排序方式和理论，只记录排序算法的拓展应用。\u003c/p\u003e\n\u003cp\u003e在理论分析的部分主要使用cpp进行撰写，而在具体使用的时候，目前会主要按照python来进行编写，这主要是面向的场景不同决定的。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e基础的排序理论，包括快排等等算法的分析在另一篇文章中记录（当初实习准备的时候有整理过，后续重新整理出来）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"排序算法和理论\"\u003e排序算法和理论\u003c/h2\u003e\n\u003cp\u003eplaceholder\u003c/p\u003e\n\u003ch2 id=\"排序算法应用\"\u003e排序算法应用\u003c/h2\u003e\n\u003cp\u003eplaceholder\u003c/p\u003e\n\u003ch3 id=\"同步排序\"\u003e同步排序\u003c/h3\u003e\n\u003cp\u003e常用于Machine Learning中，将数据集中的数据和标签进行同步排序，避免打乱其中的对应关系。\u003c/p\u003e\n\u003cp\u003e使用numpy的 \u003ccode\u003eargsort\u003c/code\u003e功能来进行排序：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eidx\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enp\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eargsort\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elabels\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003elabels\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003elabels\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eidx\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003edatas\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edatas\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eidx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c!-- more --\u003e\r\n\u003cp\u003e使用\u003ccode\u003esort\u003c/code\u003e中的\u003ccode\u003eargs: key\u003c/code\u003e来进行同步排序，选出一个作为依据, 但是这种方式不支持存在np的情况，因为np无法建立hash，除非我们转化成tuple再转回来。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 默认按照第0维度进行排序\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003elables\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edatas\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"nb\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003ezip\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nb\"\u003esorted\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003ezip\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elabels\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edatas\u003c/span\u003e\u003cspan class=\"p\"\u003e)))]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 若要指定特定维度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003eoperator\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003eitemgetter\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003edatas\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elabels\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"nb\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003ezip\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nb\"\u003esorted\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003ezip\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edatas\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elabels\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eitemgetter\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)))]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e额外介绍\u003cstrong\u003e我的愚蠢\u003c/strong\u003e实现思路：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用 $index/length$  作为小数位添加到 $labelList$ 上\u003c/li\u003e\n\u003cli\u003e$SORT$ 排序列表，分离并复原Index\u003c/li\u003e\n\u003cli\u003e基于Index对列表进行排序赋值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003esort_dataset\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# the num_new_class can be calculate by some formula, but in this part make it HARD\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# sort those data and label which make it easier to del class.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003enum_data\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eup_limit\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003epow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003estr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enum_data\u003c/span\u003e\u003cspan class=\"p\"\u003e)))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eindex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eindex\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003eup_limit\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003eindex\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003enum_data\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# using this mark to sort the data\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003e_\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003eenumerate\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etargets\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etargets\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etargets\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esort\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# get the new order \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003enew_order\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003etarget\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"nb\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etargets\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eup_limit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etargets\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"nb\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etargets\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# it\u0026#39;s necessary for us to swith to list or not?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enp\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003earray\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e)[\u003c/span\u003e\u003cspan class=\"n\"\u003enew_order\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"kc\"\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Algorithm Sort"},{"content":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r@aiken 2021 Framework\nAbstract Try To make structure universal，编写一个自己的通用的架构，框架化，满足通过不同的model文件和特殊配置文件就能实现不同的模型的一个架构。\n只是一个初步的框架集成，还有很多没有完善的地方，目前测试了ResNet18 跑Cifar10，没有什么问题，如果有什么可以改进的地方，或者你实现了一些Feature，*欢迎进行交流*！（私下联系我最好啦！）\n感谢帮助\n还有一些可以参数化或者可视化的地方，由于时间关系目前还没有修改，有兴趣的可以自己先添加一下\n暂时只集成了分类的模块，后续可能会随缘扩展\n本框架主要希望实现的是：易读性，可拓展性，以及简洁；\n希望将重要的，可变的参数都尽量的分离出来，通过配置文件和命令行参数去定义和运行我们的网络，在这种情况下实现一个较好的工作流程。\nFinal Project Design PURPOSE：新类发现和模型自主更新；同时希望能够解决长尾分布的数据情景；\n**ANALYSIS：**为了实现这种模型的自主更新过程，将整体的流程分成两个部分\n启动（start）： self supervissed 等方法无监督的学习特征提取网络（这种方式是否会对Unbalance产生增益）\n初始化预测模型： 基于Unbalance的数据训练一个基础的分类模型，在输出分类结果的同时需要输出对应的预测置信度，这两个其实都是一些简单的Trick，而最重要的是Backbone的分类效果需要得到保证，同时Backbone需要支撑后续的模型蒸馏更新。 模型的自主更新和迭代： Online：在线运行推断模型，通过置信度输出筛选出新类样本，将样本在样本池中收集 Offline：基于样本池的规模和评估触发离线更新：伪标签生成模型；模型蒸馏和更新 创新点：自主新类发现和学习\nUnbalance：\nStrategy Status Desc Two Stage Todo 可以作为一个Baseline策略 Causla Analysis Doing 基于TwoStage做出的偏差校正 Rebalance TBD 作为数据增强的辅助策略 置信度生成方法：\n置信度生成的方法可以从Active Learning等领域的文章中作为参考\nStrategy Status pros and cons Evidential Learning Doing pros：有坚实的数学基础；\ncons：增加模型复杂度和训练的难度 Least Confident Done pros：实现简单，不影响原有复杂度\ncons：原理上简单，不是特别靠谱 Entropy and\u0026hellip; TBD\n同上，可以随时取代测试 置信度准确率评估：\n使用下面的指标去做置信度输出的准确率评估\n$$ ac = NumNew/NumLowconfi\r$$\r$$ recall = NumOld/NumLowconfi\r$$\r伪标签生成模型：\n在进行新的模型训练，之前，要将数据集混合现有的已知数据，生成的方式主要可以分成两种，网络或者聚类\n聚类：通过现有类别的聚类结果，还能判断聚类的质量 网络：切分Mini-Batch进行Meta-Like的Training，训练FSL或者Unsupervised的模型，输出伪标签预测（一致性原则） 基本思想：\n当特征以通用表征的无监督预训练进行，这种情况下不存在对应的数据瓶颈，因为我们不需要标记，我们可以将Backbone得到一个泛化性极强的高级特征，那么在这种情况下LT和FC带来的泛化性问题将集中在Classifier中，对Classifer进行校准和调整就是我们的主要方向，这样就能将问题归化到蒸馏和FC的训练一个Linear的问题 所以处理Unbalance的分类器和特征迁移方式是我们后续work的方向，可以从复杂度高的网络训练一个高级表征的分类器，或者通过Graph和Cluster的构建，来实现一个更为依赖Backbone的一种方式。 创新点：\n（Augmentation）在做伪标签生成之前，我们基于原本特征特征提取器，组合数据特征，数据混合和增强方法作为后续的数据基础 （Loss-Design）通过混合的数据集中的伪标签生成，和标签的双指标，定义损失，去更新原有的特征提取架构同时赋予新类伪标签。这是由于我们知道部分数据集的真实标签，我们就可以通过这一部分的信息去做一个对应的标准。 这样就可以通过生成的伪标签对原特征提取器进行一定的更新，这种更新应该是交替进行的，因为我们不知道哪个Coder是更为可靠的一个label generator。（除非我们使用的是有终点的聚类） 模型更新：\n参考蒸馏学习的思想，使用原有网络和pseudo generator作为Teacher 进行模型的更新，Duplicate Feature Extractor，Modify FC（num_class），考虑使用双重循环去freeze，利用不同的lr training网络的两部分。\n在这里参考其他蒸馏学习的方法，去设计这种Teacher给予Label或者Parms的机制\n考虑基于prototype的方法，是否会和聚类的方法更加的匹配，但是prototype\n的方法和我们之前设想的实验过程应该是一个区分度比较大的情况\n创新点：\n（Framework）double teacher to generate a new siamese model which train in two diff phase for feature extractor and classifier 使用孪生的机制，在两个不同的阶段来训练特征提取器和分类器，在这里我们将训练的重心转化到Projector以及Cluster，Model上 设计思路\n在模型的整体架构上还是会和awb师弟的有很多类似的地方，后续可以详细进行探讨和借鉴。\nDevLog 开发中的一些疑问和细节会放在这个地方，包括开发的RoadMap，实现中遇到的问题，FrameWork设计中的主要矛盾和问题。\n下面是一些基本的实验内容：首先将流程跑通，在设计对应的消融实验。\nFull-Data 的模型基准实验 BackBone测试 数据集 进度 结果 resnet-18 cifar10 完成（配置文件已保存） 93% cifar100 完成（配置文件已保存） 77% ImageNet conclusion 过拟合in cifar100 Efficient Net b0 cifar10 完成（非最佳）（配置文件已保存） 90% cifar100 完成（非最佳）（配置文件已保存） 73% ImageNet conclusion 过拟合in cifar Swin Transformer 实际上在训练集和测试集中，resnet18 和 efficient net呈现的都是一种训练集远高于数据集的过拟合like的情况，我认为这种情况与问题规模简单，等诸多原因导致，为了改善这种情况，我们可以考虑\n使用更多数据增强来使得问题更为复杂 使用特征学习无监督与训练的方法，同样通过数据增强来加大问题规模 增加数据，使用大规模数据集对模型进行与训练，但是也要考虑到数据的规模和模型的capability Cifar10-100的模型调优过程 后续可以考虑加入MAE的方式，实际上这种方式就是代替了EnAET中的多种复杂数据增强，还是从数据增强的角度入手对模型进行处理实现的一种自监督的机制，这种自监督的策略来学习一种图像上的通用表征，保持在识别问题上，整体的有效性。\nResNet 在对cifar10-100的图像进行分类的时候需要修改初始的入口层，因为cifar数据集中的图像太小，如果一开始使用7*7的卷积层，在精度上会损失很多特征信息。\n可以将7*7 2的卷积改成3*3 1,然后去掉maxpooling层 亦可以将图像resize到224*224 前者在cifar10中最终测试可得接近93%的准确率，在cifar100中最终测试可以取得稳定77%的准确率\n此外，对图像进行randomcrop的过程中，由于原图本来就只有32*32所以我们希望crop到32的时候，我们最好是先进行padding，不然该增强是一个无效的增强。\nEfficient Net 和对ResNet进行调整的时候一样，训练集太过简单，所以过快的收敛，影响了模型的泛化能力，这里考虑可能是dropout没有设置好，或者是任务过于简单，我们可以对其设置一些图像的增强等等的操作来对对训练过程进行调整，可以将一部分需要较多io的任务存放在本地，然后在线进行一些random transformer。\n在这里不需要对模型进行修改，只需要调整学习的参数即可。\nSwin Transformer 在new class - LT 的数据环境中的基准实验： 首先测试LT和NC的数据策略是否能进行正常的数据训练，确保数据抽取策略\n后续为了可复现和效果对比，我们在类别抽取的时候取消随机性（使用固定的随机种子），抽取固定的类别作为新类，对比未进行长尾采样以及采样之后的效果。\nmodel 数据集以及预处理 进度 LT结果 NC结果 Combine TAG \u0026hellip; cifar10， cifar100\n分别测试LT和NC的策略 Done :heavy_check_mark: :heavy_check_mark: \\ varify resnet cifar100 NC：20 LT：0.5(step) Done \\ 75%-.5 \\ try pre-cifar100 NC20 LT0.5(STEP) Done 63% 75%-.5 63%- 0.5 basic 下面开始矫正 问题更大的实际上是LT部分 resnet-CA resnet-ReBalance resnet-MAR-iBOT Efficient Net Swin Transformer 实验结果一：置信度问题 使用Cifar100置信度划分的过程中，发现对新类的筛选效果并不好，我们考虑，这可能是由于超类和子类之间的关系造成的，为此，在初步的研究阶段，我们决定，拆分出特定的超类来作为新类，避免对于新类识别的干扰；\n后续的研究中可以考虑像安文斌的方式去做纵向的新类发现，现阶段首先考虑横向的新类发现问题，在这里可以参考安文斌师弟的两个研究 实际上新类的拆分要求的是precision，相对的recall在当前的问题上并不是很重要，所以对该算法的改进不是很迫切，但是相应的，我们需要完善recall和Precision的输出用来作为我们后续进行判断的依据\n拆分特定新类的情况下，置信度结果并没有明显的改进，说明问题更多的出自模型的特征提取和分类本身，用于分类的特征没有将类别之间的差异性体现出来，所以后续在这一方面的训练应该进行改进，改进思路如下：\n修改Loss：使用Contrastive Learning的训练策略，在分类准确率之上结合NLL对比损失，在这一部分可以结合人脸比对的相应损失进行设计\n实际上我们可以用MAE训练一个通用的预训练表征，Backbone，然后使用Contrastive训练Classifier，两种不同的策略的侧重点实际上是不一样的。那么如何结合这两种训练方式，或者将其中的一种训练和分类的训练相互结合起来，使得我们的训练步骤不会如此的冗余。\nContrastive Learn的预训练方式：得到一个类别之间更为分明的Backbone or MLP？\nMAE的预训练方式，得到一个通用的表征？\n实验结果二：LT问题 准确率下降到63%（下降了10%左右），过拟合问题愈发严重，需要更多的去分析这种下降出现的原因。\nDistill部分网络结构设计 为了使得能够进行代码复用，不做重复的造轮子，在对蒸馏部分网络进行设计的时候遇到了一些问题，以下是问题和解决方式，假如这些方式不能很好的解决对应的问题，我们就duplicate代码并重新编写Train_ditill 的设计\n这一部分其实设计的是整个框架中的数据流程，要注意在每个不同的阶段我们使用的数据是不同的。如何更有效的利用这个数据，是框架设计中的关键部分。\n损失部分对输入的要求不同 面临问题：\n需要额外的模型输出作为Loss的计算依据 损失函数的输入维度不统一 暂定解决方案，\n（Both）使用额外的args参数对损失计算的部分进行分支处理 伪标签的处理 具体问题：\n在什么阶段将标签转化为对应的伪标签 如何和真实标签进行一个对照分析，如何保存并实现验证和真实环境的匹配度 暂定解决方案：\n再labelGe中仿照人类标注，按照绝大多数类别的真是标签来确定伪标签，然后再初始化蒸馏训练中，将训练集中的数据替换为伪标签，而test数据集中仍然是真实标签，就解决了验证的问题和伪标签和真实标签之前缺乏一次映射的问题。\nRoadMap 开发路线图部分，主要分为基本的模块，和不同的训练方式两个阶段，用来集成完整的Framework.\nDeadline Settting 具体时间节点，主要是为了给自己明确当前的任务，后续可能会继续细化，时间上也会随着实验的顺利与否进行调整。\nTask Desc 部分功能重写 config，dataloader（read data and load in GPU）\nby define collate_fn function 完成 数据处理 几个部分的数据还有整体的数据：New（FS divide into phase？）-Old（LT）-Cloud（无关数据） 完成 调整运行Swin 交织在多个任务中并行，时不时的调整参数测试一下 待定 长尾模块功能实现 在cifar数据集上用resnet先进行实验和swin的实验并行\n实现对长尾的优化 进行 小样本模型和聚类模型嵌入 1. 确定数据混合策略\n2. EnAet中训练的策略集成到该函数中\n3 确定标签的输出和参与的形式 进行 蒸馏架构实现 架构编写，实现蒸馏框架的嵌入\n测试双模型之间的蒸馏的结果 完成 模型实验和测试 Data 数据集收集和初始数据的采样处理：\n分析一下数据的使用场景：\n首先我们使用Unbalance的数据进行初始模型的构建，然后我们需要在训练的过程中加入小样本的新类别。\n可以额外的构建小样本的数据集来训练小样本模型，但这不在我们的Workflow里，不作为我们的主题框架中的代码。\nFunction Stage Desc New Class（Larget version） done like mini-imagenet，mv some cls to other dir Unbalance done sampling data in differ rate Mix data done mix old knowledge and the new data，the point:\nwhether we want to use meta-learning or pnot Few Shot done testing the model only have few data 所以数据准备工作应该分为两步：\n（Script）数据集预处理，将一部分类别抽离出去，建立新的文件夹，但是对于Cifar这种数据集好像都是一次性载入的，思考一下怎么写成对应的函数进行处理。\n（Load）初始数据的Unbalance处理，通过不同的采样策略使得数据不均衡\n此外，我们在进行新类训练的时候会将旧数据和新数据进行混合，我们需要设计对应的数据混合策略，进行小样本模型的训练和聚类的训练\nModel Functional Part Stage KeyWord/Method Basic Training abjust ImageNet1k Using ImageNet to Pretrain or Self-Training Backbone todo Swin（abjust params and train on ImageNet）\nLT and Confidence done two-stage\nrebalance\ncausal analysis FSL doing Self-Supervise\nCluster Cluster todo New-Descover\nK-Means\nSelf-Supervised + linear Framework Training Process Stage KeyWord/Method Meta Training TBD / Multi-Stage Training Intergrate with Framwork / Distill Training done Incremental learning, Unsupervised todo MAE Clustering doing Projector-Head + Kmeans Swin-T 问题描述：在cifar10，或者ImageNet数据集上训练的时候，损失曲线过早收敛，识别准确率很低；\n问题分析：\nLR 过高，没有办法学到好的解 框架中学习率设置的问题，同理可以分析其他的和config中的冲突\n数据集标签的问题\n模型定义的问题\n损失函数设计，模型的体量问题\n解决方法拟定：\n直接使用官方的模型和官方的数据集进行训练后比对 加载并编写论文中提到的各种trick 对比官方的模型和自己编写的模型之间的差异 Dataset 这一部分描写使用到的dataset的具体参数，主要至少包含一下的一些信息\nName Class EachNum Resolution Useage Cifar10 10 5000+1000 32*32 Cls LT Cifar100 100 500+100 32*32 Cls NC LT TinyImageNet 200 500+50+50 64*64 Cls NC LT MiniImageNet 100 500+100 86*86 Cls NC LT ImageNet-1k 1000 700-1300 resize to (256*256)\navg:469*387 PreTrain If Need List the dataset here :\nTiny-ImageNet-200 | Tiny-ImageNet-Plus Reference Confidental\n主动学习(Active learning)算法的原理 ResNet\nPytorch.org 、官方实现解读 、ResNet详解与分析 、Pytorch手工实现 Mini ImageNet\n用Mini-ImageNet训练分类网络 Swin Transformer\n","permalink":"https://hugotest-phi.vercel.app/posts/uniframework/","summary":"\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"aikenhong_blog\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003cp\u003e@aiken 2021  Framework\u003c/p\u003e\n\u003ch2 id=\"abstract\"\u003eAbstract\u003c/h2\u003e\n\u003cp\u003eTry To make structure universal，编写一个自己的通用的架构，框架化，满足通过不同的model文件和特殊配置文件就能实现不同的模型的一个架构。\u003c/p\u003e\n\u003cp\u003e只是一个初步的框架集成，还有很多没有完善的地方，目前测试了ResNet18 跑Cifar10，没有什么问题，如果有什么可以改进的地方，或者你实现了一些Feature，\u003cem\u003e\u003cstrong\u003e*欢迎进行交流*\u003c/strong\u003e\u003c/em\u003e！（私下联系我最好啦！）\u003c/p\u003e\n\u003cp\u003e感谢帮助\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e还有一些可以参数化或者可视化的地方，由于时间关系目前还没有修改，有兴趣的可以自己先添加一下\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e暂时只集成了分类的模块，后续可能会随缘扩展\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e本框架主要希望实现的是：易读性，可拓展性，以及简洁；\u003c/p\u003e\n\u003cp\u003e希望将重要的，可变的参数都尽量的分离出来，通过配置文件和命令行参数去定义和运行我们的网络，在这种情况下实现一个较好的工作流程。\u003c/p\u003e\n\u003ch2 id=\"final-project-design\"\u003eFinal Project Design\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003ePURPOSE：新类发现和模型自主更新\u003c/strong\u003e；同时希望能够解决\u003cstrong\u003e长尾分布\u003c/strong\u003e的数据情景；\u003c/p\u003e\n\u003cp\u003e**ANALYSIS：**为了实现这种模型的自主更新过程，将整体的流程分成两个部分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e启动（start）：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003eself supervissed 等方法无监督的学习特征提取网络（这种方式是否会对Unbalance产生增益）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e初始化预测模型：\u003c/strong\u003e\n基于\u003cstrong\u003eUnbalance\u003c/strong\u003e的数据训练一个基础的分类模型，在输出分类结果的同时需要输出对应的预测\u003cstrong\u003e置信度\u003c/strong\u003e，这两个其实都是一些简单的Trick，而最重要的是Backbone的分类效果需要得到保证，同时\u003cstrong\u003eBackbone需要支撑后续的模型蒸馏\u003c/strong\u003e更新。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210921164616.png\"\u003e\r\n    \u003cimg alt=\"image-20210921164615348\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210921164616.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210921164616.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210921164615348\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e模型的自主更新和迭代：\u003c/strong\u003e\nOnline：在线运行推断模型，通过\u003cstrong\u003e置信度输出筛选\u003c/strong\u003e出新类样本，将样本在\u003cstrong\u003e样本池\u003c/strong\u003e中收集\nOffline：基于样本池的规模和评估触发离线更新：\u003cstrong\u003e伪标签生成模型\u003c/strong\u003e；\u003cstrong\u003e模型蒸馏和更新\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e创新点：自主新类发现和学习\u003c/p\u003e","title":"UniFramework 01"},{"content":"@AikenHong 2021 @Code: Scipy（repo） @Reference: 匈牙利算法\u0026amp;KM算法 该篇笔记用来介绍匈牙利算法和KM算法(Kuhn-Munkres Algorithm)，这两个算法通常用来做目标之间的匹配问题。 常用于：多目标跟踪，和深度聚类中的标签匹配问题。\nMethod 这两种方法实际上解决的问题都是： 二分图的最大匹配问题； 首先需要对二分图有个基本的了解：\n实际上就是将数据分为两组，各组的每一个点都去另一个组找对应的匹配，我们希望将两组中，相关的数据尽可能的准确的匹配起来。\n可以想象成，是同一个数据在不同的映射下的不同表征需要做这样的匹配关系。\n解决这种问题的方式就是使用匈牙利算法或者KM算法\n匈牙利算法 匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法\n匈牙利算法可以将二分图中的连线，看成是我们认为可能是相同的目标（不带权值），实际上就是从上到下假想成立，然后进行唯一匹配的搜索，有点像BackTrack的过程。\n整体算法的成功率或者准确率实际上十分依赖与连线的准确率，对算法输出预测的准确度要求更高。\nKM KM解决的是带权的二分图的最优匹配的问题。\n相当于我们给每条线都给出一个置信度预测值，基于这样的权值图去计算对应的匹配关系\nStep1: 将左边节点标上与他所关联的最大权值的边的数值 Step2: 寻找匹配，原则如下\n只有权重和左边分数相同的边才进行匹配； 如果找不到边，此条路径的所有左边顶点-d，右侧+d，这里我们将d取值为0.1 对于考虑换边的另一个节点，如果无法换边，也需要对应的进行-d 具体的例子可以这么看（最好还是看blog）： Code 使用scipy中的集成版本实现，但是要注意对应的输入是二分图的cost_matrix\n算法的实现应该是将最大的权值转换成了最大代价来进行计算的，所以为了使用KM算法，我们首先应该构造对应的损失矩阵。\n假如我们使用相似度指标计算的话，对应的大小关系应该做一个反转，可以直接用负号进行计算，计算完相似度直接取一个负值进行计算。\n1 2 from scipy.optimize import linear_sum_assignment row_ind, ol_ind = linear_sum_assignment(cost_matrix, maximize) ","permalink":"https://hugotest-phi.vercel.app/posts/hungarian/","summary":"\u003cp\u003e@AikenHong 2021\n@Code: \u003cstrong\u003eScipy\u003c/strong\u003e（repo）\n@Reference:  \u003ca href=\"https://zhuanlan.zhihu.com/p/62981901\" target=\"_blank\" rel=\"noopener\"\u003e匈牙利算法\u0026amp;KM算法\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e该篇笔记用来介绍匈牙利算法和KM算法(Kuhn-Munkres Algorithm)，这两个算法通常用来做目标之间的匹配问题。\n常用于：多目标跟踪，和深度聚类中的标签匹配问题。\u003c/p\u003e\n\u003ch2 id=\"method\"\u003eMethod\u003c/h2\u003e\n\u003cp\u003e这两种方法实际上解决的问题都是： 二分图的最大匹配问题；\n首先需要对二分图有个基本的了解：\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211202164156.png\"\u003e\r\n    \u003cimg alt=\"二分图\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211202164156.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/20211202164156.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"二分图\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e实际上就是将数据分为两组，各组的每一个点都去另一个组找对应的匹配，我们希望将两组中，相关的数据尽可能的准确的匹配起来。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e可以想象成，是同一个数据在不同的映射下的不同表征需要做这样的匹配关系。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e解决这种问题的方式就是使用匈牙利算法或者KM算法\u003c/p\u003e\n\u003ch3 id=\"匈牙利算法\"\u003e匈牙利算法\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e匈牙利算法可以将二分图中的连线，看成是我们认为可能是相同的目标（不带权值），实际上就是从上到下假想成立，然后进行唯一匹配的搜索，有点像BackTrack的过程。\u003c/p\u003e\n\u003cp\u003e整体算法的成功率或者准确率实际上十分依赖与连线的准确率，对算法输出预测的准确度要求更高。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch3 id=\"km\"\u003eKM\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eKM解决的是带权的二分图的最优匹配的问题。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e相当于我们给每条线都给出一个置信度预测值，基于这样的权值图去计算对应的匹配关系\u003c/p\u003e\n\u003cp\u003eStep1: 将左边节点标上与他所关联的最大权值的边的数值\nStep2: 寻找匹配，原则如下\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e只有权重和左边分数相同的边才进行匹配；\u003c/li\u003e\n\u003cli\u003e如果找不到边，此条路径的所有左边顶点-d，右侧+d，这里我们将d取值为0.1\u003c/li\u003e\n\u003cli\u003e对于考虑换边的另一个节点，如果无法换边，也需要对应的进行-d\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e具体的例子可以这么看（最好还是看blog）：\n\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/cf20ef3a1fa97ecf3dc0e4c620f61b8.jpg\"\u003e\r\n    \u003cimg loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/cf20ef3a1fa97ecf3dc0e4c620f61b8.jpg\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/cf20ef3a1fa97ecf3dc0e4c620f61b8.jpg\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Hungarian"},{"content":"this notebook is based on Cherno‘s Video Class in YouTube ；if there is sth get confused，I can recheck the video which talk about it, or just google it.\nthis is not totally for newbie, so some basic information we should search it And this is a important websize to tell us basic info about C++. ToDo:\nusing c++ and Python to finish the leetcode. review data structure when we code. eorganize the notebook by onenote** and leetcode 后续可能会添加 Effetive C++中的相关内容 C++ Switch语句 Attention：\n为了防止一些遗漏，或者搜索上的困难，虽然我们会尽量避免内容的overlap，但是如果和两者都特别相关的话，可能会在两个地方出现完全一致的内容。 后续补充：如果是confused的内容（不确信的话）就加入:question: 或者 still in puzzle: 内容的格式添加把 Typora常用快捷键 Introduction About C++ C++是一种强类型的语言，也就是我们需要实现指定数据的类型，同时我们没法随意的改变类型或者混杂类型把。（其实也是可以的就是需要执行特定的代码，相对而言没有那么方便而已。）\n有疑惑就去查cppreference，永远的神；此外当我们对某个不知道什么时候用的时候就google xxx when why how.\nPart 1 编译器基本工作原理 Visual Studio中C++的compiler，linker的基本工作原理；以及在Visual Studio中一些相关工作环境的设置，比如输入输出配置，debugging环境之类的；此外建议使用VsCode的键盘映射，对于自己来说比较熟悉）；同时也会介绍一些和编译器原理相关的预处理模块；以及Library\n基本信息 STD：standard library C++中的标准库，包含了一些最基础的标准操作，包括cin; cout;``\u0026lt;cmath\u0026gt; #:hash tag（预处理符号）+预处理语句（基本的就是include，define之类的） = 预处理器\nBuild ：Compiler + linker的基本原理 编译和连接的规则：\n原则1：.Cpp都会被编译，但是.h不会被编译，他是以#后接的指定模式(include被嵌入(copy)到指定的.Cpp中的指定位置再进行编译。（下面是一些预处理指令）\ninclude：直接复制粘贴到**指定的位置，**所以你也可以定义}之类的进入h。\ndefine：搜索并替换\n可以用做简单的函数定义\n也可以使用成定义pi的值之类的，指定一个名称\n#if 0/1 … #endif:中间的内容将根据if后的true or false 来决定是否存在。（是否编译）\n上述的三种操作都是文本级别的操作，也就是针对编码文本进行处理后再送入编译器进行编译的。\n**原则2：**每个cpp都会被编译成.obj文件然后由Linker，将这些obj连接起来成为一个.exe\nTHIS IS IMPORTANT：如果我们想要将功能和主体main（entrypoint）分离开来，除了用header的方式，我们也可以写在另外的.cpp中，然后再主要文件中进行declaration（定义函数名和指定的传入参数即可），也就是声明该函数是存在的，而不用具体定义（具体定义在另外的cpp中），这样在build的过程中，linker就会在我们的工程项目文件夹中搜索其他cpp中的指定function（we just declaration in the main cpp）。这样也能成功的编译。\n所以如果我们一个函数在多个cpp中定义（多重定义），或者由于header中的include h，这样可能会导致compile的时候出现代码（链接？）混淆的问题（bug），再不济也是个冗余的编译操作。\n如果需要多次使用.h文件，我们可以将其中的函数定义成static的方式，这样在每个cpp中都会有自己版本的.h中的函数，就不会有重复编写导致模棱两可的问题了。\ninline前缀也能解决同样的问题：内联函数\ninline：内联标识符适用于结构简单的小型函数。\n增加了 inline 关键字的函数称为“内联函数”。内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。\n所以在这里我们推荐在header中只实现Declaration，而具体的Definition就只在某一个cpp中进行编写。\n**机器码：**Visual Studio中可以将输出的obj之类的，包括代码中转化成汇编代码去看，就能知道我器的实际运行逻辑，在VisualStudio中我们也可以设置针对汇编的自动优化来提升算法的运行速度。（一般是在release中会自动优化，而Debug中便于定位问题就没有优化）\nDebug标识符： C：Compile Error；LINK：Linker Error\nStatic标识符：在变量的部分细讲，实际上对于编译过程也是一个很重要的关键词\nBuild： 头文件（Header Files） 一般在header 中写入declaration，然后把definition写在Cpp files里面。\n#Include 命令 \u0026quot;\u0026quot; 或 \u0026lt;\u0026gt;\n\u0026ldquo;[content]\u0026rdquo; : content是文件的相对路径，可以使用类似..去索引 \u0026lt;\u0026gt;:一般用来索引标准库之类的，用\u0026quot;\u0026ldquo;来存储.h之类的文件 有.h后缀的导入一般是C，Cpp的就没有后缀 #Pragma once 这个hash tag的作用是让预处理仅仅只编译头文件一次，就是多次import也不会重复编译把，这个东西不要删除它。\n原理上是取代了原本的ifnder；实际上也是一个宏\n1 2 3 #ifndef Tag1_H void functionA(int var1); #endif **基本概念：**使用通用的header文件，将一些include放入header中，然后对这些header进行预编译，生成二进制文件。这样的话，\n我们就不需要每个cpp中的#include .h 都对其中的所有的include在进行copy paste然后进行编译，这样的话，加入了很多不必要的编译过程。 也不用每次修改代码进行编译测试的时候，都有繁重的编译工作要去做了。 使用情景：\n在大型工程或者文件的时候使用头文件的预编译器是非常重要的。用它 对于一些通用的常用的操作或者文件可以放进去，但是频繁更改的那些内容就不要放进去了，每次进行重新的预编译是浪费时间的 。 主要是一些include，declaration就别放在这了把？ 预编译的header可以对project中的所有cpp负责吗？还是需要include 但是那些特定的依赖项，对于专门操作或者环境的，我们还是放到特定的cpp中，这样会使得代码更加易读，也不会增加负担。实际上就是两方面的考量，特定的和通用的两种处理方式。实际上取决于依赖程度； Visual Studio中的使用方法\n创建需要预编译的头文件pch.h;创建pch.cpp 包含#include \u0026quot;pch.h\u0026quot; 右键pch.cpp属性：c/c++ -\u0026gt;预编译头-\u0026gt;预编译头（使用） 右键项目属性： c/c++ -\u0026gt;预编译头-\u0026gt;预编译头（使用/create） c/c++ -\u0026gt;预编译头-\u0026gt;预编译头文件（pch.h） 试一下把，不对的话，再回来检查视频。（可以在vscode的设置里，project c++中设置编译时间输出） Build：代码存储的文件结构 补充说明：VS侧栏的文件夹实际上只是分组，不是真实文件夹，所以我们在哪创建h和cpp都一样\nRule1: 推荐在header中只实现Declaration，而具体的Definition就只在某一个cpp中进行编写。\n**Relu2：**在大型或者规范的Project中建议修改Vscode 的文件保存设置，当然我们也可以根据自己的需求去修改。\n输出目录： $(SolutionDir)bin$ (Platform)$(Configuration)\\\n中间目录： $(SolutionDir)bin\\intermediate$ (Platform)$(Configuration)\\\nBuild: 宏（Macros） #define的各种用法；实际上就是通过预处理器对某些操作进行宏处理，“我不喜欢过度使用宏，这样可能比较不方便阅读”这点上其实和template是一样的道理。\n#define : 实际上就是在代码中搜索指定的文本进行替换\n是一种文本级别的操作\n推荐的使用方法：\n约定俗称的名称或者表达，或者一些简单的函数（但是实际上为了便于阅读，并不是太推荐，见仁见智把）\n#define pi=3.14159265:类似的一种约定俗称的value\n#define LOG(x) std::cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;std::endl;\nDebug：条件与动作断点 基本操作：\n设置breakpoint 内存信息读取：从debug-windows中可以调出各种窗口，从变量名或者\u0026amp;para找到内存地址也可以 条件与动作断点：\n当然我们可以在代码中嵌入循环来使用普通断点来实现这些，简单的就是在断点的地方使用右键。主要的优势在于，我们无需暂停我们正在运行的程序，就可以执行这样的Break.\nConditional：条件断点就不说了。\nAction：就是不需要stop我们的运行，我们添加了以后，就能在执行我们断点的操作的时候，在terminal输出，我们设置的action（简单的来说就是用于监控运行过程中的参数变化）\nLib： Using Libraries 外部依赖的使用 Static Linking and Dynamic Linking静态与动态链接库\n基本思想：希望在C++中不需要进行Package Manage 也就是不需要自己再去一个个的下载依赖项，也就是希望能pull下来就能用。\n以GLFW为例，我们下载的时候可以下载2进制文件也可以下载源代码；下载的时候是x86还是x64与编写的目标代码有关，和OS无关。\n动态静态连接的基本概念 静态链接在编译的时候实现，而动态链接是在运行的时候才操作；\n静态链接，意味着这个库直接放到可执行文件中（比如说exe）\n静态链接在一些情况下会更快，而且我们可以进行各种优化，所以这个作者比较喜欢静态优化。 静态链接可以实现更多的优化操作，实际上是你exe中的一部分 动态链接，在运行的时候加载DLL（动态链接库）之类的。\n询问dll载入调用到的函数，静态lib就是一次性把所有的都载入了\n它实现在运行过程中，linking一个外部文件，而不是可执行文件的一部分。\n当然也可以在你启动电脑的时候就启动，也可以设置为require，就是没链接就会完全报错。\n静态和动态连接的具体实现 **静态链接的具体实现：**Head File，Include file的形式\n创建dependency文件夹然后-\u0026gt;libraries子文件夹(归属关系)\nCopy include 和相关vs版本的lib文件夹进去\n如果我们使用静态链接就和lib有关，如果我们使用动态链接就和DLL有关。 在VS 设置中c++ general +额外包含文件夹+相对文件夹（${SolutionDir} -\u0026gt;include文件夹）的路径\n如果需要我们也能在这看到其他的指代路径的意思 然后include\u0026lt;GLFW/…h\u0026gt; (其实使用双引号也没问题)\n这个头文件实际上支持动态链接和静态链接（include中的） 这里提供了declaration，但是没有实际的definition，所以我们还需要 VS设置Linker/general/ Addition Libraries设置相对路径(Lib-vsxxx)和刚刚类似\nVS设置Linker/Input/Additional Dependencies设置具体lib文件的地址\nOver\n第二种静态链接的方法(不推荐) 在前面的库设置好了以后，我们也可以不include，但是我们要声明（declaration）这个函数存在，注意类型不能错（这就好麻烦）\n需要注意的是，我们链接的有的函数实际上是c而不是c++，这种时候就要添加前缀：\nExtern \u0026ldquo;C\u0026rdquo;\n动态链接的具体实现：基于静态的实现来分析\ndll和dll.liB需要同时使用，lib提供了一堆指向dll文件中函数的指针，两者直接相关。\n也就是相对于静态链接改变dependency中lib文件为dll.lib 然后要把dll放在我们需要运行的exe的同一个文件夹下。 Lib：Multiple Project 编写自己的Lib或Dll 在解决方案Title下可以添加项目，一个解决方案下多个project\n将主project的属性中配置类型设置为exe\n将依赖文件设置为lib 或者dll，所有的配置和平台\n同样的在h中下写declaration在cpp中definition，然后在include的时候，由于路径不在一个文件夹下，所以我们可以用相对路径的方式设置，但是这样就比较傻，正确的做法：👇\n属性，c++通用，额外的包含目录，把该目录放进去就行了\n但是这样其实我们没link，所以我们可以通过再主项目中右键添加引用，把我们要的引用添加进去，就可以了。（当然我们也可以生成lib再用）\n但是这种情况好像只适用于同一个项目文件夹的时候。 这种自动处理同时会自动执行engineer的build\n在这里使用了namespace的写法，也许就是和类中的函数是特别像的把，也就是std那样的双冒号\nLib：Timing 计时器 C++中的计时器功能：主要用于统计程序运行时间和控制进程等等的操作。\n具体还有timer的cast还有一些单位转化的工作，去cpp中查找或者看benchmark那课的视频\n主要使用的库：#include\u0026lt;chrono\u0026gt;\n1 2 3 4 5 6 // 还有一个暂时不知道起什么作用的namespace using namespace std::literals::chrono_literals; // 获取当前的时间 auto start = std::chrono::high_resolution_clock::now(); // 获取时间间隔的方式，这里的type比较特别 std::chrono::duration\u0026lt;float\u0026gt; duration = end - start; 上面这个方式,如果每次都要调用的话，就写得比较麻烦，如果我们希望能够比较简单的得到比如某个function运行的时间，我们可以利用lifetime签署一个类别，在function开始的时候定义一个就可以了。\n看下面的实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct Timer { std::chrono::time_point\u0026lt;std::chrono::steady_clock\u0026gt; start, end; std::chrono::duration\u0026lt;float\u0026gt; duration; Timer() { start = std::chrono::high_resolution_clock::now(); } ~Timer() { end = std::chrono::high_resolution_clock::now(); duration = end -start; // std::endl 实际上比较慢 std::cout\u0026lt;\u0026lt;\u0026#34;timer took\u0026#34;\u0026lt;\u0026lt; duration \u0026lt;\u0026lt;\u0026#34;s\\n\u0026#34; } } Lib：Sort排序iterator std::sort need to include\u0026lt;algorithm\u0026gt; ；这是c++标准库中一个对Iterator进行排序的库。\n复杂度 O(N·log(N))，其中N=std::distance(first,last)\n参考网站：https://zh.cppreference.com/w/cpp/algorithm/sort\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //简单实例 #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;functional\u0026gt; //其中有一些分类的标准可以调用 int main(){ std::verctor\u0026lt;int\u0026gt; values = {1,3,4,5,2,6} std::sort(values.bagin(),values.end()); //空载或者\u0026lt;,\u0026gt;是基本的用法 //如果我们试图自定义函数的话 std::sort(values.bagin(),values.end(),[](int a, int b){ if (a==1) return False; //1放到其他所有的后面 if (b==1) return true; // 同上 return a\u0026lt;b //升序 }) } Part 2 “变量”的使用和定义 In this section we‘ll introduce variables（data structure） in C++，主要是变量的声明和使用方式和用途，生存周期，存储空间，各种Keyword，类型转换。\n变量（Variables） As we know all datatype in machine is different number 实际上就是给机器指定存储的空间和解析的类型。\nChar 实际上只是内联了“数字到字符的转换”，所以我们可以用各种类型来输入字符或数字（主要是内存空间占用），但是最后表达的类型会根据我们预定义的类型相关，有内联的数字和字符的转换存在。 基本的数据类型 实际上就是预先定义了内存的分配了表达的类型，大小实际上取决于编译器。\n可以用sizeof()查看各种类型占用的内存空间大小\nKeyword：\n整型：\n​\tchar（1 byte）；shot；int（4 byte）；Long；Long long（8 btyte）\n​\tunsigned\n非整型：\n​\tFloat（4 byte）；double（8 byte）\n​\t实际上是精度类型，比如再数据后面+f指定精度类型\nBOOL：\n​\tbool （true， false == 0）；!0 即True\nVoid：\n​\t类型未指定\n特殊类型\n指针类型（Pointers）：再类型后面+ *: int* variables 引用类型和取值符号（reference）： 引用： 在类型后面+\u0026amp;:int\u0026amp; refer 取址：int* a = \u0026amp;variable; 变量的作用域（{}）和生命周期 作用域：在哪个范围内能访问到该变量\n生命周期：\n在内存中存在的范围（stack变量一般是活不过}） 需要跨越作用域的生存的话通常需要指定存储heap object“对象”的生命周期 （不使用New关键词的时候）生命周期只到栈或者说是大括号内（可以使用空的大括号组），是存在的\n（使用new关键词的时候）如果我们不delete它，就只能在程序终止的时候才退出了。\n:x: 下面这是一种十分错误的写法\n1 2 3 4 5 6 7 8 9 10 11 int* CreateArray() { int array[50]; return array; } int main() { int array[50]; CreateArray(array); } //完全错误，在函数结束的时候这个指针会被完全销毁，所以指向的地址是没有值的， 如果我们希望延长声明周期，我们可以将数据分配到heap上，或者通过传入指针，对指针调用的地址的值进行修改。\n编写一个会自己销毁的在heap上的指针（实际上和智能指针又异曲同工之妙）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class ScopedPtr { // 该ScopedPtr的申明是存在stack上的，所以销毁的时候调用delete就直接。 private: Entity* m_ptr; public: ScopedPtr(Entity* ptr) :m_ptr(ptr){} ~ScopedPtr（） { delete m_ptr; } } int main() { { ScopedPtr e = new Entity(); //申明周期也只到内部的大括号，出不去。会顺便把实例也销毁了。这个还稍微有点疑问。:question } } const 常量修饰符 C++ const 关键字小结 | 菜鸟教程 (runoob.com) 语义含义：不可变，不可修改；\n可以令值不可变，也可以令指针不可变；定义一些常量之类的东西 可以在函数传入值中定义，使得传入值不可被修改，或者防止传入的指针或者是引用被不正确的修改导致一些奇怪的问题。 要注意根据位置的不同是指针不可修改还是值不可修改的含义是不一样的。 本质含义：实际上是一种代码的可见性机制，只是个promise，用来简化我们的代码。所以我们应该遵守它：就是我们不去修改这个const。（避免使用强制类型转换去修改它）\n几种基本的定义方式：\n这种形式指的是我们没法修改地址的值，但是我们可以改变指针所指向的地址。\n1 2 3 //这两种都是一样的，在指针*的前面 const int* a = new int ; int const* a = new int ; 这种形式指的是无法修改指针引用的那个地址，但是可以随意的修改值。\n1 int* const a = new int 复用就是都不能改\n在类中的public函数declaration的括号后面加 const，指的是我们没法在类内函数中修改类内的private的值。这样的操作会被定义为illegal。\n类内指针的话就有意思了，要有三个const全用 :question:这一点后面慢慢补充，没搞清楚来着，记得太模糊了。\nconst Entity\u0026amp; e 指的是我们没法修改指向的地址。\n实例说明：\n对于传入函数的Instance（Entity）也是一样的，如果我们不希望进行内存上的copy，我们就加上\u0026amp;，如果我们不希望改变值就加入const。\n用一些例子来说明一些其他情况的Const用法。 需要注意！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Entity { private: int m_x, m_y; public: int GetX() const //需要保证函数不能修改类内的private的值 { return m_x; } } // 但是还是有一些问题 在这种情况下的const最前面的就是指的指针的地址不能变，但是其中的值能变。那么在这个时候，涉及到实体的那些函数，如果我们再类中没有加入const后缀的话，那么我们就不能使用这个get函数，因为编译器不能确保他不修改我们不能动的那些数据。 所以有时候会出现一个+const的定义和一个不加const的定义。 如果我们对一些private需要指定在一些const后缀的情况下可以改变，那么我们可以再声明的时候加入mutable前缀：允许的可变。 void PrintEntity(const Entity\u0026amp; e) { std::cout\u0026lt;\u0026lt;e.GetX()\u0026lt;\u0026lt;std::endl; } Mutable可变标识符 **用途1：**基本上对于一些private类，在有const后缀的情况下我们又希望修改其中的某个值，才会用到这个关键词。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class A { private: std::string m_name; mutable int m_DebugCount = 0; public: // 结合上面的范例可以看出这个返回类型为啥回事这个const+\u0026amp; const std::string\u0026amp; GetName() const { m_DebugCount++; return m_name; } } 用途2：使用lambda的时候。我们希望能够修改传入值本身，（但是lambda是不允许修改的所以需要）\n1 2 3 4 5 6 7 int x = 8; auto f = [=]() mutable { x++; std::cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;std::endl; } f(); Static静态标识符 静态标识符类型： class or struct 内部，外部，function 内\n类外的static：\n对于Linker起作用的修饰符，表示为局部的，也就是只对它本身的obj起作用，不会和别的文件连接起来，只对本身可见。\n如果在function的前面添加Static 就表示该Function 只被该.cpp调用，也不会考虑外部的Link，所以当我们如果希望被外部调用的时候就不能加static标识符，在要调用的地方进行declaration.\n实际上全局的参数定义，对于Linker来说也可以是跨文件的，所以如果我们定义全局参数的话，我们要考虑是否是通用的（需要重复include的常量），就可只在cpp定义一次。同时我们要在引用（另一个文件）的时候添加修饰符。（比如在头文件中用Extern Declaration参数）\nExtern（也是用于声明：在外部已经定义过了，定义参数独有的）\nhttps://www.cnblogs.com/lulululu/p/3693865.html 类内的static：\n这部分*memory对于这个类别的所有实例是共享的，换句话说也就是，无论你定义了多少个instances，这个变量或者方法也是唯一的，对于所有的类别是通用的。你改变了一个，也就改变了所有。\n所以，类内的静态方法可以在没有类实例的情况下被调用，而且在这种静态方法中不能refer to 一个具体的类实例。 也不能通过实例对静态变量进行调用处理，这样Linker会找不到我们实例对应的变量，因为那几个变量是类的变量而不是实例的变量。那么怎么去调用或者修改呢。 使用作用域(type ClassName:: x)的方式去声明,同样也以这样的方式去调用（ClassName（同样也能类比成namespace）:: x）才是真正正确的使用方法，类内的静态函数也是这样定义和操作的。但是不用像参数一样在类外声明 Function内的Static：\n其实和类内的Static是一样的，当我们第一次调用这个function的时候就会存储这样一个对于所有的function的静态变量，后续调用的时候这个参数就不会被重新创建了。 也就是说这种参数对于函数来说是恒定的，在该参数上进行的变化会被继承下来，也就是会被迭代运作。 某种程度上来说也算是延长了参数的生命周期，通常来说需要\u0026amp;的return值的一些情况下就需要用static关键词定义的vars。(:question:这一点是啥意思来着） 数组、多维变量（Array） 经典数组 数组实际上是一组连续的变量，在内存上存储指定长度的空间，本质是指针\n定义方式：type var[n],定义n个连续的type内存空间，这里的var实际上是相应的指针\n1 2 int example [5]; int* ptr = example; 用var[idx]去索引指针相应地址的值：（实际上就是在初始地址上加上相应的偏移）\n默认在stack上：没有new就是在stack上，需要heap就＋new把 记得delete[]\n同时也可以用New关键字去声明数组，同时这个数组就会被存储到Heap中，这样的话该数组的声明周期就能活过大括号了，需要我们手动调用delete命令去删除它，由于定义的形式是数组所以在delete的时候记得使用的是delete[] var 命令\n1 2 3 int* another = new int[5]; for (int i ; i \u0026lt;5; i++) another[i] = 2; 和传统的array好像有一定的同质性；找到数组长度的方法：\n1 2 int count = sizeof(a) / sizeof(int); // 用std::array的会自己保存数据的array 静态数组（std::array） 数组的长度或者大小没办法自动（动态）改变的，我们应该用这种方式来代替传统的定义方式，有很多好处。\nhttps://blog.csdn.net/thinkerleo1997/article/details/80415059 https://blog.csdn.net/fengbingchun/article/details/72809699 1 2 #include\u0026lt;array\u0026gt; std::array\u0026lt;int,5\u0026gt; data; 什么时候我们应该用这种array来取代传统的int array？\n现在这种方式有很多的集成函数：比如说size，sort，began好像还有iterator之类的方法。 因为传统的使用New，关键词是slow的，这种方法也会快一点，而且长度是不知道的。 verctor是heap上的，而array和传统的int，array都是存在在stack上的，（非new关键词） 有很多优化，同时这种方法有自动的边界检测？ 在函数传入array的时候，建议可以使用template的方法。 **BTW：**快不是标准库（STD）的基本目的和最求，所以很多时候需要资源最大化利用的情况下，很多project都会编写自己的数据类型：（可以从Cherno的最后两课去看看）\n动态数组（std::vector） 更详细的一些操作指南可以google或者看HR的vector.svg(附件)\n就是个不指定大小的Array，可以改变数组的大小，其实就是自动执行内存的重新分配（内存动态分配），牺牲性能来得到更好的便捷性。\n虽然C++命名Vector，但是实际上是个动态的ArrayList，而不是向量。\nvector移动数据而不是Copy的方式在很大程度上提升了效率（没超过默认大小的情况下），但是在超过了指定大小的时候，还是需要用到copying（内存的动态分配）这就不是一个非常理想的情况。\nVector：当append超过了现有的容量，找到一个足够大的内存位置，然后把原本的参数copy迁移过去，然后加上我们要添加的参数，然后删除原本占用的内存空间。\n这样就会造成运行缓慢，那么我们如何避免这样的copy操作，\nhttps://blog.csdn.net/theonegis/article/details/50533770 基本的声明方式\n1 2 3 4 5 6 7 8 #include\u0026lt;vector\u0026gt; std::vector\u0026lt;type\u0026gt;name; //type 也可以是自己定义的class；实际上存储的就是数据的内存顶点（起始点） // using vector = std::vector以后 vector \u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; b(a); //声明容器b, 用容器a初始化b vector\u0026lt;int\u0026gt; b(a.begin(),a.begin()+3); //用0-2个元素来初始化 vector \u0026lt;int\u0026gt; a(num); // vector \u0026lt;int\u0026gt; a (num,value); 基本的一些method\nPush_back({v1,v2,v3}) 就相当于append；size（）获取长度；clear（）将长度设置为0\n索引还是[]；\neraser（）：需要在括号中设置一个迭代器，比如我们需要移除第二个参数\n​ ↑：vertices.begin() +1\n使用示例：\n1 2 3 4 5 6 7 8 std::vector\u0026lt;Vertex\u0026gt; vertices; vertices.push_back({1,2,3}); vertices.push_back({4,5,6}); for (int i = 0; i\u0026lt;vertices.size();i++) Print(vertices[i]); for (vertices\u0026amp; v: vertices) Print(v); 存储空间\n默认应该是在heap上的，但是会自动删除的。\n优化vector的使用\nissue1：我们会先调用最原始的构造函数，在main function的栈中构造一个vectex，然后copy it to Vertor类所在的空间中，如何直接在指定的地方添加（或者说只进行一次构造）呢？\n解决方法：用emplace_back 取代push_back,直接传入构造对象需要的参数即可\n1 2 vetrices.emplace_back(1,2,3); vetrices.push_back(vetrices(4,5,6)); **issue2:**空间超过以后进行了复制和迁移操作，也就是我们每一次添加都需要把原本的空间进行resize（copy and move）\n解决方法：直接在开始的时候指定可能的最大size，就是给定一个预留空间 1 2 std::vector\u0026lt;Vertex\u0026gt; Vertices; Vertices.reserve(3); 字符串（String） String - stream of text 一组字符串 == array of characters\n一些额外的信息：字符串相关的一些其他事项\n实际上\u0026quot;\u0026quot;定义的就是固定（const）的type为char的指针，也就是 const char*；换句话说也就是占据固有长度的char array\n实际上这是c中编写string的风格，为了熟悉基本的原理才这么编写的，现在就直接用string库了\n原本定义的时候还需要在末尾指定ascii码终止符，但是在新的版本中不需要特地指定，也就是下述的两者是一样的。\n1 2 char name2[7] = { \u0026#39;A\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;n\u0026#39;,0}; char name2[7] = { \u0026#39;A\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;n\u0026#39; }; 基本信息: 使用string的基本注意事项\n基本的定义方式也就是和int之类的没区别 string类别就可以使用find size append +=之类的操作了，所以拥抱string； 官方的参考链接地址 （看看其中的function的作用）： \u0026quot;\u0026quot;定义的类别实际上就是const char[]，本身就是一个不可修改的指针了，各种意义上的不可修改 ''定义的才是像普通的123这样的char value string实际上也是std中的一部分: 同时include它包含了重载\u0026laquo;，使得其得以接受stiring类型。 +=不能再“”中执行，但是可以在string和“”中进行。 将string 传入函数的时候，也是不修改原值的，所以我们还是使用\u0026amp;的传入参数设置去使得不需要赋值一个新的，同时如果不希望修改的话，就在最前面加入const String Literals\n实际上我们在上面说的“”定义的就是String Literals，字符常量，这种方式定义的后面会自带一个休止符的位置，再内存中也就是00；我们也可以手动定义休止符\\0 实际上我们修改string都是再内存中获取一个Copy去进行的。所以我们需要善用\u0026amp;符号 一些函数：\nStrlen（）:返回string长度，char array，要注意自己手写休止符的特殊情况\n基本的“”实际上也是utf-8类型的。\n1 2 3 4 const char* name = u8\u0026#34;Aiken\u0026#34;; //1 byte const wchar* name2 = L\u0026#34;Aiken\u0026#34;; // (2/4) byte const char16_t* name3 = u\u0026#34;Aiken\u0026#34;; // 2 byte const char32_t* name4 = U\u0026#34;Aiken\u0026#34;; //4 byte 可以使用\nusing namespace std::string_literals使得我们对 “” -\u0026gt; string的类型转换可以从 std::string(\u0026quot;\u0026quot;)变成只需要\u0026quot;\u0026quot;s R\u0026rdquo;\u0026quot; 也很有用，:question:但是我忘了这个是用来干嘛的了 枚举类型（ENUMS） 枚举类型：也就是set of value\n根据第一个var = x; 后面每一项的默认值在前一项的基础上+1，自动匹配对应的value\n本质上就是一组指定的别名和其对应的value\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class example { public: enum Level: unsigned char { L_error = 0,L_Warning,L_info }; //取代了下面这种表达其实 /* const int L_error = 0; const int L_warning = 1; const int L_info = 2; */ private: Level m_logLevel =L_info; } 自动类别指定（Auto Keyword） 可以结合模板来使用\n实际上就是根据我们键入的等式右边的内容，自动指定int float or any other type。\n但是作者不是很推荐这种用途，很简单的情况，就很没必要，而且不利于阅读和维护auto a = 4;\n比较推荐的用法：\n调用函数时的返回值前缀： 在这种情况下我们修改function（API）的return type的时候就不需要重新在修复赋值的定义了，这种时候auto还是很有用的，或者返回类型不明确的时候。\n1 2 3 4 5 6 7 8 9 // 比如function的type 我们可能经常会动，或者有几个相似的函数的情况 char* GetName() { return \u0026#34;aiken\u0026#34; } int main() { auto name = Getname(); } 缺点：但是这种方式的话实际上也会让我们是否修改了代码的指示比较不明确，比如有时候会发生隐式转换。\n替代特别长的数据类型： 比如使用像vector这种的时候，参数名实在是太长了，就你懂的了，推荐使用（当然这种可以用using 来取代也是一样的。）\n1 2 3 4 5 // 使用 using的话就是。 using DeviceMap = std::unordered_map\u0026lt;std::string, std::verctor\u0026lt;Device*\u0026gt;\u0026gt;; DeviceManager dm; // 话说下面这个应该是 值不可被修改的别名（因为\u0026amp;本来就无法修改地址，所以只有一种可能把） coust DeviceMap\u0026amp; devices = dm.GetDevices(); 模板（Templates） 模板可以理解为一种指代，简单的例子就是通过这种模板的定义我们可以定义一个类别通用的函数；\n模板实际上是在编译的时候就实现的一种机制，而不是到了具体的运行的时候才实现的。\n简单使用场景：\n当我们需要多种类型的输入，来进行相似的function操作，比如说Print的时候，这种时候我们定义一种TypeName的模板；然后我们就可以使用如下方式调用定义的函数了。 1 2 3 4 5 6 7 template\u0026lt;typename T\u0026gt; void Print(T value) { std::cout\u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } print(5); print\u0026lt;int\u0026gt;(5); //其他类型的也可以，只要函数内部支持就行。 除了不确定的类别，我们也可以针对不确定的size去做（其实这里的int类型可以改成size_t） 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T, int N\u0026gt; class Array { private: T m_array[N]; public: int Getsize() const {return N;} }; //main Array\u0026lt;int, 5\u0026gt; array; 但是不要过度使用，因为可读性会比较差；但是更关键的是，模板在编译和执行的时候是两回事，这样会让我们很难定位问题。所以不要乱用。但是在编写loging的system之类的地方，就比较合适。\n操作符与操作符重载（Operators and operator overloading） 需要注意的是，存在默认参数的函数不能进行重载，因为当默认参数存在，调用的时候可以忽略部分参数，这样在进行函数的调用的时候会产生歧义。\n更多的表现是符号而不是函数，new ， + - ,之类的都是 括号\n与或非： || \u0026amp;\u0026amp; ！\n一些优先级设定：\n++之类的运算符号的优先级\u0026gt; *取值，所以我们要加入括号，使其首先解引用，防止改变的是地址的值而不是value。\n重载的用途：\n比如我们实现向量类别的时候，我们就可以重载+，来实现这个加号，就是不用写一个Add函数（麻烦），主要是比较大规模的情况下为了使用方便来写的吧。\nExample：\n1 2 3 4 5 6 7 8 Vector2 Add(const Vector2\u0026amp; other) const { return Vector2(x + other.x,); } Vector2 operator+(const Vector2\u0026amp; other) const { return Add(other); } 为了更方便的cout重载\u0026lt;\u0026lt;\n1 2 3 4 5 std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; stream, const Vector2\u0026amp; other) { stream\u0026lt;\u0026lt; other.x \u0026lt;\u0026lt;other.y; return stream; } 对bool的判断进行重载：\n1 2 3 4 5 6 7 8 bool operator==(const Vector2\u0026amp; other) const { return x==other.x \u0026amp;\u0026amp; y== other.y } bool operator!=(const Vector2\u0026amp; other) const { return !(*this == other); } 重载迭代器的索引\n1 2 3 4 char\u0026amp; operator[](unsigned int index) { return m_buffer[index]; } 命名空间（Namespace） Using namespace apple (导入apple中所有的定义)\nUsing apple：：func1（只导入func1）\nNamespace a = 定义\n类似的查看cppreference网页即可\n左值与右值（lvalue and rvalue） 其实就是赋值等式左边的变量和右边的常量的关系把？在这部分还会讲到相应的reference。\nrvalue就是 i=10中的10，这种值不能被更改，是一种临时的变量值，没有location和space，我们会将它分配到i，也就是左值。才是可分配和可改变的。实际上就是这样的。\nrvalue可以用来创建lvalue，lvalue才有reference，但是有特殊规则；\n1 2 int\u0026amp; a =10 // error,这样写是错的，rvalue没有直接的引用 const int\u0026amp; a =10; //right 了解这点的意义在于（为啥我们要使用const）\n1 2 3 4 5 6 7 std:string fName = \u0026#34;H\u0026#34;; std:string Lname = \u0026#34;Aiken\u0026#34;; std:string Fullname = \u0026#34;Aiken\u0026#34; + \u0026#34;H\u0026#34;; // 这个等式左边的全lvalue, 等式右边的（整体）都是rvalue，于是我们调用下面函数的时候，无法写输入值为\u0026#34;Aiken\u0026#34; + \u0026#34;H\u0026#34;，因为rvalue没有\u0026amp; void PrintFuc(std:string\u0026amp; name){} // 我们稍微修改一下，就能得到一个通用的Print,能够对临时变量rvalue进行传入。 void PrintFuc(const std:string\u0026amp; name){} 假如我们需要一个只能传入rvalue的函数，那么我们可以将表达修改为，这是一种特殊的方式\n1 void PrintFuc(std:string\u0026amp;\u0026amp; name){} 这种方式有什么用呢？对于下面的移动语义很有用，因为临时的变量不需要考虑livetime或者memory之类的东西，同时我们可以简单的获取其中的值，不用担心他和很多其他的地方产生关联。\n移动语义（move semantics） **Question：**为什么\u0026amp;引用符号不能解决这个问题，好像是对传入object的情况进行处理的一种方法：就像string，我们在某个地方需要她的时候，我们可能需要重新构造它。\n**Ans：**移动语义针对的对象实际上是Rvalue，也就是临时变量，临时变量的生命周期短，特别是像“”到string的情况，也是需要申请空间的，这样在我们将rvalue传入function或者class的时候，就会发生一次不必要的copy（因为rvalue没有\u0026amp;所以你懂的）\nMove Semantic： move objects around\n为了避免类似的不必要copy的操作，我们就使用移动语义的编程思想来做。👇\nmove就是获取原本存储地址的指针，然后再将原本的指针赋值为nullptr（这样会使得其自动调用析构函数，也就不会有泄露等错误了）同时将size设置为0。\n相比较于深拷贝实际上就是一种浅拷贝的操作。\n具体的实现思路其实就是针对rvalue重构copy constructor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //copy constructor 如下,以class string为例 //基础类别的部分 string(const String\u0026amp; other) { printf(\u0026#34;Copird!\u0026#34;); m_size = other.size; m_data = new_char[m_size]; memcpy(m_data, other.m_data,other.m_size); } //重构rvalue情况下的.. string(const String\u0026amp;\u0026amp; other) noexpect { printf(\u0026#34;Move!\u0026#34;); m_size = other.size; m_data = other.m_data; // 清除原本的指针 other.size = 0; other.m_data = nullptr; } // Entity部分，要添加一个针对rvalue的构造函数 Class Entity { public： Entity(const String\u0026amp; name) :m_name(name) {} // 这里注意要手动把转换写出来，不然还是会进行copy的情况(执行上面那个),move 或者(string\u0026amp;\u0026amp;) Entity(const String\u0026amp;\u0026amp; name) :m_name(std::move(name)) {} private： string m_name; } // main 部分 Entity entity(\u0026#34;aiken\u0026#34;); entity.print()// .... std::move()左右值转换\n参考资料： 详细解析 ；Anthor one 可选数据（Optional Data）（new in C++17） **基本设置：**项目，设置，C++，语言，c++语言标准\u0026gt;17\n针对那些我们可能会使用也可能不使用的可选数据。这也是一个c++ 17的内容：https://zh.cppreference.com/w/cpp/utility/optional\n传统的就是通过引用传入一个bool flag，然后通过flag去判断是否存在之类的。但是有了optional我们就可以如下的方式去做\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;fstream\u0026gt; #include \u0026lt;optional\u0026gt; std::optional\u0026lt;std::string\u0026gt; readfile(cosnt std::string\u0026amp; filepath) { std::ifstream stream(filepath); if(stream){return string1} return {}; //这种写法其实是空tuple？还是要学一下的。 } auto data = readfile(); //或者写那一长串optional string //然后就可以使用 if(data) 或者 if(data.have_value()) 还有另一种使用方式就是，用于设定不存在数据的默认值。\n1 2 3 4 std::string value = data.value_or(\u0026#34;sdsds\u0026#34;); //如果data是空的救会取到这个，相当于默认值把。 //比如 std::optional\u0026lt;int\u0026gt; count; int c = count.value_or(100); 多类型变量（MultiType Variable）（new in C++ 17） 换句话说就是数据的类型是在指定的范围内可选的，依托于#include\u0026lt;variant\u0026gt;通过指定数据可能的Type，然后用特殊的方式取出来。\n它实际上存储的是所有类型的长度相加的空间；虽然能实现和unions类似的功能，但是实际上是更安全的。就是存储空间的占用更大？两者相比推荐这个把。\nstd::get_if：对于这类型的数据很经常被拿来使用，我们可以参考这里的 用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 std::variant\u0026lt;std::string,int\u0026gt; data; data = \u0026#34;Aiken\u0026#34;; // 这种数值取出的方式只有在类型正确的时候才会起作用，不然会造成exception std::cout\u0026lt;\u0026lt;std::get\u0026lt;std::string\u0026gt;(data)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; data = 5; std::cout\u0026lt;\u0026lt;std::get\u0026lt;int\u0026gt;(data)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; ----------------------------查看当前的数据类型------------------------------- data.index(); //这个index对应我们前面的定义的顺序 //另一种更优美的数据获取方式 auto* value = std::get_if\u0026lt;std::string\u0026gt;(\u0026amp;data); // and we could use it like that if(auto value = std::get_if\u0026lt;std::string\u0026gt;(\u0026amp;data)) {} 针对Get_if的具体实例可以写成这样：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;variant\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::variant\u0026lt;int, float\u0026gt; v{12}; if(auto pval = std::get_if\u0026lt;int\u0026gt;(\u0026amp;v)) std::cout \u0026lt;\u0026lt; \u0026#34;variant value: \u0026#34; \u0026lt;\u0026lt; *pval \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else std::cout \u0026lt;\u0026lt; \u0026#34;failed to get value!\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 此外我们也可以通过这种类型来定义函数：这种的使用方式可以像这样看（对于可选的话，只是返回一个空值，这样可以更加具体的定义我们为什么访问不到文件），但是这种方式的话，不能用auto来代替吗\n1 2 3 4 5 6 7 8 9 //因为我们要当成类型传入，所以需要class但是这里不用return值吗 enum class ErrorCode { None = 0, NotFound = 1, NoAccess =2 }; std:: variant\u0026lt;std::string,ErrorCode\u0026gt; ReadFileAsString () { return {}; //这里应该也是需要修改的把，改成ErrorCode类型 } 任意类型数据的存储（store any type）（new in C++17） 我们也可以使用空指针来存储任意类型的数据；但是这不是这一块讨论的内容，这里讨论的是std::any\n就是一个能存储任意类型的variable，实际上和variant很像，但是那个更安全，因为我们知道所有的可能类型；同时这样的方式也会避免any可能会带来的动态内存分配，这个我们知道是相当影响性能的。\n1 2 3 4 5 6 7 8 #include\u0026lt;any\u0026gt; std::any data; data = 2; data = \u0026#34;aiken\u0026#34;; // variant 指定string的时候实际上会发生const char * 到string的隐式转换，但是any是不会的。 //any 取出变量的方式如下,在这种情况下数据类型不匹配的话，是不会成功取出的，我们还是需要知道我们当前的any type 以及按照指定的方式取出，所以实际上variant是一种更为安全的方式 std::string string = std::any_cast\u0026lt;std::string\u0026gt;(data); //但是这样的话我们还是会有一个copy的操作，我们是否能够直接返回一种引用👇（别名） std::string\u0026amp; string = std::any_cast\u0026lt;std::string\u0026amp;\u0026gt;(data); 使用的情境：\n实际上是存储空间是有默认的小规模存储空间和大规模存储空间(限制);超过了小规模（32byte？）的情况下会使用动态的内存分配的机制。\n当我们需要用any存储类似struct之类的大数据的时候，any可能就会调用new来动态的内存分配了。\n能用variant就用，不行，导致非要用void*（空指针）的情况下就用any；但是最好的话，我们是不需要这种东西的。\n如何使用：\n多维矩阵（2D+Array） n维数组实际上就是n-1维数组的堆叠：array的array\n也就是其实是指针机制：指针指向的地址存放一组指针，然后这组指针再指向各个Array，这就是2d array了。关键就是 指针的指针**\n多维矩阵第一次取出的时候实际上是指针类型，多重取出的最层才是数据。\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { // 实际上就是用指针的指针的方式分配多维度的数组，更多维度也是一样的（星星更多了）。 int* array = new int[50]; // 分配50个存放int指针（int是返回的类型不是指针的类型）的空间 int** a2d = new int*[50]; //绑定了50个内存位置 ------------------------------------------------------------------------------------- //实际的定义多维数组的方式,更高维度的就要嵌入更深的循环。 int** a2d = new int*[50]; for(int i=0;i\u0026lt;50;i++) a2d[i] = new int[50]; } 问题来到了下一步如何删除多维度的数组？\n如果我们只delete最外层的指针，那么内部的所有指针地址，将会发生内存泄漏。\n所以：我们需要像定义那样，反向的对每个指针都进行delete\n1 2 3 for(int i=0;i\u0026lt;50;i++) delete[] a2d[i]; delete[] a2d; 这些50*k的存储空间实际上不一定是连续的，但可能是接近的，实际上是，再内存中随机的分配50个buffer来存放50个array，这种方式会越来越慢，（因为缓存的命中问题？），连续的存放可以使得缓存有更高的命中率来提升速度。\n再某些情况使用1d array来代替2d array比如下（这不用看了，谁不会啊，手动换算行号呗），但是这样的代码在执行的时候，快很多\n1 2 3 4 5 6 7 8 9 int* array = new int[5*5]; //我还以为，是类似的写法也可以，这样的话，谁不会啊。 for (int y=0;y\u0026lt;5;y++) { for (int x=0;x\u0026lt;5;x++) { array[x + y*5] =2; } } 隐式转换和显式转换（Implicit Conversion and the Explicit Keyword） 隐式转换和显式关键词\n隐式：不用告诉他他究竟要做什么\n很多时候由于类的构造函数实现，基于类的输入类型，我们可以将函数表示的初始化，转化为等号的。同时也能在一些特定的场景下执行内置的类型转换。\n但是如果是我的话，我尽量不会这么去做🔜，因为这样会增加阅读的负担。\n显式关键词：不让执行隐式转换\nExplicit 加在构造函数的最前方，这就是让构造函数只能被显式调用，不能执行隐式调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;iostream\u0026gt; using String = std::string; class Entity { private: String m_name; int m_age; public: Entity(const String\u0026amp; name) :m_name(name){} Entity(int age) :m_age(age){} }; void PrintEntity(const String\u0026amp; name) { // print } int main() { // 在这一步中C++将根据构造函数进行隐式转换，前提是对应的类别要是正确的 Entity a = 22; Entity b = String(\u0026#34;aiken\u0026#34;); // 第二种自动进行隐式转换的场景，实际上和上面是完全一致的 printEntity(String(\u0026#39;asdad\u0026#39;)); std::cin.get(); } cast：类型转换从typeA-\u0026gt; type B\nint（22）之类的 所有的类名也能这么做（借助隐式调用这样的） 类型转换（Type Casting） cast实际上会为我们检查类型是否正确等等\n显式转换：显式的指定我们希望将当前类型强制转换成什么目标类型\n1 double s = static_cast\u0026lt;int\u0026gt;(value)+ 5.3 **隐式转换：**不需要我们显式的指定转换的数据类型，根据输入输出会自动转换\n1 2 3 4 5 6 // 反过来也是可以的 double value = 5.25; int a = value; // 我们同样也可以显式的指定,但是这种转换不是强制的，只是显式的表达 double b = (int)value;//safe style csat的样式 double b = (int)value +5.2 //我们可以看看没有这个int的结果 实际上存在四种不同的Casting：static_cast，const_cast，dynamic_cast，reinterpret_cast ，这几种cast的使用请 GoogleIt 来补充基本的含义，以及一些使用情况，（CPP reference是真的牛逼）\n在一些情况下转换失败的话会return null，所以也可以用做派生类的检查。\nconst：用来从const到非const\ndynamic：用于从基类到子类的指针转换，（反过来可以，但是实际上不需要显式转换）\n其实是一种function，实际上会有一些额外的操作。\n如果这个转换是错误的，那么这个指针会返回null，所以实际上，这个指针可以用作类型之间继承关系的验证作用。\n1 2 3 4 // 基本定义 class Entity {}; class Player : public Entity {}; class Enemy : public Entity{}; 实际上由于存储了运行的中间状态（runtime type infomation默认是启用的，关闭会报错），所以是可以知道该类到底是啥的，也就是支持从基类推导到该子类到底是啥。\n1 2 3 4 5 6 7 Player* player = new Player(); Entity* e = player; //毫无问题 Entity* e1 = new Enemy(); Player* p0 = dynamic_cast\u0026lt;Player\u0026gt;(e1); //这种转换不可行，会return null Player* p1 = dynamic_cast\u0026lt;Player\u0026gt;(e); //从基类转换到子类 ok，但是这种情况下我们需要指定多态，也就是virtual 为了避免冲突，这其实是一个多态的用法 if(dynamic_cast\u0026lt;Player\u0026gt;(e1)){} //验证类型的用法 reinterpret:用于无关类型的转换，还是需要再搜索一下，不太常用，推荐的可以使用的情况，类型转换转换回原本类型的时候\n这种类型转换实际上是更可靠的。\n类型双关（Type Punning） 实际上就是获取某种类型变量的指针，然后转化成另一种类型的指针的操作。\nGoogle it 当然接下来我们也可以解引用,其他之类的。\n首先看一串示例代码（double）实际上是为了让到double的隐式转换更加清晰，并没有真正的操作指令。\n1 2 3 4 // 这样的操作实际上就是a-b的隐式转换，但是这样的话，内存空间实际上是没有公用的，b是用的另外赋值的双精度的5 int a = 5; double b = (double)a; // 反过来也是一样的道理 如果我们想要直接使用指针转换，将double指针转换到int指向的内存地址，这样的话，由于两种类型的长度不同，所以会导致输出错，严重的话还会导致崩溃。\n但是实际上，这样的操作，我们可以通过同样长度的内存操作，来直接的对内存进行操作，但是正常人没有人这么干。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Entity { int x,y; int* GetPositions(){return \u0026amp;x;} }; int main() { Entity e = {5,8}; int* position = (int*)\u0026amp;e; //将struct的指针转化为int指针 std::cout\u0026lt;\u0026lt;postition[0]\u0026lt;\u0026lt;postirion[1]\u0026lt;\u0026lt;std::endl; int y = *(int*)((char*)\u0026amp;e+4); // 通过char的单字节操作获取到第二个指针的地址。 int* z = e.Getpositions() } Part 3 Poniter \u0026amp; References指针与引用 从指针的含义出发，对各种不同指针的用法，引用场景，内在含义，进行分析，记录世界记录你。永远的神，指针。\n指针实际上就是一个1byte的整型值，它就是一个地址，指示你在内存中存储该值的位置，和类型没有半毛钱关系，类型只是指示你可能放了个啥类型的数据在那个地址Void* ptr = \u0026amp;var;\n引用和指针本质上是一回事，用法上会有所区别它实际上是基于指针的一种高级修饰，是对某个已经存在的var的引用。他并不是一个真正的变量。Int\u0026amp; ref = var。\n引用能做的指针都能做，实际上是一种代码的优化和简化过程（moew clean），主要的用处就在将var而不是value传入function（达到能够直接修改var的作用）\n指针基础（pointer） -\u0026gt;的访问方式：实际上等同于(*e1).method，Arrow-\u0026gt;只能在左边是指针的时候使用，而.调用的方式左边只能是实体。\n1 2 3 4 Entity_virtual e1 = new Entity_virtual(); std::cout\u0026lt;\u0026lt;e1-\u0026gt;GetName()\u0026lt;\u0026lt;std::endl; Entity_virtual e2(\u0026#34;Aiken2\u0026#34;); std::cout\u0026lt;\u0026lt;e2.GetName()\u0026lt;\u0026lt;std::endl; 基本的定义和使用方式：\n用*定义一个指针类型（用来存放地址）= \u0026amp;var（用该符号取出后接变量存储所在的内存地址）var 然后我们可以在Debug Stage从windows的memory找到该变量在内存中的值。 实际上也可以用type* name = Value，这样的话name还是指的是value所在的地址。但是这种时候type就需要写好了。 在指针类型变量前加*表示我们访问该地址所存储的Var，我们可以对该var进行读取写入或者修改，但是在这个时候，我们写入的值就和之前所提到的类型有关了（指针本身是无关的） 因为类型会告诉内存，我们写入的数据要在内存中占用多少个字节，多少位之类的信息，而如果我们使用void，那当我们给该指针取到的数据赋值的时候，compiler就不知道怎么存储该数据，也就会导致error。 也可以用**定义指针的指针，也就是指针所在的内存空间的地址 BTW:从内存窗口看到的地址是逆序的 可以将指针定义为nullptr，后续再赋值，而引用必须马上引用一个已经存在的变量，他不是一个新的变量。 在同一行里定义多个指针变量的时候要在每一个前面+*千万别忘了 注意事项：\n++之类的运算符号的优先级\u0026gt; *取值，所以我们要加入括号，使其首先解引用，防止改变的是地址的值而不是value。 “0”不是一个有效的内存地址 指针偏移值实际上取决于指针前面的type：如下图就是加入了两个int长度的地址。 1 2 3 4 5 6 7 8 int example[5]; int* ptr = example; for (int i=0; i\u0026lt;5;i++) example[i] =2; example[2] = 5; *(ptr+2)=6; //上述也等同于 *((char*)ptr + 8) = 6; 引用基础（references） 用type\u0026amp; ref = var定义一个对var的引用，不需要其他的操作符\n实际上ref就是一个别称，他不是实际存在的，只是var的另一种表达形式。 需要立即赋值。 具体的用途除了创建别名方便读写以外：主要用于需要修改原值的参数引用定义上。\nfunction中通常情况下，是传值，而不是传递变量的地址。所以会有额外的内存拷贝的操作发生；所以通过function中的value产生的变化实际上是不会影响传入的变量的，这时候我们需要使用引用将变量传入，而不是值传入。（if we need this operation，也就是我们需要影响原值的时候）那么实现的方法有下面的三种。\n要这么做的话实际上就是，我们将内存地址传入，然后通过地址取值进行操作，而不是只将这个值copy一下传进去也就是def fun(int* var); func(\u0026amp;var);当然这种方式也适用于直接传入指针，\n1 2 def fun(int* var); func(\u0026amp;var); 对1进行修正，更优雅的写法，简洁，就是使用reference，接受传入的是别名，也就是具体的变量，而不是值。\n1 2 def func(type\u0026amp; value); func(var); 当然我们也可以通过return来改变原值，但是这样会需要temp value来影响内存效率之类的东西，也比较傻逼。\n无法改变引用的对象。\n再func前面类型定义为Type\u0026amp;,那么我们正常的return就是返回一个原值的引用。\n指针的-\u0026gt;操作符(Arrow Operator ) →用来取代解引用后取值，就是用于指针直接调用参数或者函数，免去用*解引用的过程。\n但是所有的操作符都可以重载，我们可以在自己的类别中定义他：比如当我们用一个Class 装载别的Class的指针的时候（比如我们为了让他能自己delete），如果我们希望能够直接指向最底层的那个Class 的function的时候。\n1 2 3 4 5 6 7 8 9 // ScopedPtr存放另一个class（Entity）的指针，和构造析构函数。 // 重载使得直接调用底层类别中的函数。 Entity* operator-\u0026gt;() { return m_obj; } ScopedPtr entity = new Entity(); entity-\u0026gt;Print(); 获取类中参数的内存偏移量（可能是特殊的用法把，和第一点最基础的代码完全不一样）：\n1 2 3 4 5 6 7 8 9 10 struct Vector3 { float x,y,z; } int main() { int offset = (int)\u0026amp;((Vector3*)nullptr)-\u0026gt;x; std::count \u0026lt;\u0026lt; offset \u0026lt;\u0026lt; std::endl; } // x,y,z会分别Get到0，4，8（字节） 函数指针（Function Pointer） 主要目的就是：获取函数所在的内存空间的地址；\nhttps://zh.cppreference.com/w/cpp/language/pointer 函数指针的补充资料：link1 ，Link2 ，还需要通过编程来加深理解\n实际上应该还有其他类型的表达；\n定义和使用\n记住这里1不加括号（有参数输入的时候才加入括号），这就等同于在HW卡面+\u0026amp;\n1 2 auto function = HelloWorld; //记住这里不加括号（有参数输入的时候才加入括号），这就等同于在HW卡面+\u0026amp; 下面这种定义方式便于我们理解：\n1 2 3 4 5 6 7 8 9 //等于下面这种方式 void(*cherno)() = HelloWorld; cherno(); // 调用函数。 // 通过4-5的参数对比，我们可以知道cherno就是一个函数的别名。 // 这种方式其实更规范的可以写成 :这里添加了参数的输入所以比较不一样 typedef void(*HelloWorldFunction)(int); HelloWorldFunction function = HelloWorld; function(8) 函数指针的使用场景：\n主要用于把function传入function，和lambda匿名函数好像有比较好的结合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void PrintValue(int value) { //Print cout } void ForEach(const std::vector\u0026lt;int\u0026gt;\u0026amp; values, void(*func)(int)) { for (int value : values) func(value); } int main() { std::vector\u0026lt;int\u0026gt; values = {1,2,3,4,5}; ForEach(values, PrintValue); } 智能指针（Smart Pointer） 非常重要，能用智能指针的情况下我们就不用传统的指针\n作用域:{} 参考资料1 ；参考资料2 唯一指针，能够自动的在作用域外就进行销毁（最基本的智能指针）\n1 2 3 4 5 6 7 #include\u0026lt;memory\u0026gt; // 下面这个是错误的，给个范例 std::unique_ptr\u0026lt;Entity\u0026gt; entity = new Entity(); // 这个是错误的！！！！！！！ //只能显式调用构造函数：正确↓ std::unique_ptr\u0026lt;Entity\u0026gt; entity(new Entity()); //另一种 写法：推荐写法：最好就这么写 std::unique_ptr\u0026lt;Entity\u0026gt; entity = std::make_unique\u0026lt;Entity\u0026gt;(); 共享指针，另一种智能指针，\n使用reference_count来进行引用指针的计数，对象的所有引用消除了以后（count=0），才进行销毁（delete）\n主要功能：\n管理动态创建的对象的销毁。它的基本原理就是记录对象被引用的次数，当引用次数为 0 的时候，也就是最后一个指向某对象的共享指针析构的时候，共享指针的析构函数就把指向的内存区域释放掉。就是一个对象可以有多个引用。\n1 std::share_ptr\u0026lt;Entity\u0026gt; sharedEntity = std::make_shared\u0026lt;Entity\u0026gt;(); 弱指针weak_ptr: 是一种弱化的共享指针，不会进行reference count\nhttps://blog.csdn.net/albertsh/article/details/82286999 它不会等到全部的指针都被销毁了才销毁，它会在指针销毁的时候就对对象进行析构，所以可能会有部分指针指向没有分配值的地址。\n**总结一下：**重要！！！\n所以只是当我们需要在一个heap上声明的对象，但是希望能在作用域外自动销毁的时候我们才应该使用智能指针。 也就是智能指针分配的数据空间是在heap上的，但是存储指针自身的空间是在stack上的 先思考使用unique point 在需要不同的地方共享的时候在考虑share pointer 避免使用new delete 实际上智智能指针就是对原生指针的一个高层封装，就是类似struct ，在struct 的destructor 调用指针指向地址的delete？ 看看视频中的代码。 Part 4 Class \u0026amp; Struct 面向对象 This Chapter 主要就是面向对象的编程逻辑，以及类和结构体中的一些知识点\n面向对象编程：这是一种非常流行的编程思想，这是一种编码的风格。\njave所有的一切都应该是一个class.\n类（Class） Class：和python是一样的，是一种将数据和function（method）组织在一起的一种方式。\n和namespace的区别是啥：namespace没有访问控制。\n一些基础用法和信息 比如玩家的属性，和玩家的一些function，就可以使用class的instance来定义多个角色，而不必重复的定义类似的方法和属性值。\n类中的function就被称为method\n可以使用大括号的方式来初始化赋值\n1 2 3 4 5 6 7 8 struct Vector2 { float x,y; }; int main() { Vector2 a = {2,3}; } 实际上可以在类内declaration函数，然后再类外用::namespace的方式进行定义\n当我们想要将Class or Struct传入Function中的时候，我们最好是使用reference \u0026amp;和Const，这样可以防止传入的类之类的被修改，同时也节省了memory，不需要额外的生成一个copy。\n建立一个Logging类：将warning Or Error 打印在控制台上，因为控制台永远不会出问题，对于debug很有帮助。\n继承所有在Entity中不是private的都会被player继承。\n访问控制（Visibility） public：可以在类外访问，也就是可以在类的外部随便定义，取出，或者修改。 private：只能通过类内的操作或者类内的函数，以及friends进行修改调用。 protect：类内或者继承类 friend的定义方式：在类内的public使用前置friend 去重载这个函数或者类别即可。就能访问私有变量了。\n类的构造函数和析构函数 C++ 类构造函数 \u0026amp; 析构函数 | 菜鸟教程 (runoob.com) constructors**：构造函数（可重载）**\n用于每个instance生成时候的初始化，我们可以通过不同的传入值来重载这个函数。\n名称和类名一致，不需要type。\n默认是存在constructor的（但是不初始化变量），如果我们不希望用户构建实例，我们可以将constructor写在private中，那么就无法使用该类别去生成一个实例。\n函数构造的初始化列表：\n构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。\n但是这种方式，需要我们按照成员函数的顺序去编写，他是默认这样执行的。\n类构造函数初始化列表 。\n这样假如我们成员中有类别实体，我们可以避免该类别实体进行重复的构造，浪费了性能。（可以用cout测试） 此外这样也可以分离初始化参数和一些其他的初始化指令操作（写在大括号里）。 Destructor**：析构函数**\n用于destory我们生成的object或者说instance；清除变量。\n在构造函数前面加~就是定义的方式。一般不需要显式编程 活到生命周期末尾（大括号之类的）会自动调用 如果New 就需要Delete才会调用 类的继承 继承的主要作用，是让我们拒绝duplicated，拒绝代码重复。所以我们就能在父类中放置通用功能，然后在子类中重载或者编写新功能。\n在子类的定义的时候：[public] 父类，父类2 如果函数的输入是（父类* a），那么所有的子类都可以输入来着 ：实际上是多态的因素，就是所有的子类都属于父类把，所以父类的指针可以代表所有的子类。 虚函数Virtual Function\n在父类中编写的virtual function就能在子类中选择覆盖重载\nVirtual function可以避免在特殊情况下，我们在子类覆盖定义了父类函数的情况下，还是调用了夫类中的同名函数的情况：它加入了动态分配的机制，通过存档虚函数 所代表的各种虚函数映射情况，便于我们找到正确的函数。\n实际上也就是在需要重载（override）函数前面加入一个virtual的关键字（在最前面）；同时可以在覆写（override）的地方加上override关键字（在声明的最后面，大括号的前面），但是这不是必须的，但是更具备可读性。\n但是需要额外的内存空间：需要表需要基类指向虚函数表的指针；\n需要额外的运行速度：因为每次调用虚函数，需要额外遍历虚函数；\n一般情况损耗不会太大，除非对于嵌入式设备来说。\nVirtual Destructors\n和virtual一样，为了我们在使用子类进行多态操作的时候，不会发生没有调用destructor导致内存泄漏的情况。所以就要再析构函数的时候virtual一下。\nInterface（PureVirtualFunction）纯虚函数\n纯虚函数也可以理解为接口，就是需要后续被实现的一些\n实际纯虚函数就是一种在基类中没有实现的函数：在Jave和C#这类语言中就被称作接口，也就是我们需要在子类中一定要重写的函数。（有时候我们需要每个子类都定义特殊的函数，基类的定义顶多就当作模板，不包含实现方法） 在基类中对虚函数的实现（{}）改成（=0；），就是纯虚函数了，如果我们想要使得子类能够实例化对象，我们就必须在子类中override这个纯虚函数。这种时候基类也不能被实例化了。 如果父类对祖父类的override了，那么我们可以直接继承父类就不用再覆写了。BTW：纯虚函数（和成员变量）组成的也叫做抽象类 类的多态 多态 https://www.runoob.com/cplusplus/cpp-polymorphism.html 其实就是用base的指针来指向子类的一种调用方式\n“This” 指针 this是指指向当前对象的指针，索引到当前的instance；\n用来调用当前类中的函数或者变量\n1 2 3 4 5 6 7 8 9 class Entity { public: int x,y; Entity(int x, int y) { this.x = x; } }; 复制构造函数以及浅拷贝深拷贝 基本概念 通常对Class进行复制或者等号赋值操作的时候，很多情况下会发生内存拷贝，这样会使用新的内存地址去存储新的相同数据，也就是建立一个副本，但是很多情况下是不需要的。（用等号的时候都是进行的copy）\n这种方式就是建立副本：\n1 2 3 Vector2 a = {2,3}; Vector2 b = a; b.x = 5; //不改变a 可以使用指针建立指针的副本，数据空间不进行拷贝；\n1 2 3 Vector2* a = new Vector2(); Vector2* b = a; b-\u0026gt;x 浅拷贝：以自定义的String为例 c++已经实现了，这就是个范例；\nmemcpy是内存赋值（赋值内存块）：在这里就是取代for loop 去copy value\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class String { private: char* m_buffer; unsigned int m_size; public: String(const char* string) { m_size = strlen(string); m_buffer = new char[m_size + 1]; //假设包含终止符的情况，但是这样就会对于非普通string的类别不太安全（它们可能不包括终止符） memcpy(m_buffer, string, m_size); } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; stream, const String\u0026amp; string); } std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; stream, const String\u0026amp; string) { stream\u0026lt;\u0026lt; string.m_buffer; return stream; } 基于终止符的不同情况，我们可以修改成：\n1 2 memcpy(m_buffer, string, m_size); m_buffer[m_size] = 0; 但是实际上这样可能会发生内存泄漏，所以实际上我们不应该忘记析构函数：\n1 2 3 4 ~String() { delete[] m_buffer; } 但是如果我们在这种情况下定义的string进行复制的时候，我们会发现，我们实际上是对类中所有的value进行copy，所以我们实际上拷贝了一个指针，然后再最终程序结束的时候，我们对同一个地址调用了两次析构函数，于是程序崩溃了。这就是浅拷贝。\n深拷贝：以自定义的String为例 我们想要的就是有一个指向新地址的新指针，然后指向的地址有一样的value。\n于是复制构造函数就被需要了，就是实际上我们是重新调用了一次前面的构造函数，去构造了一个完全相同的变量，而不是只是浅拷贝。\nC++实际上已经存在了一个默认了：我们可以直接声明，但是这实际上是浅拷贝，也就是默认的方式\n1 2 3 4 5 6 7 8 9 10 11 String(const String\u0026amp; other); //这个实际上是浅拷贝 == 下面的 String(const String\u0026amp; other) :m_buffer(other.m_buffer), m_size(other.m_size) {} or if you want to be more exciting... // 也等同于下面这个，都是浅拷贝 String(const String\u0026amp; other) { memcpy(this, \u0026amp;other, sizeof(String)); } 那么如果我们想要完全禁用浅拷贝：我们可以在声明后面加上=delete\n实际上就是通过构造函数的类型隐式转换（就是那个等号的重载来实现的），所以我们要弄一个深拷贝的话：\n1 2 3 4 5 6 String(const String\u0026amp; other) :m_size(other.m_size) { m_buffer = new char[m_size+1] memcpy(m_buffer, other.m_buffer, m_size+1); } 单例（singleton） 单例模式(Singleton)及其C++实现_FBeetle的博客-CSDN博客 单例是面向对象里面的一种编程模式，也就是某些类别只有一个例子：比如班主任，一个班只需要一个班主任。\n或者我们只是要提供一个通用的方法库这种情况下，可以使用这种编程模式。\n这就是一种编程方法，我们把东西都放到类中。然后使用类变量来调用global set of function 或者data.我们不需要进行实例化或者其他的操作、\n换句话说，我们就是把class 像namespace这样来用。\nSingleton 就是组织大量全局变量和static function的方法，将这些组合成一个blob。\n阻止实例化\n可以通过把构造函数设置为私有来阻止实例化操作，但是还是会存在缺陷，还是可以通过下面的操作来类似的实例化； 1 Singleton instance = Singleton::Get(); 但是这样的话会把我们singleton的数据都复制一次（每执行一次复制一次），所以我们需要去除复制构造函数来防止这种操作的实现。这样的话，我们最多就是使用\u0026amp;来使用一个别名进行这个singleton的调用（在上面那个定义加入\u0026amp; -\u0026gt;Singleton\u0026amp;） 1 2 public: Singleton(const Singleton\u0026amp;) = delete; 标准的单例调用模式存在一定的麻烦（代码块1），如果我们希望去掉Get来优化调用的过程：可以在定义的时候修改成（代码块2） 1 2 3 4 5 Random::Get().Float(); // 先获得单例，然后调用函数 // 或者使用下面的方式 auto\u0026amp; random = Random::Get(); float number = random.Float(); 1 2 3 4 public: static float Float() {return Get().IFloat();} private: float IFloat() {return m_RandomGenerator;} 单例通常使用::在外面定义，就像下面大图的nullptr\n但是如果我们不希望这样（不希望自己在外面进行一个初始化）我们可以写成（写在get里，那么初次调用的时候会生成类static的singleton）（这也是结合了后面修正的最终版）（分析一下这些static）第一次生成，后面全是singleton引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Singleton_origin { private: // 构建一个通用的单例指针 static Singleton_origin* s_Instance; public: // 通过Get返回指针所指向的singleton对象 static Singleton_origin\u0026amp; Get() { return *s_Instance; } // 每个Singleton_origin class 的实例中的通用Function void hello() { } }; Singleton_origin* Singleton_origin::s_Instance = nullptr; // TYPE2: 实际构建一个singleton怎么去做 // 这一步还没有对复制的情况以及调用的麻烦的情况进行优化，结合下面的最终版。 class Singleton { public: static Singleton\u0026amp; Get() { // 这个静态的instance只会在初次调用这个GET的时候生成，后续的话就是直接return他了。所以这样写就行 // 需要注意的是，由于我们返回的类型设定为reference（\u0026amp;），所以如果我们去掉的了↓的static关键词，就会出错 // 因为reference返回的是别名，也就是需要这个值一直存在，不然在后续的使用中会出现问题，而不是返回一个copy，当然也可以去掉函数中的\u0026amp;。 // 所以我们需要借助static 关键词，来延长这个instance的声明周期，才会被正确的使用。 // 这种只有第一次起到作用的方法，就适用于很多需要初始化的场景。 static Singleton instance; return instance; } void hello() {} }; int main() { //Singleton_origin::Get().hello(); Singleton::Get().hello(); std::cin.get(); } 最终版 集成了上面的全部优点，简化了调用，不会进行复制，不需要在类外进行单例的初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public: Random(const Random\u0026amp;) =delete; static Random\u0026amp; Get() { static Random instance; return instance; } static float Float() {return Get().IFloat();} private: float IFloat() {return m_RandomGenerator;} Random(){} float m_RandomGenerator = o.5f 结构体（Structure） 实际上就是一个默认是Public的Class，Class是反过来的。\n什么时候该用结构体什么时候该用类？\n默认情况下：class是私有的，类或属性（需要共有的时候要public）；而Struct是默认公有的（需要私有的时候要用private）；\n这是唯一的区别，但是在代码实际使用的时候还是有所不同的：存在的原因\n保持和c之间的兼容性 或者我们想要全都用public的时候。 自定义使用场景（规定编程风格）\nPlain old data（pod）的时候喜欢更多的用struct，就是仅仅只代表一堆变量的时候。比如说定义向量，这中类似的数据体的时候 “我将永远不会对struct使用继承” 公用体（Unions） 是一种类似Struct的结构，但是同时只能存在一个member（变量），无论你声明了多少个，实际上都是共享内存空间（地址）的，所以如果我们declaration的Type不同，就可能会出现Type Punning的现象，实际上也可以理解为一个变量的多个别名？\n菜鸟教程 ，CPP reference 但是通常匿名使用，也就是只使用其只能有一个member的特性，很多时候会放置再Struct 之类的里面。和Struct一起匿名使用是不影响我们的调用层级结构的 存储空间的大小以最大的成员作为标准好像 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct Vet2 { float x,y; }; struct Vet4 { union { struct { float x,y,z,w; }; struct { Vet2 a,b; }; }; }; // 这样的话 Vet4 v = {1.0f,2.0f,3.0f,4.0f}; //v.x 实际上和 v.a.x 是一样的,他们共享了一样的内存地址，这个和type punning有点像。 结构体绑定（Structured binding） 这一部分实际上解决的是，我们使用struct的方式来实现多类回归的情况：[linkto](#Func: 多值输出 (Multiple Return)),所以参考那一部分就好了\nPart 5 WorkFlow\u0026amp;逻辑控制 This Part 介绍一些算法的逻辑控制以及workflow控制，包括循环，条件，函数，线程之类的，控制工作流的内容。\nFunc： 基本的函数定义（Functions） 其实没啥特别好说的就是：\n一般在header 中写入declaration，然后把definition写在Cpp files里面。 其实定义的全局变量在function中也是可以直接调用的，不需要重新导入之类的。这个应该都是懂的吧 :star: Always pass you object by const reference!总是使用const和reference传入我们的参数。 需要副本就复制. Func： 匿名函数（Lambdas） 参考资料：lambda详细教程 ，捕获值理解 匿名函数实际上是用于基本上一次性的函数：我们不需要真正的（实际的）对函数进行定义。\n基本定义方式：[capture](传入参数){实现内容}\n1 2 3 auto lambda = [](int value){std::cout\u0026lt;\u0026lt;\u0026#34;Value:\u0026#34;\u0026lt;\u0026lt;value\u0026lt;\u0026lt;std::endl;}; // 调用的时候 lambda(5); 需要传入外部数据的时候就需要使用Capture，比如main中的值，用\u0026amp;or =；如果我们要使用Capture的时候，我们可能要#include\u0026lt;functional\u0026gt;\nQuestion: lambda的传入的参数默认是不能修改的，要修改的话我们需要加入mutable关键词（在传入参数和实现内容之间）\n其他的lambda实例：\n1 2 3 4 5 std::vector\u0026lt;int\u0026gt;values = {1,5,4,2,3}; std::find_if(values.begin(), values.end(), [](int value){return value\u0026gt;3;}); // it actually is👇 返回第一个\u0026gt;3的值 auto it = std::find_if(values.begin(), values.end(), [](int value){return value\u0026gt;3;}); std::cout\u0026lt;\u0026lt; *it \u0026lt;\u0026lt;std::endl; Func：三元运算符（Ternary Operator） 条件表达式？表达式1：表达式2\n这种形式实际上和python中的如下的表达式一致\n1 2 Flag = True a = 5 if Flag else 10 c++中表示为如下\n1 2 s_Speed = s_Level \u0026gt; 5? 10: 5; s_Speed = s_Level \u0026gt; 5? s_Level \u0026gt;10? 15: 10: 5; Func: 多值输出 (Multiple Return) include新报本的结构体绑定方式。\n由于C++本身的Type机制，我们没办法在func中同时直接return不同类型。\n而如果我们试图return同一type的多个value的话，我们实际上可以用returnvector或者array的方式实现，当然这就是一种比较蠢的操作了。\nstdarray或者传统的array\n好像也可以使用tuple的方式{v1,v2}同个类型的多个值\n推荐：当然聪明一点的方法就是，我们定义一个struct，包含我们需要的这些所有type，然后return这个struct就好了\n还有一种方法就是使用**\u0026amp;来传递参数**，就不需要return了，设置为void就可以了\n也可以用指针的方式，指针方式的好处就是可以是空值\nC++的默认指定方式：tuple和pair\n用tuple类型的方式操作起来有点麻烦啊如下，但是也可以混杂多种类型输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #import \u0026lt;tuple\u0026gt; static std::tuple\u0026lt;type1,typw2\u0026gt; func() { //return std::make_pair\u0026lt;type1,type2\u0026gt;(var1,var2); //上面的type指定有时候也能省略 //或者使用下面这种方式,上面那种实际上是pair类型的返回把 return {var1,var2} } auto [name, age] = func(); // c++ 标准更新以后tuple的使用方法变得更加的好用了。 ------------------👆NEW Version \u0026amp; Called Structure Binding---------------- --------------------------------👇OLD VERSION \u0026lt;c++17---------------------- //std::tuple\u0026lt;type1,type2\u0026gt; a = func(); ////或者 //auto a = func(); ////oldversion要取出元素的时候我们还需要 //std::string\u0026amp; name=std::get\u0026lt;0\u0026gt;(a); //这里可以用\u0026amp;防止动态的内存copy的情况 //std::get\u0026lt;1\u0026gt;(a); ////所以这边建议使用struct //// 取出元素的第二种方法. //std::string name; //int age; //std::tie(name,age) = func(); Threads：线程操作 函数编写过程中的多线程操作和线程管理，下面是一个典型的例子，我们好像也可以使用进程去建立一个线程对象。\n使用线程主要的目的是为了1. 完成单线程没法完成的事情以及2. 优化一些算法的运行速度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; //支撑线程的基准库 static bool Flag = true; // 编写一个函数用于子进程的执行，通常使用函数指针的方式调用 void DoWork() { while (true) { std::cout\u0026lt;\u0026lt;\u0026#34;Working... \\n\u0026#34;; std::this_thread::sleep_for(1s); //休眠这个进程1s，防止疯狂打印 } } int main(){ std::thread worker(DoWork); //使用一个进程去执行Dowork std::cin.get(); Flag = false; //使得子进程得以结束。 worker.join();//等待到子进程结束，再继续主进程 std::cin.get(); } 如果我们再调用某个进程的时候想看当前的ID，也可以再运行的函数中加入STD::this_thread::get_id()得到当前进程的ID。当然我们每次运行可能都是不一样的。\nThreads：多线程管理 这一部分没有英文字幕，缺失了很多信息，后续使用到的时候进行补充和修正把。\n线程并行；异步；等等的多线程管理。std::async\n对于independent的Application和Function Part，实际上很多操作我们可以在cpu和memory上并行进行，对不相关的任务进行分布（异步），对相关的任务有所约束（同步），合理的对进程进行调度，能够使得我们对资源有更充分的利用，同时也能提升程序的运行速度。\n对于不依赖于运行次序的一些操作：比如载入很多模型或者数据（num_worker）\ncppref参考页面 ；异步合同的概念 ；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;future\u0026gt; static std::mutex s_meshesMutex; //解决1. 针对变量定义一个互斥锁 static void LoadMesh(std::vector\u0026lt;Ref\u0026lt;Mesh\u0026gt;\u0026gt;\u0026amp; meshes, std::string filepath) { auto mesh = Mesh::Load(filepath); //解决1. 使用lock，锁住我们可能需要修改的这个变量，使得一个thread在进行修改的时候，🔒（其余不能对该变量进行操作），修改完成解锁🔑； std::Lock_guard(std::mutex) lock(s_meshexMutex) meshes.push_back(mesh); } for (const auto\u0026amp; file : filelist) { //1. 异步使用文件载入，但是这样会出现问题，就是当我们两个进程同时进行修改操作的时候怎么办？ m_Futures.push_back(std::async(std::lauch::async,LoadMesh,m_Meshes,filelist)); } 为了防止同时的写入操作，我们还需要Lock操作去锁住可能会修改的变量。同时好像异步程序的返回值比较特殊，所以我们需要在头文件中进行如下定义：\n1 std::vector\u0026lt;std::future\u0026lt;void\u0026gt;\u0026gt; m_Future; 此外我们可以控制是否执行异步程序（老办法了）\n1 2 3 4 5 6 #define ASYNC 1 #if ASYNC ASYNCfunc() #else func() #endif 最后我们可以在debug的时候 windows ，parallel stacks找到进程表（很吊）。好像也可以在执行代码的地方跳到正在执行的某个进程\nBenchmark：基准测试 在运行程序的时候如何监控我们该代码的性能（运行时间等等），或者测试新方法的方式。这里给出了他的方式。实际上有很多不同的方式。\n_debugbreak(): 类似python中的raise exception\n1 2 3 4 5 6 7 8 9 10 11 // 简单的范例， int main() { int v = 0; { Timer timer1; func() } ...; _debugbreak(); } 我们要确信的一点是，计时器是否真正的测量了运行的时间，因为有时候编译器会直接进行中间态计算，所以实际运行的时候，就会没有计算到开销。\n测量share pointer和unique pointer\nunique\u0026gt;make share \u0026gt;new share\nVisual Benchmarking （可视化） 使用chrome:://tracing 在浏览器中进行可视化,这一课作为补充资料把。暂时不需要用这种方式\nSwitch：case 分支 一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。\n1 2 3 4 5 6 7 8 9 10 11 12 switch(expression){ case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s); } Workflow：Conditions and Branches 条件和分支 if 指令实际上是检查值是否为0，0 == False， !0 ==True;\nKeyword：if; else if; else;\nLoops: For and While 循环定义 For 循环其实就是 （声明变量；condition；迭代规则）\n我们可以直接在括号里写，也可以全部写在外面\ncondition要声明，但是可以在外面定义\nWhile （condition）\nDo {\n}While（condition）\n即使条件为false也至少能执行一次\nWorkflow: Control Flow (contiune, break , return) 循环控制 这几个关键词的使用和含义基本是和Python一致的，但是这里的Break还用于switch\nWorkflow： Iterators迭代器 迭代器的一些基本的参数：first（key），（当然这个是以这种形式存在的是时候才有的）second（value）；it本身是以指针形式存在的？\n是一种对dataset中的数据进行迭代的方式，这就是一种迭代器，有点像是运算符重载，通常用于对数据结构进行迭代（遍历）。\n1 2 3 4 5 6 7 8 9 10 11 //最常见的方式就不再说了，。vector.size()来循环就行了 #include \u0026lt;vector\u0026gt; // type1 内置的迭代器，也是常用的使用方式。 std::vector\u0026lt;int\u0026gt; values = {1,2,3,4,5}; for (int value : values) std::cout\u0026lt;\u0026lt;value\u0026lt;\u0026lt;std::endl; // type2 使用内置的iterator，还有反向的iterator，但是正常人谁用这个啊 // 这里注意到it是一堆指针，我们如果要取值的话需要解除指针。* for(std::vector\u0026lt;int\u0026gt;::iterator it = values.begin(); it != values.end(); it++){ std::cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;std::endl; } 那么我们如何对于无序的数集(实际上unorder_map是Hash的C++实现)来进行迭代或者遍历呢？，看下面这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;unordered_map\u0026gt; using ScoreMap = std::unordered_map\u0026lt;std::string, int\u0026gt;; //std::unordered_map\u0026lt;std::string, int\u0026gt; map; ScoreMap map; map[\u0026#34;aiken\u0026#34;] = 5; map[\u0026#34;c++\u0026#34;] = 2; // 由于无序图没有index，经典的就是使用这样的方式 for (ScoreMap::const_iterator it = map.begin(); it != map.end(); it++) { auto\u0026amp; key = it-\u0026gt;first; auto\u0026amp; value = it-\u0026gt;second; //second 应该指的是value把，但是对于多元素的hash怎么处理？ PRINT_FUC HERE. } // 仿照上面那种更方便的方式来编写迭代的话(这里的auto 实际上是pair的形式) for (auto kv : map) { auto\u0026amp; key = kv-\u0026gt;first; auto\u0026amp; value = kv-\u0026gt;second; PRINT_FUC HERE. } // 当然还有一种梦寐以求的方式，后续可能我们会最常用的方式 for (auto [key, value] : map) { std::cout \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } 编写我们自己Structure中的Iterator：\n假设：这是不是应该使用类似linklist之类的方式，将数据通过类似指针的方式迭代的串起来？\n这一部分太长了，还是参考视频94 把，我就直接重载[]和size通过for去做迭代器了，建议加入相关的.cpp，不要集成在文档中。\n这一部分其实可以帮助对一些重载，还有一些vector机制有一个更好的理解，以及一些动态的内存管理，可以自己在后续编写一下试试。\nWorkflow: Continuous Integration CI （持续集成） 每次commit后都build 以及run \u0026amp;test就是CI吗？\n“持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译 ，发布，自动化测试）来验证，从而尽早地发现集成错误。”\n使用：jenkins（第86课）\nWorkflow: Static Analysis(静态代码分析) 也就是一些分析工具，比如pylint之类的东西；\nCherno推荐：PVS-Studio\nPart 6 Memory 资源管理 This Section 我们从memory出发来谈及关于Stack，Heap之类的内存管理和优化方法,以及编写的safe。\n粗略：Heap和Stack的区别 ；进阶1：C++中内存分配，堆（Heap）与栈（Stack）区别 为什么c++中要分为heap（堆）和stack（栈） Stack vs Heap: C++中的内存栈与堆 char* buffer = new char[8] 定义一个8个字节的内存空间，并返回指向内存开始的地址的指针\n基本概念：stack和heap都是内存（RAM）中实际存在的单元\nstack存在预定义的长度: 2M左右。 heap虽然已有预设的默认值，但会随着我们的Application去更改大小 目的都是为我们的程序和全局或者局部变量提供存储空间。 不同的内存分配方式。 memset可以用来填充内存块 memcpy 内存拷贝，拷贝内存块 **基本定义方式：**前面一般是定义在stack上的，后半部分是定义在heap上的\n1 2 3 4 5 6 7 8 9 10 11 int main() { int value = 5; int array[5]; ClassA vector; int* hvalue = new int; *havalue = 5; int* harray = new int[5]; ClassA* hvector = new ClassA(); } 分配方式上的区别（主要是new）\nstack上分配的内存空间是连续的，实际上就是栈顶的指针移动需要的距离，然后重新赋予数值。每一个在另一个上面。 所以这样分配会比较快，我们只需要在寄存器上移动指针的地址就可以了 {}实际上就是一个stack，超出这个作用域后，栈内的数据会自动销毁，也就是实际上就是将指针还原到了作用域开始的地方。Free操作实际上只是指针的移动。 heap上分配的内存空间是随机的。 实际上会call malloc，给你一个指定大小的内存块，同时也会管理一个需要free-list的内存列表（也就是已经申请了的列表）， 所以在heap上分配空间实际上是一整套任务，而在stack上实际上就是指针移动，他们两个的效率是完全不一样的。但是有各自面对的状况吧。 需要大量数据，或者说是，需要延长生存周期的话都需要用heap。 在debug model中的汇编之类的机器代码是没有经过精简的，但是release后vs会自己优化。 New：Keyword For Mem内存关键词 使用new实际上是一系列命令（运算符重载），包括在空闲的内存块中占用一块指定大小的内存，所以会需要时间；\n基本准则：有new有Delete；无new 无delete\nnew经常和数组一起使用来获得指定大小的heap空间 new在使用的时候也会调用constructor（构造函数），相应的delete； new -\u0026gt;delete; new [] -\u0026gt; delete []; 1 2 3 int* b = new int [50]; Entity* e = new Entity[50]; //这种情况下同时会调用构造函数 //虽然我们可以用malloc指令定义，但是这种方式不会调用析构函数，所以千万不要用这种方法。 具体的底层原因：\nnew底层其实是call了malloc，malloc是memory allocation的简写，从名字也可以知道它负责分配内存，delete则调用了free()。区别是new和delete不仅管理内存，还会调用constructor和destructor，另外它们都是operator，所以你可以重载它们，做一些有趣的事情。\n对了，new【】和delete【】其实另两个operator，它们做的事情稍微有点不一样，你调用new【】的时候，必须要指定一个size，但调用delete【】的时候，并没有指定size，它怎么知道delete多少呢？这是因为new【】不仅分配了所需要的内存，还会多分配一个额外的空间，来存储这个size，所以以视频中的举例，它所做的是分配这样一块内存【8, 0, 0, 0, 0, 0, 0, 0, 0】，连续的，但是多一块在最前面，但是return给你的是跳过那块内存的地址，比如malloc返回的是0x1，但new【】给你返回的是0x1+2（我记得它分配的是一个word（一般是short）的大小，具体大小需要看系统），然后在delete【】的时候，它会往前推一个word，因为它知道前面一个word肯定是size，从而拿到size，进而delete所有）\n什么时候通过New来定义实体（instance）\n就是如果我们希望在一个Function中定义类的实体的时候，为了延长生命周期，我们需要将实体定义在heap上\n或者是class 规模太大，但是stack太小了，所以我们要借助heap的存储空间\n1 Entity* entity = new Entity(\u0026#34;Cherno\u0026#34;); Safety：使用智能指针的情景 什么样的程序是safe的？减少崩溃和内存泄漏的情况，也就是让Code尽量不要越过需要的边界。This Part is about Smart Pointer。\n实际上安全性和内存分配是分不开的。\n对自己所有allocated的memory负责，所以智能指针特别屌，应该**100%使用智能指针，不要仅仅使用原生指针（Raw Poniter），能不用就尽量不用。**智能指针我们就不需要担心delete或者内存泄漏等等的问题了。 Raw Poniter在我们使用的小规模程序的时候偷懒，因为只要使用※，他不安全，就只是好读和简单。 所以就是，使用smart pointer，当然在确保安全的情况下，我们也可以用raw pointer自由选择反正。优点和缺点就是这样了。 Track Memory Allocation：内存申请跟踪 优化跟踪内存管理对于计算机的性能来说相当重要，特别是我们要知道我们在哪里分配了数据。\n虽然heap的space比较大，但是在性能至上的环境中，可能heap不会是一个最佳的选择。\n智能指针会在heap上分配内存，（std::string都是分配在内存中的）\nEasy Way：\n这一部分能够简单的嵌入我们的任何project；(void* 存储的就是一个内存地址)\n基本思路：重载我们的new 操作符;\n1 2 3 4 5 6 import \u0026lt;memory\u0026gt; void* operator new(size_t size) { std::cout\u0026lt;\u0026lt;\u0026#34;Allocating\u0026#34;\u0026lt;\u0026lt;size\u0026lt;\u0026lt;\u0026#39;Bytes\\n\u0026#39;; return malloc(size); } 那么当然我们也可以重载delete去检测内存的释放情况\n1 2 3 4 5 void operator delete(void* memory, size_t size) { std::cout\u0026lt;\u0026lt;\u0026#34;deleteing\u0026#34;\u0026lt;\u0026lt;size\u0026lt;\u0026lt;\u0026#39;Bytes\\n\u0026#39;; free(memory); } 那么最方便的实现方法就是我们使用一个struct来统一管理我们的内存分配情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct AllocationMetrics { uint32_t TotalAllocated = 0; uint32_t TotalFreed = 0; uint32_t CurrentUsage(){return TotalAllocated-TotalFreed;} } //实例化全局架构 static AllocationMetrics s_AllocationMetrics; // 然后将上面的new和delete中的print改成+= 和-= static void PrintUsage() { std::cout\u0026lt;\u0026lt;\u0026#34;usage::\u0026#34;\u0026lt;\u0026lt;s_AllocationMetrics.CurrentUsage()\u0026lt;\u0026lt;\u0026#34;...\\n\u0026#34; } Part 7 How to make C++ run Faster 算法或者进程优化的部分，这一部分在做题的时候慢慢的进行填充把，在学习的时候先选择性的看看，实际上应该是Part6的延申，逃不脱资源管理的部分、\nTODO：（已知可以但是应该暂时没用）\nstd::async （应该是用于进程优化） 79课 80 83：string优化 run string faster 优化string的运行速度 string会在heap上allocated，所以对于性能优先的情况下不是特别推荐的,可以通过下面的方式查看heap申请。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void PrintName(const std::string\u0026amp; name){} // 想要看空间的声明，重载new就对了，看Part6 static uint32_t s_AllocCount = 0; void* operator new(size_t size) { s_AllocCount ++; PrintHere; return malloc(size) } PrintName(const std::string\u0026amp; name){} int main() { name = \u0026#34;aiken\u0026#34;; Print(name); //copy一次 std::string name = \u0026#34;aiken aiken\u0026#34;; //copy std::string firstname = name.substr(0,3); //copy std::string lastname = name.substr(4,9); //copy } 但是加入我们只是想要一个很简单的输出“”，不希望发生再次的construct，来增加一个string的heap空间。甚至我们使用substr()来输出其中的一部分，也会copy（allocation）一次原本的string。\n避免这样无意义的Copy，只是要一个指向原数据内存地址的指针，以及size把，我们可以很容易写一个这样的类，但是在C++17中官方集成了把👇\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 PrintName(std::string_view name){} //这样以后print（“”）也不会分配了，原本的情况，执行print甚至都会复制一份。究极不合适 std::string name = \u0026#34;aiken aiken\u0026#34;; //allocation only //3可以修改成5 就没有allocation了,但是5的话 6，7的c_str()要去掉 const char* name = \u0026#34;aiken aiken\u0026#34;; //not allocation std::string_view firstName(name.c_str(),3); std::string_view lastName(name.c_str()+4,9); print(firstName); //这种类型也不会再发生复制了 print(LastName); print(\u0026#34;aiken aiken\u0026#34;); ----------------------------------整理如下-------------------------------------- //只在定义的时候发生一次赋值。 printname(std::string_view name){} std::string name = \u0026#34;aikenaiken\u0026#34;; //allow 1(copy happen) std::string_view firstName(name.c_str(),3); std::string_view lastName(name.c_str()+4,9); print(firstName); //这种类型也不会再发生复制了 print(LastName); print(\u0026#34;aiken aiken\u0026#34;); Somthing Else 无题 畅所欲言，或者等待归类。\nsizeof通常用来获取数据的存储空间； strlen():获取const char*的长度 alloca(size)：再当前地址内存分配；所以我们可以类型转换指针（int*） size_t:可以存储各种类型大小的值,size type constexprhttps://www.jianshu.com/p/34a2a79ea947 \\:编写代码的时候的换行续接符号 wandbox.org ：在线编译网站\nVisual Studio 表达式的编译顺序是从右到左运算\nArgument Evaluation Order 参数输入顺序（面试？） 传入参数实际上可以是传入一个函数或者是一个表达式，我们应该规划一下这样的输入。（和++相关）\ni ++ : 先传递在增长 ，++i：先增长在传递把\n(undefine behavior: 意味着这种方式实际上没有被定义，也就是说是一种不可控的行为，下面是一种实例)（切换这种++的位置也是）\n1 2 3 4 5 6 7 8 void Psum(int a, int b) { std::cout\u0026lt;\u0026lt;a \u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;b \u0026lt;\u0026lt;\u0026#34;=\u0026#34;\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;std::endl; } value = 0； Psum(value++,value++); //这是一种不可靠的编写方式,这个输出是不确定的，也就是一个不可靠的结果。 //哪个在线编译网站会告诉我们这个的编写是不确定的。有warning 正确答案是这种实际上是C++没有规范的，我们没法得到真实的值，但是再C++17中要求：\nThe Postfix-Expression is Sequenced before each expression in the expression-list and any default argument。\n也就是他们需要被一个接着一个的运行。这个其实没有太听清。\nhttps://blog.csdn.net/samantha_wang/article/details/46942343 https://blog.51cto.com/8681495/1416759 也不要写像这种的\nv[i] = ++i;\n","permalink":"https://hugotest-phi.vercel.app/posts/cpp/","summary":"\u003cp\u003ethis notebook is based on Cherno‘s Video Class in \u003ca href=\"https://www.youtube.com/watch?v=wXBcwHwIt_I\u0026amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb\u0026amp;index=62\u0026amp;ab_channel=TheCherno\" target=\"_blank\" rel=\"noopener\"\u003eYouTube\u003c/a\u003e\n；if there is sth get confused，I can \u003cstrong\u003erecheck\u003c/strong\u003e the video which talk about it, or \u003cstrong\u003ejust google it\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethis is not totally for newbie, so some basic information we should search it\u003c/li\u003e\n\u003cli\u003eAnd this is a important \u003ca href=\"https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5\" target=\"_blank\" rel=\"noopener\"\u003ewebsize\u003c/a\u003e\n to tell us basic info about C++.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e\u003cstrong\u003eToDo:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e using c++ and Python to finish the leetcode.\u003c/li\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e review data structure when we code.\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e eorganize the notebook by onenote** and leetcode\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e 后续可能会添加 Effetive C++中的相关内容\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e C++ Switch\u003ca href=\"https://www.runoob.com/cplusplus/cpp-switch.html\" target=\"_blank\" rel=\"noopener\"\u003e语句\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eAttention：\u003c/strong\u003e\u003c/p\u003e","title":"Cherno的cpp教程笔记"},{"content":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r主要是limited labels \u0026amp; Few Samples \u0026amp; Data programing Weakly supervised learning\nsemi-supervised in video field\nif we can recoding this work?\n多指标下降（LOSS的耦合或者循环的选择）、相关的CV最新论文等等会在后续关注\n元学习、浅层神经网络的概念等等 semi-supervised\nPART1 Limited Labels （base on LiFeiFei‘s reference） in this part we may list the paper which is useful for my recoding.\n还有一些其他重要的可能在对论文进行重新精读的时候要记得注意reference：就比如说在loss变换和决策树生成那一块。\ndistant supervision(it\u0026rsquo;s kind of early) can be another baseline for our method, we need to understand how this method work for that situation\ndistant supervisor到底是什么机制可以去CSDN什么的看一下\nTransfer Learning\\label propagation算法也是这一块重要的baseline\nBaseline ：scene graph prediction with limited labels\nreference：\n×Induction of decision trees if want download, try google it Pattern Learning for Relation Extraction with a Hierarchical Topic Model maybe we\u0026rsquo;ll need this paper,when we try to recoding.\nnope.当我们写论文需要理论基础的时候可能需要， √Data Programming: Creating Large Training Sets, Quickly it\u0026rsquo;s important to see if this article have same idea with me? it\u0026rsquo;s kind of learning paradigm,\n是一种构建数据集中，标注数据的范式，通过这样的method可以对多种labeling function进行整合，同时减少标注的误差和overlap情况的解决。后续我们实现方法的时候可以参考一下这个的数学理论，帮助在实际中进行应用。\n（本文中对这里的noise-aware的损失函数进行了应用，使其适应概率标签从而抑制噪声。）\n严重怀疑这是snorkel算法中的引文，直接引用过来\n×Knowledge-Based Weak Supervision for Information Extraction of Overlapping Relations figure out how can knowledge-based benefit weakly supervised learning ?\nnope. NIP method. 运用语言结构，类似于发的东西，来对文本进行补全。如果我们需要了解基础知识怎么使用，可以尝试参考。 ※Realistic Evaluation of DeepSemi-Supervised Learning Algorithms NIPS 2018\n深度半监督学习的现实性评估：公布了统一的重新实现和评估的平台（方式？），（针对于算法在生产现实之中的适用性发布的一个标准。）\nbased on analysis of image algorithm：半监督的方法通过对未标注的数据中的结构范式进行学习，从而降低了对标注数据的需求，也就是说输入的数据是大部分未标注和少量标注数据，就可以逼近完全标记数据集的表现效果。[32,50,39]，这几个针对于图像情况的方法。\n分析后发现，他们评估算法的方式并不适用于将算法推广到实际的生产领域中，于是我们对于评估ssl算法的方式提出了一些新的看法。\n说的就是以前这些ssl在算法的效果上可能作弊的一些方面，如果使用这样统一的标准对算法进行评估的话，才能使得算法得到一个好的效果，此外他也提出了一些ssl在训练过程中的一些棉铃的问题：比如说假如我们把其他类别的数据，混入其中的话，那么所有这些ssl的算法的效果都会受到极大的影响。 ×Learning from labeled and unlabeled data with label propagation 这是一个很重要的方法，但是没想到这个竟然这么早？（math or algorithm？）（2002）（最近读的另一篇论文好像就借鉴的这个思路）\n将数据从标记的高密度区域向未标记的数据区域进行传播，这一篇论文的话，主要存在一些数学推导，我建议从19的那一篇新的标签传播开始阅读，通过这篇来补全需要的数学基础，如果另一边已经讲述的很完备了就不需要这篇的内容了 PART2 key words searching（such as few samples etc.） limited labels on github：\n※microsoft\u0026rsquo;s work:github |paper i think it’ll be important one，we‘ll need to think carefully about this.seems like they have already make it great.\n思路上可以给我们启发：提出了一个针对few samples的通用框架（通过度度量传播来进行的label propagation方法），来解决无论是transfer、semi-supervised、few-shot这样解决的问题，并有了一个巨大的提升。\n将少量标记的label propagation到大量的未标注数据上，从而创建训练数据。主要贡献：用于传播的相似性度量从其他相关域转移时，这样的标签传播方法非常有效。\n这个算法框架可以细读一下，后续关照一下具体的思路和实现 ※The Limited Multi-Label Projection Layer:github |paper CVPR19 LML projection Layer 是一种几何的K类预测，用来再多类别少样本的情况下取代softmax的一个映射函数，这一篇主要是数学理论，在最后实现的话，要进行一定的参考和学习。 ※Learning Classifiers for Target Domain with Limited or No Labelspaper ICML2019\n从所有的训练数据中学习一个混杂（mixture）的“原型”，然后将原型撕裂成一个个part/part-type（用attention机制来实现）、 然后通过多个part的概率组合来表示一个new instance。（use MACNN）。（即将变成低维的概率向量组成的编码=低维视觉属性LDVA）到时候找个图把这些方法全都对比一下。md花样太多了，玩晕了。 Hand and Face Segmentation with Deep Convolutional Networks using Limited Labelled Data(论文还没出)github 一些奇奇怪怪的github项目github1 limited labels on google scholar：\n√Large Scale Sentiment Learning with Limited Labels SIGKDD2017\n他是通过对tweet的表情数据进行标注，建立的数据集，使用了self-learning和co-training两种WSL的方法，来对未标注的数据进行标注两种方法的具体注解我已经放在pdf上了 ×[Large-Scale Video Understanding with Limited Training Labels](google it)\n这尼玛是本综述的书，吓老子一跳 few samples on google scholar：\n×Learning Convolutional nerual networks from few samples 2013\nthis paper use the method of pre-trained (transfer learning instead nowadays) to get a satisfatory result.\n这篇文章太早了，需要的话再重新说吧。先不看 ※※Few-Shot Learning with Graph Neural Networks （two-version）（2017）（2018ICLR）\nusing graph network to implement semi-supervised. this research prove that the graph method perform well on \u0026lsquo;relathinal\u0026rsquo; tasks.\n定义了一种图模型的网络框架来实现few-shot等few samples的任务，表明这样的图网络架构能够很好的实现关系这样的处理，也很容易在这样的情境下进行拓展，这也是一个框架设计的任务。但是我们能够从中学习一下图模型如何针对关系网络进行学习和训练的，以及探讨一下图网络的优势。这一篇文章也探讨了度量学习和元学习的一些东西，这一篇可以给一个高的阅读优先级。 data programing:\nend Label propagation:\n※Active Frame Selection for Label Propagation in Videos ECCV2012\ndecide how many frames we\u0026rsquo;ll need to mark by human for the best result .\n文章通过动态规划来选定视频中的k个frame，作为key frame，通过这几个frame的人工标记，能够最大的降低算法在label propagation中的标记误差，（其中num of k和误差的权衡还不是特别清楚）取代了以往这个key frame选择的随机性，带来更好的性能。\n此外这个方法还关注于帧数选择的动态性，由于视频的独立性，所以固定帧数的选择不一定是合适的，应该根据视频本身的特性来选择才是更好的。（但是不知道时空复杂度怎么说）\n值得一提的是，文中还提到了一些辅助人工标注的算法，这些算法有时间的话可以通过CSDN去调研一下。（防撞车） √Dynamic Label Propagation for Semi-Supervised Multi-class Multi-label Classification ICCV2013\n是一个基于图的方法，和eccv2012一致的地方在于，都认为视频任务的标注任务中，动态规划的part是需要的，上一篇用动态规划来实现keyframe的选择，这篇文章这是完全的semi-supervised的任务，他用dynamic的办法，动态的对多标签和多类信心进行拟合，从而动态的去更新相似性的度量，使用KNN来保留数据的固有结构。 ※※Label Propagation via Teaching-to-Learn and Learning-to-Teach 2016TNNLS\n一个迭代的label propagation方法，结合了一定self-learning 的机制，从dataset中迭代的选出易于分类的部分，然后通过不断的对这种易于标注的数据中去self-learning，从而提高分类器的性能，然后逐步的去针对模糊边界进行propagate。感觉是一个好方法\nintro中简要的对比介绍了这之前的一些label propagation方法，包括DLP。 based on the sota LPmethod，所以之前的一些可能可以不用看了， ※※※Learning to Propagate Labels: Transductive Propagation Network for Few-shot Learning ICLR2019\n结合了meta-learning/label propagation/transductive inference的方法，细看细看，这一篇一定要细看。太强了兄弟。intro里面也包含了很多的东西。 PART3 few-shot learning etc.（including one-shot learning) 淦淦淦，这尼玛比的定义能不能统一一哈\nFew-Shot Learning:\n√Prototypical Networks for Few-shot Learning 2017\\NIPS\n思路上好像和19年的cvpr那片有点像，先学习一个overall 再通过度量空间对newdata进行适应性的分配和训练。通过intro，我认为更像是一个简单的embedding的办法，将sample聚集到embedding space的一个原型上，在对其进行近邻标签传播算法把。\n但是里面有一些数学推导，可能是关于距离的，在我们后续需要划分指标的时候可以来看看这篇到底说了啥。（原型网络的数学推导。） √Meta-Learning for Semi-Supervised Few-Shot Classification 2018、ICLR\n正好是上面那片原型网络的升级方法，这也太巧了把。重开一个新的课题，设置环境成为一个wild的环境，存在干扰项，将未标注的data也混杂进原型的训练中。 ×Conditional Networks for Few-Shot Semantic Segmentation 2018\\ICLRworkshop track\n貌似有点弟弟，没提出什么有用的东西 ※Few-Shot Object Detection via Feature Reweighting 2019/ICCV\n在一个base class 的dataset上进行meta training，然后通过 reweighting 操作，adapt to novel classes。\nglobal原型，meta的场景学习策略，transfer的reweighting操作，以及在few-shot问题种加入了很多算法并没有考虑的localization问题。\n这篇论文看起来还行。 ※※Meta-Transfer Learning for Few-Shot Learning 2019\\CVPR\n通过多次的meta学习，来找到参数相对于原DNN网络（普通的meta都是用的浅层网络）而言的scaling和shifting，感觉和上一篇reweighting方法存在一定的相似性。 同时我们也知道基本的meta-learning 方法和场景图应用的方法存在极大的相似性。 此外在训练策略上，采用了一个HTmini-batch的变体策略。（figure1有简要说明，结合后面的策略观看） ×Deep Learning Models for Few-shot and Metric Learning 这一篇看不了 √Learning to Compare: Relation Network for Few-Shot Learning 2018\\CVPR\nmeta-learning 中的query 和support 不要搞混了。\n（前面还有一步是通过embedding来学习一个合适的feature）\n感觉上是一个基础的meta-learning框架，通过训练过程中对metric distance的学习，得到一个模型框架，然后通过模型将support data在metric space中与query data进行distance的衡量，从中选择shortest one作为classification的指标。 ※Dynamic Few-Shot Visual Learning Without Forgetting 2018\\CVPR\n为了使得模型在学习新的类别的时候，对旧的类别的识别能力依旧能保留下来，提出了两个策略，一个是基于attention 的分类权重生成器，二是对ConvNet进行重新设计，使其提取出feature的表征向量和分类权重向量之间的余弦相似性。？具体的还没看。但我认为主要努力的方向好像不是很对。 Few-Shot Human Motion Prediction via Meta-Learning 2018\\CVPR\n是一种结合了MAML、MRN、Meta-Learning的策略，本质还是一个few-shot的工作，没有提到怎么把这样的工作适应到真实的应用上，\n这一篇论文非常需要机器详细的阅读，不然的话不知道他到底是怎么操作的。 最终我们可以提出一个framework，通过对弱监督方法的嵌入，使得标注的任务变成一个人机交互的loop，通过我们对算法的干预，他将从标签的概率预测变成一个确定的指标预测，然后执行self-learning的方法，让自己逐渐变得更好，设定一个drop out，可以计算一个算法的最终所求时间。\n","permalink":"https://hugotest-phi.vercel.app/posts/fsl%E5%89%8D%E6%9C%9F%E8%B0%83%E7%A0%94/","summary":"\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"aikenhong_blog\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003ch2 id=\"主要是limited-labels--few-samples--data-programing\"\u003e主要是limited labels \u0026amp; Few Samples \u0026amp; Data programing\u003c/h2\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cdel\u003eWeakly supervised learning\u003c/del\u003e\u003cbr\u003e\n\u003cdel\u003esemi-supervised in video field\u003c/del\u003e\u003cbr\u003e\nif we can recoding this work?\u003cbr\u003e\n\u003cdel\u003e多指标下降（LOSS的耦合或者循环的选择）、相关的CV最新论文等等会在后续关注\u003c/del\u003e\u003cbr\u003e\n\u003cdel\u003e元学习、浅层神经网络的概念等等\u003c/del\u003e  \u003cdel\u003esemi-supervised\u003c/del\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"part1-limited-labels-base-on-lifeifeis-reference\"\u003ePART1 Limited Labels （base on LiFeiFei‘s reference）\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003ein this part we may list the paper which is useful for my recoding.\u003c/em\u003e\u003cbr\u003e\n还有一些其他重要的可能在对论文进行重新精读的时候要记得注意reference：就比如说在loss变换和决策树生成那一块。\u003cbr\u003e\n\u003cem\u003edistant supervision(it\u0026rsquo;s kind of early) can be another baseline for our method, we need to understand how this method work for that situation\u003c/em\u003e\u003cbr\u003e\ndistant supervisor到底是什么机制可以去CSDN什么的看一下\u003c/p\u003e","title":"FSL前期调研"},{"content":"@Author \u0026amp; Paper：Arxiv @Note：Aikenhong 2021/11/12\nOther’s Note 1 Intro 旧知识的缓慢忘记和新知识的快速适应的困境：主要探讨Incremental中的Old和New的相互牵制和适应的问题，\n旧知识的缓慢遗忘会导致对新任务的欠拟合，而快速适应会导致灾难性的遗忘，如何对这两种策略之间进行权衡，是一个重要的问题。\n多尺度混合的解决这个问题：\nIntra-space： 新类别的特征在同一个特征空间中 inter-saoce：新旧类别的特征在不同的特征空间中 本文提出的多粒度策略：\n提出了一种频率感知的正则化操作，加速空间内的增量学习能力 新的特征空间组合操作，提升空间间的学习性能 实际上新类和旧类的特征最好是通过自监督或者无监督的特征学习方法归化到同一个特征空间中，在这种情况下对Classifier进行调整可能是一种更好的策略。通过混合特征空间来得到一个泛化能力更高的特征表示器。\n传统的策略：无论是累加还是进行数据混合进行梯度计算，这种方式应该是将类别之间的梯度进行直接的叠加。\n是否可以自行混合不同类别之间的学习梯度？通过对梯度的下降方程求解来得到一个旧类和新类之间的更好的下降方法。 具体的操作上就是对step进行处理，通过mixdataset对梯度进行分开计算 在混合策略上可以考虑梯度的下降方向，对不同的维度进行加权计算？ 上述的策略难以实施的点在于框架中的梯度是自动计算的，我们可以对损失进行加权，但是很难重新计算不同节点之间的梯度值 退而求其次的方法就是对新旧类的损失进行加权处理, 或者直接的混合数据 如果我们能获取梯度的方向, 或许我们能在每次迭代的过程中获得一个更好的加权值 首先可以尝试对梯度进行获取,Grad 我们在蒸馏的过程中通过MLP对不同的类别进行聚类划分, 这种方式的聚类和传统机器学习聚类的优劣又如何对比解释呢. 能不能用PCA方法或者multi-head策略来对特征进行处理, 这种类似因果的方式来分析特征中的冗余维度 上述的分析基于Mix Guide make error 的想法, 实际上还有一个问题就是Feature’s capabliity 不足的问题 New Key Word： Few-Shot class-incremental Learning\n有大规模训练样本的第一个任务和具有有限样本的新类学习两阶段任务的这种场景\nRelated Work 框架策略: 复习策略 正则化策略 Main 该文认为统一的特征空间是相互关联的，很难相互解开进行svf分析，同时新知识和旧知识的学习方向通常而言不一致，甚至有时是相互矛盾的，所以他认为需要一个全新的特征空间。\n但是在Few-Shot的情境下，新的特征空间的泛化能力可能很差，本身带来的准确率就很有问题把\n使用离散余弦变化，建立一个空间内的SVF特征分解方案，实现了一个像互不相关的正交频率空间，同时在不同频率上对新旧两种知识的重要性不同，低频分量对于保存旧知识的贡献更大，遗忘率则随着频率的增加而增加。\n所以逼近旧特征空间的低频分量的正则项权重更高, 具体而言就是独立的特征空间的更新比其他空间更新更慢, 通过对特征空间的组合来组成上述空间的方法, 是十分灵活的, 即使是简单的串联也能带来巨大的性能提高\n这确实是我没想到的, 也就是如果我们使特征并行化, 对最终准确率的提升增益是更大的, 这是为何.\nFrameWork 实际上就是维护两个模型, 然后进行特征的串联, 进行分类. 每次只对新的数据进行训练, 不会使用旧的数据.\n","permalink":"https://hugotest-phi.vercel.app/posts/il-mgsvf/","summary":"\u003cp\u003e@Author \u0026amp; Paper：\u003ca href=\"https://arxiv.org/pdf/2006.15524.pdf\" target=\"_blank\" rel=\"noopener\"\u003eArxiv\u003c/a\u003e\n\n@Note：Aikenhong 2021/11/12\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/cp_oldy/article/details/111714896\" target=\"_blank\" rel=\"noopener\"\u003eOther’s Note 1 \u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e旧知识的缓慢忘记和新知识的快速适应的困境\u003c/strong\u003e：主要探讨Incremental中的Old和New的相互牵制和适应的问题，\u003c/p\u003e\n\u003cp\u003e旧知识的缓慢遗忘会导致对新任务的欠拟合，而快速适应会导致灾难性的遗忘，如何对这两种策略之间进行权衡，是一个重要的问题。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211112114701.png\"\u003e\r\n    \u003cimg alt=\"image-20211112110043089\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211112114701.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211112114701.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20211112110043089\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e多尺度混合\u003c/strong\u003e的解决这个问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIntra-space： 新类别的特征在同一个特征空间中\u003c/li\u003e\n\u003cli\u003einter-saoce：新旧类别的特征在不同的特征空间中\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e本文提出的\u003cstrong\u003e多粒度策略\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e提出了一种频率感知的正则化操作，加速空间内的增量学习能力\u003c/li\u003e\n\u003cli\u003e新的特征空间组合操作，提升空间间的学习性能\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- more --\u003e\r\n\u003cblockquote\u003e\n\u003cp\u003e实际上新类和旧类的特征最好是通过自监督或者无监督的特征学习方法归化到同一个特征空间中，在这种情况下对Classifier进行调整可能是一种更好的策略。通过混合特征空间来得到一个泛化能力更高的特征表示器。\u003c/p\u003e\n\u003cp\u003e传统的策略：无论是累加还是进行数据混合进行梯度计算，这种方式应该是将类别之间的梯度进行直接的叠加。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e是否可以自行混合不同类别之间的学习梯度？通过对梯度的下降方程求解来得到一个旧类和新类之间的更好的下降方法。\u003c/li\u003e\n\u003cli\u003e具体的操作上就是对step进行处理，通过mixdataset对梯度进行分开计算\u003c/li\u003e\n\u003cli\u003e在混合策略上可以考虑梯度的下降方向，对不同的维度进行加权计算？\u003c/li\u003e\n\u003cli\u003e上述的策略难以实施的点在于框架中的梯度是自动计算的，我们可以对损失进行加权，但是很难重新计算不同节点之间的梯度值\u003c/li\u003e\n\u003cli\u003e退而求其次的方法就是对新旧类的损失进行加权处理, 或者直接的混合数据\u003c/li\u003e\n\u003cli\u003e如果我们能获取梯度的方向, 或许我们能在每次迭代的过程中获得一个更好的加权值\u003c/li\u003e\n\u003cli\u003e首先可以尝试对梯度进行获取,\u003ca href=\"https://zhuanlan.zhihu.com/p/168443176\" target=\"_blank\" rel=\"noopener\"\u003eGrad\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e我们在蒸馏的过程中通过MLP对不同的类别进行聚类划分, 这种方式的聚类和传统机器学习聚类的优劣又如何对比解释呢.\u003c/li\u003e\n\u003cli\u003e能不能用PCA方法或者multi-head策略来对特征进行处理, 这种类似因果的方式来分析特征中的\u003cstrong\u003e冗余维度\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e上述的分析基于Mix Guide make error 的想法, 实际上还有一个问题就是Feature’s capabliity 不足的问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNew Key Word： Few-Shot class-incremental Learning\u003c/p\u003e","title":"IL-MgSvF"},{"content":"@Aiken 2021\n恺明大神对自监督学习+transformer的实证研究，针对Transformer再自监督学习学习框架中的训练不稳定问题提出了Random Patch Projection的解决方案。\nArticle ；Paper ；\nMotivation ViT的方法在自监督学习的任务中，精度下降的主要原因是由于算法的不稳定性，容易陷入局部的最优值，本文主要聚焦于采用视觉领域的自监督框架进行Transformer的训练，CNN的训练方法已经是一个比较明确约定俗称的方法，而Transformer的训练架构实际上还没有被完全的构建。\n","permalink":"https://hugotest-phi.vercel.app/posts/ssl-mocov3/","summary":"\u003cp\u003e@Aiken 2021\u003c/p\u003e\n\u003cp\u003e恺明大神对自监督学习+transformer的实证研究，针对Transformer再自监督学习学习框架中的训练不稳定问题提出了\u003cstrong\u003eRandom Patch Projection\u003c/strong\u003e的解决方案。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s/waqkJkwqxU-7utfNnwr2Gg\" target=\"_blank\" rel=\"noopener\"\u003eArticle\u003c/a\u003e\n；\u003ca href=\"https://arxiv.org/abs/2104.02057\" target=\"_blank\" rel=\"noopener\"\u003ePaper\u003c/a\u003e\n；\u003c/p\u003e\n\u003ch2 id=\"motivation\"\u003eMotivation\u003c/h2\u003e\n\u003cp\u003eViT的方法在自监督学习的任务中，精度下降的主要原因是由于算法的不稳定性，容易陷入局部的最优值，本文主要聚焦于\u003cstrong\u003e采用视觉领域的自监督框架进行Transformer的训练\u003c/strong\u003e，CNN的训练方法已经是一个比较明确约定俗称的方法，而Transformer的训练架构实际上还没有被完全的构建。\u003c/p\u003e","title":"SSL-MoCov3"},{"content":"@aikenhong 2020 @h.aiken.970@gmail.com\n另一个综述文章：https://zhuanlan.zhihu.com/p/61215293 对该文中一些内容有一些补充，可以看看\nFSL简介：https://blog.csdn.net/xhw205/article/details/79491649\nGCN用于FSL：https://blog.csdn.net/qq_36022260/article/details/93753532\nAbstract FSL的根本目的就是弥合人工智能和人类之间的鸿沟，从少量带有监督信息的示例中学习。像人类一样有很高的泛化能力。这也能解决在实际应用场景中，数据难以收集或者大型数据难以建立的情景。\nFSL的核心问题是：经验风险最小化器不可靠；那么如何使用先验知识去解决这个问题？\n三个主要的角度：\n数据：使用先验知识增强数据的监督经验 模型：使用先验知识来降低假设空间 算法：使用先验知识来改变搜索最佳假设（来进行搜索？) 现阶段针对FSL提出的一些相关的机器学习方法： meta-learning; embedding learning; generative modeling etc.\n本文的主要工作：\n基于FSL的原有设定，在现阶段的FSL发展上给出正式定义，同时阐明具体目标以及解决方式\n通过具体示例列举和FSL的相关学习问题，比较了相关性和差异性，更好的区分问题\n指出核心问题：经验风险最小化器不可靠，这提供了更系统有组织的改进FSL的方向。 经验风险最小化器👉：基于ML中的错误分解来分析的\n整理，更好的理解\n未来方向\nNotation and Terminology 一般基于参数方法（因为非参数方法需要大量数据），在假设空间中搜索最优假设，并基于基于标签的Loss Function 来衡量效果。\nMain Body Overview 2.1：具体定义\u0026amp;示例 2.2：相关问题和FSL的相关性和差异 2.3：核心问题 2.4:现有的方法如何处理这个问题\nDefinition 基本定义：FSL是一类机器学习（由E，T，P定义），其中E只包含有限数量的带有目标T监管信息的示例。\n**研究方法：**通常使用N-way K-shot的分类研究方法：从少量类别中的少量样本回归出ML模型，\n​\tTraining Set Contains：KN examples.\nTypical scenarios of FSL:\nReducing data gathering effort and computational cost: “raw images of other classes or pre-trained models ” 似乎有点迁移学习的味道了，改善从已有的类似数据集过来的model？ Learning for rare cases Acting as a test bed for learning like human. 和普通的ML的应用最明显的区别就是E中prior knowledge的应用，将T和先验知识结合起来。（such as Bayesian Learning [35,76]）\n**Attention：**Zero-shot：要求E中需要包含其他模态的信息（比如属性，wordnet，word embedding之类的）\nRelevant Learning Problems WSL:Weakly supervised learning: 重点在于learns from E containing only Weak supervised（such as： 不完全，不精确，不准确，或者充满噪声的监督信息），WS 中信息不完全只有少样本这一类情况就是FSL了，在此基础上基于Oracle还是人工干预的方法，可以进一步细分为：\nSemi-supervised learning： 从E中的少量标记样本和大量未标记样本中学习。示例：文本和网页分类；其中包含Positive-unlabeled learning这种特殊问题，只包含positive label的问题：具体而言就是，只知道用户现在用户中标记的好友，而与其他未标记人之间的关系是未知的。\nActive Learning： 文章：选择信息量最大的未标记数据区query an ordacle？ 个人理解：选择信息量最大（通常用不确定性大的数据表示）来让人标注，从而构建数据集，让算法能够通过较少的数据标注操作实现更好的效果。\nWSL with incomplete supervision 仅仅包括分类和回归的内容，而FSL还包含RL问题；WSL使用unlabel data 对E进行扩充，而FSL更多的使用各种类型的prior knowledge来扩充E，包括pre-train model ，其他领域的监督数据，未标记数据等等。\nImbalance learning：\n数据集的分布不均衡，比如一些y值很少用到的情况。IL从所有可能的y中Train\u0026amp;test，FSL基于少量案例train\u0026amp;test y，同时也可能基于一些先验知识来。\nTransfer learning：\ntransfers knowledge from the source domain/task 👉 target domain/task, where training data is scarce.其中Domin adaptation，是一种TL：source/target tasks are the same but the source/target domains are different.举例说明就是：情感识别，一个基于电影评论，一个基于日用品评论。 Transfer Learning广泛的应用于FSL，[7,82,85]将先验知识从源任务转移到Few-shot task，从一些训练数据丰富的源域转移\n**Meta-learning：**感觉正文中讲的是个狗屎，后续通过附录中的看看\nMeta-learning methods can be used to deal with the FSL problem. the meta-learner is taken as prior knowledge to guide each specific FSL task.\nCore Issue 经验风险最小化 Machine Learning其实是一个经验风险最小化的模型 $$ R(h)=\\int \\ell(h(x), y) d p(x, y)=\\mathbb{E}[\\ell(h(x), y)] \\\\\r$$\r$$ R_{I}(h)=\\frac{1}{I} \\sum_{i=1}^{I} \\ell\\left(h\\left(x_{i}\\right), y_{i}\\right)\\\\\r$$\r$$ \\mathbb{E}\\left[R\\left(h_{I}\\right)-R(\\hat{h})\\right]=\\underbrace{\\mathbb{E}\\left[R\\left(h^{*}\\right)-R(\\hat{h})\\right]}_{\\mathcal{E}_{\\mathrm{app}}(\\mathcal{H})}+\\underbrace{\\mathbb{E}\\left[R\\left(h_{I}\\right)-R\\left(h^{*}\\right)\\right]}_{\\mathcal{S}_{\\mathrm{est}}(\\mathcal{H}, I)}\r$$\r上面这1 3的区别一个是在全空间上，另一个是在是我们的假设空间中，能取到的最优解。\n总体误差可以基于最小预期风险和最小经验风险来表示，如等式3。期望实和训练集的随机选择有关的，the approximation error 衡量了假设空间中的函数能够接近最优假设的程度，the estimation error 衡量了，最小经验误差代替最小期望误差在假设空间内的影响。\ndata （which provides Dtrain）数据角度\nmodel which determines H（embedding function，转换到假设空间）\nalgorithm（searches for the optimal h）学习算法，下降方向\n不可靠的经验风险最小化\n如果数据足够大的话，通过少量样本计算出来的假设空间就可以逼近实际上的最优假设空间，也就能得到一个很好的近似，但是在FSL中，可用的样本数很少，所以可能没办法产生很好的逼近，在这种情况下，产生的经验风险最小化指标hl过拟合，这就是FSL中的核心问题。\nTaxonomy 为了解决FSL问题中经验风险最小化工具中hl的问题，prior knowledge是至关重要的，利用先验知识来扩充信息量的不足，基于先验知识的类别和使用方式就能对FSL works进行分类。\nData：通过数据增强等方式，增加数据量，从而使得经验风险最小化因子能够更加的准确。 Model：用先验知识来约束假设空间，使得需要搜索的范围变小，那么基于较少的数据也能够得到一个较好的估计，（相比原来） Algorithm：使用先验知识，来搜索最优假设的参数，基于这些先验知识提供一个较好的initialization，或者guiding the searching steps Data 通过手工指定规则来进行数据增强的方式例如：:arrow_double_down: 很大程度上取决于领域的知识也需要人工成本，此外，这样的方式在数据集间的泛化能力很差，一般都是针对性设计，而且这样的不变性，不可能由人工穷举出来，所以这样的方式不能完全解决FSL问题。\ntranslation, flipping, shearing, scaling, reflection, cropping, rotation.\nAdvance data augmentation:\nTransforming Samples from Dtrain 对训练集的数据进行几何变化处理，生成其他的样本，构建一个更大的数据集。\n从相似类中学习一组编码器（每个编码器代表一个类内可变性），将这些习得的变化量添加到样本中形成新的样本。\n基于差异从其他类别中转移过来\n从一个样本变成多个；连续属性子空间来添加属性变化\n基本思路是一致的，通过变换，在原本数据的基础上，构建新的数据，只是有着不同的构建方式。详细的各种类型的构建可以看参考文献。\nTransforming Samples from a Weakly Labeled or Unlabeled Data Set 基于弱标签或者无标签的数据来进行数据增强的情况，类似视频中有些事件之间变化比较大的情况，可以将这样的数据添加到训练集中来更清楚的预测。\n:dagger:但是如何筛选哪些有需要的弱监督数据？\n⭐基于训练数据训练一个svm进行筛选，然后将具有目标的示例添加进数据集\n⭐Label Propagation,直接使用未标记的数据集\n⭐也有文章采取逐步从信息量最大的数据中筛选的做法\nTransforming Samples from Similar Data Sets :tada: 汇总和改造相似的数据集，来扩充Few shot情况，基于样本之间的相似性度量来确立权重，典型的方法就是：使用GAN，生成器将Few-shot的训练集映射到大规模数据集，另一个生成器将大规模数据集的样本映射过来，从而训练出可以辅助样本迁移的模型。\nSummary1 这些方法的使用取决于具体任务；\n:x: 缺点：通常是针对数据集量身定做的\n:+1: 针对这个问题有人提出了AutoAugment\n:heavy_multiplication_x: 缺点：文本和音频的情况下就很难做这样的生成了\nMODEL :fire: 如果仅仅基于简单的假设去考虑的话，那么可能在我们的假设空间中的最优和实际的最优(不足以模拟现实社会中的复杂问题)会有比较大的距离，但是如果考虑复杂多样的假设空间，那么标准的机器学习模型也是不可行的（数据量不足以优化到最优解），考虑使用先验知识，将复杂多样的假设空间H 约束到较小的情况下进行学习，这样的话经验风险最小化器将会更加的可靠，同时也降低了过拟合的可能性。\n根据先验知识的类型，可以划分成如下几种FSL：\nMultitask Learning :fire: 多个相关任务协同训练，基于特定任务的信息和通用任务的信息来一起学习，其中利用某些/其他任务的大量数据（源任务），在训练过程中，通过学习到的参数来对只有Few-shot（target task）进行约束。基于训练中参数对target的约束方式可以分为\nparameter sharing参数共享 160 61 95 12 基本的网络架构如下图\n:zero: 有多种不同的架构，整体都是由共享层（参数是一致的）和特定于任务的层一起构建的，简单的描述一下如下：\n初始共享然后分配到特定任务；2. 源任务（pre训练）训练共享层，目标任务训练目标层；3.分别单独学习再有共享的编码器嵌入成一体。 parameter tying参数绑定 45 151 85 ⭐基本思路：鼓励不同任务之间的参数存在相似性。对参数进行正则化是一种流行的方法。\n:one: 有的方法对成对参数之间的差异及逆行了惩罚，从而确保参数分布的相似性\n:two: 有的方法通过针对源任务和目标任务设置不同的CNN，之间使用特殊的正则化术语对齐。\nEmbedding Learning 基于先验知识（同时可以额外使用Dtrain中的任务特定信息）构建样本的一个低维嵌入，这样便能得到一个较小的假设空间，同时相似的样本会紧密接近，而异类的样本更容易区分。\nKey Components：\n将测试，训练样本用embedding函数（f，g）嵌入。f，g可以统一，但是分离的时候可以受获更好的准确度 相似性度量在嵌入空间（一般都是维度更低的空间）进行， 可以根据embedding函数的参数是否随任务变化分类\n针对任务的嵌入模型 仅仅使用来自该任务的信息来学习针对性的嵌入模型。\n通用的嵌入模型（task-invariant） 使用有足够样本且具有各种输出的大规模数据集，学习通用的embedding function，然后直接用于Fewshot。Recently, more complicated embeddings are learned [70, 150] by a convolutional siamese net [20] 通常而言，task-invariant不会使用Few-shot的数据集来更新embedding function参数，但是，其中很多情景都会模拟few-shot 的情景来训练embedding从而确保对此类任务有更好的概括性能。\n⭐Mathching Nets meta-learning / resLSTM / AL /set-to-set\n⭐Prototypical Networks\n​\tembedding(xtest)不与每个g(xi)对比，而是每一类别的训练数据都有一个”原型“（原型公式如下），与原型对比，减少计算量。有两种变体：应用到matching-net 和 semi-supervised-108（软分配未标注的样本用以增强Dtrain）\n$$ c_{n}=\\frac{1}{K} \\sum_{i=1}^{K} g\\left(x_{i}\\right)c_{n}=\\frac{1}{K} \\sum_{i=1}^{K} g\\left(x_{i}\\right)\r$$\r:zap:Other Method\n​\tARC：利用attention+LSTM将xtest的不同区域和原型进行比较，然后将比较结果作为中间嵌入，在使用biLSTM（双向LSTM）进行最终嵌入； ​\tRelation Net 使用CNN将Xtest和Xi拼接在一起，再使用另一个CNN输出相似度得分。 ​\tGNN：利用GNN使用临近节点的信息 ​\tSNAIL简单神经注意力学习器（RL通常看重时间信息）：temporal convolution +Attention，聚合临近步长和通过Attention选择特定时间步长的信息。\n混合嵌入模型，可以编码 task-specific 和 task-invariant 的信息 虽然task-invariant可以再迁移的时候减少计算成本，但是针对一些特殊的少样本情况，他是无法直接适应的，比如说原本就是小概率事件（异常），这种情况下，基于Dtrain训练的先验知识来adapt通用的embedding模型，从而组成一个混合的结构，如下图所示。\n​\tLearnet从多个meta-training set中学习meta-learner，并将训练实例映射成网络中的参数（convolutional Siamese net），这样f的参数就会随着输入改变。还有一些针对其的改进\nTADAM：将类别原型平均化到嵌入中，并使用meta-learned 映射成圆形网络的参数\nDCCN：使用固定的滤波器，并从Dtrain中学习组合系数。\nLearning with External Memory 基于Dtrain 训练一个Embedding function，提取出 key-value的知识，存储在外部存储器中，对于新样本（test），用Embedding\u0026amp;相似度函数查询最相似的slots，用这些slots的组合来表示样本，然后用简单的分类器（like softmax）进行分类预测。由于对M操作成本高，所以M通常尺寸较小。当M未满时，可以讲新样本写如空闲的存储插槽。\nkey-value的表征，也就是memory中的定义在这个方法中至关重要，它决定了键值对对test的表征水平。根据存储器的功能，将这类方法分成两种类型：\n:one:Refining Representations:\nMANN：meta-learns embedding f，将同类的样本映射到同一个value，同一类的样本一起在内存中优化类表示。可以看成ProtoNet中精致的类原型。 当且仅当M不能很好的表征x的时候更新M。 The Abstract Memory： 使用两个M，一个基于大量数据训练出的固定键值对，另一个从固定键值对对少量类进行精炼提取。为此有的方法会注意保留M中的FS。 few-shot在M中很容易被其他samples的值表征从而取代，为了解决这个问题，提出的此算法👇 **lifelong memory：**通过删除oldest slot来update M，同时给所有slot的期限置为0，当新样本在经过M后输出的表征与实际输出匹配的时候，就合并，而不更新M。（但是还是没有真正的解决这个问题） :two:Refining Parameters:\nMetaNet、MN-Net： 对特定任务的数据进行fast 学习，而通用任务slow更新，然后结合memory的机制。（参数化学习 Generative Modeling 借助先验知识，从x的分布中估计先验p(x； $\\theta$ )的分布，从而估计和p(x|y)和p(y)，基于这样的先验数学模型进行后续的计算。而先验估计过程中通常是从别的数据集获悉的先验分布中，基于某个潜在的参数z迁移过来的如下式，这样就能基于既有的后验分布，约束H假设空间。\n$$ x \\sim \\int p(x | z ; \\theta) p(z ; y) d z\r$$\r通常在识别，生成，反转，重建中有较常见的应用\nDecomposable Components： 基于人类的认知，将数据分解成组件级别，在进行后续的识别和重组；利用类间的通用性；\nGroupwise Shared Prior： 新的FS类别，先通过无监督学习分组，共享组内的类别先验，然后基于组内的先验对其进行建模。\n**Parameters of Inference Networks：**网络参数推理\n$$ p(z | x ; \\theta, \\gamma)=\\frac{p(x, z ; \\theta, y)}{p(x ; y)}=\\frac{p(x | z ; \\theta) p(z ; \\gamma)}{\\int p(x | z ; \\theta) p(z ; \\gamma) d z}\r$$\r为了找到最优的 $\\theta$ ，必须最大化以上的后验概率：\n基于数据对其进行求解，inference network能够高效的迁移到新任务，但是inference network 需要大量的参数，所以通常需要在辅助的大规模数据集训练后才使用。很多经典的推理网络都可以在FSL上应用，比如VAE（可变自动编码器），autoregressive model，GAN，VAE+GAN\nSummary2 详细的优缺点，参考文章\n存在相似任务或者辅助任务：多任务学习 ​ 包含足够的各种类别的大规模数据集：embedding方法 存在可用的内存网络：在内存顶部训练一个简单的模型（分类器），可以简单的用于FSL，主要是要精心设计更新规则。 除了FSL还想要执行生成和重构的任务的时候：generative modeling ALGORITHM 算法层面的改进指的是在最优空间H搜索H*的策略，最基础的有SGD。:x:在FSL的情况下，数据会使得更新次数不够多，同时也没法基于交叉验证找到合适的补偿之类的。:arrows_counterclockwise:本节中的方法用先验知识来影响 $\\theta$ ，具体体现为：:one:良好的初值；:two:直接学习优化器以输出搜索步骤；​\n:zap:基于先验知识对策略的影响，对算法进行分类\nRefining Existing Parameters :jack_o_lantern:基本思想：从相关任务中预训练模型的 $\\theta$ 0作为一个良好的初始化，然后基于训练集的几次训练来adapt。\nFine-Tuning Existing Parameter by Regularization： 如何解决overfit的问题是此类预训练算法设计关键：其中一种方式就是依赖正则化操作来adapt参数。 正则化的方式主要有以下几种：\nMethod Analysis Early-stopping 监视训练过程，性能没有提高则停止学习 Selectively updating $\\theta$ 根据具体问题，选择需要的部分来更新参数，不更新所有参数 Updating related parts of $\\theta$ together 聚类 $\\theta$ ，然后共同更新每个组，BP更新 $\\theta$ Using a model regression network 捕获任务无关的transformation，基于function进行embedding的映射？ Aggregating a Set of Parameters： 聚合相关模型：不贴切的比如眼口鼻到脸；具体使用上，unlabeled/similar label dataset,的pretrain model参数到FSL参数的适应。\nunlabeled dataset: 把相似样本分组聚类，然后adapt\nsimilar dataset: 替换相似类别中的特征，重新使用已训练的分类器，然后对新类调整分类阈值。\nFine-Tuning Existing Parameter with New Parameters： 仅仅对模型迁徙可能没办法对FSL完全编码，所以我们在对参数进行adapt的时候加入一个新的参数，然后再Dtrain中同时adapt现存参数和learn新参数 Refining Meta-Learned Parameter 本节中细化meta-learned的参数学习： $\\theta$ 再过程中是持续优化的，不是固定的。 Model-Agnostic Meta-Learning（MAML）通过梯度下降来元学习 $ \\theta$ ,基于该参数，得到任务特定参数 $\\phis$ ,更新公式类似如下形式 $\\phi_{s}=\\theta_{0}-\\alpha \\nabla_{\\theta_{0}} \\mathcal{L}{\\mathrm{train}}^{s}\\left(\\theta{0}\\right) . $ 其中 $L^s train$ 是训练样本的损失和， $\\alpha $ 是步长，该参数 $\\phis$ ,对于样本的顺序不受影响，此外元学习中基本的参数更新公式如下 $\\theta_{0} \\leftarrow \\theta_{0}-\\beta \\nabla_{\\theta_{0}} \\sum_{T_{s} \\sim P(T)} \\mathcal{L}{\\text {test }}^{s}\\left(\\theta{0}\\right)$ ，其中测试误差是整个过程中损失的和。通过元学习将参数转移。\n最近针对MAML提出了主要再以下三个方面的改进：\n:zap:合并特定任务的信息：MAML为所有任务提供相同的初始化，但是这样忽视了特异性，所以，从一个好的初始化参数的子集中为新任务选择初值 :zap:使用meta-learned $\\theta$ 的不确定性去建模：结合AL :zap:改进refining过程：对 $T~s$ 使用正则化？ Learning the Optimizer 不使用梯度下降，学习一种可以直接输出更新的优化器，无需调整步长 $\\alpha$ 和搜索方向。\nLSTM+Meta-Learner？\nDiscussion and Summary: 通过对现有参数进行微调，从而减少H需要的搜索量：\n使用现有 $\\theta$ 作为初始化：牺牲一些精度换取速度 另外两种策略都是依赖于元学习，元学习可以让参数和指定任务更为接近，还有一种直接充当优化器。 Future Works 在未来的FSL中使用多模态的prior knowledge SOTA网络架构的使用来改进data，algorithm，model； AutoML在FSL任务中的应用 meta-learning中动态学习中，如何避免catastrophic forgetting 在各领域中的应用：CV，bot，NLP，Acoustic signal process，etc :zap:Theories：\nFSL使用先验知识来弥补缺少监管信息的情况；\nFSL很多时候和domain adaptation 有关系\nFSL的收敛性研究还没有完全了解\nAppendix Reference: 之后整理一些可能需要阅读的reference\n只关注小样本的概念学习和经验学习的Another FSL survey: J. Shu, Z. Xu, and D Meng. 2018. Small sample learning in big data era. arXiv preprint arXiv:1808.04572 (2018).\nFS-RL，在仅给出少量状态和动作对组成的轨迹的情况下找到一种策略：\n[3,33]\nBayesian Learning : [35,76]\nAdditional Vocabulary： 序号 希腊字母 Markdoown 序号 希腊字母 Markdoown 1 α \\alpha 19 β \\beta 2 γ \\gamma 20 δ \\delta 3 Γ \\Gamma 21 Δ \\Delta 4 ε \\varepsilon 22 ϵ \\epsilon 5 ζ \\zeta 23 η \\eta 6 Θ \\Theta 24 ι \\iota 7 θ \\theta 25 κ \\kappa 8 Λ \\Lambda 26 λ \\lambda 9 μ \\mu 27 ν \\nu 10 ξ \\xi 28 ο \\omicron 11 Π \\Pi 29 ρ \\rho 12 π \\pi 30 τ \\tau 13 Σ \\Sigma 31 Φ \\Phi 14 σ \\sigma 32 ϕ \\phi 15 Υ \\Upsilon 33 Ψ \\Psi 16 υ \\upsilon 34 ψ \\psi 17 Ω \\Omega 35 ω \\omega 18 φ \\varphi 36 Ξ \\Xi 术语或生词:\nempirical risk minimizer ：经验风险最小化器 ultimate goal ：最终目的 To name a few： 举几个例子 autonomous driving car：自动驾驶汽车 tackled：解决 paradigm：范式 ethic：道德 taxonomy：分类 the pros and cons of different approaches：不同方法的利弊 with respect to：关于 the approximation error：逼近误差 the estimation error：估计误差 alleviate：缓和，减轻 aggregation：聚集 simultaneously：同时，兼 penalized：受惩罚的 hybrid:混合的 interleaved：交错的 denominator：分母 注意区分：\nsufficient：足够 terminology：术语 refine：提炼 提纯 leverage：利用 latent：潜在的 FAQ Testing Set需要在N-way上进行吗？应该是要的 AL的query or oracle 是啥意思 According to whether the oracle or human intervention is leveraged, this can be further classified into the following 此处 oracle到底是什么意思 Semi-Supervised 又和FSL有什么区别呢 Imbalance Learning确实不是很理解 Generative Modeling的具体要素不是很懂 Core Issue中的三个h的关系还有点疑惑 app：在最优的情况下，能搜索到的最优解和实际最优解之间的差距 est：实际的假设空间中的最优解和基于少量样本的经验得到的假设空间中的最优解之间的距离。 Parameters of Inference Networks，不知道怎么理解，后续要补充 \u0026ndash;\n需要思考的点 Few-shot-learning \u0026amp; meta learning的问题设置，就是多类中都有足量样本，然后随机的从多类中选取few-way和few-shot的data模拟多种meta环境（fewshot和fewway），单次训练都是小样本的情况，进行学习，在这种环境下学习到，一个模式，然后从而减少数据量的要求。（这样就哪里减少了数据量啊，我就没懂了，） 那么假如说没有多类动作（怎么构造多类动作）：不会，我们可以在网上爬取，或者自己拍摄，因为只需要少量有标注的数据即可，也就是positive数据可以比较容易获得。 那么我们在构造增量的时候，也是考虑边际效益，然后当数据量达到一定规模的时候可以采用直接训练分类器的分类器，来对效果进行分类 Few-shot-learning中，训练集和测试集，标签已知和未知到底怎么弄，从代码中以及定义中分析的话怎么感觉是两个意思。我们需要的应该不能用到那个。 few-shot-learning应该指的是，新类只有很少的样本，但是旧类还是有大量标注样本的情况这个我们要好好分析。 但是这样的创新点在于更多的是算法的组合，有没有办法提出一个网络结构将这样的思路融合起来。！！！ ","permalink":"https://hugotest-phi.vercel.app/posts/fsl-collection/","summary":"\u003cp\u003e@aikenhong 2020\n@h.aiken.970@gmail.com\u003c/p\u003e\n\u003cp\u003e另一个综述文章：https://zhuanlan.zhihu.com/p/61215293\n对该文中一些内容有一些补充，可以看看\u003c/p\u003e\n\u003cp\u003eFSL简介：https://blog.csdn.net/xhw205/article/details/79491649\u003c/p\u003e\n\u003cp\u003eGCN用于FSL：https://blog.csdn.net/qq_36022260/article/details/93753532\u003c/p\u003e\n\u003ch2 id=\"abstract\"\u003eAbstract\u003c/h2\u003e\n\u003cp\u003eFSL的根本目的就是弥合人工智能和人类之间的鸿沟，从少量带有监督信息的示例中学习。像人类一样有很高的泛化能力。这也能解决在实际应用场景中，数据难以收集或者大型数据难以建立的情景。\u003c/p\u003e\n\u003cp\u003eFSL的\u003cstrong\u003e核心问题\u003c/strong\u003e是：经验风险最小化器不可靠；那么如何\u003cstrong\u003e使用先验知识\u003c/strong\u003e去解决这个问题？\u003c/p\u003e\n\u003cp\u003e三个主要的角度：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e数据：使用先验知识增强数据的监督经验\u003c/li\u003e\n\u003cli\u003e模型：使用先验知识来降低假设空间\u003c/li\u003e\n\u003cli\u003e算法：使用先验知识来改变搜索最佳假设（来进行搜索？)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e现阶段针对FSL提出的一些相关的机器学习方法：\n\u003ccode\u003emeta-learning;\u003c/code\u003e \u003ccode\u003eembedding learning;\u003c/code\u003e  \u003ccode\u003egenerative modeling etc.\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e本文的主要工作：\u003c/strong\u003e\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e基于FSL的原有设定，在现阶段的FSL发展上给出正式定义，同时阐明具体目标以及解决方式\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e通过具体示例列举和FSL的相关学习问题，比较了相关性和差异性，更好的区分问题\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e指出核心问题：经验风险最小化器不可靠，这提供了更系统有组织的改进FSL的方向。\n经验风险最小化器👉：基于ML中的错误分解来分析的\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e整理，更好的理解\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e未来方向\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"notation-and-terminology\"\u003eNotation and Terminology\u003c/h2\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20200519154522883.png\"\u003e\r\n    \u003cimg alt=\" \" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20200519154522883.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20200519154522883.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\" \"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\n一般基于参数方法（因为非参数方法需要大量数据），在假设空间中搜索最优假设，并基于基于标签的Loss Function 来衡量效果。\u003c/p\u003e\n\u003ch2 id=\"main-body\"\u003eMain Body\u003c/h2\u003e\n\u003ch3 id=\"overview\"\u003eOverview\u003c/h3\u003e\n\u003cp\u003e2.1：具体定义\u0026amp;示例 2.2：相关问题和FSL的相关性和差异 2.3：核心问题 2.4:现有的方法如何处理这个问题\u003c/p\u003e","title":"Survey for Few-Shot Learning"},{"content":"对于各种形式的标记文档（markup）和数据集的处理进行一个整合，还有一些python中的相关模块（比比如glob，后续可能会迁移到别的文档中），主要包括：yaml，json，csv，xml，这些可拓展的标记语言.\nTODO：\ncsv,xml：这一部分可以看一下吉仲师兄那边是怎么存和取文件的，继承一下代码减少我这一部分的工作量 按照csv文件对数据集进行本地的文件夹切分。实际上很多数据集，像mini-imageNet这类的是需要我们下载下来之后按照csv文件对训练集和测试集进行切分的 使用sklearn对完整的未切分数据进行切分。 Python: Glob 文件操作相关模块，用于简单的路径匹配的模块，用来查找路径中的相关文件，基本的正则匹配规则如下：\n“*”: 匹配0哥或多个字符\n“?” : 匹配单个字符\n“[ ]”: 匹配指定范围内的字符,如[0-9]匹配所有的数字\nglob.glob: 返回所有匹配的路径列表,只有一个参数pathname,定一乐文件路径的匹配规则,可以是绝对路径或者是相对路径,具体的使用可以参考如下的方式:\n1 2 3 4 5 6 7 8 9 10 11 for xmlpath in glob.glob(\u0026#39;media/all/DATAPART/\u0026#39; + \u0026#34;*\u0026#34;) # xmlpath 遍历文件夹下的所有文件和文件夹 for xmlpath in glob.glob(xmlpath + \u0026#34;/*/*\u0026#34;) # xmlpath 遍历文件夹下所有文件夹中的文件夹中的文件:按照层数自由设定 img_path = sorted(glob.glob(os.path.join(images, \u0026#39;*.npy\u0026#39;))) # 遍历文件夹下的所有npy文件,说实话感觉这个怪离谱的,晚点试一下 import glob print(glob.glob(r\u0026#34;E:/imgdir/*/*.jpg\u0026#34;)) glob.iglob() 获取一个可遍历对象使用它可以逐个获取匹配的文件路径名:\nglob:一次获取全部 iglob:逐个匹配路径获取. Python：pickle palceholder\nYAML YAML是一种标记语言，可以通过YAML定义超参数，然后从外部引入，所以常用来作为一些特定的config，具体的用发和用途可以这样理解：\n当我们使用不同的backbone module的时候，我们可能对于超参数等等的一系列配置是不恒定的，所以使用config文件去配置的时候，当我们每次切换，我们就只需要读取不同的config文件就行了。 实际上就是argparse的一种替代 所以本文档聚焦于如何在python/cpp中读取yaml（以及cpp补充相应的数据类型）\n写在前面 基本的语法什么的很好搜索，随便百度一下就行了\noffical site 菜鸟入门教程 实际上大部分都是使用缩进去控制的，例子👇，很明显可以看出对应的元素关系，包括字典，boolean，float等其他的类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # default num_head = 2 criterions: PerformanceLoss: def_file: ./loss/SoftmaxLoss.py loss_params: {} optim_params: null weight: 1.0 last: false # apply incremental pca to remove main components apply_ipca: false num_components: 512 networks: classifier: def_file: ./models/CausalNormClassifier.py optim_params: {lr: 0.2, momentum: 0.9, weight_decay: 0.0005} scheduler_params: {coslr: true, endlr: 0.0, gamma: 0.1, step_size: 30} params: {dataset: ImageNet_LT, feat_dim: 2048, num_classes: 1000, stage1_weights: false, use_effect: true, num_head: 2, tau: 16.0, alpha: 3.0, gamma: 0.03125} shuffle: false training_opt: backbone: resnext50 batch_size: 512 dataset: ImageNet_LT display_step: 10 YAML-Python 下面直接给出一个例子，基本就按照这个格式去编写就没什么问题了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import yaml import os # 通常使用这种方式去打开文件并进行读取，这里实际上涉及到Python的IO操作 with open(args.cfg) as f: config = yaml.load(f) # 为了保证编写的一致性和与argparse的一致性使用（整合同个用途或者同个类型的数据），通常会编写update函数将两种类型中的参数整合起来 config = update(config,args) # 然后用字典的方式将config（yaml）中的每一部分要素按照命名读取出来 # 原则是：让读取出来的数据的堆叠层数不要太多，尽量就是一个dict或者一个list把 def update(config,args): # 在这里可以只提取出args中感兴趣的要素，也可以递归调用args中的所有参数 for k,v in args.items(): config[k] = v # or write down some interest elements only config[\u0026#39;element\u0026#39;] = \u0026#39;specific value\u0026#39; YAML的写入 JSON json是一种存储和交换文本的语法，类似XML。Link1 经纬师兄这块是按照coco的json格式去整理的文档，同时数据的存储用的是npy,npz\n1 2 3 4 5 6 { \u0026#34;employees\u0026#34;: [ { \u0026#34;firstName\u0026#34;:\u0026#34;Bill\u0026#34; , \u0026#34;lastName\u0026#34;:\u0026#34;Gates\u0026#34; }, { \u0026#34;firstName\u0026#34;:\u0026#34;George\u0026#34; , \u0026#34;lastName\u0026#34;:\u0026#34;Bush\u0026#34; }, { \u0026#34;firstName\u0026#34;:\u0026#34;Thomas\u0026#34; , \u0026#34;lastName\u0026#34;:\u0026#34;Carter\u0026#34; }] } 可以看VsCode中的配置文件实际上也是这种格式的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#34;todo-tree.highlights.customHighlight\u0026#34;: { \u0026#34;TODO\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#2f3542\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#f6b93b\u0026#34;, \u0026#34;iconColour\u0026#34;: \u0026#34;#f39c12\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;issue-opened\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;line\u0026#34; }, \u0026#34;FIXME\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#2f3542\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#e55039\u0026#34;, \u0026#34;iconColour\u0026#34;: \u0026#34;#e55039\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;flame\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;line\u0026#34; } }, 读取的时候实际上也是和键值对一样的读取,用dict,\nJson-Python 首先给出一个Json和python的类型对照表\nPython Json dict object list,tuple array str string int float int-\u0026amp;float-derived Enums number True true False false None null Python中Json的主要导入和输出的方式主要是使用dumps和loads将python对象编写成json字符串,以及对json字符串在python中编码\ndumps\n1 2 3 4 5 6 7 8 9 import json data = [ { \u0026#39;a\u0026#39; : 1, \u0026#39;b\u0026#39; : 2, \u0026#39;c\u0026#39; : 3, \u0026#39;d\u0026#39; : 4, \u0026#39;e\u0026#39; : 5 } ] data2 = json.dumps(data) print(data2) # 使用参数让json数据格式化输出 #!/usr/bin/python data2 = json.dumps({\u0026#39;a\u0026#39;: \u0026#39;Runoob\u0026#39;, \u0026#39;b\u0026#39;: 7}, sort_keys=True, indent=4, separators=(\u0026#39;,\u0026#39;, \u0026#39;: \u0026#39;)) print(data2) loads 载入字符串类型的时候用loads\n1 2 3 4 5 #!/usr/bin/python import json jsonData = \u0026#39;{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2,\u0026#34;c\u0026#34;:3,\u0026#34;d\u0026#34;:4,\u0026#34;e\u0026#34;:5}\u0026#39;; text = json.loads(jsonData) print(text) load载入文件时用load：\n1 2 3 4 5 6 7 8 with open(\u0026#34;../config/record.json\u0026#34;,\u0026#39;r\u0026#39;) as load_f: load_dict = json.load(load_f) print(load_dict) load_dict[\u0026#39;smallberg\u0026#39;] = [8200,{1:[[\u0026#39;Python\u0026#39;,81],[\u0026#39;shirt\u0026#39;,300]]}] print(load_dict) with open(\u0026#34;../config/record.json\u0026#34;,\u0026#34;w\u0026#34;) as dump_f: json.dump(load_dict,dump_f) XML 参考一下吉仲师兄的数据处理文件,按照该文件进行数据处理和xml python 读取情景的学习。\nCSV python3：csv的读写_katyusha1的博客-CSDN博客 write 好像直接修改文件后缀进行编写的编码方式会出现一些离奇的问题，所以最好还是调用代码来写入csv\nread 需要注意的参数是 quotechar：说明：delimiter是分隔符，quotechar是引用符，当一段话中出现分隔符的时候，用引用符将这句话括起来，就能排除歧义。\n首先按照row进行文件的读取，这应该回事比较常见的那种类型。\n1 2 3 4 5 6 7 import csv with open(\u0026#39;test.csv\u0026#39;，newline = \u0026#39;\u0026#39;) as f: f_csv = f.reader(f,delimiter=default,quotechar = default) for row in f_csv: print(row) # 这种格式读取出来的数据会有一个存放对应的=label，然后剩下的就是每一行数据的每一个 # 可以按照这种方式去根据index 索引对应的数据 [‘class’,‘name’,’sex’,\u0026hellip;]\n[‘1’,‘xiaoming’，‘male’,\u0026hellip;]\n[‘1’,‘xiaohong’，‘male’,\u0026hellip;]\n按照上面的很容易知道，只读取指定的列就是通过即可\n1 2 for row in f_csv: print(row[i]) ","permalink":"https://hugotest-phi.vercel.app/posts/markup_langs/","summary":"\u003cp\u003e对于各种形式的标记文档（markup）和数据集的处理进行一个整合，还有一些python中的相关模块（比比如glob，后续可能会迁移到别的文档中），主要包括：yaml，json，csv，xml，这些可拓展的标记语言.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTODO：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e csv,xml：这一部分可以看一下吉仲师兄那边是怎么存和取文件的，继承一下代码减少我这一部分的工作量\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e 按照csv文件对数据集进行本地的文件夹切分。实际上很多数据集，像mini-imageNet这类的是需要我们下载下来之后按照csv文件对训练集和测试集进行切分的\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e 使用sklearn对完整的未切分数据进行切分。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"python-glob\"\u003ePython: Glob\u003c/h2\u003e\n\u003cp\u003e文件操作相关模块，用于简单的路径匹配的模块，用来查找路径中的相关文件，基本的正则匹配规则如下：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“*”: 匹配0哥或多个字符\u003c/p\u003e\n\u003cp\u003e“?” : 匹配单个字符\u003c/p\u003e\n\u003cp\u003e“[ ]”: 匹配指定范围内的字符,如[0-9]匹配所有的数字\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"globglob\"\u003eglob.glob:\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e返回所有匹配的路径列表\u003c/strong\u003e,只有一个参数pathname,定一乐文件路径的匹配规则,可以是绝对路径或者是相对路径,具体的使用可以参考如下的方式:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003exmlpath\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eglob\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eglob\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;media/all/DATAPART/\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;*\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# xmlpath 遍历文件夹下的所有文件和文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003exmlpath\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eglob\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eglob\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003exmlpath\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;/*/*\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# xmlpath 遍历文件夹下所有文件夹中的文件夹中的文件:按照层数自由设定\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eimg_path\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003esorted\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eglob\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eglob\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epath\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eimages\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;*.npy\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 遍历文件夹下的所有npy文件,说实话感觉这个怪离谱的,晚点试一下\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003eglob\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eglob\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eglob\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"sa\"\u003er\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;E:/imgdir/*/*.jpg\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c!-- more --\u003e\r\n\u003ch3 id=\"globiglob\"\u003eglob.iglob()\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e获取一个可遍历对象\u003c/strong\u003e使用它可以逐个获取匹配的文件路径名:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eglob:一次获取全部\u003c/li\u003e\n\u003cli\u003eiglob:逐个匹配路径获取.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"pythonpickle\"\u003ePython：pickle\u003c/h2\u003e\n\u003cp\u003epalceholder\u003c/p\u003e\n\u003ch2 id=\"yaml\"\u003eYAML\u003c/h2\u003e\n\u003cp\u003eYAML是一种标记语言，可以通过YAML定义超参数，然后从外部引入，所以常用来作为一些特定的config，具体的用发和用途可以这样理解：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当我们使用不同的backbone module的时候，我们可能对于超参数等等的一系列配置是不恒定的，所以使用config文件去配置的时候，当我们每次切换，我们就只需要读取不同的config文件就行了。\u003c/li\u003e\n\u003cli\u003e实际上就是argparse的一种替代\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所以本文档聚焦于如何在\u003ccode\u003epython/cpp\u003c/code\u003e中读取yaml（以及cpp补充相应的数据类型）\u003c/p\u003e","title":"python 与标记语言的交互"},{"content":"\nWhat the f*ck Python! 🐍\r一些有趣且鲜为人知的 Python 特性.\nEnglish\r| 中文\r[![WTFPL 2.0][license-image]][license-url] [![Commit id][commit-image]][commit-url] [![996.icu][996.icu-image]][996.icu-url]\rPython, 是一个设计优美的解释型高级语言, 它提供了很多能让程序员感到舒适的功能特性. 但有的时候, Python 的一些输出结果对于初学者来说似乎并不是那么一目了然.\n这个有趣的项目意在收集 Python 中那些难以理解和反人类直觉的例子以及鲜为人知的功能特性, 并尝试讨论这些现象背后真正的原理!\n虽然下面的有些例子并不一定会让你觉得 WTFs, 但它们依然有可能会告诉你一些你所不知道的 Python 有趣特性. 我觉得这是一种学习编程语言内部原理的好办法, 而且我相信你也会从中获得乐趣!\n如果您是一位经验比较丰富的 Python 程序员, 你可以尝试挑战看是否能一次就找到例子的正确答案. 你可能对其中的一些例子已经比较熟悉了, 那这也许能唤起你当年踩这些坑时的甜蜜回忆 :sweat_smile:\nPS: 如果你不是第一次读了, 你可以在这里 获取变动内容.\n那么, 让我们开始吧\u0026hellip;\nTable of Contents/目录 Table of Contents/目录 Structure of the Examples/示例结构 Usage/用法 👀 Examples/示例 Section: Strain your brain!/大脑运动! \u0026gt; Strings can be tricky sometimes/微妙的字符串 * \u0026gt; Time for some hash brownies!/是时候来点蛋糕了! \u0026gt; Return return everywhere!/到处返回！ \u0026gt; Deep down, we\u0026rsquo;re all the same./本质上,我们都一样. * \u0026gt; For what?/为什么? \u0026gt; Evaluation time discrepancy/执行时机差异 \u0026gt; is is not what it is!/出人意料的is! \u0026gt; A tic-tac-toe where X wins in the first attempt!/一蹴即至! \u0026gt; The sticky output function/麻烦的输出 \u0026gt; is not ... is not is (not ...)/is not ... 不是 is (not ...) \u0026gt; The surprising comma/意外的逗号 \u0026gt; Backslashes at the end of string/字符串末尾的反斜杠 \u0026gt; not knot!/别纠结! \u0026gt; Half triple-quoted strings/三个引号 \u0026gt; Midnight time doesn\u0026rsquo;t exist?/不存在的午夜? \u0026gt; What\u0026rsquo;s wrong with booleans?/布尔你咋了? \u0026gt; Class attributes and instance attributes/类属性和实例属性 \u0026gt; yielding None/生成 None \u0026gt; Mutating the immutable!/强人所难 \u0026gt; The disappearing variable from outer scope/消失的外部变量 \u0026gt; When True is actually False/真亦假 \u0026gt; From filled to None in one instruction\u0026hellip;/从有到无\u0026hellip; \u0026gt; Subclass relationships/子类关系 * \u0026gt; The mysterious key type conversion/神秘的键型转换 * \u0026gt; Let\u0026rsquo;s see if you can guess this?/看看你能否猜到这一点? Section: Appearances are deceptive!/外表是靠不住的! \u0026gt; Skipping lines?/跳过一行? \u0026gt; Teleportation/空间移动 * \u0026gt; Well, something is fishy\u0026hellip;/嗯, 有些可疑\u0026hellip; Section: Watch out for the landmines!/小心地雷! \u0026gt; Modifying a dictionary while iterating over it/迭代字典时的修改 \u0026gt; Stubborn del operator/坚强的 del * \u0026gt; Deleting a list item while iterating/迭代列表时删除元素 \u0026gt; Loop variables leaking out!/循环变量泄漏! \u0026gt; Beware of default mutable arguments!/当心默认的可变参数! \u0026gt; Catching the Exceptions/捕获异常 \u0026gt; Same operands, different story!/同人不同命! \u0026gt; The out of scope variable/外部作用域变量 \u0026gt; Be careful with chained operations/小心链式操作 \u0026gt; Name resolution ignoring class scope/忽略类作用域的名称解析 \u0026gt; Needle in a Haystack/大海捞针 Section: The Hidden treasures!/隐藏的宝藏! \u0026gt; Okay Python, Can you make me fly?/Python, 可否带我飞? * \u0026gt; goto, but why?/goto, 但为什么? * \u0026gt; Brace yourself!/做好思想准备 * \u0026gt; Let\u0026rsquo;s meet Friendly Language Uncle For Life/让生活更友好 * \u0026gt; Even Python understands that love is complicated/连Python也知道爱是难言的 * \u0026gt; Yes, it exists!/是的, 它存在! \u0026gt; Inpinity/无限 * \u0026gt; Mangling time!修饰时间! * Section: Miscellaneous/杂项 \u0026gt; += is faster/更快的 += \u0026gt; Let\u0026rsquo;s make a giant string!/来做个巨大的字符串吧! \u0026gt; Explicit typecast of strings/字符串的显式类型转换 \u0026gt; Minor Ones/小知识点 Contributing/贡献 Acknowledgements/致谢 🎓 License/许可 Help/帮助 Surprise your geeky pythonist friends?/想给你的极客朋友一个惊喜? Need a pdf version?/需要来一份pdf版的? Follow Commit/追踪Commit 996.icu Structure of the Examples/示例结构 所有示例的结构都如下所示:\n\u0026gt; 一个精选的标题 * 标题末尾的星号表示该示例在第一版中不存在，是最近添加的.\n1 2 # 准备代码. # 释放魔法... Output (Python version):\n1 2 \u0026gt;\u0026gt;\u0026gt; 触发语句 出乎意料的输出结果 (可选): 对意外输出结果的简短描述.\n💡 说明: 简要说明发生了什么以及为什么会发生. 1 如有必要, 举例说明 Output: 1 2 \u0026gt;\u0026gt;\u0026gt; 触发语句 # 一些让魔法变得容易理解的例子 # 一些正常的输入 注意: 所有的示例都在 Python 3.5.2 版本的交互解释器上测试过, 如果不特别说明应该适用于所有 Python 版本.\nUsage/用法 我个人建议, 最好依次阅读下面的示例, 并对每个示例:\n仔细阅读设置例子最开始的代码. 如果您是一位经验丰富的 Python 程序员, 那么大多数时候您都能成功预期到后面的结果. 阅读输出结果, 确认结果是否如你所料. 确认你是否知道这背后的原理. 如果不知道, 深呼吸然后阅读说明 (如果你还是看不明白, 别沉默! 可以在这 提个 issue). 如果知道, 给自己点奖励, 然后去看下一个例子. PS: 你也可以在命令行阅读 WTFpython. 我们有 pypi 包 和 npm 包(支持代码高亮).(译: 这两个都是英文版的)\n安装 npm 包 wtfpython 1 $ npm install -g wtfpython 或者, 安装 pypi 包 wtfpython 1 $ pip install wtfpython -U 现在, 在命令行中运行 wtfpython, 你就可以开始浏览了.\n👀 Examples/示例 Section: Strain your brain!/大脑运动! \u0026gt; Strings can be tricky sometimes/微妙的字符串 * 1.\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a = \u0026#34;some_string\u0026#34; \u0026gt;\u0026gt;\u0026gt; id(a) 140420665652016 \u0026gt;\u0026gt;\u0026gt; id(\u0026#34;some\u0026#34; + \u0026#34;_\u0026#34; + \u0026#34;string\u0026#34;) # 注意两个的id值是相同的. 140420665652016 2.\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026gt;\u0026gt;\u0026gt; a = \u0026#34;wtf\u0026#34; \u0026gt;\u0026gt;\u0026gt; b = \u0026#34;wtf\u0026#34; \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; a = \u0026#34;wtf!\u0026#34; \u0026gt;\u0026gt;\u0026gt; b = \u0026#34;wtf!\u0026#34; \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; a, b = \u0026#34;wtf!\u0026#34;, \u0026#34;wtf!\u0026#34; \u0026gt;\u0026gt;\u0026gt; a is b True # 3.7 版本返回结果为 False. 3.\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026#39;a\u0026#39; * 20 is \u0026#39;aaaaaaaaaaaaaaaaaaaa\u0026#39; True \u0026gt;\u0026gt;\u0026gt; \u0026#39;a\u0026#39; * 21 is \u0026#39;aaaaaaaaaaaaaaaaaaaaa\u0026#39; False # 3.7 版本返回结果为 True 很好理解, 对吧?\n💡 说明: 这些行为是由于 Cpython 在编译优化时, 某些情况下会尝试使用已经存在的不可变对象而不是每次都创建一个新对象. (这种行为被称作字符串的驻留[string interning])\n发生驻留之后, 许多变量可能指向内存中的相同字符串对象. (从而节省内存)\n在上面的代码中, 字符串是隐式驻留的. 何时发生隐式驻留则取决于具体的实现. 这里有一些方法可以用来猜测字符串是否会被驻留:\n所有长度为 0 和长度为 1 的字符串都被驻留.\n字符串在编译时被实现 ('wtf' 将被驻留, 但是 ''.join(['w', 't', 'f']) 将不会被驻留)\n字符串中只包含字母，数字或下划线时将会驻留. 所以 'wtf!' 由于包含 ! 而未被驻留. 可以在这里 找到 CPython 对此规则的实现.\n当在同一行将 a 和 b 的值设置为 \u0026quot;wtf!\u0026quot; 的时候, Python 解释器会创建一个新对象, 然后同时引用第二个变量(译: 仅适用于3.7以下, 详细情况请看这里 ). 如果你在不同的行上进行赋值操作, 它就不会“知道”已经有一个 wtf！ 对象 (因为 \u0026quot;wtf!\u0026quot; 不是按照上面提到的方式被隐式驻留的). 它是一种编译器优化, 特别适用于交互式环境.\n常量折叠(constant folding) 是 Python 中的一种 窥孔优化(peephole optimization) 技术. 这意味着在编译时表达式 'a'*20 会被替换为 'aaaaaaaaaaaaaaaaaaaa' 以减少运行时的时钟周期. 只有长度小于 20 的字符串才会发生常量折叠. (为啥? 想象一下由于表达式 'a'*10**10 而生成的 .pyc 文件的大小). 相关的源码实现在这里 .\n如果你是使用 3.7 版本中运行上述示例代码, 会发现部分代码的运行结果与注释说明相同. 这是因为在 3.7 版本中, 常量折叠已经从窥孔优化器迁移至新的 AST 优化器, 后者可以以更高的一致性来执行优化. (由 Eugene Toder 和 INADA Naoki 在 bpo-29469 和 bpo-11549 中贡献.)\n(译: 但是在最新的 3.8 版本中, 结果又变回去了. 虽然 3.8 版本和 3.7 版本一样, 都是使用 AST 优化器. 目前不确定官方对 3.8 版本的 AST 做了什么调整.)\n\u0026gt; Time for some hash brownies!/是时候来点蛋糕了! hash brownie指一种含有大麻成分的蛋糕, 所以这里是句双关 1.\n1 2 3 4 some_dict = {} some_dict[5.5] = \u0026#34;Ruby\u0026#34; some_dict[5.0] = \u0026#34;JavaScript\u0026#34; some_dict[5] = \u0026#34;Python\u0026#34; Output:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; some_dict[5.5] \u0026#34;Ruby\u0026#34; \u0026gt;\u0026gt;\u0026gt; some_dict[5.0] \u0026#34;Python\u0026#34; \u0026gt;\u0026gt;\u0026gt; some_dict[5] \u0026#34;Python\u0026#34; \u0026ldquo;Python\u0026rdquo; 消除了 \u0026ldquo;JavaScript\u0026rdquo; 的存在?\n💡 说明: Python 字典通过检查键值是否相等和比较哈希值来确定两个键是否相同. 具有相同值的不可变对象在Python中始终具有相同的哈希值. 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; 5 == 5.0 True \u0026gt;\u0026gt;\u0026gt; hash(5) == hash(5.0) True 注意: 具有不同值的对象也可能具有相同的哈希值（哈希冲突）. 当执行 some_dict[5] = \u0026quot;Python\u0026quot; 语句时, 因为Python将 5 和 5.0 识别为 some_dict 的同一个键, 所以已有值 \u0026ldquo;JavaScript\u0026rdquo; 就被 \u0026ldquo;Python\u0026rdquo; 覆盖了. 这个 StackOverflow的 回答 漂亮地解释了这背后的基本原理. \u0026gt; Return return everywhere!/到处返回！ 1 2 3 4 5 def some_func(): try: return \u0026#39;from_try\u0026#39; finally: return \u0026#39;from_finally\u0026#39; Output:\n1 2 \u0026gt;\u0026gt;\u0026gt; some_func() \u0026#39;from_finally\u0026#39; 💡 说明: 当在 \u0026ldquo;try\u0026hellip;finally\u0026rdquo; 语句的 try 中执行 return, break 或 continue 后, finally 子句依然会执行. 函数的返回值由最后执行的 return 语句决定. 由于 finally 子句一定会执行, 所以 finally 子句中的 return 将始终是最后执行的语句. \u0026gt; Deep down, we\u0026rsquo;re all the same./本质上,我们都一样. * 1 2 class WTF: pass Output:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; WTF() == WTF() # 两个不同的对象应该不相等 False \u0026gt;\u0026gt;\u0026gt; WTF() is WTF() # 也不相同 False \u0026gt;\u0026gt;\u0026gt; hash(WTF()) == hash(WTF()) # 哈希值也应该不同 True \u0026gt;\u0026gt;\u0026gt; id(WTF()) == id(WTF()) True 💡 说明: 当调用 id 函数时, Python 创建了一个 WTF 类的对象并传给 id 函数. 然后 id 函数获取其id值 (也就是内存地址), 然后丢弃该对象. 该对象就被销毁了.\n当我们连续两次进行这个操作时, Python会将相同的内存地址分配给第二个对象. 因为 (在CPython中) id 函数使用对象的内存地址作为对象的id值, 所以两个对象的id值是相同的.\n综上, 对象的id值仅仅在对象的生命周期内唯一. 在对象被销毁之后, 或被创建之前, 其他对象可以具有相同的id值.\n那为什么 is 操作的结果为 False 呢? 让我们看看这段代码.\n1 2 3 class WTF(object): def __init__(self): print(\u0026#34;I\u0026#34;) def __del__(self): print(\u0026#34;D\u0026#34;) Output:\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; WTF() is WTF() I I D D False \u0026gt;\u0026gt;\u0026gt; id(WTF()) == id(WTF()) I D I D True 正如你所看到的, 对象销毁的顺序是造成所有不同之处的原因.\n\u0026gt; For what?/为什么? 1 2 3 4 some_string = \u0026#34;wtf\u0026#34; some_dict = {} for i, some_dict[i] in enumerate(some_string): pass Output:\n1 2 \u0026gt;\u0026gt;\u0026gt; some_dict # 创建了索引字典. {0: \u0026#39;w\u0026#39;, 1: \u0026#39;t\u0026#39;, 2: \u0026#39;f\u0026#39;} 💡 说明: Python 语法 中对 for 的定义是:\nfor_stmt: \u0026#39;for\u0026#39; exprlist \u0026#39;in\u0026#39; testlist \u0026#39;:\u0026#39; suite [\u0026#39;else\u0026#39; \u0026#39;:\u0026#39; suite] 其中 exprlist 指分配目标. 这意味着对可迭代对象中的每一项都会执行类似 {exprlist} = {next_value} 的操作.\n一个有趣的例子说明了这一点:\n1 2 3 for i in range(4): print(i) i = 10 Output:\n0\r1\r2\r3 你可曾觉得这个循环只会运行一次?\n💡 说明:\n由于循环在Python中工作方式, 赋值语句 i = 10 并不会影响迭代循环, 在每次迭代开始之前, 迭代器(这里指 range(4)) 生成的下一个元素就被解包并赋值给目标列表的变量(这里指 i)了. 在每一次的迭代中, enumerate(some_string) 函数就生成一个新值 i (计数器增加) 并从 some_string 中获取一个字符. 然后将字典 some_dict 键 i (刚刚分配的) 的值设为该字符. 本例中循环的展开可以简化为:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; i, some_dict[i] = (0, \u0026#39;w\u0026#39;) \u0026gt;\u0026gt;\u0026gt; i, some_dict[i] = (1, \u0026#39;t\u0026#39;) \u0026gt;\u0026gt;\u0026gt; i, some_dict[i] = (2, \u0026#39;f\u0026#39;) \u0026gt;\u0026gt;\u0026gt; some_dict \u0026gt; Evaluation time discrepancy/执行时机差异 1.\n1 2 3 array = [1, 8, 15] g = (x for x in array if array.count(x) \u0026gt; 0) array = [2, 8, 22] Output:\n1 2 \u0026gt;\u0026gt;\u0026gt; print(list(g)) [8] 2.\n1 2 3 4 5 6 7 array_1 = [1,2,3,4] g1 = (x for x in array_1) array_1 = [1,2,3,4,5] array_2 = [1,2,3,4] g2 = (x for x in array_2) array_2[:] = [1,2,3,4,5] Output:\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; print(list(g1)) [1,2,3,4] \u0026gt;\u0026gt;\u0026gt; print(list(g2)) [1,2,3,4,5] 💡 说明 在生成器 表达式中, in 子句在声明时执行, 而条件子句则是在运行时执行. 所以在运行前, array 已经被重新赋值为 [2, 8, 22], 因此对于之前的 1, 8 和 15, 只有 count(8) 的结果是大于 0 的, 所以生成器只会生成 8. 第二部分中 g1 和 g2 的输出差异则是由于变量 array_1 和 array_2 被重新赋值的方式导致的. 在第一种情况下, array_1 被绑定到新对象 [1,2,3,4,5], 因为 in 子句是在声明时被执行的， 所以它仍然引用旧对象 [1,2,3,4](并没有被销毁). 在第二种情况下, 对 array_2 的切片赋值将相同的旧对象 [1,2,3,4] 原地更新为 [1,2,3,4,5]. 因此 g2 和 array_2 仍然引用同一个对象(这个对象现在已经更新为 [1,2,3,4,5]). \u0026gt; is is not what it is!/出人意料的is! 下面是一个在互联网上非常有名的例子.\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026gt;\u0026gt;\u0026gt; a = 256 \u0026gt;\u0026gt;\u0026gt; b = 256 \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; a = 257 \u0026gt;\u0026gt;\u0026gt; b = 257 \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; a = 257; b = 257 \u0026gt;\u0026gt;\u0026gt; a is b True 💡 说明: is 和 == 的区别\nis 运算符检查两个运算对象是否引用自同一对象 (即, 它检查两个运算对象是否相同). == 运算符比较两个运算对象的值是否相等. 因此 is 代表引用相同, == 代表值相等. 下面的例子可以很好的说明这点, 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; [] == [] True \u0026gt;\u0026gt;\u0026gt; [] is [] # 这两个空列表位于不同的内存地址. False 256 是一个已经存在的对象, 而 257 不是\n当你启动Python 的时候, 数值为 -5 到 256 的对象就已经被分配好了. 这些数字因为经常被使用, 所以会被提前准备好.\nPython 通过这种创建小整数池的方式来避免小整数频繁的申请和销毁内存空间.\n引用自 https://docs.python.org/3/c-api/long.html 当前的实现为-5到256之间的所有整数保留一个整数对象数组, 当你创建了一个该范围内的整数时, 你只需要返回现有对象的引用. 所以改变1的值是有可能的. 我怀疑这种行为在Python中是未定义行为. :-)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026gt;\u0026gt;\u0026gt; id(256) 10922528 \u0026gt;\u0026gt;\u0026gt; a = 256 \u0026gt;\u0026gt;\u0026gt; b = 256 \u0026gt;\u0026gt;\u0026gt; id(a) 10922528 \u0026gt;\u0026gt;\u0026gt; id(b) 10922528 \u0026gt;\u0026gt;\u0026gt; id(257) 140084850247312 \u0026gt;\u0026gt;\u0026gt; x = 257 \u0026gt;\u0026gt;\u0026gt; y = 257 \u0026gt;\u0026gt;\u0026gt; id(x) 140084850247440 \u0026gt;\u0026gt;\u0026gt; id(y) 140084850247344 这里解释器并没有智能到能在执行 y = 257 时意识到我们已经创建了一个整数 257, 所以它在内存中又新建了另一个对象.\n当 a 和 b 在同一行中使用相同的值初始化时，会指向同一个对象.\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; a, b = 257, 257 \u0026gt;\u0026gt;\u0026gt; id(a) 140640774013296 \u0026gt;\u0026gt;\u0026gt; id(b) 140640774013296 \u0026gt;\u0026gt;\u0026gt; a = 257 \u0026gt;\u0026gt;\u0026gt; b = 257 \u0026gt;\u0026gt;\u0026gt; id(a) 140640774013392 \u0026gt;\u0026gt;\u0026gt; id(b) 140640774013488 当 a 和 b 在同一行中被设置为 257 时, Python 解释器会创建一个新对象, 然后同时引用第二个变量. 如果你在不同的行上进行, 它就不会 \u0026ldquo;知道\u0026rdquo; 已经存在一个 257 对象了. 这是一种特别为交互式环境做的编译器优化. 当你在实时解释器中输入两行的时候, 他们会单独编译, 因此也会单独进行优化. 如果你在 .py 文件中尝试这个例子, 则不会看到相同的行为, 因为文件是一次性编译的. \u0026gt; A tic-tac-toe where X wins in the first attempt!/一蹴即至! 1 2 3 4 # 我们先初始化一个变量row row = [\u0026#34;\u0026#34;]*3 #row i[\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;] # 并创建一个变量board board = [row]*3 Output:\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; board [[\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;], [\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;], [\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;]] \u0026gt;\u0026gt;\u0026gt; board[0] [\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;] \u0026gt;\u0026gt;\u0026gt; board[0][0] \u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt; board[0][0] = \u0026#34;X\u0026#34; \u0026gt;\u0026gt;\u0026gt; board [[\u0026#39;X\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;], [\u0026#39;X\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;], [\u0026#39;X\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;]] 我们有没有赋值过3个 \u0026ldquo;X\u0026rdquo; 呢？\n💡 说明: 当我们初始化 row 变量时, 下面这张图展示了内存中的情况。\n而当通过对 row 做乘法来初始化 board 时, 内存中的情况则如下图所示 (每个元素 board[0], board[1] 和 board[2] 都和 row 一样引用了同一列表.)\n我们可以通过不使用变量 row 生成 board 来避免这种情况. (这个 issue提出了这个需求.)\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; board = [[\u0026#39;\u0026#39;]*3 for _ in range(3)] \u0026gt;\u0026gt;\u0026gt; board[0][0] = \u0026#34;X\u0026#34; \u0026gt;\u0026gt;\u0026gt; board [[\u0026#39;X\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;], [\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;], [\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;]] \u0026gt; The sticky output function/麻烦的输出 1 2 3 4 5 6 7 8 9 funcs = [] results = [] for x in range(7): def some_func(): return x funcs.append(some_func) results.append(some_func()) # 注意这里函数被执行了 funcs_results = [func() for func in funcs] Output:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; results [0, 1, 2, 3, 4, 5, 6] \u0026gt;\u0026gt;\u0026gt; funcs_results [6, 6, 6, 6, 6, 6, 6] 即使每次在迭代中将 some_func 加入 funcs 前的 x 值都不相同, 所有的函数还是都返回6.\n// 再换个例子\n1 2 3 \u0026gt;\u0026gt;\u0026gt; powers_of_x = [lambda x: x**i for i in range(10)] \u0026gt;\u0026gt;\u0026gt; [f(2) for f in powers_of_x] [512, 512, 512, 512, 512, 512, 512, 512, 512, 512] 💡 说明: 当在循环内部定义一个函数时, 如果该函数在其主体中使用了循环变量, 则闭包函数将与循环变量绑定, 而不是它的值. 因此, 所有的函数都是使用最后分配给变量的值来进行计算的.\n可以通过将循环变量作为命名变量传递给函数来获得预期的结果. 为什么这样可行? 因为这会在函数内再次定义一个局部变量.\n1 2 3 4 5 funcs = [] for x in range(7): def some_func(x=x): return x funcs.append(some_func) Output:\n1 2 3 \u0026gt;\u0026gt;\u0026gt; funcs_results = [func() for func in funcs] \u0026gt;\u0026gt;\u0026gt; funcs_results [0, 1, 2, 3, 4, 5, 6] \u0026gt; is not ... is not is (not ...)/is not ... 不是 is (not ...) 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026#39;something\u0026#39; is not None True \u0026gt;\u0026gt;\u0026gt; \u0026#39;something\u0026#39; is (not None) False 💡 说明: is not 是个单独的二元运算符, 与分别使用 is 和 not 不同. 如果操作符两侧的变量指向同一个对象, 则 is not 的结果为 False, 否则结果为 True. \u0026gt; The surprising comma/意外的逗号 Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026gt;\u0026gt;\u0026gt; def f(x, y,): ... print(x, y) ... \u0026gt;\u0026gt;\u0026gt; def g(x=4, y=5,): ... print(x, y) ... \u0026gt;\u0026gt;\u0026gt; def h(x, **kwargs,): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 def h(x, **kwargs,): ^ SyntaxError: invalid syntax \u0026gt;\u0026gt;\u0026gt; def h(*args,): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 def h(*args,): ^ SyntaxError: invalid syntax 💡 说明: 在Python函数的形式参数列表中, 尾随逗号并不一定是合法的. 在Python中, 参数列表部分用前置逗号定义, 部分用尾随逗号定义. 这种冲突导致逗号被夹在中间, 没有规则定义它.(译:这一句看得我也很懵逼,只能强翻了.详细解释看下面的讨论帖会一目了然.) 注意: 尾随逗号的问题已经在Python 3.6中被修复 了. 而这篇帖子 中则简要讨论了Python中尾随逗号的不同用法. \u0026gt; Backslashes at the end of string/字符串末尾的反斜杠 Output:\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;\\\\ C:\\\\\u0026#34;)\r\\ C:\\\r\u0026gt;\u0026gt;\u0026gt; print(r\u0026#34;\\ C:\u0026#34;)\r\\ C:\r\u0026gt;\u0026gt;\u0026gt; print(r\u0026#34;\\ C:\\\u0026#34;)\rFile \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1\rprint(r\u0026#34;\\ C:\\\u0026#34;)\r^\rSyntaxError: EOL while scanning string literal 💡 说明: 在以 r 开头的原始字符串中, 反斜杠并没有特殊含义. 1 2 \u0026gt;\u0026gt;\u0026gt; print(repr(r\u0026#34;wt\\\u0026#34;f\u0026#34;)) \u0026#39;wt\\\\\u0026#34;f\u0026#39; 解释器所做的只是简单的改变了反斜杠的行为, 因此会直接放行反斜杠及后一个的字符. 这就是反斜杠在原始字符串末尾不起作用的原因. \u0026gt; not knot!/别纠结! 1 2 x = True y = False Output:\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; not x == y True \u0026gt;\u0026gt;\u0026gt; x == not y File \u0026#34;\u0026lt;input\u0026gt;\u0026#34;, line 1 x == not y ^ SyntaxError: invalid syntax 💡 说明: 运算符的优先级会影响表达式的求值顺序, 而在 Python 中 == 运算符的优先级要高于 not 运算符. 所以 not x == y 相当于 not (x == y), 同时等价于 not (True == False), 最后的运算结果就是 True. 之所以 x == not y 会抛一个 SyntaxError 异常, 是因为它会被认为等价于 (x == not) y, 而不是你一开始期望的 x == (not y). 解释器期望 not 标记是 not in 操作符的一部分 (因为 == 和 not in 操作符具有相同的优先级), 但是它在 not 标记后面找不到 in 标记, 所以会抛出 SyntaxError 异常. \u0026gt; Half triple-quoted strings/三个引号 Output:\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;wtfpython\u0026#39;\u0026#39;\u0026#39;) wtfpython \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;wtfpython\u0026#34;\u0026#34;\u0026#34;) wtfpython \u0026gt;\u0026gt;\u0026gt; # 下面的语句会抛出 `SyntaxError` 异常 \u0026gt;\u0026gt;\u0026gt; # print(\u0026#39;\u0026#39;\u0026#39;wtfpython\u0026#39;) \u0026gt;\u0026gt;\u0026gt; # print(\u0026#34;\u0026#34;\u0026#34;wtfpython\u0026#34;) 💡 说明: Python 提供隐式的字符串连接 , 例如, \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;wtf\u0026#34; \u0026#34;python\u0026#34;)\rwtfpython\r\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;wtf\u0026#34; \u0026#34;\u0026#34;) # or \u0026#34;wtf\u0026#34;\u0026#34;\u0026#34;\rwtf ''' 和 \u0026quot;\u0026quot;\u0026quot; 在 Python中也是字符串定界符, Python 解释器在先遇到三个引号的的时候会尝试再寻找三个终止引号作为定界符, 如果不存在则会导致 SyntaxError 异常. \u0026gt; Midnight time doesn\u0026rsquo;t exist?/不存在的午夜? 1 2 3 4 5 6 7 8 9 10 11 12 13 from datetime import datetime midnight = datetime(2018, 1, 1, 0, 0) midnight_time = midnight.time() noon = datetime(2018, 1, 1, 12, 0) noon_time = noon.time() if midnight_time: print(\u0026#34;Time at midnight is\u0026#34;, midnight_time) if noon_time: print(\u0026#34;Time at noon is\u0026#34;, noon_time) Output:\n1 (\u0026#39;Time at noon is\u0026#39;, datetime.time(12, 0)) midnight_time 并没有被输出.\n💡 说明: 在Python 3.5之前, 如果 datetime.time 对象存储的UTC的午夜时间(译: 就是 00:00), 那么它的布尔值会被认为是 False. 当使用 if obj: 语句来检查 obj 是否为 null 或者某些“空”值的时候, 很容易出错.\n\u0026gt; What\u0026rsquo;s wrong with booleans?/布尔你咋了? 1.\n1 2 3 4 5 6 7 8 9 10 # 一个简单的例子, 统计下面可迭代对象中的布尔型值的个数和整型值的个数 mixed_list = [False, 1.0, \u0026#34;some_string\u0026#34;, 3, True, [], False] integers_found_so_far = 0 booleans_found_so_far = 0 for item in mixed_list: if isinstance(item, int): integers_found_so_far += 1 elif isinstance(item, bool): booleans_found_so_far += 1 Output:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; integers_found_so_far 4 \u0026gt;\u0026gt;\u0026gt; booleans_found_so_far 0 2.\n1 2 3 4 another_dict = {} another_dict[True] = \u0026#34;JavaScript\u0026#34; another_dict[1] = \u0026#34;Ruby\u0026#34; another_dict[1.0] = \u0026#34;Python\u0026#34; Output:\n1 2 \u0026gt;\u0026gt;\u0026gt; another_dict[True] \u0026#34;Python\u0026#34; 3.\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; some_bool = True \u0026gt;\u0026gt;\u0026gt; \u0026#34;wtf\u0026#34;*some_bool \u0026#39;wtf\u0026#39; \u0026gt;\u0026gt;\u0026gt; some_bool = False \u0026gt;\u0026gt;\u0026gt; \u0026#34;wtf\u0026#34;*some_bool \u0026#39;\u0026#39; 💡 说明: 布尔值是 int 的子类\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; isinstance(True, int) True \u0026gt;\u0026gt;\u0026gt; isinstance(False, int) True 所以 True 的整数值是 1, 而 False 的整数值是 0.\n1 2 \u0026gt;\u0026gt;\u0026gt; True == 1 == 1.0 and False == 0 == 0.0 True 关于其背后的原理, 请看这个 StackOverflow 的回答 .\n\u0026gt; Class attributes and instance attributes/类属性和实例属性 1.\n1 2 3 4 5 6 7 8 class A: x = 1 class B(A): pass class C(A): pass Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026gt;\u0026gt;\u0026gt; A.x, B.x, C.x (1, 1, 1) \u0026gt;\u0026gt;\u0026gt; B.x = 2 \u0026gt;\u0026gt;\u0026gt; A.x, B.x, C.x (1, 2, 1) \u0026gt;\u0026gt;\u0026gt; A.x = 3 \u0026gt;\u0026gt;\u0026gt; A.x, B.x, C.x (3, 2, 3) \u0026gt;\u0026gt;\u0026gt; a = A() \u0026gt;\u0026gt;\u0026gt; a.x, A.x (3, 3) \u0026gt;\u0026gt;\u0026gt; a.x += 1 \u0026gt;\u0026gt;\u0026gt; a.x, A.x (4, 3) 2.\n1 2 3 4 5 6 7 8 class SomeClass: some_var = 15 some_list = [5] another_list = [5] def __init__(self, x): self.some_var = x + 1 self.some_list = self.some_list + [x] self.another_list += [x] Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026gt;\u0026gt;\u0026gt; some_obj = SomeClass(420) \u0026gt;\u0026gt;\u0026gt; some_obj.some_list [5, 420] \u0026gt;\u0026gt;\u0026gt; some_obj.another_list [5, 420] \u0026gt;\u0026gt;\u0026gt; another_obj = SomeClass(111) \u0026gt;\u0026gt;\u0026gt; another_obj.some_list [5, 111] \u0026gt;\u0026gt;\u0026gt; another_obj.another_list [5, 420, 111] \u0026gt;\u0026gt;\u0026gt; another_obj.another_list is SomeClass.another_list True \u0026gt;\u0026gt;\u0026gt; another_obj.another_list is some_obj.another_list True 💡 说明: 类变量和实例变量在内部是通过类对象的字典来处理(译: 就是 __dict__ 属性). 如果在当前类的字典中找不到的话就去它的父类中寻找. += 运算符会在原地修改可变对象, 而不是创建新对象. 因此, 在这种情况下, 修改一个实例的属性会影响其他实例和类属性. \u0026gt; yielding None/生成 None 1 2 3 4 some_iterable = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) def some_func(val): return \u0026#34;something\u0026#34; Output:\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; [x for x in some_iterable] [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; [(yield x) for x in some_iterable] \u0026lt;generator object \u0026lt;listcomp\u0026gt; at 0x7f70b0a4ad58\u0026gt; \u0026gt;\u0026gt;\u0026gt; list([(yield x) for x in some_iterable]) [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; list((yield x) for x in some_iterable) [\u0026#39;a\u0026#39;, None, \u0026#39;b\u0026#39;, None] \u0026gt;\u0026gt;\u0026gt; list(some_func((yield x)) for x in some_iterable) [\u0026#39;a\u0026#39;, \u0026#39;something\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;something\u0026#39;] 💡 说明: 来源和解释可以在这里找到: https://stackoverflow.com/questions/32139885/yield-in-list-comprehensions-and-generator-expressions 相关错误报告: http://bugs.python.org/issue10544 这个bug在3.7以后的版本中不被推荐使用, 并在3.8中被修复. 因此在3.8中尝试在推导式中使用 yield, 只会得到一个 SyntaxError. 详细内容可以看3.7更新内容 , 3.8更新内容 . \u0026gt; Mutating the immutable!/强人所难 1 2 some_tuple = (\u0026#34;A\u0026#34;, \u0026#34;tuple\u0026#34;, \u0026#34;with\u0026#34;, \u0026#34;values\u0026#34;) another_tuple = ([1, 2], [3, 4], [5, 6]) Output:\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; some_tuple[2] = \u0026#34;change this\u0026#34; TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment \u0026gt;\u0026gt;\u0026gt; another_tuple[2].append(1000) # 这里不出现错误 \u0026gt;\u0026gt;\u0026gt; another_tuple ([1, 2], [3, 4], [5, 6, 1000]) \u0026gt;\u0026gt;\u0026gt; another_tuple[2] += [99, 999] TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment \u0026gt;\u0026gt;\u0026gt; another_tuple ([1, 2], [3, 4], [5, 6, 1000, 99, 999]) 我还以为元组是不可变的呢\u0026hellip;\n💡 说明: 引用 https://docs.python.org/2/reference/datamodel.html 不可变序列 不可变序列的对象一旦创建就不能再改变. (如果对象包含对其他对象的引用，则这些其他对象可能是可变的并且可能会被修改; 但是，由不可变对象直接引用的对象集合不能更改.)\n+= 操作符在原地修改了列表. 元素赋值操作并不工作, 但是当异常抛出时, 元素已经在原地被修改了.\n(译: 对于不可变对象, 这里指tuple, += 并不是原子操作, 而是 extend 和 = 两个动作, 这里 = 操作虽然会抛出异常, 但 extend 操作已经修改成功了. 详细解释可以看这里 )\n\u0026gt; The disappearing variable from outer scope/消失的外部变量 1 2 3 4 5 e = 7 try: raise Exception() except Exception as e: pass Output (Python 2.x):\n1 2 \u0026gt;\u0026gt;\u0026gt; print(e) # prints nothing Output (Python 3.x):\n1 2 \u0026gt;\u0026gt;\u0026gt; print(e) NameError: name \u0026#39;e\u0026#39; is not defined 💡 说明: 出处: https://docs.python.org/3/reference/compound_stmts.html#except 当使用 as 为目标分配异常的时候, 将在except子句的末尾清除该异常.\n这就好像\n1 2 except E as N: foo 会被翻译成\n1 2 3 4 5 except E as N: try: foo finally: del N 这意味着异常必须在被赋值给其他变量才能在 except 子句之后引用它. 而异常之所以会被清除, 则是由于上面附加的回溯信息(trackback)会和栈帧(stack frame)形成循环引用, 使得该栈帧中的所有本地变量在下一次垃圾回收发生之前都处于活动状态.(译: 也就是说不会被回收)\n子句在 Python 中并没有独立的作用域. 示例中的所有内容都处于同一作用域内, 所以变量 e 会由于执行了 except 子句而被删除. 而对于有独立的内部作用域的函数来说情况就不一样了. 下面的例子说明了这一点:\n1 2 3 4 5 6 def f(x): del(x) print(x) x = 5 y = [5, 4, 3] Output:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt;f(x) UnboundLocalError: local variable \u0026#39;x\u0026#39; referenced before assignment \u0026gt;\u0026gt;\u0026gt;f(y) UnboundLocalError: local variable \u0026#39;x\u0026#39; referenced before assignment \u0026gt;\u0026gt;\u0026gt; x 5 \u0026gt;\u0026gt;\u0026gt; y [5, 4, 3] 在 Python 2.x 中, Exception() 实例被赋值给了变量 e, 所以当你尝试打印结果的时候, 它的输出为空.（译: 正常的Exception实例打印出来就是空）\nOutput (Python 2.x):\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; e Exception() \u0026gt;\u0026gt;\u0026gt; print e # 没有打印任何内容! \u0026gt; When True is actually False/真亦假 1 2 3 True = False if True == False: print(\u0026#34;I\u0026#39;ve lost faith in truth!\u0026#34;) Output:\nI\u0026#39;ve lost faith in truth! 💡 说明: 最初, Python 并没有 bool 型 (人们用0表示假值, 用非零值比如1作为真值). 后来他们添加了 True, False, 和 bool 型, 但是, 为了向后兼容, 他们没法把 True 和 False 设置为常量, 只是设置成了内置变量. Python 3 由于不再需要向后兼容, 终于可以修复这个问题了, 所以这个例子无法在 Python 3.x 中执行! \u0026gt; From filled to None in one instruction\u0026hellip;/从有到无\u0026hellip; 1 2 3 4 5 6 7 8 9 some_list = [1, 2, 3] some_dict = { \u0026#34;key_1\u0026#34;: 1, \u0026#34;key_2\u0026#34;: 2, \u0026#34;key_3\u0026#34;: 3 } some_list = some_list.append(4) some_dict = some_dict.update({\u0026#34;key_4\u0026#34;: 4}) Output:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; print(some_list) None \u0026gt;\u0026gt;\u0026gt; print(some_dict) None 💡 说明: 大多数修改序列/映射对象的方法, 比如 list.append, dict.update, list.sort 等等. 都是原地修改对象并返回 None. 这样做的理由是, 如果操作可以原地完成, 就可以避免创建对象的副本来提高性能. (参考这里 )\n\u0026gt; Subclass relationships/子类关系 * Output:\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; from collections import Hashable \u0026gt;\u0026gt;\u0026gt; issubclass(list, object) True \u0026gt;\u0026gt;\u0026gt; issubclass(object, Hashable) True \u0026gt;\u0026gt;\u0026gt; issubclass(list, Hashable) False 子类关系应该是可传递的, 对吧? (即, 如果 A 是 B 的子类, B 是 C 的子类, 那么 A 应该 是 C 的子类.)\n💡 说明: Python 中的子类关系并不一定是传递的. 任何人都可以在元类中随意定义 __subclasscheck__. 当 issubclass(cls, Hashable) 被调用时, 它只是在 cls 中寻找 __hash__ 方法或者从继承的父类中寻找 __hash__ 方法. 由于 object is 可散列的(hashable), 但是 list 是不可散列的, 所以它打破了这种传递关系. 在这里 可以找到更详细的解释. \u0026gt; The mysterious key type conversion/神秘的键型转换 * 1 2 3 4 class SomeClass(str): pass some_dict = {\u0026#39;s\u0026#39;:42} Output:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; type(list(some_dict.keys())[0]) str \u0026gt;\u0026gt;\u0026gt; s = SomeClass(\u0026#39;s\u0026#39;) \u0026gt;\u0026gt;\u0026gt; some_dict[s] = 40 \u0026gt;\u0026gt;\u0026gt; some_dict # 预期: 两个不同的键值对 {\u0026#39;s\u0026#39;: 40} \u0026gt;\u0026gt;\u0026gt; type(list(some_dict.keys())[0]) str 💡 说明: 由于 SomeClass 会从 str 自动继承 __hash__ 方法, 所以 s 对象和 \u0026quot;s\u0026quot; 字符串的哈希值是相同的.\n而 SomeClass(\u0026quot;s\u0026quot;) == \u0026quot;s\u0026quot; 为 True 是因为 SomeClass 也继承了 str 类 __eq__ 方法.\n由于两者的哈希值相同且相等, 所以它们在字典中表示相同的键.\n如果想要实现期望的功能, 我们可以重定义 SomeClass 的 __eq__ 方法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class SomeClass(str): def __eq__(self, other): return ( type(self) is SomeClass and type(other) is SomeClass and super().__eq__(other) ) # 当我们自定义 __eq__ 方法时, Python 不会再自动继承 __hash__ 方法 # 所以我们也需要定义它 __hash__ = str.__hash__ some_dict = {\u0026#39;s\u0026#39;:42} Output:\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; s = SomeClass(\u0026#39;s\u0026#39;) \u0026gt;\u0026gt;\u0026gt; some_dict[s] = 40 \u0026gt;\u0026gt;\u0026gt; some_dict {\u0026#39;s\u0026#39;: 40, \u0026#39;s\u0026#39;: 42} \u0026gt;\u0026gt;\u0026gt; keys = list(some_dict.keys()) \u0026gt;\u0026gt;\u0026gt; type(keys[0]), type(keys[1]) (__main__.SomeClass, str) \u0026gt; Let\u0026rsquo;s see if you can guess this?/看看你能否猜到这一点? 1 a, b = a[b] = {}, 5 Output:\n1 2 \u0026gt;\u0026gt;\u0026gt; a {5: ({...}, 5)} 💡 说明: 根据 Python 语言参考 , 赋值语句的形式如下\n(target_list \u0026#34;=\u0026#34;)+ (expression_list | yield_expression) 赋值语句计算表达式列表(expression list)(牢记 这可以是单个表达式或以逗号分隔的列表, 后者返回元组)并将单个结果对象从左到右分配给目标列表中的每一项.\n(target_list \u0026quot;=\u0026quot;)+ 中的 + 意味着可以有一个或多个目标列表. 在这个例子中, 目标列表是 a, b 和 a[b] (注意表达式列表只能有一个, 在我们的例子中是 {}, 5).\n表达式列表计算结束后, 将其值自动解包后从左到右分配给目标列表(target list). 因此, 在我们的例子中, 首先将 {}, 5 元组并赋值给 a, b, 然后我们就可以得到 a = {} 且 b = 5.\na 被赋值的 {} 是可变对象.\n第二个目标列表是 a[b] (你可能觉得这里会报错, 因为在之前的语句中 a 和 b 都还没有被定义. 但是别忘了, 我们刚刚将 a 赋值 {} 且将 b 赋值为 5).\n现在, 我们将通过将字典中键 5 的值设置为元组 ({}, 5) 来创建循环引用 (输出中的 {...} 指与 a 引用了相同的对象). 下面是一个更简单的循环引用的例子\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; some_list = some_list[0] = [0] \u0026gt;\u0026gt;\u0026gt; some_list [[...]] \u0026gt;\u0026gt;\u0026gt; some_list[0] [[...]] \u0026gt;\u0026gt;\u0026gt; some_list is some_list[0] True \u0026gt;\u0026gt;\u0026gt; some_list[0][0][0][0][0][0] == some_list True 我们的例子就是这种情况 (a[b][0] 与 a 是相同的对象)\n总结一下, 你也可以把例子拆成\n1 2 a, b = {}, 5 a[b] = a, b 并且可以通过 a[b][0] 与 a 是相同的对象来证明是循环引用\n1 2 \u0026gt;\u0026gt;\u0026gt; a[b][0] is a True Section: Appearances are deceptive!/外表是靠不住的! \u0026gt; Skipping lines?/跳过一行? Output:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; value = 11 \u0026gt;\u0026gt;\u0026gt; valuе = 32 \u0026gt;\u0026gt;\u0026gt; value 11 什么鬼?\n注意: 如果你想要重现的话最简单的方法是直接复制上面的代码片段到你的文件或命令行里.\n💡 说明: 一些非西方字符虽然看起来和英语字母相同, 但会被解释器识别为不同的字母.\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;е\u0026#39;) # 西里尔语的 \u0026#39;e\u0026#39; (Ye) 1077 \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;e\u0026#39;) # 拉丁语的 \u0026#39;e\u0026#39;, 用于英文并使用标准键盘输入 101 \u0026gt;\u0026gt;\u0026gt; \u0026#39;е\u0026#39; == \u0026#39;e\u0026#39; False \u0026gt;\u0026gt;\u0026gt; value = 42 # 拉丁语 e \u0026gt;\u0026gt;\u0026gt; valuе = 23 # 西里尔语 \u0026#39;e\u0026#39;, Python 2.x 的解释器在这会抛出 `SyntaxError` 异常 \u0026gt;\u0026gt;\u0026gt; value 42 内置的 ord() 函数可以返回一个字符的 Unicode 代码点 , 这里西里尔语 \u0026rsquo;e\u0026rsquo; 和拉丁语 \u0026rsquo;e\u0026rsquo; 的代码点不同证实了上述例子.\n\u0026gt; Teleportation/空间移动 * 1 2 3 4 5 6 7 8 9 import numpy as np def energy_send(x): # 初始化一个 numpy 数组 np.array([float(x)]) def energy_receive(): # 返回一个空的 numpy 数组 return np.empty((), dtype=np.float).tolist() Output:\n1 2 3 \u0026gt;\u0026gt;\u0026gt; energy_send(123.456) \u0026gt;\u0026gt;\u0026gt; energy_receive() 123.456 谁来给我发个诺贝尔奖?\n💡 说明: 注意在 energy_send 函数中创建的 numpy 数组并没有返回, 因此内存空间被释放并可以被重新分配. numpy.empty() 直接返回下一段空闲内存，而不重新初始化. 而这个内存点恰好就是刚刚释放的那个(通常情况下, 并不绝对). \u0026gt; Well, something is fishy\u0026hellip;/嗯，有些可疑\u0026hellip; 1 2 3 4 5 6 7 8 def square(x): \u0026#34;\u0026#34;\u0026#34; 一个通过加法计算平方的简单函数. \u0026#34;\u0026#34;\u0026#34; sum_so_far = 0 for counter in range(x): sum_so_far = sum_so_far + x return sum_so_far Output (Python 2.x):\n1 2 \u0026gt;\u0026gt;\u0026gt; square(10) 10 难道不应该是100吗?\n注意: 如果你无法重现, 可以尝试运行这个文件mixed_tabs_and_spaces.py .\n💡 说明: 不要混用制表符(tab)和空格(space)! 在上面的例子中, return 的前面是\u0026quot;1个制表符\u0026quot;, 而其他部分的代码前面是 \u0026ldquo;4个空格\u0026rdquo;.\nPython是这么处理制表符的:\n首先, 制表符会从左到右依次被替换成8个空格, 直到被替换后的字符总数是八的倍数 \u0026lt;\u0026hellip;\u0026gt;\n因此, square 函数最后一行的制表符会被替换成8个空格, 导致return语句进入循环语句里面.\nPython 3 很友好, 在这种情况下会自动抛出错误.\nOutput (Python 3.x):\n1 TabError: inconsistent use of tabs and spaces in indentation Section: Watch out for the landmines!/小心地雷! \u0026gt; Modifying a dictionary while iterating over it/迭代字典时的修改 1 2 3 4 5 6 x = {0: None} for i in x: del x[i] x[i+1] = None print(i) Output (Python 2.7- Python 3.5):\n0\r1\r2\r3\r4\r5\r6\r7 是的, 它运行了八次然后才停下来.\n💡 说明: Python不支持对字典进行迭代的同时修改它. 它之所以运行8次, 是因为字典会自动扩容以容纳更多键值(我们有8次删除记录, 因此需要扩容). 这实际上是一个实现细节. (译: 应该是因为字典的初始最小值是8, 扩容会导致散列表地址发生变化而中断循环.) 在不同的Python实现中删除键的处理方式以及调整大小的时间可能会有所不同.(译: 就是说什么时候扩容在不同版本中可能是不同的, 在3.6及3.7的版本中到5 就会自动扩容了. 以后也有可能再次发生变化. 这是为了避免散列冲突. 顺带一提, 后面两次扩容会扩展为32和256. 即8-\u0026gt;32-\u0026gt;256.) 更多的信息, 你可以参考这个StackOverflow的回答 , 它详细的解释一个类似的例子. \u0026gt; Stubborn del operator/坚强的 del * 1 2 3 class SomeClass: def __del__(self): print(\u0026#34;Deleted!\u0026#34;) Output: 1.\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; x = SomeClass() \u0026gt;\u0026gt;\u0026gt; y = x \u0026gt;\u0026gt;\u0026gt; del x # 这里应该会输出 \u0026#34;Deleted!\u0026#34; \u0026gt;\u0026gt;\u0026gt; del y Deleted! 唷, 终于删除了. 你可能已经猜到了在我们第一次尝试删除 x 时是什么让 __del__ 免于被调用的. 那让我们给这个例子增加点难度.\n2.\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; x = SomeClass() \u0026gt;\u0026gt;\u0026gt; y = x \u0026gt;\u0026gt;\u0026gt; del x \u0026gt;\u0026gt;\u0026gt; y # 检查一下y是否存在 \u0026lt;__main__.SomeClass instance at 0x7f98a1a67fc8\u0026gt; \u0026gt;\u0026gt;\u0026gt; del y # 像之前一样, 这里应该会输出 \u0026#34;Deleted!\u0026#34; \u0026gt;\u0026gt;\u0026gt; globals() # 好吧, 并没有. 让我们看一下所有的全局变量 Deleted! {\u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;__builtin__\u0026#39; (built-in)\u0026gt;, \u0026#39;SomeClass\u0026#39;: \u0026lt;class __main__.SomeClass at 0x7f98a1a5f668\u0026gt;, \u0026#39;__package__\u0026#39;: None, \u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__doc__\u0026#39;: None} 好了，现在它被删除了 :confused:\n💡 说明: del x 并不会立刻调用 x.__del__(). 每当遇到 del x, Python 会将 x 的引用数减1, 当 x 的引用数减到0时就会调用 x.__del__(). 在第二个例子中, y.__del__() 之所以未被调用, 是因为前一条语句 (\u0026gt;\u0026gt;\u0026gt; y) 对同一对象创建了另一个引用, 从而防止在执行 del y 后对象的引用数变为0. 调用 globals 导致引用被销毁, 因此我们可以看到 \u0026ldquo;Deleted!\u0026rdquo; 终于被输出了. (译: 这其实是 Python 交互解释器的特性, 它会自动让 _ 保存上一个表达式输出的值, 详细可以看这里 .) \u0026gt; Deleting a list item while iterating/迭代列表时删除元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 list_1 = [1, 2, 3, 4] list_2 = [1, 2, 3, 4] list_3 = [1, 2, 3, 4] list_4 = [1, 2, 3, 4] for idx, item in enumerate(list_1): del item for idx, item in enumerate(list_2): list_2.remove(item) for idx, item in enumerate(list_3[:]): list_3.remove(item) for idx, item in enumerate(list_4): list_4.pop(idx) Output:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; list_1 [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; list_2 [2, 4] \u0026gt;\u0026gt;\u0026gt; list_3 [] \u0026gt;\u0026gt;\u0026gt; list_4 [2, 4] 你能猜到为什么输出是 [2, 4] 吗?\n💡 说明: 在迭代时修改对象是一个很愚蠢的主意. 正确的做法是迭代对象的副本, list_3[:] 就是这么做的.\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; some_list = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; id(some_list) 139798789457608 \u0026gt;\u0026gt;\u0026gt; id(some_list[:]) # 注意python为切片列表创建了新对象. 139798779601192 del, remove 和 pop 的不同:\ndel var_name 只是从本地或全局命名空间中删除了 var_name (这就是为什么 list_1 没有受到影响). remove 会删除第一个匹配到的指定值, 而不是特定的索引, 如果找不到值则抛出 ValueError 异常. pop 则会删除指定索引处的元素并返回它, 如果指定了无效的索引则抛出 IndexError 异常. 为什么输出是 [2, 4]?\n列表迭代是按索引进行的, 所以当我们从 list_2 或 list_4 中删除 1 时, 列表的内容就变成了 [2, 3, 4]. 剩余元素会依次位移, 也就是说, 2 的索引会变为 0, 3 会变为 1. 由于下一次迭代将获取索引为 1 的元素 (即 3), 因此 2 将被彻底的跳过. 类似的情况会交替发生在列表中的每个元素上. 参考这个StackOverflow的回答 来解释这个例子 关于Python中字典的类似例子, 可以参考这个Stackoverflow的回答 . \u0026gt; Loop variables leaking out!/循环变量泄漏! 1.\n1 2 3 4 for x in range(7): if x == 6: print(x, \u0026#39;: for x inside loop\u0026#39;) print(x, \u0026#39;: x in global\u0026#39;) Output:\n1 2 6 : for x inside loop 6 : x in global 但是 x 从未在循环外被定义\u0026hellip;\n2.\n1 2 3 4 5 6 # 这次我们先初始化x x = -1 for x in range(7): if x == 6: print(x, \u0026#39;: for x inside loop\u0026#39;) print(x, \u0026#39;: x in global\u0026#39;) Output:\n1 2 6 : for x inside loop 6 : x in global 3.\nx = 1\rprint([x for x in range(5)])\rprint(x, \u0026#39;: x in global\u0026#39;) Output (on Python 2.x):\n[0, 1, 2, 3, 4]\r(4, \u0026#39;: x in global\u0026#39;) Output (on Python 3.x):\n[0, 1, 2, 3, 4]\r1 : x in global 💡 说明: 在 Python 中, for 循环使用所在作用域并在结束后保留定义的循环变量. 如果我们曾在全局命名空间中定义过循环变量. 在这种情况下, 它会重新绑定现有变量.\nPython 2.x 和 Python 3.x 解释器在列表推导式示例中的输出差异, 在文档 What’s New In Python 3.0 中可以找到相关的解释:\n\u0026ldquo;列表推导不再支持句法形式 [... for var in item1, item2, ...]. 取而代之的是 [... for var in (item1, item2, ...)]. 另外, 注意列表推导具有不同的语义: 它们更接近于 list() 构造函数中生成器表达式的语法糖(译: 这一句我也不是很明白), 特别是循环控制变量不再泄漏到周围的作用域中.\u0026rdquo;\n\u0026gt; Beware of default mutable arguments!/当心默认的可变参数! 1 2 3 def some_func(default_arg=[]): default_arg.append(\u0026#34;some_string\u0026#34;) return default_arg Output:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; some_func() [\u0026#39;some_string\u0026#39;] \u0026gt;\u0026gt;\u0026gt; some_func() [\u0026#39;some_string\u0026#39;, \u0026#39;some_string\u0026#39;] \u0026gt;\u0026gt;\u0026gt; some_func([]) [\u0026#39;some_string\u0026#39;] \u0026gt;\u0026gt;\u0026gt; some_func() [\u0026#39;some_string\u0026#39;, \u0026#39;some_string\u0026#39;, \u0026#39;some_string\u0026#39;] 💡 说明: Python中函数的默认可变参数并不是每次调用该函数时都会被初始化. 相反, 它们会使用最近分配的值作为默认值. 当我们明确的将 [] 作为参数传递给 some_func 的时候, 就不会使用 default_arg 的默认值, 所以函数会返回我们所期望的结果.\n1 2 3 def some_func(default_arg=[]): default_arg.append(\u0026#34;some_string\u0026#34;) return default_arg Output:\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; some_func.__defaults__ # 这里会显示函数的默认参数的值 ([],) \u0026gt;\u0026gt;\u0026gt; some_func() \u0026gt;\u0026gt;\u0026gt; some_func.__defaults__ ([\u0026#39;some_string\u0026#39;],) \u0026gt;\u0026gt;\u0026gt; some_func() \u0026gt;\u0026gt;\u0026gt; some_func.__defaults__ ([\u0026#39;some_string\u0026#39;, \u0026#39;some_string\u0026#39;],) \u0026gt;\u0026gt;\u0026gt; some_func([]) \u0026gt;\u0026gt;\u0026gt; some_func.__defaults__ ([\u0026#39;some_string\u0026#39;, \u0026#39;some_string\u0026#39;],) 避免可变参数导致的错误的常见做法是将 None 指定为参数的默认值, 然后检查是否有值传给对应的参数. 例:\n1 2 3 4 5 def some_func(default_arg=None): if not default_arg: default_arg = [] default_arg.append(\u0026#34;some_string\u0026#34;) return default_arg \u0026gt; Catching the Exceptions/捕获异常 1 2 3 4 5 6 7 8 9 10 11 12 some_list = [1, 2, 3] try: # 这里会抛出异常 ``IndexError`` print(some_list[4]) except IndexError, ValueError: print(\u0026#34;Caught!\u0026#34;) try: # 这里会抛出异常 ``ValueError`` some_list.remove(4) except IndexError, ValueError: print(\u0026#34;Caught again!\u0026#34;) Output (Python 2.x):\n1 2 3 Caught! ValueError: list.remove(x): x not in list Output (Python 3.x):\n1 2 3 4 File \u0026#34;\u0026lt;input\u0026gt;\u0026#34;, line 3 except IndexError, ValueError: ^ SyntaxError: invalid syntax 💡 说明: 如果你想要同时捕获多个不同类型的异常时, 你需要将它们用括号包成一个元组作为第一个参数传递. 第二个参数是可选名称, 如果你提供, 它将与被捕获的异常实例绑定. 例,\n1 2 3 4 5 6 7 some_list = [1, 2, 3] try: # 这里会抛出异常 ``ValueError`` some_list.remove(4) except (IndexError, ValueError), e: print(\u0026#34;Caught again!\u0026#34;) print(e) Output (Python 2.x):\nCaught again!\rlist.remove(x): x not in list Output (Python 3.x):\n1 2 3 4 File \u0026#34;\u0026lt;input\u0026gt;\u0026#34;, line 4 except (IndexError, ValueError), e: ^ IndentationError: unindent does not match any outer indentation level 在 Python 3 中, 用逗号区分异常与可选名称是无效的; 正确的做法是使用 as 关键字. 例,\n1 2 3 4 5 6 7 some_list = [1, 2, 3] try: some_list.remove(4) except (IndexError, ValueError) as e: print(\u0026#34;Caught again!\u0026#34;) print(e) Output:\nCaught again!\rlist.remove(x): x not in list \u0026gt; Same operands, different story!/同人不同命! 1.\n1 2 3 a = [1, 2, 3, 4] b = a a = a + [5, 6, 7, 8] Output:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, 4, 5, 6, 7, 8] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, 4] 2.\n1 2 3 a = [1, 2, 3, 4] b = a a += [5, 6, 7, 8] Output:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, 4, 5, 6, 7, 8] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, 4, 5, 6, 7, 8] 💡 说明: a += b 并不总是与 a = a + b 表现相同. 类实现 op= 运算符的方式 也许 是不同的, 列表就是这样做的.\n表达式 a = a + [5,6,7,8] 会生成一个新列表, 并让 a 引用这个新列表, 同时保持 b 不变.\n表达式 a += [5,6,7,8] 实际上是使用的是 \u0026ldquo;extend\u0026rdquo; 函数, 所以 a 和 b 仍然指向已被修改的同一列表.\n\u0026gt; The out of scope variable/外部作用域变量 1 2 3 4 5 6 7 a = 1 def some_func(): return a def another_func(): a += 1 return a Output:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; some_func() 1 \u0026gt;\u0026gt;\u0026gt; another_func() UnboundLocalError: local variable \u0026#39;a\u0026#39; referenced before assignment 💡 说明: 当你在作用域中对变量进行赋值时, 变量会变成该作用域内的局部变量. 因此 a 会变成 another_func 函数作用域中的局部变量, 但它在函数作用域中并没有被初始化, 所以会引发错误.\n可以阅读这个 简短却很棒的指南, 了解更多关于 Python 中命名空间和作用域的工作原理.\n想要在 another_func 中修改外部作用域变量 a 的话, 可以使用 global 关键字.\n1 2 3 4 def another_func() global a a += 1 return a Output:\n1 2 \u0026gt;\u0026gt;\u0026gt; another_func() 2 \u0026gt; Be careful with chained operations/小心链式操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026gt;\u0026gt;\u0026gt; (False == False) in [False] # 可以理解 False \u0026gt;\u0026gt;\u0026gt; False == (False in [False]) # 可以理解 False \u0026gt;\u0026gt;\u0026gt; False == False in [False] # 为毛? True \u0026gt;\u0026gt;\u0026gt; True is False == False False \u0026gt;\u0026gt;\u0026gt; False is False is False True \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt; 0 \u0026lt; 1 True \u0026gt;\u0026gt;\u0026gt; (1 \u0026gt; 0) \u0026lt; 1 False \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt; (0 \u0026lt; 1) False 💡 说明: 根据 https://docs.python.org/2/reference/expressions.html#not-in 形式上, 如果 a, b, c, \u0026hellip;, y, z 是表达式, 而 op1, op2, \u0026hellip;, opN 是比较运算符, 那么除了每个表达式最多只出现一次以外 a op1 b op2 c \u0026hellip; y opN z 就等于 a op1 b and b op2 c and \u0026hellip; y opN z.\n虽然上面的例子似乎很愚蠢, 但是像 a == b == c 或 0 \u0026lt;= x \u0026lt;= 100 就很棒了.\nFalse is False is False 相当于 (False is False) and (False is False) True is False == False 相当于 True is False and False == False, 由于语句的第一部分 (True is False) 等于 False, 因此整个表达式的结果为 False. 1 \u0026gt; 0 \u0026lt; 1 相当于 1 \u0026gt; 0 and 0 \u0026lt; 1, 所以最终结果为 True. 表达式 (1 \u0026gt; 0) \u0026lt; 1 相当于 True \u0026lt; 1 且 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; int(True) 1 \u0026gt;\u0026gt;\u0026gt; True + 1 # 与这个例子无关，只是好玩 2 所以, 1 \u0026lt; 1 等于 False \u0026gt; Name resolution ignoring class scope/忽略类作用域的名称解析 1.\n1 2 3 4 x = 5 class SomeClass: x = 17 y = (x for i in range(10)) Output:\n1 2 \u0026gt;\u0026gt;\u0026gt; list(SomeClass.y)[0] 5 2.\n1 2 3 4 x = 5 class SomeClass: x = 17 y = [x for i in range(10)] Output (Python 2.x):\n1 2 \u0026gt;\u0026gt;\u0026gt; SomeClass.y[0] 17 Output (Python 3.x):\n1 2 \u0026gt;\u0026gt;\u0026gt; SomeClass.y[0] 5 💡 说明: 类定义中嵌套的作用域会忽略类内的名称绑定. 生成器表达式有它自己的作用域. 从 Python 3.X 开始, 列表推导式也有自己的作用域. \u0026gt; Needle in a Haystack/大海捞针 1.\n1 x, y = (0, 1) if True else None, None Output:\n\u0026gt;\u0026gt;\u0026gt; x, y # 期望的结果是 (0, 1)\r((0, 1), None) 几乎每个 Python 程序员都遇到过类似的情况.\n2.\n1 2 3 4 5 6 7 8 9 10 t = (\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;) for i in t: print(i) t = (\u0026#39;one\u0026#39;) for i in t: print(i) t = () print(t) Output:\n1 2 3 4 5 6 one two o n e tuple() 💡 说明: 对于 1, 正确的语句是 x, y = (0, 1) if True else (None, None). 对于 2, 正确的语句是 t = ('one',) 或者 t = 'one', (缺少逗号) 否则解释器会认为 t 是一个字符串, 并逐个字符对其进行迭代. () 是一个特殊的标记，表示空元组. Section: The Hidden treasures!/隐藏的宝藏! This section contains few of the lesser-known interesting things about Python that most beginners like me are unaware of (well, not anymore).\n\u0026gt; Okay Python, Can you make me fly?/Python, 可否带我飞? * 好, 去吧.\n1 import antigravity Output: 嘘.. 这是个超级秘密.\n💡 说明: antigravity 模块是 Python 开发人员发布的少数复活节彩蛋之一. import antigravity 会打开一个 Python 的经典 XKCD 漫画 页面. 不止如此. 这个复活节彩蛋里还有一个复活节彩蛋. 如果你看一下代码 , 就会发现还有一个函数实现了 XKCD\u0026rsquo;s geohashing 算法 . \u0026gt; goto, but why?/goto, 但为什么? * 1 2 3 4 5 6 7 8 9 from goto import goto, label for i in range(9): for j in range(9): for k in range(9): print(\u0026#34;I\u0026#39;m trapped, please rescue!\u0026#34;) if k == 2: goto .breakout # 从多重循环中跳出 label .breakout print(\u0026#34;Freedom!\u0026#34;) Output (Python 2.3):\n1 2 3 I\u0026#39;m trapped, please rescue! I\u0026#39;m trapped, please rescue! Freedom! 💡 说明: 2004年4月1日, Python 宣布 加入一个可用的 goto 作为愚人节礼物. 当前版本的 Python 并没有这个模块. 就算可以用, 也请不要使用它. 这里是为什么Python中没有 goto 的原因 . \u0026gt; Brace yourself!/做好思想准备 * 如果你不喜欢在Python中使用空格来表示作用域, 你可以导入 C 风格的 {},\n1 from __future__ import braces Output:\n1 2 3 File \u0026#34;some_file.py\u0026#34;, line 1 from __future__ import braces SyntaxError: not a chance 想用大括号? 没门! 觉得不爽, 请去用java.\n💡 说明: 通常 __future__ 会提供 Python 未来版本的功能. 然而，这里的 “未来” 是一个讽刺. 这是一个表达社区对此类问题态度的复活节彩蛋. \u0026gt; Let\u0026rsquo;s meet Friendly Language Uncle For Life/让生活更友好 * Output (Python 3.x)\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; from __future__ import barry_as_FLUFL \u0026gt;\u0026gt;\u0026gt; \u0026#34;Ruby\u0026#34; != \u0026#34;Python\u0026#34; # 这里没什么疑问 File \u0026#34;some_file.py\u0026#34;, line 1 \u0026#34;Ruby\u0026#34; != \u0026#34;Python\u0026#34; ^ SyntaxError: invalid syntax \u0026gt;\u0026gt;\u0026gt; \u0026#34;Ruby\u0026#34; \u0026lt;\u0026gt; \u0026#34;Python\u0026#34; True 这就对了.\n💡 说明: 相关的 PEP-401 发布于 2009年4月1日 (所以你现在知道这意味着什么了吧).\n引用 PEP-401\n意识到 Python 3.0 里的 != 运算符是一个会引起手指疼痛的恐怖错误, FLUFL 将 \u0026lt;\u0026gt; 运算符恢复为唯一写法.\nUncle Barry 在 PEP 中还分享了其他东西; 你可以在这里 获得他们.\n(译: 虽然文档中没写，但应该是只能在交互解释器中使用.)\n\u0026gt; Even Python understands that love is complicated/连Python也知道爱是难言的 * 1 import this 等等, this 是什么? this 是爱 :heart:\nOutput:\nThe Zen of Python, by Tim Peters\rBeautiful is better than ugly.\r优美胜于丑陋（Python 以编写优美的代码为目标）\rExplicit is better than implicit.\r明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）\rSimple is better than complex.\r简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）\rComplex is better than complicated.\r复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）\rFlat is better than nested.\r扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）\rSparse is better than dense.\r间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）\rReadability counts.\r可读性很重要（优美的代码一定是可读的）\rSpecial cases aren\u0026#39;t special enough to break the rules.\r没有特例特殊到需要违背这些规则（这些规则至高无上）\rAlthough practicality beats purity.\r尽管我们更倾向于实用性\rErrors should never pass silently.\r不要安静的包容所有错误\rUnless explicitly silenced.\r除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）\rIn the face of ambiguity, refuse the temptation to guess.\r拒绝诱惑你去猜测的暧昧事物\rThere should be one-- and preferably only one --obvious way to do it.\r而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）\rAlthough that way may not be obvious at first unless you\u0026#39;re Dutch.\r虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）\rNow is better than never.\r现在行动好过永远不行动\rAlthough never is often better than *right* now.\r尽管不行动要好过鲁莽行动\rIf the implementation is hard to explain, it\u0026#39;s a bad idea.\r如果你无法向人描述你的方案，那肯定不是一个好方案；\rIf the implementation is easy to explain, it may be a good idea.\r如果你能轻松向人描述你的方案，那也许会是一个好方案（方案测评标准）\rNamespaces are one honking great idea -- let\u0026#39;s do more of those!\r命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 这是 Python 之禅!\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; love = this \u0026gt;\u0026gt;\u0026gt; this is love True \u0026gt;\u0026gt;\u0026gt; love is True False \u0026gt;\u0026gt;\u0026gt; love is False False \u0026gt;\u0026gt;\u0026gt; love is not True or False True \u0026gt;\u0026gt;\u0026gt; love is not True or False; love is love # 爱是难言的 True 💡 说明: this 模块是关于 Python 之禅的复活节彩蛋 (PEP 20 ). 如果你认为这已经够有趣的了, 可以看看 this.py 的实现. 有趣的是, Python 之禅的实现代码违反了他自己 (这可能是唯一会发生这种情况的地方). * 至于 love is not True or False; love is love, 意外却又不言而喻. \u0026gt; Yes, it exists!/是的, 它存在! 循环的 else. 一个典型的例子:\n1 2 3 4 5 6 7 def does_exists_num(l, to_find): for num in l: if num == to_find: print(\u0026#34;Exists!\u0026#34;) break else: print(\u0026#34;Does not exist\u0026#34;) Output:\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; some_list = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; does_exists_num(some_list, 4) Exists! \u0026gt;\u0026gt;\u0026gt; does_exists_num(some_list, -1) Does not exist 异常的 else . 例,\n1 2 3 4 5 6 try: pass except: print(\u0026#34;Exception occurred!!!\u0026#34;) else: print(\u0026#34;Try block executed successfully...\u0026#34;) Output:\n1 Try block executed successfully... 💡 说明: 循环后的 else 子句只会在循环没有触发 break 语句, 正常结束的情况下才会执行. try 之后的 else 子句也被称为 \u0026ldquo;完成子句\u0026rdquo;, 因为在 try 语句中到达 else 子句意味着try块实际上已成功完成. \u0026gt; Inpinity/无限 * 英文拼写是有意的, 请不要为此提交补丁. (译: 这里是为了突出 Python 中无限的定义与Pi 有关, 所以将两个单词拼接了.)\nOutput (Python 3.x):\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; infinity = float(\u0026#39;infinity\u0026#39;) \u0026gt;\u0026gt;\u0026gt; hash(infinity) 314159 \u0026gt;\u0026gt;\u0026gt; hash(float(\u0026#39;-inf\u0026#39;)) -314159 💡 说明: infinity 的哈希值是 10⁵ x π. 有意思的是, float('-inf') 的哈希值在 Python 3 中是 \u0026ldquo;-10⁵ x π\u0026rdquo; , 而在 Python 2 中是 \u0026ldquo;-10⁵ x e\u0026rdquo;. \u0026gt; Mangling time!/修饰时间! * 1 2 3 4 class Yo(object): def __init__(self): self.__honey = True self.bitch = True Output:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; Yo().bitch True \u0026gt;\u0026gt;\u0026gt; Yo().__honey AttributeError: \u0026#39;Yo\u0026#39; object has no attribute \u0026#39;__honey\u0026#39; \u0026gt;\u0026gt;\u0026gt; Yo()._Yo__honey True 为什么 Yo()._Yo__honey 能运行? 只有印度人理解.(译: 这个梗可能是指印度音乐人Yo Yo Honey Singh )\n💡 说明: 名字修饰 用于避免不同命名空间之间名称冲突. 在 Python 中, 解释器会通过给类中以 __ (双下划线)开头且结尾最多只有一个下划线的类成员名称加上_NameOfTheClass 来修饰(mangles)名称. 所以, 要访问 __honey 对象,我们需要加上 _Yo 以防止与其他类中定义的相同名称的属性发生冲突. Section: Miscellaneous/杂项 \u0026gt; += is faster/更快的 += 1 2 3 4 5 6 # 用 \u0026#34;+\u0026#34; 连接三个字符串: \u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#34;s1 = s1 + s2 + s3\u0026#34;, setup=\u0026#34;s1 = \u0026#39; \u0026#39; * 100000; s2 = \u0026#39; \u0026#39; * 100000; s3 = \u0026#39; \u0026#39; * 100000\u0026#34;, number=100) 0.25748300552368164 # 用 \u0026#34;+=\u0026#34; 连接三个字符串: \u0026gt;\u0026gt;\u0026gt; timeit.timeit(\u0026#34;s1 += s2 + s3\u0026#34;, setup=\u0026#34;s1 = \u0026#39; \u0026#39; * 100000; s2 = \u0026#39; \u0026#39; * 100000; s3 = \u0026#39; \u0026#39; * 100000\u0026#34;, number=100) 0.012188911437988281 💡 说明: 连接两个以上的字符串时 += 比 + 更快, 因为在计算过程中第一个字符串 (例如, s1 += s2 + s3 中的 s1) 不会被销毁.(译: 就是 += 执行的是追加操作，少了一个销毁新建的动作.) \u0026gt; Let\u0026rsquo;s make a giant string!/来做个巨大的字符串吧！ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def add_string_with_plus(iters): s = \u0026#34;\u0026#34; for i in range(iters): s += \u0026#34;xyz\u0026#34; assert len(s) == 3*iters def add_bytes_with_plus(iters): s = b\u0026#34;\u0026#34; for i in range(iters): s += b\u0026#34;xyz\u0026#34; assert len(s) == 3*iters def add_string_with_format(iters): fs = \u0026#34;{}\u0026#34;*iters s = fs.format(*([\u0026#34;xyz\u0026#34;]*iters)) assert len(s) == 3*iters def add_string_with_join(iters): l = [] for i in range(iters): l.append(\u0026#34;xyz\u0026#34;) s = \u0026#34;\u0026#34;.join(l) assert len(s) == 3*iters def convert_list_to_string(l, iters): s = \u0026#34;\u0026#34;.join(l) assert len(s) == 3*iters Output:\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; timeit(add_string_with_plus(10000)) 1000 loops, best of 3: 972 µs per loop \u0026gt;\u0026gt;\u0026gt; timeit(add_bytes_with_plus(10000)) 1000 loops, best of 3: 815 µs per loop \u0026gt;\u0026gt;\u0026gt; timeit(add_string_with_format(10000)) 1000 loops, best of 3: 508 µs per loop \u0026gt;\u0026gt;\u0026gt; timeit(add_string_with_join(10000)) 1000 loops, best of 3: 878 µs per loop \u0026gt;\u0026gt;\u0026gt; l = [\u0026#34;xyz\u0026#34;]*10000 \u0026gt;\u0026gt;\u0026gt; timeit(convert_list_to_string(l, 10000)) 10000 loops, best of 3: 80 µs per loop 让我们将迭代次数增加10倍.\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; timeit(add_string_with_plus(100000)) # 执行时间线性增加 100 loops, best of 3: 9.75 ms per loop \u0026gt;\u0026gt;\u0026gt; timeit(add_bytes_with_plus(100000)) # 二次增加 1000 loops, best of 3: 974 ms per loop \u0026gt;\u0026gt;\u0026gt; timeit(add_string_with_format(100000)) # 线性增加 100 loops, best of 3: 5.25 ms per loop \u0026gt;\u0026gt;\u0026gt; timeit(add_string_with_join(100000)) # 线性增加 100 loops, best of 3: 9.85 ms per loop \u0026gt;\u0026gt;\u0026gt; l = [\u0026#34;xyz\u0026#34;]*100000 \u0026gt;\u0026gt;\u0026gt; timeit(convert_list_to_string(l, 100000)) # 线性增加 1000 loops, best of 3: 723 µs per loop 💡 说明: 你可以在这获得更多 timeit 的相关信息. 它通常用于衡量代码片段的执行时间. 不要用 + 去生成过长的字符串, 在 Python 中, str 是不可变的, 所以在每次连接中你都要把左右两个字符串复制到新的字符串中. 如果你连接四个长度为10的字符串, 你需要拷贝 (10+10) + ((10+10)+10) + (((10+10)+10)+10) = 90 个字符而不是 40 个字符. 随着字符串的数量和大小的增加, 情况会变得越发的糟糕 (就像add_bytes_with_plus 函数的执行时间一样) 因此, 更建议使用 .format. 或 % 语法 (但是, 对于短字符串, 它们比 + 稍慢一点). 又或者, 如果你所需的内容已经以可迭代对象的形式提供了, 使用 ''.join(可迭代对象) 要快多了. add_string_with_plus 的执行时间没有像 add_bytes_with_plus 一样出现二次增加是因为解释器会如同上一个例子所讨论的一样优化 +=. 用 s = s + \u0026quot;x\u0026quot; + \u0026quot;y\u0026quot; + \u0026quot;z\u0026quot; 替代 s += \u0026quot;xyz\u0026quot; 的话, 执行时间就会二次增加了. 1 2 3 4 5 6 7 8 9 10 def add_string_with_plus(iters): s = \u0026#34;\u0026#34; for i in range(iters): s = s + \u0026#34;x\u0026#34; + \u0026#34;y\u0026#34; + \u0026#34;z\u0026#34; assert len(s) == 3*iters \u0026gt;\u0026gt;\u0026gt; timeit(add_string_with_plus(10000)) 100 loops, best of 3: 9.87 ms per loop \u0026gt;\u0026gt;\u0026gt; timeit(add_string_with_plus(100000)) # 执行时间二次增加 1 loops, best of 3: 1.09 s per loop \u0026gt; Explicit typecast of strings/字符串的显式类型转换 1 2 3 4 a = float(\u0026#39;inf\u0026#39;) b = float(\u0026#39;nan\u0026#39;) c = float(\u0026#39;-iNf\u0026#39;) # 这些字符串不区分大小写 d = float(\u0026#39;nan\u0026#39;) Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026gt;\u0026gt;\u0026gt; a inf \u0026gt;\u0026gt;\u0026gt; b nan \u0026gt;\u0026gt;\u0026gt; c -inf \u0026gt;\u0026gt;\u0026gt; float(\u0026#39;some_other_string\u0026#39;) ValueError: could not convert string to float: some_other_string \u0026gt;\u0026gt;\u0026gt; a == -c #inf==inf True \u0026gt;\u0026gt;\u0026gt; None == None # None==None True \u0026gt;\u0026gt;\u0026gt; b == d #但是 nan!=nan False \u0026gt;\u0026gt;\u0026gt; 50/a 0.0 \u0026gt;\u0026gt;\u0026gt; a/a nan \u0026gt;\u0026gt;\u0026gt; 23 + b nan 💡 说明: 'inf' 和 'nan' 是特殊的字符串(不区分大小写), 当显示转换成 float 型时, 它们分别用于表示数学意义上的 \u0026ldquo;无穷大\u0026rdquo; 和 \u0026ldquo;非数字\u0026rdquo;.\n\u0026gt; Minor Ones/小知识点 join() 是一个字符串操作而不是列表操作. (第一次接触会觉得有点违反直觉)\n💡 说明: 如果 join() 是字符串方法 那么它就可以处理任何可迭代的对象(列表，元组，迭代器). 如果它是列表方法, 则必须在每种类型中单独实现. 另外, 在 list 对象的通用API中实现一个专用于字符串的方法没有太大的意义.\n看着奇怪但能正确运行的语句:\n[] = () 语句在语义上是正确的 (解包一个空的 tuple 并赋值给 list) 'a'[0][0][0][0][0] 在语义上也是正确的, 因为在 Python 中字符串同时也是序列 (可迭代对象支持使用整数索引访问元素). 3 --0-- 5 == 8 和 --5 == 5 在语义上都是正确的, 且结果等于 True.(译: 3减负0等于3，再减负5相当于加5等于8；负的负5等于5.) 鉴于 a 是一个数字, ++a 和 --a 都是有效的 Python 语句, 但其效果与 C, C++ 或 Java 等不一样.\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; a = 5 \u0026gt;\u0026gt;\u0026gt; a 5 \u0026gt;\u0026gt;\u0026gt; ++a 5 \u0026gt;\u0026gt;\u0026gt; --a 5 💡 说明:\npython 里没有 ++ 操作符. 这其实是两个 + 操作符. ++a 被解析为 +(+a) 最后等于 a. --a 同理. 这个 StackOverflow 回答 讨论了为什么 Python 中缺少增量和减量运算符. Python 使用 2个字节存储函数中的本地变量. 理论上, 这意味着函数中只能定义65536个变量. 但是，Python 内置了一个方便的解决方案，可用于存储超过2^16个变量名. 下面的代码演示了当定义了超过65536个局部变量时堆栈中发生的情况 (警告: 这段代码会打印大约2^18行文本, 请做好准备!):\n1 2 3 4 5 6 7 8 9 import dis exec(\u0026#34;\u0026#34;\u0026#34; def f(): \u0026#34;\u0026#34;\u0026#34; + \u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;.join([\u0026#34;X\u0026#34;+str(x)+\u0026#34;=\u0026#34; + str(x) for x in range(65539)])) f() print(dis.dis(f)) 你的 Python 代码 并不会多线程同时运行 (是的, 你没听错!). 虽然你觉得会产生多个线程并让它们同时执行你的代码, 但是, 由于 全局解释锁 的存在, 你所做的只是让你的线程依次在同一个核心上执行. Python 多线程适用于IO密集型的任务, 但如果想要并行处理CPU密集型的任务, 你应该会想使用 multiprocessing 模块.\n列表切片超出索引边界而不引发任何错误\n1 2 3 \u0026gt;\u0026gt;\u0026gt; some_list = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; some_list[111:] [] int('١٢٣٤٥٦٧٨٩') 在 Python 3 中会返回 123456789. 在 Python 中, 十进制字符包括数字字符, 以及可用于形成十进制数字的所有字符, 例如: U+0660, ARABIC-INDIC DIGIT ZERO. 这有一个关于此的 有趣故事 .\n'abc'.count('') == 4. 这有一个 count 方法的相近实现, 能更好的说明问题\n1 2 3 4 5 def count(s, sub): result = 0 for i in range(len(s) + 1 - len(sub)): result += (s[i:i + len(sub)] == sub) return result 这个行为是由于空子串('')与原始字符串中长度为0的切片相匹配导致的.\nContributing/贡献 欢迎各种补丁! 详情请看CONTRIBUTING.md .(译: 这是给原库提贡献的要求模版)\n你可以通过新建 issue 或者在上 Gitter 与我们进行讨论.\n(译: 如果你想对这个翻译项目提供帮助, 请看这里 )\nAcknowledgements/致谢 这个系列最初的想法和设计灵感来自于 Denys Dovhan 的项目 wtfjs . 社区的强大支持让它成长为现在的模样.\nSome nice Links!/一些不错的资源 https://www.youtube.com/watch?v=sH4XF6pKKmk https://www.reddit.com/r/Python/comments/3cu6ej/what_are_some_wtf_things_about_python https://sopython.com/wiki/Common_Gotchas_In_Python https://stackoverflow.com/questions/530530/python-2-x-gotchas-and-landmines https://stackoverflow.com/questions/1011431/common-pitfalls-in-python https://www.python.org/doc/humor/ https://www.codementor.io/satwikkansal/python-practices-for-efficient-code-performance-memory-and-usability-aze6oiq65 🎓 License/许可 © Satwik Kansal Help/帮助 如果您有任何想法或建议，欢迎分享.\nSurprise your geeky pythonist friends?/想给你的极客朋友一个惊喜? 您可以使用这些快链向 Twitter 和 Linkedin 上的朋友推荐 wtfpython,\nTwitter | Linkedin Need a pdf version?/需要来一份pdf版的? 我收到一些想要pdf版本的需求. 你可以快速在这 获得.\nFollow Commit/追踪Commit 这是中文版 fork 时所处的原库 Commit, 当原库更新时我会跟随更新.\n996.icu ","permalink":"https://hugotest-phi.vercel.app/posts/pythontips/","summary":"\u003cp align=\"center\"\u003e\u003cimg src=\"/images/logo.png\" alt=\"\"\u003e\u003c/p\u003e\r\n\u003ch1 align=\"center\"\u003eWhat the f*ck Python! 🐍\u003c/h1\u003e\r\n\u003cp align=\"center\"\u003e一些有趣且鲜为人知的 Python 特性.\u003c/p\u003e\r\n\u003cp align=\"center\"\u003e\r\n\u003ca href=\"https://github.com/satwikkansal/wtfpython\"\u003eEnglish\u003c/a\u003e\r\n| \u003ca href=\"#\"\u003e中文\u003c/a\u003e\r\n\u003c/p\u003e\r\n[![WTFPL 2.0][license-image]][license-url] [![Commit id][commit-image]][commit-url] [![996.icu][996.icu-image]][996.icu-url]\r\n\u003cp\u003ePython, 是一个设计优美的解释型高级语言, 它提供了很多能让程序员感到舒适的功能特性. 但有的时候, Python 的一些输出结果对于初学者来说似乎并不是那么一目了然.\u003c/p\u003e\n\u003cp\u003e这个有趣的项目意在收集 Python 中那些难以理解和反人类直觉的例子以及鲜为人知的功能特性, 并尝试讨论这些现象背后真正的原理!\u003c/p\u003e\n\u003cp\u003e虽然下面的有些例子并不一定会让你觉得 WTFs, 但它们依然有可能会告诉你一些你所不知道的 Python 有趣特性.  我觉得这是一种学习编程语言内部原理的好办法, 而且我相信你也会从中获得乐趣!\u003c/p\u003e\n\u003cp\u003e如果您是一位经验比较丰富的 Python 程序员, 你可以尝试挑战看是否能一次就找到例子的正确答案. 你可能对其中的一些例子已经比较熟悉了, 那这也许能唤起你当年踩这些坑时的甜蜜回忆 :sweat_smile:\u003c/p\u003e\n\u003cp\u003ePS: 如果你不是第一次读了, 你可以在\u003ca href=\"https://github.com/satwikkansal/wtfpython/releases/\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e\n获取变动内容.\u003c/p\u003e\n\u003cp\u003e那么, 让我们开始吧\u0026hellip;\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch1 id=\"table-of-contents目录\"\u003eTable of Contents/目录\u003c/h1\u003e\n\u003c!-- TOC --\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#table-of-contents%e7%9b%ae%e5%bd%95\"\u003eTable of Contents/目录\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#structure-of-the-examples%e7%a4%ba%e4%be%8b%e7%bb%93%e6%9e%84\"\u003eStructure of the Examples/示例结构\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#usage%e7%94%a8%e6%b3%95\"\u003eUsage/用法\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-examples%e7%a4%ba%e4%be%8b\"\u003e👀 Examples/示例\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#section-strain-your-brain%e5%a4%a7%e8%84%91%e8%bf%90%e5%8a%a8\"\u003eSection: Strain your brain!/大脑运动!\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#-strings-can-be-tricky-sometimes%e5%be%ae%e5%a6%99%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2-\"\u003e\u0026gt; Strings can be tricky sometimes/微妙的字符串 *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-time-for-some-hash-brownies%e6%98%af%e6%97%b6%e5%80%99%e6%9d%a5%e7%82%b9%e8%9b%8b%e7%b3%95%e4%ba%86\"\u003e\u0026gt; Time for some hash brownies!/是时候来点蛋糕了!\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-return-return-everywhere%e5%88%b0%e5%a4%84%e8%bf%94%e5%9b%9e\"\u003e\u0026gt; Return return everywhere!/到处返回！\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-deep-down-were-all-the-same%e6%9c%ac%e8%b4%a8%e4%b8%8a%e6%88%91%e4%bb%ac%e9%83%bd%e4%b8%80%e6%a0%b7-\"\u003e\u0026gt; Deep down, we\u0026rsquo;re all the same./本质上,我们都一样. *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-for-what%e4%b8%ba%e4%bb%80%e4%b9%88\"\u003e\u0026gt; For what?/为什么?\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-evaluation-time-discrepancy%e6%89%a7%e8%a1%8c%e6%97%b6%e6%9c%ba%e5%b7%ae%e5%bc%82\"\u003e\u0026gt; Evaluation time discrepancy/执行时机差异\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-is-is-not-what-it-is%e5%87%ba%e4%ba%ba%e6%84%8f%e6%96%99%e7%9a%84is\"\u003e\u0026gt; \u003ccode\u003eis\u003c/code\u003e is not what it is!/出人意料的\u003ccode\u003eis\u003c/code\u003e!\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-a-tic-tac-toe-where-x-wins-in-the-first-attempt%e4%b8%80%e8%b9%b4%e5%8d%b3%e8%87%b3\"\u003e\u0026gt; A tic-tac-toe where X wins in the first attempt!/一蹴即至!\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-the-sticky-output-function%e9%ba%bb%e7%83%a6%e7%9a%84%e8%be%93%e5%87%ba\"\u003e\u0026gt; The sticky output function/麻烦的输出\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-is-not--is-not-is-not-is-not--%e4%b8%8d%e6%98%af-is-not-\"\u003e\u0026gt; \u003ccode\u003eis not ...\u003c/code\u003e is not \u003ccode\u003eis (not ...)\u003c/code\u003e/\u003ccode\u003eis not ...\u003c/code\u003e 不是 \u003ccode\u003eis (not ...)\u003c/code\u003e\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-the-surprising-comma%e6%84%8f%e5%a4%96%e7%9a%84%e9%80%97%e5%8f%b7\"\u003e\u0026gt; The surprising comma/意外的逗号\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-backslashes-at-the-end-of-string%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9c%ab%e5%b0%be%e7%9a%84%e5%8f%8d%e6%96%9c%e6%9d%a0\"\u003e\u0026gt; Backslashes at the end of string/字符串末尾的反斜杠\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-not-knot%e5%88%ab%e7%ba%a0%e7%bb%93\"\u003e\u0026gt; not knot!/别纠结!\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-half-triple-quoted-strings%e4%b8%89%e4%b8%aa%e5%bc%95%e5%8f%b7\"\u003e\u0026gt; Half triple-quoted strings/三个引号\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-midnight-time-doesnt-exist%e4%b8%8d%e5%ad%98%e5%9c%a8%e7%9a%84%e5%8d%88%e5%a4%9c\"\u003e\u0026gt; Midnight time doesn\u0026rsquo;t exist?/不存在的午夜?\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-whats-wrong-with-booleans%e5%b8%83%e5%b0%94%e4%bd%a0%e5%92%8b%e4%ba%86\"\u003e\u0026gt; What\u0026rsquo;s wrong with booleans?/布尔你咋了?\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-class-attributes-and-instance-attributes%e7%b1%bb%e5%b1%9e%e6%80%a7%e5%92%8c%e5%ae%9e%e4%be%8b%e5%b1%9e%e6%80%a7\"\u003e\u0026gt; Class attributes and instance attributes/类属性和实例属性\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-yielding-none%e7%94%9f%e6%88%90-none\"\u003e\u0026gt; yielding None/生成 None\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-mutating-the-immutable%e5%bc%ba%e4%ba%ba%e6%89%80%e9%9a%be\"\u003e\u0026gt; Mutating the immutable!/强人所难\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-the-disappearing-variable-from-outer-scope%e6%b6%88%e5%a4%b1%e7%9a%84%e5%a4%96%e9%83%a8%e5%8f%98%e9%87%8f\"\u003e\u0026gt; The disappearing variable from outer scope/消失的外部变量\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-when-true-is-actually-false%e7%9c%9f%e4%ba%a6%e5%81%87\"\u003e\u0026gt; When True is actually False/真亦假\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-from-filled-to-none-in-one-instruction%e4%bb%8e%e6%9c%89%e5%88%b0%e6%97%a0\"\u003e\u0026gt; From filled to None in one instruction\u0026hellip;/从有到无\u0026hellip;\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-subclass-relationships%e5%ad%90%e7%b1%bb%e5%85%b3%e7%b3%bb-\"\u003e\u0026gt; Subclass relationships/子类关系 *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-the-mysterious-key-type-conversion%e7%a5%9e%e7%a7%98%e7%9a%84%e9%94%ae%e5%9e%8b%e8%bd%ac%e6%8d%a2-\"\u003e\u0026gt; The mysterious key type conversion/神秘的键型转换 *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-lets-see-if-you-can-guess-this%e7%9c%8b%e7%9c%8b%e4%bd%a0%e8%83%bd%e5%90%a6%e7%8c%9c%e5%88%b0%e8%bf%99%e4%b8%80%e7%82%b9\"\u003e\u0026gt; Let\u0026rsquo;s see if you can guess this?/看看你能否猜到这一点?\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#section-appearances-are-deceptive%e5%a4%96%e8%a1%a8%e6%98%af%e9%9d%a0%e4%b8%8d%e4%bd%8f%e7%9a%84\"\u003eSection: Appearances are deceptive!/外表是靠不住的!\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#-skipping-lines%e8%b7%b3%e8%bf%87%e4%b8%80%e8%a1%8c\"\u003e\u0026gt; Skipping lines?/跳过一行?\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-teleportation%e7%a9%ba%e9%97%b4%e7%a7%bb%e5%8a%a8-\"\u003e\u0026gt; Teleportation/空间移动 *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-well-something-is-fishy%e5%97%af%e6%9c%89%e4%ba%9b%e5%8f%af%e7%96%91\"\u003e\u0026gt; Well, something is fishy\u0026hellip;/嗯, 有些可疑\u0026hellip;\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#section-watch-out-for-the-landmines%e5%b0%8f%e5%bf%83%e5%9c%b0%e9%9b%b7\"\u003eSection: Watch out for the landmines!/小心地雷!\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#-modifying-a-dictionary-while-iterating-over-it%e8%bf%ad%e4%bb%a3%e5%ad%97%e5%85%b8%e6%97%b6%e7%9a%84%e4%bf%ae%e6%94%b9\"\u003e\u0026gt; Modifying a dictionary while iterating over it/迭代字典时的修改\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-stubborn-del-operator%e5%9d%9a%e5%bc%ba%e7%9a%84-del-\"\u003e\u0026gt; Stubborn \u003ccode\u003edel\u003c/code\u003e operator/坚强的 \u003ccode\u003edel\u003c/code\u003e *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-deleting-a-list-item-while-iterating%e8%bf%ad%e4%bb%a3%e5%88%97%e8%a1%a8%e6%97%b6%e5%88%a0%e9%99%a4%e5%85%83%e7%b4%a0\"\u003e\u0026gt; Deleting a list item while iterating/迭代列表时删除元素\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-loop-variables-leaking-out%e5%be%aa%e7%8e%af%e5%8f%98%e9%87%8f%e6%b3%84%e6%bc%8f\"\u003e\u0026gt; Loop variables leaking out!/循环变量泄漏!\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-beware-of-default-mutable-arguments%e5%bd%93%e5%bf%83%e9%bb%98%e8%ae%a4%e7%9a%84%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0\"\u003e\u0026gt; Beware of default mutable arguments!/当心默认的可变参数!\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-catching-the-exceptions%e6%8d%95%e8%8e%b7%e5%bc%82%e5%b8%b8\"\u003e\u0026gt; Catching the Exceptions/捕获异常\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-same-operands-different-story%e5%90%8c%e4%ba%ba%e4%b8%8d%e5%90%8c%e5%91%bd\"\u003e\u0026gt; Same operands, different story!/同人不同命!\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-the-out-of-scope-variable%e5%a4%96%e9%83%a8%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%8f%98%e9%87%8f\"\u003e\u0026gt; The out of scope variable/外部作用域变量\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-be-careful-with-chained-operations%e5%b0%8f%e5%bf%83%e9%93%be%e5%bc%8f%e6%93%8d%e4%bd%9c\"\u003e\u0026gt; Be careful with chained operations/小心链式操作\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-name-resolution-ignoring-class-scope%e5%bf%bd%e7%95%a5%e7%b1%bb%e4%bd%9c%e7%94%a8%e5%9f%9f%e7%9a%84%e5%90%8d%e7%a7%b0%e8%a7%a3%e6%9e%90\"\u003e\u0026gt; Name resolution ignoring class scope/忽略类作用域的名称解析\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-needle-in-a-haystack%e5%a4%a7%e6%b5%b7%e6%8d%9e%e9%92%88\"\u003e\u0026gt; Needle in a Haystack/大海捞针\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#section-the-hidden-treasures%e9%9a%90%e8%97%8f%e7%9a%84%e5%ae%9d%e8%97%8f\"\u003eSection: The Hidden treasures!/隐藏的宝藏!\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#-okay-python-can-you-make-me-flypython-%e5%8f%af%e5%90%a6%e5%b8%a6%e6%88%91%e9%a3%9e-\"\u003e\u0026gt; Okay Python, Can you make me fly?/Python, 可否带我飞? *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-goto-but-whygoto-%e4%bd%86%e4%b8%ba%e4%bb%80%e4%b9%88-\"\u003e\u0026gt; \u003ccode\u003egoto\u003c/code\u003e, but why?/\u003ccode\u003egoto\u003c/code\u003e, 但为什么? *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-brace-yourself%e5%81%9a%e5%a5%bd%e6%80%9d%e6%83%b3%e5%87%86%e5%a4%87-\"\u003e\u0026gt; Brace yourself!/做好思想准备 *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-lets-meet-friendly-language-uncle-for-life%e8%ae%a9%e7%94%9f%e6%b4%bb%e6%9b%b4%e5%8f%8b%e5%a5%bd-\"\u003e\u0026gt; Let\u0026rsquo;s meet Friendly Language Uncle For Life/让生活更友好 *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-even-python-understands-that-love-is-complicated%e8%bf%9ePython%e4%b9%9f%e7%9f%a5%e9%81%93%e7%88%b1%e6%98%af%e9%9a%be%e8%a8%80%e7%9a%84-\"\u003e\u0026gt; Even Python understands that love is complicated/连Python也知道爱是难言的 *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-yes-it-exists%e6%98%af%e7%9a%84-%e5%ae%83%e5%ad%98%e5%9c%a8\"\u003e\u0026gt; Yes, it exists!/是的, 它存在!\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-inpinity%e6%97%a0%e9%99%90-\"\u003e\u0026gt; Inpinity/无限 *\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-mangling-time%e4%bf%ae%e9%a5%b0%e6%97%b6%e9%97%b4-\"\u003e\u0026gt; Mangling time!修饰时间! *\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#section-miscellaneous%e6%9d%82%e9%a1%b9\"\u003eSection: Miscellaneous/杂项\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#--is-faster%e6%9b%b4%e5%bf%ab%e7%9a%84-\"\u003e\u0026gt; \u003ccode\u003e+=\u003c/code\u003e is faster/更快的 \u003ccode\u003e+=\u003c/code\u003e \u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-lets-make-a-giant-string%e6%9d%a5%e5%81%9a%e4%b8%aa%e5%b7%a8%e5%a4%a7%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%90%a7\"\u003e\u0026gt; Let\u0026rsquo;s make a giant string!/来做个巨大的字符串吧!\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-explicit-typecast-of-strings%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%98%be%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2\"\u003e\u0026gt; Explicit typecast of strings/字符串的显式类型转换\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-minor-ones%e5%b0%8f%e7%9f%a5%e8%af%86%e7%82%b9\"\u003e\u0026gt; Minor Ones/小知识点\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#contributing%e8%b4%a1%e7%8c%ae\"\u003eContributing/贡献\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#acknowledgements%e8%87%b4%e8%b0%a2\"\u003eAcknowledgements/致谢\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-license%e8%ae%b8%e5%8f%af\"\u003e🎓 License/许可\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#help%e5%b8%ae%e5%8a%a9\"\u003eHelp/帮助\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#surprise-your-geeky-pythonist-friends%e6%83%b3%e7%bb%99%e4%bd%a0%e7%9a%84%e6%9e%81%e5%ae%a2%e6%9c%8b%e5%8f%8b%e4%b8%80%e4%b8%aa%e6%83%8a%e5%96%9c\"\u003eSurprise your geeky pythonist friends?/想给你的极客朋友一个惊喜?\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#need-a-pdf-version%e9%9c%80%e8%a6%81%e6%9d%a5%e4%b8%80%e4%bb%bdpdf%e7%89%88%e7%9a%84\"\u003eNeed a pdf version?/需要来一份pdf版的?\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#follow-commit%e8%bf%bd%e8%b8%aaCommit\"\u003eFollow Commit/追踪Commit\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#996icu\"\u003e996.icu\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- /TOC --\u003e\r\n\u003ch1 id=\"structure-of-the-examples示例结构\"\u003eStructure of the Examples/示例结构\u003c/h1\u003e\n\u003cp\u003e所有示例的结构都如下所示:\u003c/p\u003e","title":"（转）What the Fuck Python！ 一些python特性"},{"content":"主要介绍一些常用数据类型的一些method，区别还有一些特殊的定义；\npriority_queue 默认是大顶堆，great的话是小顶堆，less的话是大顶堆，自定义的话不知道是不是一致的\nset默认top是小顶，这个大小我就不知道了，自定义的话，好像和我想得是一致的\n所有的动态容器都是存放在heap上的，像是什么Vector，String，unordered_map之类的\n指定精度的输出和计算 在腾讯的笔试中出现的需要指定精度和指定的计算精度的分析，在使用常数的时候一定要使用.0去修正一个方法。\nVector 动态数组 Vector中的一些常用的函数，方法，以及一些属性介绍和辨析\nemplace_back \u0026amp; push_back（在末尾添加元素） empalce_back 直接在数组的末尾进行构造，而push_back借助于构造的临时变量再将其加入数组末尾，所以在一些操作中empalce_back对于空间时间的效率是会更高的，但是如果我们有重复构筑的数据的话，可能就需要使用push_back。\n要注意实际上vector中并没有append的方法。\n初始化方法 主要有几种常用的构造函数，在这里主要介绍的是关于多维度的初始化构造方式。\n1 2 3 4 5 6 vector\u0026lt;int\u0026gt; v = {7, 5, 16, 8}; // 最基本的定义 // 通过大括号来设定多级的vector的初始值 vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; value = { {\u0026#39;5\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;}, {\u0026#39;6\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;9\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;} }; 常用的长度和常量\n1 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec(size1,vector\u0026lt;int\u0026gt;(size2,defaultvalue)); Unordered_map\u0026amp;set哈希结构 CPP中hash table的实现数据类型： 实际上就是无序表，针对不同情况下的基本的定义方式，理念相同，针对不同的应用场景\nunordered_map\u0026lt;typedef,typedef\u0026gt; Hashtable : 实际上是Key-Value的架构\nunordered_set\u0026lt;typedef\u0026gt; Hashset ：只包含key的类型\n插入的话，可以使用数组的形式，也可以用insert 或者emplace把。\n取值方式 除了通过Key取Value这种老生常谈的方式，我们这里探讨的是iterator的情况下如何取到当前的值：\nset: *it即可； map：*it取的应该是value，key的话通过 it-\u0026gt;first来取值，value通过it-\u0026gt;second 按照迭代器来初始化 1 unordered_set\u0026lt;string\u0026gt; deaded(deadends.begin(),deadends.end()); 是否存在键值 使用.count不要再用find和end了，那个估计时间成本特别高了。。。。怎么更慢了。\n使用map[key] 可以访问键对应的值，但是如果Key不存在，cpp会自动创建这个key同时赋值为0；\nerase 可以直接根据键值进行erase()\nList 双向链表like 通常用list 来实现类似双向链表的类型，基本的使用上好像和其他的容器没什么区别，没有index索引，可能需要用iteration来进行遍历操作，\n和双向队列相同，可以在两端添加和删除，pop push emplace也就是有_back和_front的后缀。 自带reverse，可以将元素的顺序反转； unique可以删除连续的重复元素； sort自带排序算法； Pair 二元元组对 二元tuple类型 实际上应该就是python中的二元tuple，也就是包含两个元素的数据结构，都是公开，可以是同样类别或者不同类别的，再STL中。\nUSAGE： 初始化：基本的初始化方式如下\n1 2 3 4 pair\u0026lt;type1, type2\u0026gt; Data1; // 基本的调用方式如下 Data1.first = {}; Data2.second = {}; 用作新的类型定义的方式\n1 2 typedef pair\u0026lt;type1, type2\u0026gt; newtypeName; newtypeName Data2; 实际上再DP中也是比较常见的，因为有一些情况下需要额外的信息存储就会使用这个类型。\nString \u0026amp; char 字符串 一些常用的函数 strcpy：将stringA 的值复制到stringB\nstrcat：直接用+就行了\nqueue队列 实际上就是队列数据结构的CPP实现，基本的特征和队列的要求是一致的，常在BFS中使用到。\n常用的成员函数和操作 front/back：访问首/尾元素; push/emplace/pop: 在末尾插入/构造数据；弹出队首数据； swap：交换内容（还没尝试过使用的方式）; Deque双端队列 有下标顺序的容器，允许在首尾两端快速插入和删除，相比于原本的普通队列，元素访问上没什么区；主要的区别在于\npop、emplace、push都变成了两种形式：pop_back\\ pop_front \u0026hellip;etc. Priority_queue优先队列 参考资料 “例如，用 std::greaterT 将导致最小元素作为 top() 出现。”\nUsage 基本使用方式 1 2 priority_queue\u0026lt;type, container, compare\u0026gt; 存放的数据类型，底层的容器类型，比较方程 基本的使用\n1 2 3 top push、pop、emplace swap Priority_queue与Multiset辨析： 实际上set和map这些数据结构是基于红黑树进行建立的，而优先队列是基于最大堆最小堆来建立的，虽然他们都有序，但是实际上他们的结构还是大不相同的。\n堆本身是一个完全二叉树（除了最后一层以外都是满的，而且空的值都在右侧），同时满足夫节点大于所有子节点\nSet本身是一个自平衡的BST（红黑树）：\n红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍\nset/multiset 堆相关的数据类型 比起说是堆，实际上就是集合的意思，但是这两个数据类型，本质上是基于红黑树等数据结构的基础设计（实现）的，很容易能转化为最大值堆和最小值堆。\n两者之间的基础区别： 两者都包含在\u0026lt;set\u0026gt;中，进入这两个数据结构的数据都是会直接被排序好的（迭代器输出的话是从小到大的顺序排列），支持插入，删除，查找。\nset不允许重复元素的录入，会自动屏蔽重复元素； multiset可以容忍元素的重复，也就是不会做统筹处理； Usage使用方式： 可以通过在初始化的时候自定义compare，来规定排序的方向（来构建最大堆和最小堆），这里就涉及到了一下的两部分内容：\nless、greater的使用和介绍 两者包含在functional中\n是系统定义好的基本bool比较器，前者就是当A小于B的时候会return true；后者应该是反过来的；\n在一些函数或者类型定义的时候会使用到这两者的参数，避免我们的重复定义。\n:question:但是这里目前有一个问题就是他这里介绍的使用方式来建立最大值和最下值堆，和我个人理解的不太一样，我们需要去后面辨析一下到底是怎么样才是对的。\n应该和我理解的是一眼的，less最终就会是升序排列的，greater就会是降序排列的集合，然后只要我们在下面的pop或者push中指定一样的compare function就行。不，和我理解的是相反的\npush_heap pop_heap堆元素的添加和删除 帮助通过最大值堆和最小值堆的数据的添加和删除；此外我们在这里可能需要额外的介绍一下make_heap，应该也是heap的系列套件，不知道是从什么数据类型开始来帮助建立堆，我们后续需要补充一下。\n通过push_heap能够实现堆元素的添加同时并不破坏数据结构，实际上应该也就是实现了shiftup之类的操作。 而通过pop_heap的话，实际上实现的是将要弹出的元素换到了末尾，这样我们从0，n-2的元素就是重构好的最大/小堆。必要的时候我们需要手动调用pop_back()，来对要弹出的元素进行实质上的弹出。 make_heap将一个可迭代容器按照指定的compere建立成堆，默认是最大堆，输入的是begin，end，compa， AVL平衡二叉搜索树 实际上就是在插入元素的时候实现两个操作：\n单旋转：插入的大小关系符合但是失衡的情况 双旋转：插入的大小关系不符合同时发生了失衡的情况 平衡二叉树 B+、B树、红黑树 根节点最少有两个子女，每个中间节点都包含k-1个元素和k个孩子，每个叶子节点都包含k-1个元素，所有的叶子节点都位于同一层。\n重点就在于节省io时间还有中间的节点数量等等\nB树与B+树：https://blog.csdn.net/windflybird/article/details/79875972\n红黑树：https://zhuanlan.zhihu.com/p/31805309\n红黑树和AVL的区分：https://www.jianshu.com/p/37436ed14cc6 ；https://www.it610.com/article/1297797681401372672.htm\nSWAP FUNCTION swap在实际操作的时候经常被用到，很多时候会被拿来代替删除等等的命令。\n他适用的数据结构和数据类型以及传入的方式可以简单总结如下：\n初始定义就是交换两个变量之间的赋值，但是在各个数据类型中都存在swap的特化方程，所以根据该特化执行的情况下，等价于varA.swap(varB)，会交换其中的所有值； 通过基本的定义也能实现vector中两个不同index下的值的交换； Switch操作要常用 代替if else\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int calculate(string s) { vector\u0026lt;int\u0026gt; stk; char preSign = \u0026#39;+\u0026#39;; int num = 0; int n = s.length(); for (int i = 0; i \u0026lt; n; ++i) { if (isdigit(s[i])) { num = num * 10 + int(s[i] - \u0026#39;0\u0026#39;); } if (!isdigit(s[i]) \u0026amp;\u0026amp; s[i] != \u0026#39; \u0026#39; || i == n - 1) { switch (preSign) { case \u0026#39;+\u0026#39;: stk.push_back(num); break; case \u0026#39;-\u0026#39;: stk.push_back(-num); break; case \u0026#39;*\u0026#39;: stk.back() *= num; break; default: stk.back() /= num; } preSign = s[i]; num = 0; } } return accumulate(stk.begin(), stk.end(), 0); } }; 位操作运算 参考资料 ^异或；~取反；|或；\u0026amp; 与。\n位运算符的优先级从高到低，依次为~、\u0026amp;、^、|。\n基本的一些操作Tips 根据剑指offer后面的两道题，我们可以分析一下怎么做到按位来进行操作\nException 异常处理 介绍cpp中的断言等异常处理的语句：assert try catch\nAssert 断言 设置条件断点，当Expression == false 的时候终止程序运行， Just take one arguments （Expression）；\n可以使用 #define NOEDEBUG 预处理符来终止程序中assert的作用。\n1 2 3 // #define NODEBUG // 注释掉的时候assert是有效的 assert(2+2==5); Try_Catch \u0026amp; Throw 异常捕捉和抛出 Throw就是Try中遇到异常执行的抛出语句，有默认的抛出类类型，我们也可以自定义抛出的值就是了，基本语法框架如下\n1 2 3 try { /* */ } catch (const std::exception\u0026amp; e) { /* */ } // 具名形参 try { /* */ } catch (const std::exception\u0026amp;) { /* */ } // 不具名形参 try { /* */ } catch (...) { /* */ } // 可被任何异常激活的catch 还有一个比较具体的例子可以表示如下\n1 2 3 4 5 6 7 8 9 10 11 try { f(); } catch (const std::overflow_error\u0026amp; e) { // 若 f() 抛出 std::overflow_error 则执行之（“相同类型”规则） } catch (const std::runtime_error\u0026amp; e) { // 若 f() 抛出 std::underflow_error 则执行之（“基类”规则） } catch (const std::exception\u0026amp; e) { // 若 f() 抛出 std::logic_error 则执行之（“基类”规则） } catch (...) { // 若 f() 抛出 std::string 或 int 或任何其他无关类型则执行之 } 然后介绍一下我们自己调用throw的方式：我们可以抛出任意类型的值，然后通过catch捕获该类型即可，示范如下：\n不知道可不可以直接抛出“\u0026hellip;”这种，下次试试。\n1 2 3 4 5 6 try { std::cout \u0026lt;\u0026lt; \u0026#34;Throwing an integer exception...\\n\u0026#34;; throw 42; } catch (int i) { std::cout \u0026lt;\u0026lt; \u0026#34; the integer exception was caught, with value: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } Printf 按照format输出 #inlcude\u0026lt;cstdio\u0026gt; 参考cpp reference进行基本的学习吧，实际上\nAccumulate，isdigit 通过迭代器叠加其中的所有数字\nisdigit：返回的是是否是0~9的字符把\nDefine定义函数 1 #define nRand(n){rand() % n} 指针相关内容 函数指针 用typedef减少输入量的写法，实际应用在之前的cpp笔记中已经有了\n智能指针 unique_prt\u0026lt;\u0026gt;:会自己销毁的指针，管理的是堆对象，但是指针本身是随着栈，来进行管理的\nshared_ptr\u0026lt;\u0026gt;：对于同一个对象会维护一个指向该对象的count，通过这个count，在count清零的时候自动析构该类\nweak_ptr\u0026lt;\u0026gt;: 防止shared_ptr产生两个shard交互引用的情况，这样就永远不会被释放，通过weak指针，他不进行计数，当weak指针被销毁的时候就直接将空间释放，也不会使得技术++\n","permalink":"https://hugotest-phi.vercel.app/posts/cpp%E8%A6%81%E7%82%B9%E8%BE%A8%E6%9E%90%E4%B8%8E%E8%A1%A5%E5%85%85/","summary":"\u003cp\u003e主要介绍一些常用数据类型的一些method，区别还有一些特殊的定义；\u003c/p\u003e\n\u003cp\u003epriority_queue 默认是大顶堆，great的话是小顶堆，less的话是大顶堆，自定义的话不知道是不是一致的\u003c/p\u003e\n\u003cp\u003eset默认top是小顶，这个大小我就不知道了，自定义的话，好像和我想得是一致的\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e所有的动态容器都是存放在heap上的，像是什么Vector，String，unordered_map之类的\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"指定精度的输出和计算\"\u003e指定精度的输出和计算\u003c/h2\u003e\n\u003cp\u003e在腾讯的笔试中出现的需要指定精度和指定的计算精度的分析，在使用常数的时候一定要使用.0去修正一个方法。\u003c/p\u003e\n\u003ch2 id=\"vector-动态数组\"\u003eVector 动态数组\u003c/h2\u003e\n\u003cp\u003eVector中的一些常用的函数，方法，以及一些属性介绍和辨析\u003c/p\u003e\n\u003ch3 id=\"emplace_back--push_back在末尾添加元素\"\u003eemplace_back \u0026amp; push_back（在末尾添加元素）\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eempalce_back \u003c/code\u003e直接在数组的末尾进行构造，而\u003ccode\u003epush_back\u003c/code\u003e借助于构造的临时变量再将其加入数组末尾，所以在一些操作中\u003ccode\u003eempalce_back\u003c/code\u003e对于空间时间的效率是会更高的，但是如果我们有重复构筑的数据的话，可能就需要使用\u003ccode\u003epush_back\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e要注意实际上vector中并\u003cstrong\u003e没有\u003c/strong\u003eappend的方法。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch3 id=\"初始化方法\"\u003e初始化方法\u003c/h3\u003e\n\u003cp\u003e主要有几种常用的构造函数，在这里主要介绍的是关于多维度的初始化构造方式。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e7\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e16\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 最基本的定义\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 通过大括号来设定多级的vector的初始值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;5\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;3\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;7\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;6\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;1\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;9\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;5\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"sc\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e常用的长度和常量\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003edefaultvalue\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"unordered_mapset哈希结构\"\u003eUnordered_map\u0026amp;set哈希结构\u003c/h2\u003e\n\u003ch3 id=\"cpp中hash-table的实现数据类型\"\u003eCPP中hash table的实现数据类型：\u003c/h3\u003e\n\u003cp\u003e实际上就是无序表，针对不同情况下的基本的定义方式，理念相同，针对不同的应用场景\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e unordered_map\u0026lt;typedef,typedef\u0026gt; Hashtable\u003c/code\u003e : 实际上是Key-Value的架构\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eunordered_set\u0026lt;typedef\u0026gt; Hashset\u003c/code\u003e ：只包含key的类型\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e插入的话，可以使用数组的形式，也可以用insert 或者emplace把。\u003c/p\u003e\n\u003ch3 id=\"取值方式\"\u003e取值方式\u003c/h3\u003e\n\u003cp\u003e除了通过Key取Value这种老生常谈的方式，我们这里探讨的是iterator的情况下如何取到当前的值：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eset\u003c/strong\u003e: \u003ccode\u003e*it\u003c/code\u003e即可；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003emap：\u003c/strong\u003e\u003ccode\u003e*it\u003c/code\u003e取的应该是value，\u003cstrong\u003ekey\u003c/strong\u003e的话通过 \u003ccode\u003eit-\u0026gt;first\u003c/code\u003e来取值，\u003cstrong\u003evalue\u003c/strong\u003e通过\u003ccode\u003eit-\u0026gt;second\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"按照迭代器来初始化\"\u003e按照迭代器来初始化\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eunordered_set\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003edeaded\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edeadends\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e\u003cspan class=\"n\"\u003edeadends\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"是否存在键值\"\u003e是否存在键值\u003c/h3\u003e\n\u003cp\u003e使用\u003ccode\u003e.count\u003c/code\u003e不要再用find和end了，那个估计时间成本特别高了。。。。怎么更慢了。\u003c/p\u003e\n\u003cp\u003e使用map[key] 可以访问键对应的值，但是如果Key不存在，cpp会自动创建这个key同时赋值为0；\u003c/p\u003e\n\u003ch3 id=\"erase\"\u003eerase\u003c/h3\u003e\n\u003cp\u003e可以直接根据键值进行erase()\u003c/p\u003e","title":"C++的常见数据类型和操作"},{"content":"学习资源汇总 manual：菜鸟Shell | ExplainShell 收录一些Linux的工具书以及相关的OnLine-Doc，方便后续进行学习和查阅：\n鸟哥的Linux私房菜 ：相对全面一点但是内容有点太多了 Linux就该这么学 ：从开始到结束的流程挺完善的，但是这个网站做的是纯傻逼 Linux Tools Quick Tutorial ：简单入门教程好像是 Linux命令行于Shell脚本编程大全：本地PDF，在当前文件夹下面进行查看 文件架构\u0026amp;系统信息 Linux各文件夹的含义 分析LInux下的文件架构体系，包括最外层的一些系统文件夹的基础作用以及对应的特殊功能等等，帮助我们能够更清楚我们文件的存储体系以及系统文件的存储地址。\n/tmp：临时文件夹，系统会定期清理其中的文件，用来存放一些下载和安装的文件 /mnt: mount挂载文件夹，作为挂载目录来使用，比如在WSL中，对应的就是windows系统的文件 /etc :用来存放所有的系统管理所需要的配置文件和子目录，linux正是因为这些文件才能正常运行 /home: 个人文件夹，在home下会有自己的user dir,通常情况下我们的工作区和对应的其余资料都会放在这个部分 /bin: 是binary的缩写,包含了引导系统启动所需的命令和普通用户可以使用的常用命令 /root: 系统管理员的主目录 /var:这个目录中存放着那些不断在扩充着的东西，为了保持/usr的相对稳定那些经常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的顺带说一下系统的日志文件就在/var/log目录中。 /usr: 最庞大的目录，要用到的应用程序和文件几乎都在这个目录 GPU \u0026amp; CPU信息 Linux查看显卡信息：\n1 2 3 4 5 lspci | grep -i vga # 如果是nvidia还可以 lspci | grep -i nvidia # 最常用：或者使用nvidia的自带命令 nvidia-smi 监视GPU使用情况\n1 2 3 watch nvidia-smi # or gpustat --watch 显示CUDA版本\n1 cat /usr/local/cuda/version.txt 查看CPU：相关信息 1 cat /proc/cpuinfo 显示CPU个数：\n1 cat /proc/cpuinfo |grep \u0026#34;processor\u0026#34;|wc -l 软件安装工具介绍 开源的 Linux 有许多发行版本，其中有不同类型的包管理器，dnf 和 apt 管理器分别针对 rpm 和 deb 的包，这里介绍一下 RPM 包管理器的发展。\nRPM (red-hat program manager) 其是最早的软件安装工具，最早只能基于源码安装，但是其无法分析安装的软件和已安装软件间的依赖关系，这样很容易导致在安装的时候出现问题; 于是后续有了 Yum ;\nYUM 管理了很多 rpm 软件包，并能自动分析其中的依赖关系，避免安装软件出错，但是 yum 仍然存在分析不准确和内存占用的问题，所以后面再2015年的时候又有了更新，也就是 DNF;\nDNF 和 yum 的使用命令是完全一致的，即从 yum install \u0026lt;package\u0026gt; 变成了 dnf install \u0026lt;package\u0026gt;;\n系统服务 Linux 中控制系统服务的命令在 RHEL5/6 中为 service ，而在 RHEL7/8 中则改为 systemctl ，其对应的使用范式分别为：\nservice \u0026lt;server\u0026gt; \u0026lt;action\u0026gt; systemctl \u0026lt;action\u0026gt; \u0026lt;server\u0026gt; 其对应执行服务的 \u0026lt;action\u0026gt; 都是一致的，例如 start、restart 等服务启动命令。\n启动ssh服务 1 2 3 service ssh start # or systemctl restart sshd ssh 配置免密登陆和远程登录，可以参考 SSH 常用场景和操作 文章。\n添加用户以及赋予 Sudo 权限 存在两个命令 useradd 和 adduser 都能添加新用户，但是 useradd 不会设置用户目录和 unix-name 的选项，所以推荐使用 adduser 指令来新建用户。\n对应的删除命令为 userdel 和 deluser, 管理用户组的文件为 /etc/group\n1 2 adduser \u0026lt;aikenhong\u0026gt; # 安装之时输入密码后会提示你输入ROOM等个人信息可以跳过 为用户添加 root 权限\nsudo vim /etc/sudoers\r# 可能需要w!来保存 基础环境配置 配置环境之前首先要清楚自己所使用的Linux发行版以及对应的内核版本，如果使用的是Ubuntu，可通过以下指令查看所属的版本：\n1 2 3 cat /proc/version # or cat /etc/issue 在进行一切配置之前，首先使用passwd指令修改密码。\n编辑器 Vim or Neovim 接下来是安装vim或者neovim（或是spacevim等各种变体），其中服务器上推荐以vim作为主力配置的编辑器，neovim和插件的版本迭代和兼容性差，应对版本更新需要更多的精力，相对没有那么稳定（暂时。\n安装vim后手动创建配置文件\n1 sudo apt-get install vim 安装neovim，需要首先安装neovim的ppa发布源后，才能下载\n1 2 3 sudo apt-add-repository ppa:neovim-ppa/stable sudo apt-get update sudo install neovim 安装vim的各种其他变体可参考对应的官方站点或github，在完成安装之后，就是配置其使用，这里vim和neovim的配置单独开blog来讲，个人的配置可参考：AikensDotfile ZSH \u0026amp;\u0026amp; OMZ Install： 参考资料：WSL终端美化 、zsh \u0026amp; oh-my-zsh 的配置与使用 、 zsh、oh-my-zsh、tmux、vim 查看当前使用的 shell：\n1 2 echo $SHELL # 可以产看系统默认的shell 安装Zsh和OMZ对命令行进行优化：\n1 2 3 4 5 6 7 8 9 10 11 # 安装zsh，很多会内置，其一些语法和调用逻辑相比默认的bash更好 sudo apt-get install zsh # omz参考官网安装连接，可以使用wget、curl、or github sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34; sh -c \u0026#34;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026#34; git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 切换默认终端，以及恢复：\n1 2 chsh -s /bin/zsh chsh -s /bin/bash root 官方主题 预览，在zsh配置文件中修改vim ~/.zshrc\nZsh插件安装：zsh插件安装 ；zsh插件配置 ，主要是两个插件zsh-synyax-highlighting高亮命令和zsh-autosuggestions自动补全。\n语法高亮安装： 1 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 自动补全安装： 1 git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 这两个命令将插件安装到相应的位置中，找到后在.zshrc 中进行配置，再通过 source ~/.zshrc 刷新配置即可。\n其他的一些插件推荐（除了上述两个需要额外下载的，其他大多都是内置的插件，zshrc 中设置后 source 即可）：推荐几个常用的 zsh 插件 | ohmyzsh插件推荐_JASON凯伊 | Plugins·ohmyzsh/ohmyzsh Wiki 1 2 3 4 5 6 7 8 9 10 plugins=( z git zsh-syntax-highlighting zsh-autosuggestions colored-man-pages safe-paste themes sudo ) 删除zsh后远程无法连接：可能是由于接受ssh启动的默认shell被改成了zsh，而zsh已经卸载，导致无法进入终端页面，因此需要想办法进入console，然后修改默认的登陆项为bash。vim /etc/passwd。\nzsh作为基本的shell，可以不删；此外若要删除，记得优先将默认启动项改回bash，此外，不要修改root的默认登录shell，LINK Conda 相关指令消失：\n1 2 # 基于别的shell，例如bash，执行 conda init zsh 添加Alias方便使用，个人常用的一些alias如下:\n1 2 3 4 5 6 alias g=\u0026#34;git\u0026#34; alias ltr=\u0026#34;ls -rsthl\u0026#34; alias lwc=\u0026#34;ll | grep \u0026#39;^-\u0026#39; | wc -l \u0026#34; alias cl=\u0026#34;clear\u0026#34; alias nvim=\u0026#34;vim -u {my .vimrc}\u0026#34; alias hsp=\u0026#34;history | grep \u0026#34; 进程管理 Monitors 进程和性能检测工具安装，可以检测系统的运行状态，以及对相应的进程进行查看，同时也能起到装逼的作用，主要有以下几个工具：Htop，Bottom，Zenith\nHtop 是最general且相对实用的一个版本，主要侧重于进程管理，安装也最为简单。\n1 2 sudo apt-get install htop htop Bottom 需要下载对应内核的安装包后再命令行中执行安装指令，因此也需要curl来下载对应的软件包：\n1 2 3 4 5 # 以ubuntu为例，下载deb版本 curl -s https://api.github.com/repos/ClementTsang/bottom/releases/latest | grep browser_download_url | grep amd64.deb | cut -d \u0026#39;\u0026#34;\u0026#39; -f 4 | wget -qi - sudo apt install ./bottom*.deb btm Zenith 可能需要系统中支持cargo或者rust，安装放方式类似btm，但是两者之间可做一个相互替代，均着重于可视化系统用量，因此二选一即可：\n首先安装rust\n1 sudo apt-get install rustc 下载对应的安装包，解压，并安装\n1 2 3 4 5 6 7 8 9 # download the package of Zenith curl -s https://api.github.com/repos/bvaisvil/zenith/releases/latest | grep browser_download_url | grep linux | cut -d \u0026#39;\u0026#34;\u0026#39; -f 4 | wget -qi - # unzip it and install tar -xvf zenith.linux.tgz # change the mode of shell chmod +x zenith sudo mv zenith /usr/local/bin 似乎从源码编译能支持GPU的信息显示，后续有需要的情况下进行拓展。\n参考资料:\nTop Terminal Based Monitoring Tools for Linux | ComputingForGeeks Zenith (reposhub.com) ClementTsang/bottom (github.com) bvaisvil/zenith (github.com) ZIP支持 tgz应该是linux内置的压缩命令，而许多时候在windows中的压缩包会有zip等格式，所以这里也添加一下ZIP支持。\n1 sudo apt-get install zip zip指令的基础使用如下：\n1 2 # r means recurrent zip -r newpackage.zip dir1 1 2 # -d 解压到特定文件夹 unzip package.zip -d dir/* 1 2 3 4 -m: 压缩文件删除源文件 -o: 将压缩文件的最新变动时间设置为压缩的时间 -r: 递归压缩，目录下的所有子级目录一并压缩 -x: “文件列表”，压缩时排除文件列表中的文件 额外配置 只保留必要的额外配置，帮助系统的使用更加便捷，遵循奥卡姆剃刀原则。\n资源管理器 Ranger 安装Ranger\n参考offical-site ，可使用对应发行版本的package-manager进行安装：\n1 sudo apt-get install ranger 配置Ranger\n1 ranger --copy-config=all 该命令能将基础的配置复制到相应的地址，随后根据我们的需要对其进行配置，包括是否启用边框等，配置结构如下：\n1 2 3 4 rc.conf - 选项设置和快捷键 commands.py - 能通过 : 执行的命令 rifle.conf - 指定不同类型的文件的默认打开程序。 scope.sh - 用于指定预览程序的文件 这些生成的配置文件的所在目录为：/Users/test/.config/ranger/\n详细配置参考资料：Ranger使用 终端复用器 Tmux 为了避免远程终端执行的代码由于ssh连接的不稳定而中断，可以使用nohup挂起进程，或者使用tmux和screen类的session软件来保持进程，但是鉴于Tmux优秀的终端复用和诸多特性，这里选择tmux。\n1 sudo apt-get install tmux 配置TMUX\n新版本的时候出现了问题，等待更新，official example ，tutor 在~目录下生成配置文件，然后写入我们希望的配置，后续合并到Dotfile中\n1 vim ~/.tmux.conf 主要包含相关的按键映射以及页面主题等等操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # use alt+arrpw to switch panes bind -n M-Left select-pane -L bind -n M-Right select-pane -R bind -n M-Up select-pane -U bind -n M-Down select-pane -D # mouse mode set -g mouse on # set easier window split keys bind-key v split-window -h bind-key h split-window -v #Enable oh my zsh in tmux set -g default-command /usr/bin/zsh #################################### config color ###################################### set -g default-terminal \u0026#34;screen-256color\u0026#34; ## COLORSCHEME: gruvbox dark set-option -g status \u0026#34;on\u0026#34; # default statusbar color set-option -g status-style bg=colour237,fg=colour223 # bg=bg1, fg=fg1 # default window title colors set-window-option -g window-status-style bg=colour214,fg=colour237 # bg=yellow, fg=bg1 # default window with an activity alert set-window-option -g window-status-activity-style bg=colour237,fg=colour248 # bg=bg1, fg=fg3 # active window title colors set-window-option -g window-status-current-style bg=red,fg=colour237 # fg=bg1 # pane border set-option -g pane-active-border-style fg=colour214 #fg2 set-option -g pane-border-style fg=colour237 #bg1 # message infos set-option -g message-style bg=colour239,fg=colour223 # bg=bg2, fg=fg1 # writing commands inactive set-option -g message-command-style bg=colour239,fg=colour223 # bg=fg3, fg=bg1 # pane number display set-option -g display-panes-active-colour colour214 #fg2 set-option -g display-panes-colour colour237 #bg1 # clock #set-window-option -g clock-mode-colour colour109 #blue set-window-option -g clock-mode-colour colour239 #blue # bell set-window-option -g window-status-bell-style bg=colour167,fg=colour235 # bg=red, fg=bg ## Theme settings mixed with colors (unfortunately, but there is no cleaner way) set-option -g status-justify \u0026#34;left\u0026#34; set-option -g status-left-style none set-option -g status-left-length \u0026#34;80\u0026#34; set-option -g status-right-style none set-option -g status-right-length \u0026#34;80\u0026#34; set-window-option -g window-status-separator \u0026#34;\u0026#34; #################################### config status ###################################### set-option -g status-left \u0026#34;#[fg=colour248, bg=colour241] #S #[fg=colour241, bg=colour237, nobold, noitalics, nounderscore]\u0026#34; set-option -g status-right \u0026#34;#{prefix_highlight}#[fg=colour239, bg=colour237, nobold, nounderscore, noitalics]#[fg=colour246,bg=colour239] %Y-%m-%d %H:%M #[fg=colour248, bg=colour239, nobold, noitalics, nounderscore]#[fg=colour237, bg=colour248] #h\u0026#34; set-window-option -g window-status-current-format \u0026#34;#[fg=colour237, bg=colour214, nobold, noitalics, nounderscore] #[fg=colour239, bg=colour214] #I #[fg=colour239, bg=colour214, bold] #W #[fg=colour214, bg=colour237, nobold, noitalics, nounderscore]\u0026#34; set-window-option -g window-status-format \u0026#34;#[fg=colour237,bg=colour239,noitalics]#[fg=colour223,bg=colour239] #I#[fg=colour223, bg=colour239] #W #[fg=colour239, bg=colour237, noitalics]\u0026#34; TMUX基本操作\ntmux 前缀按键：ctrl+b 1 2 3 4 5 6 7 8 # tmux 新建，离开，重连，关闭，列表，重命名 tmux new -s \u0026lt;session-name\u0026gt; tmux detach # 或者prefixKey + d tmux attach -t \u0026lt;session-name\u0026gt; tmux kill-session -t \u0026lt;session-name\u0026gt; # 或者直接exit tmux kill-windows -t \u0026lt;windows-name\u0026gt; tmux ls tmux rename-session -t \u0026lt;old-session-name\u0026gt; \u0026lt;new-session-name\u0026gt; # prefixkey + b Anaconda 安装 参考资料：如何在 Ubuntu 20.04 上安装 Anaconda ；oh-my-zsh主题支持conda虚拟环境 ；oh-my-zsh主题显示conda环境名称 安装 找到最新的安装包版本：Index of anaconda 后选择对应的版本安装\n1 wget -P /tmp https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh 可选）验证下载版本的正确性：\n1 2 sha256sum /tmp/Anaconda3-2021.05-Linux-x86_64.sh # 查看输出的哈希值和对应的archive上的值是一致的 安装anaconda\n1 2 sh /tmp/Anaconda3-2021.05-Linux-x86_64.sh # 按照intro应该会执行conda init 等等操作，如果没有我们可以自行执行 环境配置 在安装完成后记得执行conda init初始化环境，而针对其他的shell，例如zsh，可以按照以下的流程执行初始化。\n1 2 3 4 5 # 假如当前的shell是zsh bash source ~/.bashrc conda init zsh # 退出bash回到zsh 关闭conda的命令行提示:\n1 conda config --set changeps1 false 安装没安装完成的包：\nsudo apt-get install package --fix-missing\n更新源：\n很多情况下Ubuntu的Source是被屏蔽的，所以我们需要使用国内源进行替代，来提升我们的下载和安装的速度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # backup the source files in cases that sth wrong sudo cp /etc/apt/sources.list /etc/apt/source.list.bak # using sudo to modify or recreate the source.list files sudo nvim /etc/apt/source.list # replace the content of it === TSINGHUA SOURCE === # update the source info sudo apt update # update the files to varify the speed. sudo apt upgrade 实际上换源只要找到对应的ubuntu的发行版，也就是在源链接后面的形式，然后将前面的url改成对应的源即可\nAll the source list ；清华源更新地址 ;聚合 ；XJTU ；Alibaba 1 2 3 4 5 6 7 8 9 10 11 ==================== aliyun source =================== deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 其他的相关操作参见Anaconda的相关文档，这里只涉及对应的安装和初始化。\n注意事项 @Aiken 2020\n本文档主要记录一些Linux下面遇到的问题解决方法：\npython环境无法识别 安装完linux以后在bash没法执行conda命令，以及识别不出conda中安装的环境，而从portainer中可以直接启动python的非对等偏差问题。\n1 2 source /opt/conda/bin/activate conda activate base 应该是由于没有将conda的自启动加入docker中的自动运作中，所以需要自行对conda 命令进行启动。\nsolve update：\n直接在portainer的terminal中执行如下命令即可一劳永逸\n1 conda init apt-get 找不到包 1 2 # 首先执行apt-get的更新 sudo apt-get update apt-get /var/lib/dpkg/lock-frontend 1 2 3 sudo rm /var/lib/dpkg/lock-frontend sudo rm /var/lib/dpkg/lock sudo rm /var/cache/apt/archives/lock 不知道哪个真正起了作用，都试试把\nchsh: PAM: Authentication failure 1 2 code /etc/passwd # 里面可能有一些配置出现了问题，包括 bin/bash 漏了前面的斜杠这种 NVCC command not found 在安装CUDA后还是找不到命令的话，可以去以下地址找一下对应的cuda文件是否存在\n1 2 ls -l /usr/local/cuda # 如果存在的话，将cuda的路径导入到bashrc中 1 2 export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH export PATH=/usr/local/cuda/bin:$PATH GDBus.Error: GDBus.Error:org.freedesktop.DBus.Error.Spawn.ExecFailed: Failed to execute program org.freedesktop.PackageKit: Permission denied\n其实就是两行命令来修复 dbus 文件的执行权限：\n1 2 Sudo chown root:messagebus /usr/lib/dbus-1.0/dbus-daemon-launch-helper Sudo chmod 4754 /usr/lib/dbus-1.0/dbus-daemon-launch-helper ———————————————— 版权声明：本文为 CSDN 博主「Main(happy)」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接： https://blog.csdn.net/baidu_31628641/article/details/108586804 Syntax error: \u0026ldquo;(\u0026rdquo; unexpected 该错误可能由于 Ubuntu 本身默认的 sh 指定的为 dash，而我们通常编写的脚本都是基于 Bash 的，因此这里介绍一下切换 sh 的命令\n1 2 3 4 5 # 查看当前默认的sh ls -l /bin/sh # 切换为bash，在弹出的对话框选择no则切换为bash，yes则为dash sudo dpkg-reconfigure dash 切换完成后使用 sh 执行脚本应该不会出现上述问题了，验证的话也可以使用 bash 执行脚本。\n","permalink":"https://hugotest-phi.vercel.app/posts/linux/","summary":"\u003ch2 id=\"学习资源汇总\"\u003e学习资源汇总\u003c/h2\u003e\n\u003cp\u003emanual：\u003ca href=\"https://www.runoob.com/w3cnote/linux-common-command-2.html\" target=\"_blank\" rel=\"noopener\"\u003e菜鸟Shell\u003c/a\u003e\n | \u003ca href=\"https://www.explainshell.com/explain/1/ps\" target=\"_blank\" rel=\"noopener\"\u003eExplainShell\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e收录一些Linux的工具书以及相关的OnLine-Doc，方便后续进行学习和查阅：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://cn.linux.vbird.org/linux_basic/linux_basic.php\" target=\"_blank\" rel=\"noopener\"\u003e鸟哥的Linux私房菜\u003c/a\u003e\n：相对全面一点但是内容有点太多了\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.linuxprobe.com/chapter-00.html\" target=\"_blank\" rel=\"noopener\"\u003eLinux就该这么学\u003c/a\u003e\n：从开始到结束的流程挺完善的，但是这个网站做的是纯傻逼\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html#\" target=\"_blank\" rel=\"noopener\"\u003eLinux Tools Quick Tutorial\u003c/a\u003e\n：简单入门教程好像是\u003c/li\u003e\n\u003cli\u003eLinux命令行于Shell脚本编程大全：本地PDF，在当前文件夹下面进行查看\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"文件架构系统信息\"\u003e文件架构\u0026amp;系统信息\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.cnblogs.com/sijizhen/p/10576049.html\" target=\"_blank\" rel=\"noopener\"\u003eLinux各文件夹的含义\u003c/a\u003e\n分析LInux下的文件架构体系，包括最外层的一些系统文件夹的基础作用以及对应的特殊功能等等，帮助我们能够更清楚我们文件的存储体系以及系统文件的存储地址。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/tmp\u003c/code\u003e：临时文件夹，系统会定期清理其中的文件，用来存放一些下载和安装的文件\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/mnt\u003c/code\u003e: mount挂载文件夹，作为挂载目录来使用，比如在WSL中，对应的就是windows系统的文件\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/etc \u003c/code\u003e:用来存放所有的系统管理所需要的配置文件和子目录，linux正是因为这些文件才能正常运行\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/home\u003c/code\u003e: 个人文件夹，在home下会有自己的user dir,通常情况下我们的工作区和对应的其余资料都会放在这个部分\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/bin\u003c/code\u003e: 是binary的缩写,包含了引导系统启动所需的命令和普通用户可以使用的常用命令\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/root\u003c/code\u003e: 系统管理员的主目录\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/var\u003c/code\u003e:这个目录中存放着那些不断在扩充着的东西，为了保持/usr的相对稳定那些经常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的顺带说一下系统的日志文件就在/var/log目录中。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/usr\u003c/code\u003e: 最庞大的目录，要用到的应用程序和文件几乎都在这个目录\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"gpu--cpu信息\"\u003eGPU \u0026amp; CPU信息\u003c/h3\u003e\n\u003cp\u003eLinux查看显卡信息：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003elspci \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep -i vga\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 如果是nvidia还可以\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003elspci \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep -i nvidia\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 最常用：或者使用nvidia的自带命令\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003envidia-smi\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e监视GPU使用情况\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewatch nvidia-smi\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# or\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egpustat --watch\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e显示CUDA版本\u003c/p\u003e","title":"Linux 基础操作 01"},{"content":"intergrate with those augmentation method.\nthis doc will\nRecord those theory and the effect after transformation Show the codes for ez use And the complete .py will be intergrate in my classification pipeline\nreference below:arrow_down_small:, if use them,start it for respect for his work.\naleju/imgaug :star:albumentations-team/albumentations: torchvision PIL/ImageEnhance CCBS opencv Principle Principle 1 of coding: Don’t reinvent the wheel unless it’s needed\n具体而言，仅在函数的拓展性较差，无法对其定制化，满足我们的日常需求的时候，我们会自行编写函数从而满足我们的需求，否则我们直接引用已知的库，提升我们的实现效率。 Principle 2 of coding 图像增强的两种使用方式：\n做全集的增强后存储在本地，然后通过随机载入或者按一定batch的载入来实现我们增强的作用，（or contrasive），这种方式实际上是使用空间来换时间，由于处理是一次性的，所以如果空间充足的话，是更为充足的方式。\n动态的在线增强：这种方式比较消耗io和cpu，不推荐，但是如果本地的空间不够，就只能采用这种方式了。\nPrinciple 3 of saving 如果我们要存储本地副本的话，推荐的存储格式和方式\n文件格式：npz 由于多种增强，实际上这种方式还蛮适合使用npz格式作为我们的存储，这种既保留了对应的np还可以保留对应的字典信息，此外这种方式的存取速度也不算慢，（相较之下好像没有特别突出的一种格式）\n路径格式：imagenet也就是对应的train-class-data的层级关系，通过这种约定俗称的存储关系我们得以在我们框架中的dataset格式方便读入\nPIL，CV2，SkImage的选择 pytorch图像的加载/读取方式 | cv2、PIL、matplotlib 在这里讲解三个模块之间的基本区别和其中的选择，目前希望将已有的算法从PIL转向CV2，后续也会添加一下三个模块对于Torch的适配性等等\n数据读写 基于下列的代码和注释给出相应的之间的区别，通过这些区别我们可以知道几乎所有的格式在使用的时候都是需要对应的转换的，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import cv2 img = cv2.imread(\u0026#39;lena.png\u0026#39;) # numpy格式，HWC，【0，255】，BGR img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB) # 除了最下方的转换方式外也可以通过这种方式进行转换 cv2.imwrite(\u0026#39;lena.jpg\u0026#39;, img) # img 需为BGR格式的numpy array import PIL from PIL import Image img = Image.open(\u0026#39;lena.png\u0026#39;) # PIL格式，RGB，【0，255】 img = np.array(img) # 转换为numpy格式, HWC Img.fromarray(img).save(\u0026#39;lena.png\u0026#39;) # x需要转换为PIL.Image格式才能保存 from skimage import io img = io.imread(\u0026#39;lena.png\u0026#39;) # numpy 格式， RGB，【0，1】 HWC io.imsave(\u0026#39;lena.jpg\u0026#39;) import matplotlib.pyplot as plt img = plt.imread(\u0026#39;lena.png\u0026#39;) # numpy 格式，HWC [0,255] RGB plt.imsave(\u0026#39;lena.jpg\u0026#39;) # BGR 转换 RGB, 转回来也是一样的操作 img_rgb = img_bgr[:,:,::-1] 基于上述的代码，我们可以总结出：\n当我们使用matplotlib的时候\n当我们用cv2读取图像的时候若要进行matplotlib的展示，我们需要对其做bgr2rgb的转换，PIL则需要做到numpy的转换，skimage考虑归一化方面的问题 当我们要使用tensror格式的时候\n我们需要对cv2转换成RGB\n对三个方法都是用transpose或者类似的方法转换到CHW\n1 2 3 import torch import numpy as np torch_img = torch.from_numpy(np.transpose(img,(2,0,1))) 简单图像增强 在这里由于opencv更为强大且全面，我们将框架转移到opencv中进行图像增强处理，于是本章节会主要介绍opencv, torchvision中的图像增强，同时也会对pillow,skimage`进行简单的介绍。\nTorchVision torchvision的使用实际上是最简单便捷的，为了协调统一，该类变换我们在totensor后进行使用，接在其他所有变换的后面，实际上有一些变换是可以获取参数的，要调用的对应函数我们可以在对应文档 中查询\n**随机机制：**现已向后兼容torch\n1 2 3 4 5 6 7 8 9 # 随机种子采用torch import torch torch.manual_seed(17) # KEY FUNCTION: 给一个transformers加上概率，以一定的概率执行该操作 transformers.RandomApply(transforms,p=0.5) # Key Function：从给定的一系列transforms中选一个进行操作 transformers.RandomChoice(transforms) 由于存在randomapply这个函数，所以实际上我们在调用变换的时候，我们可以用prefix random去搜补全，如果没有的话，也可以使用RandomApply来手动赋予随机性。\n**组合机制：**同时使用多种变换，这种方法将一组强关联的变换进行组合，简化后续的使用，但是对于我们如果需要做多种增强的话，实际上并不是一个合适的方式。\n1 2 3 4 5 6 # a simple example for torchvision\u0026#39;s transformer transform = transforms.Compose([ transforms.CenterCrop(10), transforms.PILtoTensor(), transforms.ConvertImageDtype(torch.float) ]) 常见的一些增强：列在下面 裁剪系列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # cental crop transforms.CenterCrop(size), # five corners and the cental crop transforms.FiveCrop(size), lambda(lambda crops: torch.stack[ToTensor()(crop) for crop in crops]) # 随机裁剪到对应的尺寸， transforms.RandomCrop(size, padding=None, pad_if_needed=False, fill=0, padding_mode=\u0026#39;constant\u0026#39;) # 随机裁剪后resize到指定的尺寸 transforms.RandomResizedCropsize, scale=(0.08, 1.0), ratio=(0.75, 1.33), interpolation=\u0026lt;InterpolationMode.BILINEAR: \u0026#39;bilinear\u0026#39;\u0026gt;) # Padding 无需多言 transformers.Pad(padding,fill=0,padding_mode=\u0026#39;constant\u0026#39;) 色彩变换增强\n1 2 3 4 5 # 色彩抖动,随机改变亮度对比度饱和度和色调 transforms.Colorjitter(brightness=0, contrast=0, saturation=0, hue=0) # 图像转换为灰度 transforms.grayscale(num_output_channel=1) 几何变换增强\n1 2 3 4 5 6 7 8 # 仿射变换 transformers.RandomAffine(degrees, translate=None, scale=None, shear=None, interpolation=\u0026lt;InterpolationMode.NEAREST: \u0026#39;nearest\u0026#39;\u0026gt;, fill=0, fillcolor=None, resample=None) # 可以通过以下函数获取变换矩阵 get_params(degrees: List[float], translate: Optional[List[float]], scale_ranges: Optional[List[float]], shears: Optional[List[float]], img_size: List[int]) → Tuple[float, Tuple[int, int], float, Tuple[float, float]] transforms.RandomHorizontalFlip(p=0.5) transforms.RandomPerspective(distortion_scale=0.5, p=0.5, interpolation=\u0026lt;InterpolationMode.BILINEAR: \u0026#39;bilinear\u0026#39;\u0026gt;, fill=0) RandomResizedCrop OpenCV Install Ubuntu：安装opencv的python版本\n1 2 apt-get -y python3-opencv pip install opencv-python Usage 这一部分可能主要还是对OpenCV基础使用方式的介绍，至于数据增强方面，上面有一个库已经集成了很大一部分图像增强的操作，且在效率上也有了很高的优化和证实，简单的使用方式如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 try: import albumentations as A except ImportError: os.system(\u0026#34;pip install - U albumentations\u0026#34;) import albumentations as A import cv2 # Declare an augmentation pipeline transform = A.Compose([ A.RandomCrop(width=256, height=256), A.HorizontalFlip(p=0.5), A.RandomBrightnessContrast(p=0.2), ]) # Read an image with OpenCV and convert it to the RGB colorspace image = cv2.imread(\u0026#34;image.jpg\u0026#34;) image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # Augment an image transformed = transform(image=image) transformed_image = transformed[\u0026#34;image\u0026#34;] 下面我们会讲一些opencv中的简单使用方式：\n(一)OpenCV-Python学习—基础知识 - silence_cho - 博客园 (cnblogs.com) Pillow Using PIL do some augmentation CCBS： color，contrast，brightness，shapen 1 2 3 4 # way1：PIL from PIL import ImageEnhance ccbs_img = ImageEnhance.Color(img).enhance(factor1) ... Blur，Detail，Edge_Enhance，Smooth，Sharpen…\n自行在文档中找到对应的方法，实际上不是很多\n1 2 3 4 5 from PIL import Image from PIL.ImageFillter import SMOOTH,BLUR img = Image.open(image_pah) img_1 = img.filtter(BLUR) img_2 = img.filtter(SMOOTH) SkImage \u0026hellip;\n混合图像增强（For ML） ==ALL in one 不是什么好点子== 为了对Machine Learning中的任务进行图像增强任务，我们在过程中可能会使用一些Github Repo，主要可能就是albumation，在进行图像增强和数据混合的过程中，我们会遇到的问题包括：\nPIL和NP，Tensor的三者格式不对应的关系 Channel混杂的关系 调用transformer的形式不统一的问题 为此我们特地开了这个专题，介绍一下使用的方式，以及使我们在后续的使用过程中注意最终转换到datalist中最好采用统一的存储形式\npath（load by cv or pil，st np） data （np（else），tensor（cuda）for instant use） 以此来规范我们的dataset，and sampler or mixer\n我们可以尝试使用如下的方式来进行transformer的管理操作，此外如果我们要用的是纯粹的数据增强而不是用来dataloader的transformer，我们就不要用这个逻辑去做，我们直接集成Augmentation就好了 ch\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class mytransformer(): # if augs is not none we need to add ToPIL to get the right data type def get_transformers(): self.transformer = { \u0026#39;augs\u0026#39;: Augs.Compose([]), \u0026#39;trans\u0026#39;: transformers.Compose([ tranformers.ToPIL(), ... ]), } # then we using k-v pair to do all my transformer, def __call__(img): for k,v in transformer: img = transformer[\u0026#39;augs\u0026#39;](image=img)[\u0026#39;image\u0026#39;] img = transformer[\u0026#39;trans\u0026#39;](img) return img 特殊图像增强 \u0026hellip;\n","permalink":"https://hugotest-phi.vercel.app/posts/dataaugmentation/","summary":"\u003cp\u003eintergrate with those augmentation method.\u003c/p\u003e\n\u003cp\u003ethis doc will\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRecord those theory and the effect after transformation\u003c/li\u003e\n\u003cli\u003eShow the codes for ez use\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd the complete \u003ccode\u003e.py\u003c/code\u003e will be intergrate in my classification pipeline\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ereference\u003c/strong\u003e below:arrow_down_small:, if use them,start it for respect for his work.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/aleju/imgaug#documentation\" target=\"_blank\" rel=\"noopener\"\u003ealeju/imgaug\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e:star:\u003ca href=\"https://github.com/albumentations-team/albumentations\" target=\"_blank\" rel=\"noopener\"\u003ealbumentations-team/albumentations: \u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pytorch.org/vision/stable/transforms.html#transforms-on-pil-image-and-torch-tensor\" target=\"_blank\" rel=\"noopener\"\u003etorchvision\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pillow.readthedocs.io/en/stable/reference/ImageEnhance.html\" target=\"_blank\" rel=\"noopener\"\u003ePIL/ImageEnhance CCBS\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003eopencv\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"principle\"\u003ePrinciple\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003ePrinciple 1\u003c/strong\u003e of coding: Don’t reinvent the wheel unless it’s needed\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e具体而言，仅在函数的拓展性较差，无法对其定制化，满足我们的日常需求的时候，我们会自行编写函数从而满足我们的需求，否则我们直接引用已知的库，提升我们的实现效率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e\u003cstrong\u003ePrinciple 2\u003c/strong\u003e of coding 图像增强的两种使用方式：\u003c/p\u003e","title":"Data Augmentation"},{"content":"MLFlow 机器学习系统的使用 @Aiken 2020\n基于Python开发的DAG数据工作流系统，面向机器学习，支持Spark并行环境和K8S容器集群；\nMLFlow主要解决了三个问题，也就是三个我们可能会需要使用的功能：\nTracking：跟踪实验训练结果，记录算法参数，模型结果和运行效果等等； Projects：对所有的算法项目有一套标准的projects概念，记录下代码版本，参数和运行环境这些东西，并且projects是可以拟合所有的算法框架的； Models：解决的是打包和部署模型的这样一个行为，提供json接口给后续的flsk框架等等进行使用 基本部署 INSTALL：\nDEPLOY：\nTracking 实验版本跟踪 Tracking为本次描述的重点，来做一个训练过程中的版本管理，记录每一次训练的参数和变量信息等等，这样便于后续的恢复和实验信息的整理。便于统计和管理。使用的时候好像也是需要代码嵌入的部分，就是需要在代码中调用MLFlow的API。\n但是在Tracking的时候有一个比较重要的点在于，这个方法和Tensorboard对原模型的参数的嵌入和Logging记录中会不会产生冲突，同时两个方法之间是不是有什么overlap；关键的问题：\n这两个API能不能进行混合使用 怎么统一和区分两个方法的应用情景 Reference https://mlflow.org/docs/latest/tracking.html https://mlflow.org/docs/latest/projects.html https://github.com/mlflow/mlflow https://blog.csdn.net/chenhuipin1173/article/details/100913909 https://my.oschina.net/u/2306127/blog/1825638 https://www.zhihu.com/question/280162556 ","permalink":"https://hugotest-phi.vercel.app/posts/mlflow/","summary":"\u003ch1 id=\"mlflow-机器学习系统的使用\"\u003eMLFlow 机器学习系统的使用\u003c/h1\u003e\n\u003cp\u003e@Aiken 2020\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e基于Python开发的DAG数据工作流系统，面向机器学习，支持Spark并行环境和K8S容器集群；\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eMLFlow主要解决了三个问题，也就是三个我们可能会需要使用的功能：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eTracking\u003c/strong\u003e：跟踪实验训练结果，记录算法参数，模型结果和运行效果等等；\u003c/li\u003e\n\u003cli\u003eProjects：对所有的算法项目有一套标准的projects概念，记录下代码版本，参数和运行环境这些东西，并且projects是可以拟合所有的算法框架的；\u003c/li\u003e\n\u003cli\u003eModels：解决的是打包和部署模型的这样一个行为，提供json接口给后续的flsk框架等等进行使用\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"基本部署\"\u003e基本部署\u003c/h2\u003e\n\u003cp\u003eINSTALL：\u003c/p\u003e\n\u003cp\u003eDEPLOY：\u003c/p\u003e\n\u003ch2 id=\"tracking-实验版本跟踪\"\u003eTracking 实验版本跟踪\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eTracking\u003c/strong\u003e为本次描述的重点，来做一个训练过程中的版本管理，记录每一次训练的参数和变量信息等等，这样便于后续的恢复和实验信息的整理。便于统计和管理。使用的时候好像也是需要代码嵌入的部分，就是需要在代码中调用MLFlow的API。\u003c/p\u003e\n\u003cp\u003e但是在Tracking的时候有一个比较重要的点在于，这个方法和\u003ccode\u003eTensorboard\u003c/code\u003e对原模型的参数的嵌入和Logging记录中\u003cu\u003e会不会产生冲突\u003c/u\u003e，同时两个方法之间是不是有什么overlap；关键的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e这两个API能不能进行混合使用\u003c/li\u003e\n\u003cli\u003e怎么统一和区分两个方法的应用情景\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003c!-- more --\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://mlflow.org/docs/latest/tracking.html\" target=\"_blank\" rel=\"noopener\"\u003ehttps://mlflow.org/docs/latest/tracking.html\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://mlflow.org/docs/latest/projects.html\" target=\"_blank\" rel=\"noopener\"\u003ehttps://mlflow.org/docs/latest/projects.html\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/mlflow/mlflow\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/mlflow/mlflow\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/chenhuipin1173/article/details/100913909\" target=\"_blank\" rel=\"noopener\"\u003ehttps://blog.csdn.net/chenhuipin1173/article/details/100913909\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://my.oschina.net/u/2306127/blog/1825638\" target=\"_blank\" rel=\"noopener\"\u003ehttps://my.oschina.net/u/2306127/blog/1825638\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.zhihu.com/question/280162556\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.zhihu.com/question/280162556\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"MLFlow"},{"content":"Trick：Hard Task 思路来源于Meta-Tranfer-Learning，基本思路是在Meta-Learning的每一次Meta-Test的时候，会从预训练错误率比较高的Task中再次采样，增加那些task的训练次数。也就是难题多做的策略。\n基本思路 对比Adaboost 这样的思路其实和AdaBoost的想法是有一定的异曲同工之妙的，或者说其实就是AdaBoost的思路：\nAdaboost\n参考笔记 ，从该笔记中我们可以看到，AdaBoost的基本思路如下：\nBoosting算法的工作机制是首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。然后基于调整权重后的训练集来训练弱学习器2.，如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过集合策略进行整合，得到最终的强学习器.\n和Meta-Transfer-Learning对比一下，我们可以发现，这个方法实际上就是讲Transfer Learning的与训练网络当成弱学习器1，然后通过弱学习器1的训练样本权重，来增大Hard-Task的配比（也就是增加任务的权重）完全一致。\n具体实现 实现上主要是，样本sample的过程，就是如何在进行参数选择后和原本的Dataloader，结合起来。在这里我们主要参考MTL中的方法，进行网络的构建处理。\n第一部分：sampler构建，为了后续Dataloader中进行数据的采样，需要构建一个这样的sampler，关键在于index的对应关系，以及最后输出的是index的集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import torch import numpy as np # 注意的点，我们需要确定我们batch数目，cls数目和每次每个cls选出多少个数据per # 紧接着定义一个sample，sample输出的是对应原dataset中的数据的index， class CatagoriesSampler(): def __init__(self, label, n_batch, n_cls, n_per): self.n_batch = n_batch self.n_cls = n_cls self.n_per = n_per label = np.array(label) # 根据不同的label输入情况，我们可可能需要找到每个label对应的样本的index，将其整合在一起。如下（option） self.m_idx = [] for i in range(max(label)+1): idx = np.argwhere(label==i).reshape(-1) idx = torch.from_numpy(idx) self.m_idx.append(idx) def __len__(self): # 要注意一下这里数据的长度是根据我们要输出的batch数目决定的 return self.n_batch def __iter__(self): # 直接定义每次采样的时候的batch输出 for i_batch in range(self.n_batch): batch = [] classes = torch.randperm(len(self.m_idx))[:self.n_cls] for c in classes: # 随机选择出的类标签 l = self.m_idx[c] # 随机选择样本 random_pos = torch.randperm(len(l))[:self.n_per] batch.append(l[random_pos]) # stack t and reshape的作用👇 # stack 变成n_cls * n_per , t转置，reshape（-1）变成行向量 batch = torch.stack(batch).t().reshape(-1) yield batch 第二部分：直接调用部分\n其实就是很简单的Dataloader中就有这个参数设置，只需要定义好sampler就没什么太大的问题了。\n1 2 3 4 5 6 7 8 self.trainset = Dataset(\u0026#39;train\u0026#39;, self.args) self.train_sampler = CategoriesSampler( self.trainset.label,self.args.num_batch, self.args.way, self.args.shot+self.args.train_query) self.train_loader = DataLoader( dataset=self.trainset,batch_sampler=self.train_sampler, num_workers=8, pin_memory=True) # 关键的地方在于最后一样的batch_sampler，这个在pytorch的dataload文档中分析过，就是每次会按这个规则在这里采样数据出来，一起训练。 第三部分：Hard-Task的选取\n以什么形式或者标准来对Hard-Task进行选择，以及构建这个label list，因为我们知道，很多时候dataloader是不输出index的。\n本文作者tmd直接偷懒，直接用数据集的label，也就是根本就不是Hard-Task的处理\n","permalink":"https://hugotest-phi.vercel.app/posts/hardtask/","summary":"\u003ch1 id=\"trickhard-task\"\u003eTrick：Hard Task\u003c/h1\u003e\n\u003cp\u003e思路来源于Meta-Tranfer-Learning，基本思路是在Meta-Learning的每一次Meta-Test的时候，会从预训练错误率比较高的Task中再次采样，增加那些task的训练次数。也就是难题多做的策略。\u003c/p\u003e\n\u003ch2 id=\"基本思路\"\u003e基本思路\u003c/h2\u003e\n\u003ch3 id=\"对比adaboost\"\u003e对比Adaboost\u003c/h3\u003e\n\u003cp\u003e这样的思路其实和AdaBoost的想法是有一定的异曲同工之妙的，或者说其实就是AdaBoost的思路：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAdaboost\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/39972832\" target=\"_blank\" rel=\"noopener\"\u003e参考笔记\u003c/a\u003e\n，从该笔记中我们可以看到，AdaBoost的基本思路如下：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eBoosting算法的工作机制是首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来\u003cstrong\u003e更新训练样本的权重\u003c/strong\u003e，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些\u003cstrong\u003e误差率高的点\u003c/strong\u003e在后面的弱学习器2中\u003cstrong\u003e得到更多的重视\u003c/strong\u003e。然后基于调整权重后的训练集来训练弱学习器2.，如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过集合策略进行整合，得到最终的强学习器.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e和Meta-Transfer-Learning对比一下，我们可以发现，这个方法实际上就是讲Transfer Learning的与训练网络当成弱学习器1，然后通过弱学习器1的训练样本权重，来增大Hard-Task的配比（也就是增加任务的权重）完全一致。\u003c/p\u003e\n\u003ch3 id=\"具体实现\"\u003e具体实现\u003c/h3\u003e\n\u003cp\u003e实现上主要是，样本sample的过程，就是如何在进行参数选择后和原本的Dataloader，结合起来。在这里我们主要参考MTL中的方法，进行网络的构建处理。\u003c/p\u003e\n\u003cp\u003e第一部分：\u003cstrong\u003esampler构建\u003c/strong\u003e，为了后续Dataloader中进行数据的采样，需要构建一个这样的sampler，关键在于index的对应关系，以及最后输出的是index的集合。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e37\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003etorch\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003enumpy\u003c/span\u003e \u003cspan class=\"k\"\u003eas\u003c/span\u003e \u003cspan class=\"nn\"\u003enp\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 注意的点，我们需要确定我们batch数目，cls数目和每次每个cls选出多少个数据per\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 紧接着定义一个sample，sample输出的是对应原dataset中的数据的index，\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eCatagoriesSampler\u003c/span\u003e\u003cspan class=\"p\"\u003e():\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__init__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elabel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en_batch\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en_cls\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en_per\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003en_batch\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003en_batch\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003en_cls\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003en_cls\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003en_per\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003en_per\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003elabel\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enp\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003earray\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elabel\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# 根据不同的label输入情况，我们可可能需要找到每个label对应的样本的index，将其整合在一起。如下（option）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003em_idx\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elabel\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eidx\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enp\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eargwhere\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elabel\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereshape\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eidx\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efrom_numpy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eidx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003em_idx\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eidx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__len__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# 要注意一下这里数据的长度是根据我们要输出的batch数目决定的\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003en_batch\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__iter__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# 直接定义每次采样的时候的batch输出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ei_batch\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003en_batch\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ebatch\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eclasses\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erandperm\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003em_idx\u003c/span\u003e\u003cspan class=\"p\"\u003e))[:\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003en_cls\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eclasses\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e# 随机选择出的类标签\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003el\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003em_idx\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e# 随机选择样本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003erandom_pos\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erandperm\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el\u003c/span\u003e\u003cspan class=\"p\"\u003e))[:\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003en_per\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003ebatch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003erandom_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# stack t and reshape的作用👇\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# stack 变成n_cls * n_per , t转置，reshape（-1）变成行向量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ebatch\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etorch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003estack\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebatch\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereshape\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eyield\u003c/span\u003e \u003cspan class=\"n\"\u003ebatch\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e第二部分：直接调用部分\u003c/p\u003e","title":"Hard Task Sampling"},{"content":"How to Train Really Large Models on Many GPUs? (lilianweng.github.io) 对于浮点运算，模型参数的存储和中间计算输出（梯度和优化器状态）的存储的在 GPU 内存上的大量需求使得我们需要并行化，下面我们参考一些常用的并行化范式：\n数据并行策略： 在Multi-GPUs上Duplicate模型，然后分别feed数据，进行运算，每个batch同步或者异步的进行多卡间的梯度传递和模型同步。\n同步可能会导致每个batch需要停止训练，异步则是可能会使用陈旧的梯度进行一段时间的训练，增加了计算时间。\n而在PT1.5以来，使用一种中间的方式：每隔x次迭代，进行多卡间的全局同步梯度一次，使用这种梯度积累的策略，根据计算图来进行计算和通信调度的优化，提高吞吐量。\n模型并行范式： 是为了解决单模型过大无法存储在单一的Node上的问题，但是这样会有GPU间的顺序依赖，虽然减少了内存的占用和计算量，但是这种IO的需求导致计算资源的利用率严重不足。\n在这种pipeline中，就存在利用率的bubble，也就是空白的部分\nPipeline并行策略： 混合模型和数据并行的策略，来减少低效时间的泡沫，也就是，将一个batch切分成多个小batch，然后分发到每个node上，减少相应的等待时间，只要我们对计算量和运行速度有合理的把握，就能极大的降低这个inefficient time bubbles. 多个mini-batch的梯度聚集起来最后同步更新. 最有情况下甚至可以忽略气泡的开销\n$$ 1- \\frac{2md}{(2m+2(d-1))d} = \\frac{d-1}{m+d-1}\r$$\rm个mini-batch和d个分布, bubble的比例将如上述所示\n这种方式能实现吞吐量和设备数量的几乎线性加速, 但是如果参数模型不能均匀的分布的话, 她并不总是能保证.\npipedream下面的这种方法, 虽然没有在最后进行全局的梯度同步, 可能会有之前提到的异步并行的问题, 使用不同的模型权重, 但作者也提出了一些相应的解决方案, 包括权重存储和垂直同步等等方法.\n详细的需要的时候对原文进行参考.\n后续还有两个对其的不同设置的改进 *PipeDream-flush* | *PipeDream-2BW*\nTensor并行范式 前面都是纵向的对模型进行切割, Tensor并行是横向的对Tenosr以及相应的矩阵运算进行切割.\nMixture of Experts 结合弱监督学习器来得到一个强学习器, 采用一个专家门控机制来实现, 用一个门控网络G来学习n个专家的概率分布, 将网络的流量导向对应的专家\nOther Memory Saving Designs CPU offloading: 异步的将一些GPU存不下的放到cpu上, 但以不影响Training Process为基准 Mixed Precision Training: 混合精度训练, 实际上应该就是APEX采用的策略. ","permalink":"https://hugotest-phi.vercel.app/posts/%E5%B9%B6%E8%A1%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E7%90%86%E8%A7%A3/","summary":"\u003cp\u003e\u003ca href=\"https://lilianweng.github.io/lil-log/2021/09/24/train-large-neural-networks.html\" target=\"_blank\" rel=\"noopener\"\u003eHow to Train Really Large Models on Many GPUs? (lilianweng.github.io)\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e对于浮点运算，模型参数的存储和中间计算输出（梯度和优化器状态）的存储的在 GPU 内存上的大量需求使得我们需要并行化，下面我们参考一些常用的并行化范式：\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"数据并行策略\"\u003e\u003cstrong\u003e数据并行\u003c/strong\u003e策略：\u003c/h2\u003e\n\u003cp\u003e在Multi-GPUs上Duplicate模型，然后分别feed数据，进行运算，每个batch同步或者异步的进行多卡间的梯度传递和模型同步。\u003c/p\u003e\n\u003cp\u003e同步可能会导致每个batch需要停止训练，异步则是可能会使用陈旧的梯度进行一段时间的训练，增加了计算时间。\u003c/p\u003e\n\u003cp\u003e而在PT1.5以来，使用一种中间的方式：每隔x次迭代，进行多卡间的全局同步梯度一次，使用这种梯度积累的策略，根据计算图来进行计算和通信调度的优化，提高吞吐量。\u003c/p\u003e\n\u003ch2 id=\"模型并行范式\"\u003e\u003cstrong\u003e模型并行\u003c/strong\u003e范式：\u003c/h2\u003e\n\u003cp\u003e是为了解决单模型过大无法存储在单一的Node上的问题，但是这样会有GPU间的顺序依赖，虽然减少了内存的占用和计算量，但是这种IO的需求导致计算资源的利用率严重不足。\u003c/p\u003e\n\u003cp\u003e在这种pipeline中，就存在利用率的bubble，也就是空白的部分\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211111171158.png\"\u003e\r\n    \u003cimg alt=\"image-20211111165251900\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211111171158.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211111171158.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20211111165251900\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"pipeline并行策略\"\u003e\u003cstrong\u003ePipeline并行\u003c/strong\u003e策略：\u003c/h2\u003e\n\u003cp\u003e混合模型和数据并行的策略，来减少低效时间的泡沫，也就是，将一个batch切分成多个小batch，然后分发到每个node上，减少相应的等待时间，只要我们对计算量和运行速度有合理的把握，就能极大的降低这个inefficient time bubbles. 多个mini-batch的梯度聚集起来最后同步更新. 最有情况下甚至可以忽略气泡的开销\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\n1- \\frac{2md}{(2m+2(d-1))d} = \\frac{d-1}{m+d-1}\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003em个mini-batch和d个分布, bubble的比例将如上述所示\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211111170038.png\"\u003e\r\n    \u003cimg alt=\"image-20211111170037307\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211111170038.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211111170038.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20211111170037307\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"并行训练"},{"content":"@Author： MSRA Zhenda Xie @Source：Arxiv ， Code TBP ，Blog_CVer @Read：AikenHong 2021.11.22\n“What I cannot create, I do not understand.” — Richard Feynman\nIntro \u0026amp; Simple Conclusion Conclusion 继MAE和iBoT之后，MSRA也提出了一个图像掩码建模的新框架，SimMIM，该方法简化了最近这些提出的方法，不需要特殊设计，作者也验证了不需要那些特殊设计就已经能让模型展现出优秀的学习能力\n采用中等大小的掩码块（32），对输入图像进行随机掩码，能使其成为强大的代理任务（pretext task） 直接回归预测原始像素的RGB值的效果并不比复杂设计的Patch分类方法差 Projector Head可以是轻量的Linear Layer，效果并不一定比MLP（多层）的差 Motivation 通过这种MIM方法可以实现在大量无标注的数据上得到一个表征能力up的通用特征模型，这种方式的backbone可以广泛的应用到图像上的各种子任务中（按照NLP）的经验来说，而为了类似的方式在图像上的大放异彩，我们首先需要分析Vision和Language的不同\n图像有更强的局部关系：相互靠近的像素是高度相关和近似的，我们可以通过简单的copy padding复制一部分缺失 视觉信号是原始，低层次的，而文本分词是高级概念：对低层次信号的预测是否对高层次的视觉识别任务有用呢？ 视觉信号是连续的，而文本的分词是离散的： 如何基于分类的掩码语言建模方法来处理连续的视觉信号 Theoretical Design 掩码选择：同样的掩码的策略还是基于Patch进行的，对于掩码的设计来说，太大的掩码快或者太密集的掩码快，可能会导致找不到附近的像素来预测，实验证明32是一个具有竞争力的size，和文本任务的信息冗余程度不同也带来了覆盖比的选择，NLP通常是0.15，而在V中，32size可以支持0.1-0.7的覆盖率。\n任务选择：使用原始像素的回归任务，因为回归任务和具有有序性的视觉信号的连续性很好的吻合。\n预测头选择：使用轻量的预测头如（linear），迁移性能与繁琐的预测头相似或者略好，同时训练上更加的块。虽然较大的头或更高的分辨率通常会导致更强的生成能力，但这种更强的能力不一定有利于下游的微调任务。\nStructure Design SimMIM方法就是掩码表示学习，实际上就是掩码图像然后预测原始信号，主要的组成部分、\nMasking Strategy，选择图像掩码掩码区域，并实现掩码，将掩码后的图像作为图像的模型输入 Encoder Architecture， 提取特征表示，用来预测原始信号，主要采用vanilla VIT和Swin Transformer Prediction Head，用于预测潜在的特征表示，表示掩码区域中的原始信号 Prediction target，定义了要预测的原始信号的形式，可以是原始像素值也有可以是元素像素变换。同时定义了损失：分类ce，回归l1，l2 Masking 使用可学习的mask token vector代替每个掩码区域，这个token向量的维度和其他的可见patch，经过patch embedding后的维数相同，主要测试了以下的几种策略：\nProjector Head 形式和大小任意，只要输入和编码器的输入是一致的，其输出达到预期目标即可，只是本文的作者证明了预测头可以做成轻量的单层线性层。\n也测试过2layers-MLP，inverse Swin-T/B\nProjector Targets 原始像素之回归，一般情况下视觉框架生成下采样分辨率的特征图，ViT为16*其他架构为32*\n为了预测输入图像全分辨率下的所有像素值，\n将feature map中的每个特征向量映射回原始分辨率，并让该向量负责相应的原始像素的预测\n例如，对于Swin Transformer编码器生成的32×下采样的feature map，作者使用输出维数为3072 = 32×32×3的1×1卷积(线性)层来表示32×32像素的RGB值。对原始图像分别进行{32×， 16×， 8×， 4×， 2×}下采样，考虑分辨率较低的目标。\n在掩码像素上使用L1-Loss， 可以使用其他的预测目标：\nColor clustering. 在iGPT中，利用大量自然图像，通过k-means将RGB值分成512个簇。然后每个像素被分配到最近的簇中心。这种方法需要一个额外的聚类步骤来生成9位调色板。在实验中，作者使用了在iGPT中学习到的512簇中心。 Vision tokenization. 在BEiT中，采用离散VAE (dVAE)网络将图像patch转换为dVAE tokens。token可用作为分类目标。在这种方法中，需要预训练一个额外的dVAE网络。 Channel-wise bin color discretization. 将R、G、B通道分别进行分类，每个通道离散为相同的bins，例如实验中使用的8和256 bins。在· ","permalink":"https://hugotest-phi.vercel.app/posts/mim-v-simmim/","summary":"\u003cp\u003e@Author： MSRA Zhenda Xie\n@Source：\u003ca href=\"arxiv.org/abs/2111.09886\"\u003eArxiv\u003c/a\u003e\n， \u003ca href=\"https://github.com/microsoft/SimMIM\" target=\"_blank\" rel=\"noopener\"\u003eCode TBP\u003c/a\u003e\n，\u003ca href=\"https://mp.weixin.qq.com/s/4YVYM9lPYghtZFhyOGnERw\" target=\"_blank\" rel=\"noopener\"\u003eBlog_CVer\u003c/a\u003e\n\n@Read：AikenHong 2021.11.22\u003c/p\u003e\n\u003cp\u003e“What I cannot create, I do not understand.” — Richard Feynman\u003c/p\u003e\n\u003ch2 id=\"intro--simple-conclusion\"\u003eIntro \u0026amp; Simple Conclusion\u003c/h2\u003e\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\u003cp\u003e继MAE和iBoT之后，MSRA也提出了一个图像掩码建模的新框架，SimMIM，该方法简化了最近这些提出的方法，不需要特殊设计，作者也验证了不需要那些特殊设计就已经能让模型展现出优秀的学习能力\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e采用中等大小的掩码块（32），对输入图像进行随机掩码，能使其成为强大的代理任务（pretext task）\u003c/li\u003e\n\u003cli\u003e直接回归预测原始像素的RGB值的效果并不比复杂设计的Patch分类方法差\u003c/li\u003e\n\u003cli\u003eProjector Head可以是轻量的Linear Layer，效果并不一定比MLP（多层）的差\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"motivation\"\u003eMotivation\u003c/h3\u003e\n\u003cp\u003e通过这种MIM方法可以实现在大量无标注的数据上得到一个表征能力up的通用特征模型，这种方式的backbone可以广泛的应用到图像上的各种子任务中（按照NLP）的经验来说，而为了类似的方式在图像上的大放异彩，我们首先需要分析Vision和Language的不同\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e图像有更强的局部关系\u003c/strong\u003e：相互靠近的像素是高度相关和近似的，我们可以通过简单的copy padding复制一部分缺失\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e视觉信号是原始，低层次的，而文本分词是高级概念\u003c/strong\u003e：对低层次信号的预测是否对高层次的视觉识别任务有用呢？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e视觉信号是连续的，而文本的分词是离散的\u003c/strong\u003e： 如何基于分类的掩码语言建模方法来处理连续的视觉信号\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"theoretical-design\"\u003eTheoretical Design\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e掩码选择\u003c/strong\u003e：同样的掩码的策略还是基于Patch进行的，对于掩码的设计来说，太大的掩码快或者太密集的掩码快，可能会导致找不到附近的像素来预测，实验证明32是一个具有竞争力的size，和文本任务的信息冗余程度不同也带来了覆盖比的选择，NLP通常是0.15，而在V中，32size可以支持0.1-0.7的覆盖率。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e任务选择\u003c/strong\u003e：使用原始像素的回归任务，因为回归任务和具有有序性的视觉信号的连续性很好的吻合。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e预测头选择\u003c/strong\u003e：使用轻量的预测头如（linear），迁移性能与繁琐的预测头相似或者略好，同时训练上更加的块。虽\u003cstrong\u003e然较大的头或更高的分辨率通常会导致更强的生成能力，但这种更强的能力不一定有利于下游的微调任务\u003c/strong\u003e。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211123104311\"\u003e\r\n    \u003cimg alt=\"图片\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211123104311\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211123104311\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"图片\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"MIM-V-simMIM"},{"content":"@aikenhong 2021\nReferences For Transformer:\nNLP The Transformer Family (lilianweng.github.io) VIT Transformer眼中世界 VS CNN眼中世界 李沐 NLP Transformer论文精读 Suveys cver1 ， cver2 ，cver3 This blog will divided into several part : lil\u0026rsquo;s blog, the survey for ViT, we using those article to help us understand the transformer.\n综述我们以最新的一篇为准进行阅读，其他的可能后续进行查缺补漏把，如无必要，勿增烦恼。\nIntro导言 主要参考文章2来进行我们简单的导入\n基本问题 Transformer原本是NLP中的重要模型, 作为LSTM的后继者, 用于处理Seq2Seq的数据类型和情景, 若是要将Transformer运用到Vision的领域中, 首要的问题就是如何:\n将Image作为序列化的Token输入Transform中 , 而达成这个目的主要有三种典型的方法:\n像素点作为token, 使用VAE离散化图片作为token再输入 ViT: 将图片切为一个个Patch在经过线性的projector之后组成一个embedding表示进行交互 CNN的异同分析 差异分析和计算主要靠CKA向量相似度计算来计算模型和表征之间的差异，这里的理论分析暂且不赘述，后续有需求的话可参考论文Similarity of neural network representations revisited或当前文章.\nViT的深浅特征高度相似, 而CNN则是层次化的存在表征区别.\n我想这和网络的结构之间有很大的关系, 序列化的结构和层次化的结构之间存在的差别.\nViT最后输出使用的是CLS token, 而CNN最终的Global Pooling导致Vi T的顶层特征是独特的, 与CNN的深浅都不匹配\nViT 模型，在底层就已经是局部和全局信息都混在一起了，而上层则基本都是全局信息。和 ResNet 差别在于，因为 CNN 本身特性，底层只利用局部信息。\n此外，当用少量数据训练 ViT 的时候，发现底层的头是学习不到局部信息的。\n而这也导致了模型性能不是很好，所以视觉模型需要表现好，底层一般都需要学习到局部信息，这也是符合解剖学里面人类视觉神经结构的。\n最后一层的空间信息的学习和Pooling有关, 导致了ViT中有更多空间信息.\nAttention Is All You Need 李沐 实际上《Attention is All You Need》就是NLP的Transformer的祖宗，这一篇论文已经反反复复的度过很多次了, 所以这一部分主要用来做查缺补漏。\n","permalink":"https://hugotest-phi.vercel.app/posts/transformer/","summary":"\u003cp\u003e@aikenhong 2021\u003c/p\u003e\n\u003cp\u003eReferences For Transformer:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eNLP \u003ca href=\"https://lilianweng.github.io/lil-log/2020/04/07/the-transformer-family.html\" target=\"_blank\" rel=\"noopener\"\u003eThe Transformer Family (lilianweng.github.io)\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003eVIT \u003ca href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODExNDA2MA==\u0026amp;mid=2449941486\u0026amp;idx=1\u0026amp;sn=336a47a31f4b4ff0f6cd8e2fc3cb184a\u0026amp;chksm=b13c258d864bac9b32d10ec36a058d77cc7cf90e066e76ae476fd2fde1b54256cd608a559bb6\u0026amp;mpshare=1\u0026amp;scene=23\u0026amp;srcid=1101rcBaNzO4pu00PCPsJOAl\u0026amp;sharer_sharetime=1635744838591\u0026amp;sharer_shareid=ec299f1c891fc72cd699f8eaeb8a0cd5#rd\" target=\"_blank\" rel=\"noopener\"\u003eTransformer眼中世界 VS CNN眼中世界\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e李沐 NLP \u003ca href=\"https://www.bilibili.com/video/BV1pu411o7BE?spm_id_from=333.999.0.0\" target=\"_blank\" rel=\"noopener\"\u003eTransformer论文精读\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003eSuveys \u003ca href=\"https://mp.weixin.qq.com/s?__biz=MzUxNjcxMjQxNg==\u0026amp;mid=2247514162\u0026amp;idx=2\u0026amp;sn=d094eecbfd91ca1e478c41e29f2b98d5\u0026amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\"\u003ecver1\u003c/a\u003e\n， \u003ca href=\"https://mp.weixin.qq.com/s?__biz=MzUxNjcxMjQxNg==\u0026amp;mid=2247514982\u0026amp;idx=2\u0026amp;sn=7e38021234b7ab5455429e4485128efd\u0026amp;chksm=f9a1c9e9ced640ff045d1c4fe9d4e98a785602d980b25df4fa18477dd2b4b829ed4fc3fd028f\u0026amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\"\u003ecver2\u003c/a\u003e\n，\u003ca href=\"https://mp.weixin.qq.com/s/_th7rXfZDuSu2xo7gdPp0w\" target=\"_blank\" rel=\"noopener\"\u003ecver3\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis blog will divided into several part : lil\u0026rsquo;s blog, the survey for ViT, we using those article to help us understand the transformer.\u003c/p\u003e\n\u003cp\u003e综述我们以最新的一篇为准进行阅读，其他的可能后续进行查缺补漏把，如无必要，勿增烦恼。\u003c/p\u003e\n\u003ch2 id=\"intro导言\"\u003eIntro导言\u003c/h2\u003e\n\u003cp\u003e主要参考文章2来进行我们简单的导入\u003c/p\u003e\n\u003ch3 id=\"基本问题\"\u003e基本问题\u003c/h3\u003e\n\u003cp\u003eTransformer原本是NLP中的重要模型, 作为LSTM的后继者, 用于处理Seq2Seq的数据类型和情景, 若是要将Transformer运用到Vision的领域中, 首要的问题就是如何:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e将Image作为序列化的Token输入Transform中\u003c/strong\u003e , 而达成这个目的主要有三种典型的方法:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e像素点作为token,\u003c/li\u003e\n\u003cli\u003e使用VAE离散化图片作为token再输入\u003c/li\u003e\n\u003cli\u003eViT: 将图片切为一个个\u003ccode\u003ePatch\u003c/code\u003e在经过线性的\u003ccode\u003eprojector\u003c/code\u003e之后组成一个\u003ccode\u003eembedding\u003c/code\u003e表示进行交互\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211120010516\"\u003e\r\n    \u003cimg alt=\"图片\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211120010516\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211120010516\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"图片\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Transformer"},{"content":"@Read: AikenHong 2021\n@Author: https://arxiv.org/abs/2111.07832 @解读：Machine Heart 基本思想 基于NLP中的MLM(Masked Language Model)的核心训练目标: 也就是遮住文本的一部分, 然后通过模型去预测和补全, 这一过程是模型学到泛化的特征, 使用这种方法来进行大规模的与训练范式.\n在基本的思想上和MAE采用的是一样的设计, 但是本文中坐着认为visual tokenizer的设计才是其中的关键.\n不同于 NLP 中 tokenization 通过离线的词频分析即可将语料编码为含高语义的分词，图像 patch 是连续分布的且存在大量冗余的底层细节信息。而作者认为一个能够提取图像 patch 中高层语义的 tokenizer 可帮助模型避免学习到冗余的这些细节信息。作者认为视觉的 tokenizer 应该具备两个属性：（a）具备完整表征连续图像内容的能力；(b) 像 NLP 中的 tokenizer 一样具备高层语义。\n文中对tokenizer的设计为一个知识蒸馏的过程:\n文中使用这种在线tokenizer同时来监督这样的MIM过程, 也就是两部分协同学习, 能够较好的保证语义的同时并将图像内容转化为连续的特征分布, 具体的, tokenizer和目标网络狗狗想网络结构, 有移动平均来得到实际的tokenizer.\n该形式近期在 DINO [3]中以自蒸馏被提出，并被用以针对同一张图片的两个不同视野在 [CLS] 标签上的优化：\n$$ L_{CLS} = - P_{\\theta^`}^{[CLS]}(v)^T logP_{\\theta}^{[CLS]}(\\mu)\r$$\r在该损失函数的基础上, MIM同样也是用这种自蒸馏的方式去优化, 其中在线tokenizer的参数为目标网络历史参数的平均.\n$$ L_{MIM} = - \\sum_{i=1}^Nm_i *P_{\\theta^`}^{patch}(\\mu_i)^TlogP_{\\theta}^{patch}(\\hat{\\mu}_i)\r$$\r基于上述的这些训练目标，提出了一种自监督预训练框架iBOT， 同时优化两种损失函数。\n其中，在 [CLS] 标签上的自蒸馏保证了在线 tokenizer 学习到高语义特征，并将该语义迁移到 MIM 的优化过程中；而在 patch 标签上的自蒸馏则将在线 tokenizer 表征的 patch 连续分布作为目标监督 masked patch 的复原。该方法在保证模型学习到高语义特征的同时，通过 MIM 显式建模了图片的内部结构。同时，在线 tokenizer 与 MIM 目标可以一起端到端地学习，无需额外的 tokenizer 训练阶段。\n预训练时采用孪生网络结构，其中在线 tokenizer 可以看作教师分支的一部分。教师、学生两分支包括结构相同的 backbone 网络和 projection 网络。作者广泛验证了 iBOT 方法搭配不同的 Transformers 作为 backbone，如 Vision Transformers（ViT-S/16, ViT-B/16, ViT-L/16）及 Swin Transformers（Swin-T/7, Swin-T/14）。作者发现共享 [CLS] 标签与 patch 标签的 projection 网络能够有效提升模型在下游任务上的迁移性能。作者还采用了随机 MIM 的训练机制，对每张图片而言，以 0.5 的概率不进行 mask，以 0.5 的概率从 [0.1, 0.5] 区间随机选取一个比例进行 mask。实验表明随机 MIM 的机制对于使用了 multi-crop 数据增强的 iBOT 非常关键。\n","permalink":"https://hugotest-phi.vercel.app/posts/mim-v-ibot/","summary":"\u003cp\u003e@Read: AikenHong 2021\u003c/p\u003e\n\u003cp\u003e@Author: \u003ca href=\"https://arxiv.org/abs/2111.07832\" target=\"_blank\" rel=\"noopener\"\u003ehttps://arxiv.org/abs/2111.07832\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e@解读：\u003ca href=\"https://mp.weixin.qq.com/s/x4yEfg9eqW6x3Ehxm1HkRA\" target=\"_blank\" rel=\"noopener\"\u003eMachine Heart\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"基本思想\"\u003e基本思想\u003c/h2\u003e\n\u003cp\u003e基于NLP中的MLM(Masked Language Model)的核心训练目标: 也就是遮住文本的一部分, 然后通过模型去预测和补全, 这一过程是模型学到泛化的特征, 使用这种方法来进行大规模的与训练范式.\u003c/p\u003e\n\u003cp\u003e在基本的思想上和MAE采用的是一样的设计, 但是本文中坐着认为visual tokenizer的设计才是其中的关键.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e不同于 NLP 中 tokenization 通过离线的词频分析即可将语料编码为含高语义的分词，图像 patch 是连续分布的且存在大量冗余的底层细节信息。而作者认为一个能够提取图像 patch 中高层语义的 tokenizer 可帮助模型避免学习到冗余的这些细节信息。作者认为视觉的 tokenizer 应该具备两个属性：（a）具备完整表征连续图像内容的能力；(b) 像 NLP 中的 tokenizer 一样具备高层语义。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e文中对tokenizer的设计为一个知识蒸馏的过程:\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211118151616.png\"\u003e\r\n    \u003cimg alt=\"image-20211118151613545\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211118151616.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211118151616.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20211118151613545\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e文中使用这种在线tokenizer同时来监督这样的MIM过程, 也就是两部分协同学习, 能够较好的保证语义的同时并将图像内容转化为连续的特征分布, 具体的, tokenizer和目标网络狗狗想网络结构, 有移动平均来得到实际的tokenizer.\u003c/p\u003e","title":"MIM-V-iBOT"},{"content":"@Author：Facebook AI Research-Kaiming He Kaiming-MAE Conclusion 总而言之这是一种大模型的训练方法, 通过在少量数据的基础上实现大模型的训练.\n整体的架构上是参考了NLP中的AutoEncoder机制，将原图切分patch，用mask掩盖原图，通过少量可见的Patch进行Encoder后和Mask融合，再通过非对称的Decoder进行pixel的还原。\n这种设计的有点在于mask的scala是可变的，同时这种mask能减少我们训练过程中对显存和计算复杂度的损耗，同时问题本身是一个比较复杂的问题，得以训练复杂的大模型，这种方式最终呈现的效果就是训练的效率高且效益好。\n体现了自监督学习在这方面的优越性，同时这种方法得以实现也是由于ViT模型对于CNN模型的取代，才使得这种序列化切块的方式容易实现和验证。\n这种方式在最终体现了自监督学习对于有监督与训练的优越性，使用这种方式能够更好的得到一个模型的通用表征。\n在这里论文中也说明了和NLP的不同点以及这样的模型对于decoder的要求实际上是比NLP更高的\nexperiment Masking：对于输入的图像进行均匀的切分并均匀的随机采样\nMAE encoder: 简单的ViT模型，对输入图像进行编码后和Mask进行混合得到一个完整的令牌集合，从而确保Decode能够得到对应的位置信息。\nMAE decoder：轻量级的架构，可以独立于编码器进行设计，我们使用更窄更浅的网络，计算量比编码器10%更小，这样能够更快的进行训练。解码器的最后一层是先行投影，输出的数量==补丁中像素值的数量，最后会resize层原图的维度。\n","permalink":"https://hugotest-phi.vercel.app/posts/mim-v-mae/","summary":"\u003cp\u003e@Author：Facebook AI Research-Kaiming He\n\u003ca href=\"https://zhuanlan.zhihu.com/p/432663453\" target=\"_blank\" rel=\"noopener\"\u003eKaiming-MAE\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003e总而言之这是一种大模型的训练方法, 通过在少量数据的基础上实现大模型的训练.\u003c/p\u003e\n\u003cp\u003e整体的架构上是参考了NLP中的AutoEncoder机制，将原图切分patch，用mask掩盖原图，通过少量可见的Patch进行Encoder后和Mask融合，再通过\u003cstrong\u003e非对称\u003c/strong\u003e的Decoder进行pixel的还原。\u003c/p\u003e\n\u003cp\u003e这种设计的有点在于mask的scala是可变的，同时这种mask能减少我们训练过程中对显存和计算复杂度的损耗，同时问题本身是一个比较复杂的问题，得以训练复杂的大模型，这种方式最终呈现的效果就是训练的效率高且效益好。\u003c/p\u003e\n\u003cp\u003e体现了自监督学习在这方面的优越性，同时这种方法得以实现也是由于ViT模型对于CNN模型的取代，才使得这种序列化切块的方式容易实现和验证。\u003c/p\u003e\n\u003cp\u003e这种方式在最终体现了自监督学习对于有监督与训练的优越性，使用这种方式能够更好的得到一个模型的通用表征。\u003c/p\u003e\n\u003cp\u003e在这里论文中也说明了和NLP的不同点以及这样的模型对于decoder的要求实际上是比NLP更高的\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211115113546.png\"\u003e\r\n    \u003cimg alt=\"image-20211115113542074\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211115113546.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20211115113546.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20211115113542074\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"experiment\"\u003eexperiment\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eMasking\u003c/strong\u003e：对于输入的图像进行均匀的切分并均匀的随机采样\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMAE encoder\u003c/strong\u003e: 简单的ViT模型，对输入图像进行编码后和Mask进行混合得到一个完整的令牌集合，从而确保Decode能够得到对应的位置信息。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMAE decoder\u003c/strong\u003e：轻量级的架构，可以独立于编码器进行设计，我们使用更窄更浅的网络，计算量比编码器10%更小，这样能够更快的进行训练。解码器的最后一层是先行投影，输出的数量==补丁中像素值的数量，最后会resize层原图的维度。\u003c/p\u003e","title":"MIM-V-MAE"},{"content":"@AikenHong2021 OWL\n分析现有的OWL特点，和当前自己的研究做一个区分，也汲取一下别人的研究的要点，\nReference arxiv @ self-supervised feature improve open-world learning arxiv @ open-world semi-supervised learning arxiv @ open-world learning without labels arxiv @ unseen class discovery in open-world classification arxiv @ Open-World Active Learning with Stacking Ensemble for Self-Driving Cars www @ open-world learning and application to product classification cvpr @ open world composition zero-shot learning cvpr @ Towards Open World Object Detection [cvpr](Large-Scale Long-Tailed Recognition in an Open World (thecvf.com) ) @ Large-Scale Long-Tailed Recognition in an Open World Conclusion Papers Mulit Open world Learning Definition\n拒绝未见过的类的实例，逐步学习新的类扩展现有模型\n:zap: Large-Scale Long-Tailed Recognition in an Open World Large-Scale Long-Tailed Recognition in an Open World (liuziwei7.github.io) Translation 这篇文章很可能作为后续我们比较的baseline，通过对这篇文章的数据和代码复用和同等环境下的处理，来进行算法优劣的比较。但是实际上该论文的定位和我们也并非完全相同，因为改论文将开放世界的类别识别为未知类，主要的问题是如何避免将未知类别分类到少样本类别中。\n我们希望将开放类作为新类别数据处理（Few-Shot），增加了Incremental的部分，这是他们论文中缺少的一部分，同时这篇论文的思路面向的任务是识别而不是分类，他们在识别上的信息实际上是更完善的，但是对于分类任务来说，如果不基于相应的标签先验，实际上容易带来问题。\n使用动态元嵌入的策略来结合两个部分处理尾部识别的鲁棒性：\n从输入图像计算得到直接特征（这一方面上FS的类别缺乏足够的监督） 视觉记忆相关的诱导特征（来源于基于memory的meta-learning），这种特征（visual-memory）具有直接的判别中心，学习一种方法从直接的特征中学到相关的记忆摘要，通过这种meta-embedding来处理尾部的类别。 我们的测试过程是否也可以看作管理一个Memory，通过对Memory的定时定量的Dynamic-Evaluation来做后续的Incremental Learning，通过这种策略来将整个框架整合起来，从最初的模型到后续的模型增量就能更好的结合在一起。\n这个方法主要是在进行分类的同时维护一个嵌入图，通过对应的距离关系来计算类别的质心，来做作为另一个角度的特征，然后讲特征整合后作为最终的特征依据\n:zap:Open-world Learning and Application to Product Classification 重点：该模型维护一组动态可见类，允许添加或删除新类，而无需重新训练模型。每个类由以小组训练示例表示，在测试中元分类器仅使用已维护的可见类，进行分类和拒绝。\n基于metric进行判别和分类\n实际上是一种prototype的方法，通过维护类别原型，使用metric的方法进行是否是已知类别的判断。\nRanker的作用是在每个已知类中抽取与一个测试样例的最近邻的k个已知类样例，然后将这些已知类的k个样例存入Meta-Classifier的Memory中。Meta-Classifier将测试样例与Memory中，经过Matching layer与Aggregation layer输出测试样例属于相应已知类的概率得分。\n本文最大的新颖之处在于，在解决开集识别问题时，采用meta-learning的思想，训练集、测试集、验证机中的类别完全不相交。这样做的好处是模型具备增量学习的能力，当源源不断的unknown样例进行测试时，完全不必重新训练模型，提供了open-set classification一种新的模式。\n:zap:TOWOO 整体思路类似，聚类方法，标记出感兴趣的类别，然后加入数据库\n1）将未识别的对象，识别为unknown\n2）在逐步接受相应的标签的时候逐步学习这些未知类别，而不会忘记旧的类别。\n使用contrastive cluster和energe-base的方法来对新类进行分类，主要的方法是通过将不确定的类别识别为未知类别。\n未知类别识别方法（energe-base）\n\u0026hellip;\nOpen World Compositional Zero-Shot Learning 假设搜索空间是先验已知的，也就是存在几种类别是已知的，但是我们训练集中是没有未知类别的，共享特征空间，通过类似A-softmax的方式做匹配分析，通过在已知类别中落入的位置来判断是我们认定的已知类别还是未知类别。\nOpen World Semi-Supervised Learning 开放世界半监督学习，使用一种同时分类和聚类数据的方法 ORCA：\n为了解决这个问题，本文提出了ORCA，一种学习同时分类和聚类数据的方法。ORCA将未标记数据集中的例子分类到以前见过的类中，或者通过将相似的例子组合在一起形成一个新的类。ORCA的关键思想是引入基于不确定性的自适应margin，有效地规避由可见类和新类/簇之间的方差不平衡引起的偏差。本文使用图像分类领域的三个常用数据集（CIFAR-10, CIFAR-100，ImageNet） 进行实验验证，结果表明，ORCA在已知类上的性能优于半监督方法，在新类上也优于新类发现方法。\nMethod\n实际上就是使用半监督SimClr的backbone然后通过设定好的位置类别数目的分类器去做训练，但是这里的损失防止对已知类的偏向性。可以参考文章中的损失\n基于对比学习方法SimCLR进行与训练\n已知类的分类头用于将未标记的例子分配给已知类，而激活附加的分类头允许ORCA发现新类别。我们假设新类的数量是已知的，并将其作为算法的输入，这是聚类和新类发现方法的典型假设。如果不知道新类的数量，这在现实环境中是经常发生的情况，可以从数据中估计出来。在这种情况下，如果头的数量太多，那么ORCA将不会分配任何例子给一些头，所以这些头将永远不会激活，因此ORCA将自动修剪类的数量。我们在实验中进一步解决了这个问题。\nrelated\n了解决这种开放世界的问题，目前有2种思路：(1) OOD检测：能够识别已知类的数据，并且能够将所有未知类的数据检测出来，标为\u0026quot;unknown\u0026quot;。这种方法很好的保证了系统鲁棒性，但是无法充分利用未知类数据进行业务扩展；(2) novel class discovery(零样本，领域自适应问题): 利用源域标记数据来学习更丰富的语义表示，然后将学到的知识迁移到目标域（包含新类别），对目标域数据进行聚类。这种方法不能准确识别出已知类，只是对目标域做了聚类。\nSelf-Supervised Features Improve Open World Learning 特征提取：使用自监督学习来做特征提取器的训练\n将新类发现作为特征空间中的位置标签，我们根据检测到的样本属于哪一个空间来做检测\n和我的想法还是蛮贴近的，总之也是把新类的标签放置到存储区中，赋予伪标签的过程，然后微调特征提取器，基于后续的数据添加分类器的权重\nUnseen Class Discovery in Open-World Classification 通过对已知类别的学习，分析已知类别之间的距离差异；\n本文的模型提出了一个contrasive模型，对实例属于同一类还是不同类进行分类，该子模型也可以作为聚类的距离函数.\n","permalink":"https://hugotest-phi.vercel.app/posts/owl-survey/","summary":"\u003cp\u003e@AikenHong2021 OWL\u003c/p\u003e\n\u003cp\u003e分析现有的OWL特点，和当前自己的研究做一个区分，也汲取一下别人的研究的要点，\u003c/p\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003earxiv @ \u003ca href=\"https://arxiv.org/pdf/2102.07848.pdf\" target=\"_blank\" rel=\"noopener\"\u003eself-supervised feature improve open-world learning\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/374268236\" target=\"_blank\" rel=\"noopener\"\u003earxiv\u003c/a\u003e\n @ \u003ca href=\"https://arxiv.org/pdf/2102.03526.pdf\" target=\"_blank\" rel=\"noopener\"\u003eopen-world semi-supervised learning\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003earxiv @ \u003ca href=\"https://arxiv.org/pdf/2011.12906.pdf\" target=\"_blank\" rel=\"noopener\"\u003eopen-world learning without labels\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003earxiv @ \u003ca href=\"https://arxiv.org/pdf/1801.05609.pdf\" target=\"_blank\" rel=\"noopener\"\u003eunseen class discovery in open-world classification\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003earxiv @ \u003ca href=\"https://arxiv.org/pdf/2109.06628.pdf\" target=\"_blank\" rel=\"noopener\"\u003eOpen-World Active Learning with Stacking Ensemble for Self-Driving Cars\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dl.acm.org/doi/pdf/10.1145/3308558.3313644\" target=\"_blank\" rel=\"noopener\"\u003ewww\u003c/a\u003e\n @ \u003ca href=\"https://blog.csdn.net/u011150266/article/details/118242627\" target=\"_blank\" rel=\"noopener\"\u003eopen-world learning and application to product classification\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003ecvpr @ \u003ca href=\"https://openaccess.thecvf.com/content/CVPR2021/papers/Mancini_Open_World_Compositional_Zero-Shot_Learning_CVPR_2021_paper.pdf\" target=\"_blank\" rel=\"noopener\"\u003eopen world composition zero-shot learning\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://arxiv.org/pdf/2103.02603.pdf\" target=\"_blank\" rel=\"noopener\"\u003ecvpr\u003c/a\u003e\n @ \u003ca href=\"https://zhuanlan.zhihu.com/p/356272271\" target=\"_blank\" rel=\"noopener\"\u003eTowards Open World Object Detection\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e[cvpr](\u003ca href=\"https://openaccess.thecvf.com/content_CVPR_2019/papers/Liu_Large-Scale_Long-Tailed_Recognition_in_an_Open_World_CVPR_2019_paper.pdf\" target=\"_blank\" rel=\"noopener\"\u003eLarge-Scale Long-Tailed Recognition in an Open World (thecvf.com)\u003c/a\u003e\n) @ \u003ca href=\"https://github.com/zhmiao/OpenLongTailRecognition-OLTR\" target=\"_blank\" rel=\"noopener\"\u003eLarge-Scale Long-Tailed Recognition in an Open World\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003ch2 id=\"papers\"\u003ePapers\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eMulit Open world Learning Definition\u003c/strong\u003e\u003c/p\u003e","title":"OWL-survey"},{"content":"Chapter 1 数据模型 Se1 magic method 数据模型在这里的定义是对python框架的描述,他规范了python构建模块的接口；这些接口对应解释器中对一些特殊句法(常用句法)的激活和使用.本章节的核心就在于对这些特殊句法的理解和使用. 特殊方法带来的一些主要交互场景:\n迭代 属性访问 集合类 函数和方法的调用 对象的创建和销毁 字符串的表示形式和格式化 上下文管理模块(with模块) 这些特殊方法的存在实际上，是为了让python的解释器调用，除非我们有大量的元编程，否则我们一般不调用他，通过内置的len等函数进行调用的话，他们的速度更快\n下面我们通过最典型的__getitem__和__len__对其有简单的介绍, 并介绍各个魔术方法的使用场景\nSe2 using it and show more 最常用也最典型的magic method 不外乎__getitem__和__len__;\nlen即对当前对象提供对于通用的len()方法的接口,通常用于查看对象的length or size getitem除了提供obj[index]的索引方式的同时, 他也会对python内置的那些迭代方法提供支持for i in range(b) 对于依托于这些迭代的方法也能够得以支持from random import choice 切片操作 Se2.1 overwrite operator 这一部分我们主要介绍如下的一些特殊方法,他们将实现+,*,abs,print,bool 对应的特殊方法可以从下面的代码中领会\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from math import hypot # hypot will calculate the eud-dis from 0-point(x,y) # we using vector as an example class Vector: def __init__(self, x=0, y=0): self.x = x self.y = y def __repr__(self): # this method -\u0026gt; print return \u0026#34;Vertor({},{})\u0026#34;.format(self.x, self.y) def __abs__(self): return hypot(self.x, self.y) def __add__(self, other:Vector): x = self.x + other.x y = self.y + other.y return Vector(x,y) def __mul__(self, scalar): return Vertor(self.x*scalar, self.y*scalar) def __bool__(self): return bool(self.x or self.y) 在这里需要注意的是,中缀运算符像add,mul的原则都是不改变操作对象,而是生成一个新的对象.\nse2.2 show more 这一部分我们会展示更多的一些特殊方法，对这些特殊方法的了解也方便我们对python中方法运行的一些掌握\n这些特殊方法的使用场景很容易从命名中可以得到一个基本的认知，像迭代，调用，集合等等的这些属性可能是相对常用的，要熟练进行掌握\n例如__str__ | __repr__的方法,就可以方便我们进行print和相应的调试输出.\n_iadd_ 对应的是+=的这种原地操作, 这个也是我们需要注意的\nChapter 2 数据结构 python的一个重要特点就在于多种数据结构上的操作通用性, 无论是字符串,列表,字节序列,XML元素,他们都公用一套丰富的操作.\n此外在python的函数中, 当我们对一个对象进行就地改动, 那他就应该返回None, 这样可以让调用者知道传入的参数发生了改变, 并未产生新的对象, 这种约定俗成的定义方法, 实际上是一种好的习惯.\n迭代, 切片, 排序, 拼接\n在这里我们还是要熟悉一下各种类型支持的一些操作, 在python中我们可以通过help(list)查看, 当然最好还是做一个简单的总结熟悉对应的数据结构的一些默认方法.\nse 1 序列构成的数组 se 1.1 类型概念 python标准库用C实现了丰富的序列类型, 列举如下.\n序列类型 具体类型 类型特点 容器序列 list, tuple, collections.deque 存放不同数据的类型 扁平序列 str, bytes, bytearray, memoryview, array.array 只能容纳一种类型 说明 上面是第一种分类情况, 下面会介绍另一种分类.\n具体的特点会在下面介绍 可变序列 list, bytearray, array.array, collections.deque, memoryview 支持增删改 不可变序列 tuple, str, bytes 不支持增删改 通过这些类别中共有和非公有的特性，我们对这些序列的不同概念进行理解。\nse 1.2 列表推导\u0026amp;生成器表达式 生成器表达式和列表推导式的区别 ，\nlist是python中重要的一个可变序列类型，列表推导式是我们构建列表的快捷方式，生成器表达式则是创建其他任何类型的序列。\n列表推导式：\n1 2 3 4 5 6 7 8 9 10 11 # 这种方式实际上相比于循环来说更加易读 symbols = “\u0026amp;*（@￥” unicode = [ord(symbol) for symbol in symbols] clothes = [(color, size) for color in colors for size in sizes] # 双层循环,写在里面的是外层循环 # 列表推导式 with conditions, 条件语句应该放在后面 res = [num(i) for i in range(10) if i \u0026gt;= 2] # filter和map 也能完成列表推导式做得到的事情，当然lambda也可以 # 具体的map和filter的定义在后面详细解读 unicode = list(filter(lambda c : c\u0026gt;127, map(ord, symbols))) 生成器表达式：\n首先理解生成器和推导式的区别，推导式是直接完成整体的构建，而生成器是逐步的餐厨我们需要的元素，需要几个就产生几个，使用yield方法进行创建，而生成器表达式可以在没有该表达式的情况下及时创建简化生成器。\n而在编写的时候和列表推导式的区别是，用()代替[]即可\n1 2 for tshirt in (\u0026#39;{} {}\u0026#39;.format(c,s) for c in colors for s in sizes): print(tshirt) 生成器会逐个产出元素而不会一次性生成，所以实际上这种方法更有内存效率\nse 1. 3 循环的本质 和迭代器有重要的关系，有iter方法都能进行迭代，我们可以用hasattr检查\n1 hasattr(str, \u0026#39;__iter__\u0026#39;) 循环的后台会发生如下的流程：\niter()将对象转换为迭代器对象 next()逐渐获取序列的下一个元素 stopiteration没有要调用的元素引发异常 se 1.4 tuple不止不可变 tuple的不可变属性更应该作为一个record这种信息载体来使用，他的这种不可变的特性，让他的position和对应的存储都显得有意义，我们可以通过_占位*解包等操作，来对我们的数据进行读取和管理。\n这里拆包的灵活使用是一个重点，用*ignore来跳过我们不需要的那些元素，也可以通过fmt来灵活的拆出嵌套元素\n1 2 3 4 5 6 7 8 9 10 metro_areas = [ (\u0026#39;Tokyo\u0026#39;, \u0026#39;JP\u0026#39;, 36, (x1, x2)), (\u0026#39;Tokyo\u0026#39;, \u0026#39;JP\u0026#39;, 36, (x1, x2)), (\u0026#39;Tokyo\u0026#39;, \u0026#39;JP\u0026#39;, 36, (x1, x2)) ] # 这种format的编写方式也值得我们学习 fmt = \u0026#39;{:15} | {:9.4f} | {:9.4f}\u0026#39; for name,cc,pop,(lati,longti) in metro_areas: if longtitude\u0026lt;=0: print(fmt.format(name,lati,longti)) 元组本身已经设计得不错, 但是作为记录来用的话, 我们通常需要给字段一个名称, nametuple就为我们解决这个问题:\ncollections.namedtuple用来构建一个带字段名的元组和一个有名字的类,这个有名字的类帮助我们调试.\n1 2 3 4 from collections import namedtuple contact = namedtuple(\u0026#39;contact\u0026#39;, key1, key2, key3) # first dimension is the typename aiken = contact(v1,v2,v3) 该collections.namedtuple除了元组的属性以外还行增了一些特性, 常用的有如下两个\n_fields 返回包含所有字段的元组\n_asdict() 将具名元组转换为collections.OrderedDict\n_make() 接受可迭代对象来生成类的一个实例, 也就是可以用*解包的方式来生成一个实例, 而这种方法在元组中是不可用的\n1 2 name_data = (v1,v2,v3) name = contact._make(*name_data) se 1 5 切片 这一块切片的设计逻辑讲的很好, 为何从零开始且不包括最后一个, 会为我们带来很多操作上和可读性上的便利, 具体看书.\nslice(start, stop, step)实现切片对象, 或者slice(stop)\n1 2 3 myslice = slice(1,5,2) arr = list(range(10)) print(arr[myslice]) 可以使用切片对象的方式能够将我们的切片规则参数化, 方便我们去设置和约定.\n省略号在python中的表示是..., 这种用来作为多维切片的时候可能会用到\n1 x[i, ...] = x[i, :, :, :] se 1.6 对序列使用+ * 序列使用*n的时候, 通常是建立一个新的对象, 但是如果序列中是对其他可变对象的引用的到时候, 实际上会得到n个引用结果.\n1 2 3 4 # 可以通过如下的代码测试 mylist = [[\u0026#39;_\u0026#39;]] * 3 mylist[1][2] = 0 # print [[\u0026#39;_\u0026#39;, \u0026#39;_\u0026#39;, 0], [\u0026#39;_\u0026#39;, \u0026#39;_\u0026#39;, 0], [\u0026#39;_\u0026#39;, \u0026#39;_\u0026#39;, 0]] python的传值类型大多数情况下都是reference assign, 有时候我们对这种对象进行赋值的时候, 我们需要使用深拷贝来进行值的拷贝.\n+=是否有_iadd_的实现, 有很大的区别, a+b对应的是实现一个新的对象的产生, 我们可以通过id来进行检查. 如果不断没有必要的产生新的对象的话, 会存在比较大的浪费.\nse 1.7 list.sort 和sorted list.sort 就地修改, 返回None sort(list) 新建一个列表作为返回值, 可接受任何形式的可迭代对象, 最终返回的都是列表. 函数有两个关键词reverse, key: 指定排序的标准.\n用bisect来管理已排序的序列: 主要有两个函数bisect和insort, 通过这两个函数使用二分查找法在有序序列中查找或插入元素.\nse 1.8 其他序列数据结构 列表虽然好用，但也不是万能的，再一些特定的情况下，有特定的数据结构能更好的支持对应的操作。\n如果我们要存放大量的数据，这种时候array的效率要高得多（存放的是机器翻译），而吐过我们频繁的进行先进先出的策略deque的速度应该更快； 同样，如果我们需要频繁的检查一个元素是否出现在一个集合中，要考虑使用set（无序）\n数组ARRAY： 如果我们只需要一个包含数字的列表，那么array.array会比list更加高效，同样他也支持所有可变序列相关的操作，pop,insert,extend,也提供共文件读取和存储的更快的操作：.frombytes, .tofild\narray在使用的过程中需要指定存储的类型码(具体使用的时候查阅): floats = array('d', (random() for i in range(10**7)))\n存取大数组到array的二进制文件比存储到文本文件中快60倍, 因为这种操作中避免了float函数的执行, 写入同样的也快7倍, 同时占用的空间更少.\n同样pickle处理浮点数组的方式几乎和array一样快, 且pickle可以处理各种各样的数字类型, 甚至简单的自定义类型, 是一个快速序列化数字类型的方法.\nmemoryview: 内存视图使得用户在不复制内容的情况下操作同一个数组的不同切片. 实际上是Numpy一些功能的简单实现\nnumpy \u0026amp; scipy: Numpy实现了多维同质数组和矩阵 Scipy是基于Numpy的科学计算库, 为线性代数,数值积分和统计学设计\ncollections.deque 线程安全, 可以从两端添加或者删除元素. 常用来作为最近用到的几个元素 queue同步类Queue, LifoQueue, PriorityQueue multiprocessing设计为了进程之间的通信 heapq当作堆和优先队列来用 Se2 字典和集合 泛映射类型 Chapter 3 把函数视作对象 se 3 函数装饰器和闭包 这一部分不同于之前的\n","permalink":"https://hugotest-phi.vercel.app/posts/fluent_python/","summary":"\u003ch2 id=\"chapter-1-数据模型\"\u003eChapter 1 数据模型\u003c/h2\u003e\n\u003ch3 id=\"se1-magic-method\"\u003eSe1 magic method\u003c/h3\u003e\n\u003cp\u003e数据模型在这里的定义是对python框架的描述,他规范了python构建模块的接口；这些接口对应解释器中对一些特殊句法(常用句法)的激活和使用.本章节的核心就在于对这些特殊句法的理解和使用.\n特殊方法带来的一些主要交互场景:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e迭代\u003c/li\u003e\n\u003cli\u003e属性访问\u003c/li\u003e\n\u003cli\u003e集合类\u003c/li\u003e\n\u003cli\u003e函数和方法的调用\u003c/li\u003e\n\u003cli\u003e对象的创建和销毁\u003c/li\u003e\n\u003cli\u003e字符串的表示形式和格式化\u003c/li\u003e\n\u003cli\u003e上下文管理模块(with模块)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这些特殊方法的存在实际上，是为了让python的解释器调用，除非我们有大量的元编程，否则我们一般不调用他，通过内置的\u003ccode\u003elen\u003c/code\u003e等函数进行调用的话，他们的速度更快\u003c/p\u003e\n\u003cp\u003e下面我们通过最典型的\u003ccode\u003e__getitem__\u003c/code\u003e和\u003ccode\u003e__len__\u003c/code\u003e对其有简单的介绍, 并介绍各个魔术方法的使用场景\u003c/p\u003e\n\u003ch3 id=\"se2-using-it-and-show-more\"\u003eSe2 using it and show more\u003c/h3\u003e\n\u003cp\u003e最常用也最典型的magic method 不外乎\u003ccode\u003e__getitem__\u003c/code\u003e和\u003ccode\u003e__len__\u003c/code\u003e;\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003elen即对当前对象提供对于通用的\u003ccode\u003elen()\u003c/code\u003e方法的接口,通常用于查看对象的\u003ccode\u003elength or size\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003egetitem除了提供\u003ccode\u003eobj[index]\u003c/code\u003e的索引方式的同时,\n\u003cul\u003e\n\u003cli\u003e他也会对python内置的那些迭代方法提供支持\u003ccode\u003efor i in range(b)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e对于依托于这些迭代的方法也能够得以支持\u003ccode\u003efrom random import choice\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e切片操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"se21-overwrite-operator\"\u003eSe2.1 overwrite operator\u003c/h4\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e这一部分我们主要介绍如下的一些特殊方法,他们将实现\u003ccode\u003e+,*,abs,print,bool\u003c/code\u003e\n对应的特殊方法可以从下面的代码中领会\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003emath\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003ehypot\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# hypot will calculate the eud-dis from 0-point(x,y)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# we using vector as an example\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eVector\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__init__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__repr__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# this method -\u0026gt; print\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Vertor(\u003c/span\u003e\u003cspan class=\"si\"\u003e{}\u003c/span\u003e\u003cspan class=\"s2\"\u003e,\u003c/span\u003e\u003cspan class=\"si\"\u003e{}\u003c/span\u003e\u003cspan class=\"s2\"\u003e)\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eformat\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__abs__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ehypot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__add__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003eVector\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eVector\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__mul__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003escalar\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eVertor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003escalar\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003escalar\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__bool__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003ebool\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"ow\"\u003eor\u003c/span\u003e \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e在这里需要注意的是,中缀运算符像add,mul的原则都是不改变操作对象,而是生成一个新的对象.\u003c/p\u003e","title":"Fluent Python 01 数据模型与结构"},{"content":"个人的《Python Cookbook》 \u0026amp;\u0026amp; 《Fluent Python》阅读笔记。\n数据模型（Python结构的通用范式） （Magic method）dunder method：Python特有的双下划线方法，这些方法能够支持Python进行特殊的调用，实现通用方法在新定义的数据结构上的使用，比如最典型的:\n__len__()后可以支持len()，获得结构的长度\n__getitem__()后可以支持data[index]来获取相应的元素，切片，等等数组的操作；\n1 2 3 4 5 6 7 8 9 10 # 也可以支持类似如下的一些操作 # 从数据结构中随机选出一个items from random import choice choice(datas) # 也可以支持迭代方法和反迭代方法 for data in datas: ... for data in reversed(datas): ... # 也可以支持sort函数 到这里也就说明了，只要我们在数据结构（class）中定义了相应的dunder method，该class就能支持相应的一系列操作，getitems就可以类比为列表，相应的操作都能够在python解释器下自动的赋予支持。\n还有一些好用但不常用的方法：\n__contain__实现的是in ，当没有实现contain的方法的时候会按照顺序在list中进行搜索 __abs__ __repr__实现的是输出的format设置，也就是print的时候的输出形式 __eq__ 实现的是 == 命令，同时in调用的是__eq__ 下面附上一张特殊方法表：\n基本命名规范 相关的文件和函数等命名规则。\n命名样例表 变量赋值传递时的引用和拷贝 Python 变量的传递类型：（赋值过程） https://www.runoob.com/w3cnote/python-variable-references-and-copies.html Python 赋值过程中不明确区分拷贝和引用，一般对静态变量的传递为拷贝，对动态变量的传递为引用。（注，对静态变量首次传递时也是引用，当需要修改静态变量时，因为静态变量不能改变，所以需要生成一个新的空间存储数据）。\n• 字符串，数值，元组 均为静态变量\r• 列表，字典为动态变量。 可以用id（）查看指向的地址\n在修改列表值之类的时候要注意这一点，不然可能会影响到源列表，可能要使用深拷贝的方法， copy.deepcopy()\npython 定义方法时候指定参数，返回值和变量的类型 ：\n1 2 3 4 5 6 def test(a:int, b:str) -\u0026gt; str: print(a, b) return 1000 if __name__ == \u0026#39;__main__\u0026#39;: test(\u0026#39;test\u0026#39;, \u0026#39;abc\u0026#39;) 类与函数 args，kwargs的用法和解包，主要将字典作为参数整体传入的这种方法值得学习\n1 可以用*，**定义和解包 id()可以获取变量的地址，type（）查看数据类型，isinstance判断类型\nlocals().keys() 获得当前已经声明的变量列表\nsys.argv[0] 可获取当前工作区的地址\n匿名函数 单下划线 定义的函数，属性，或者方法 这表明这个member是受保护的：\n是用来指定私有变量和方法的方式（只是一种约定习惯）,不希望被下游的程序员直接访问的函数。 如果使用from a_module import导入时，这部分变量和函数不会被导入 但是如果使用 import a_module这样导入模块，仍然可以用a_module._pythonPoint这样的形式访问到这样的对象。 Bool and or not 基本的就不用daaaaaaaaaaaaaaaaaaa说了，主要是一些特殊的用法举例\n1 2 # not 会先于 and 执行 if not flag1 and flag2 == True 用逻辑运算符做参数选择\n1 judge = index == 0 and num1 or num2 Argparse 基本的用法：参考universal framework即可，主要是bool类型无法通过命令行传入\n1 2 3 4 # 使用store_true属性，就可以执行默认的True or False parser.add_argument(\u0026#34;--bool_chose\u0026#34;,default=False ,action=\u0026#39;store_true\u0026#39;,help=\u0026#39;a switch of bool variable\u0026#39;) # 👇选择上与原本完全是相反的 parser.add_argument(\u0026#34;--bool_chose\u0026#34;,default=True ,action=\u0026#39;store_true\u0026#39;,help=\u0026#39;a switch of bool variable\u0026#39;) Random 使用sample不重复的选取字典或者列表中的指定项\n1 2 list = [1,2,3,4,5] choose = random.sample(list,2) 使用choice进行可重复的选取\n1 2 3 4 c_r = np.arange(20) for i in range(10): c_i = random.choice(c_r) print(c_i) 打乱列表排序\n1 2 3 4 5 6 A = [1,2,3,4,5,6] # 得到index的列表 B = np.arange(len(A)) # 对该列表进行打乱，通过打乱的列表进行索引 random.shuffle(B) print(B) Logging System 日志 HOWTO — Python 3.9.4 文档 ；日志操作手册 — Python 3.9.4 文档 Python logging模块 ；logging模块的简单使用 基础使用 从一个非常简单的例子开始，默认的命令行输出等级是warning\n1 2 3 4 5 import logging logging.debug(\u0026#39;this message should only show up in log file\u0026#39;) logging.info(\u0026#39;so do this one \u0026#39;) logging.warning(\u0026#39;this one will also show up in the console\u0026#39;) logging.error(\u0026#39;And non-ASCII stuff, too, like resund and Malm\u0026#39;) 假如我们设置log文件的存储以及输出的格式（包括算法运行的时间）\n但是注意这个config是一次性设置，只有第一次设置是有效的 1 2 logging.basicConfig(format=\u0026#39;%(asctime)s %(levelname)s %(message)s \u0026#39;, datefmt=\u0026#39;%Y-%m-%d %I:%M:%S %p\u0026#39;, filename=\u0026#34;exampleFile.log\u0026#34;,level=logging.DEBUG) # 这里设置了文件的输出名称和输出的格式，以及相应的记录到文件中的等级 也可以从命令行设置日志等级,可以获取当前的等级\n1 2 --log = INFO # getattr 这个方法目前好像还有点问题， 进阶使用 通过4个module的组合来实现record log的功能，通过Logger载入多个Handler，可以通过不同的标准和方式在多个File以及控制台输出不同Level的东西，这就是主要的功能。\nUntitled 具体的实现样例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import logging # create logger to record log messages logger = logging.getLogger(\u0026#39;textlogger\u0026#39;) # 避免等级c logger.propagate = 0 logger.setLevel(logging.DEBUG) # create file handler which logs even debug messages fh = logging.FileHandler(\u0026#39;exampleFile.log\u0026#39;) fh.setLevel(logging.WARNING) # creatr console handler... ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # create output format for all the handler formatter = logging.Formatter(\u0026#39;%(asctime)s %(levelname)s %(message)s \u0026#39;, datefmt=\u0026#39;%Y-%m-%d %I:%M:%S %p\u0026#39;) ch.setFormatter(formatter) fh.setFormatter(formatter) # add handler to logger logger.addHandler(ch) logger.addHandler(fh) # record logs logger.debug(\u0026#39;this message should only show up in log file {}\u0026#39;.format(\u0026#39;test is\u0026#39;)) logger.info(\u0026#39;so do this one \u0026#39;) logger.warning(\u0026#39;this one will also show up in the console\u0026#39;) logger.error(\u0026#39;show up twice\u0026#39;) 但是这种格式的时候怎么实现跨文件传输呢？\n1 再同个文件中我们只需要进行getlogger使用同一个名字即可获得同一个logger，但是跨文件的话可能还是需要传递logger把。 我认为应该传递该logger,然后通过该Logger进行统一的输出，遇到不同的输出要求的时候，我们可以对handler进行不一样的处理从而能够得到多样化的logger输出\nLogger与装饰器的组合使用 参见后续的装饰器解读模块\nFIles System Import manage init.py 文件的作用 init.py 文件使用 其实主要就是控制着包的导入功能，使用__all__来对应from package import *的功能，我们可以在init中批量的导入我们需要的模块，这样我们就不在需要一个个的进行导入了，基于这种特性，我们也可以编写一个manage fuction，通过config来进行选择性的导入。\n主要的左右是python中package的标识，不能删除 定义__all__用来进行模糊导入 编写python代码，会在import package的时候同时import，但是推荐在包中创建另外的模块来写，尽量保证该文件简单 Path Manage 路径切分 将路径切分成地址和文件：\n1 2 3 4 import os p,f = os.path.split(origin) print(\u0026#34;path == \u0026#34;,p) print(\u0026#34;file == \u0026#34;,f) 切分出文件的盘符和文件名\n1 dev,left = os.path.splitdrive(origin) 切分出文件和拓展名\n1 f,ext = os.path.splittext(origin) 文件遍历 os.walk() 简单好用的目录遍历器用于在目录树中游走输出目录中的文件名，向上或者向下。\n1 os.walk(top,topdown,onerror,followlinks) top：遍历的目录地址 （option）topdown：True的话优先遍历top目录，否则会优先遍历子目录 （option）onerror：当需要异常的时候，会调用 （option）followlinks：是否要跳转到快捷方式（或者软连接遍历） RETURN：（root，dirs，files）\nroot：根目录 dirs：文件夹中所有目录的名字（子文件夹） files：目录中所有文件的名字 层序遍历每次是该层的所有文件和目录的名字\nGlob.glob() 文件遍历方法\n文件读写 Data Structural 位运算 位运算判断奇偶一致性\n1 2 # T：奇偶性不一致 F：奇偶性一致 (a ^ b) \u0026amp; 1 二进制操作 与或非就不用多说，主要是介绍一个module bitarray\n序列构成的数组 这一部分主要有几个重点：列表推导式的使用、元组特性和使用\n列表推导式的使用 1 2 3 4 5 # 将字符串变成Unicode码位 symbols = \u0026#39;sdac@#\u0026#39; codes = [ord(symbol) for symbol in symbols if ord(symbol) \u0026gt;127] # 与map和filter的比较 lists(filter(lambda c:c\u0026gt;127, map(ord,symbols))) 可以看出列表推导式的表达更为简洁易懂，而且实际上运行的效率也不低\n使用列表推导式生成笛卡尔积 举例：每个size有不同的颜色\n1 2 3 4 colors = [\u0026#39;black\u0026#39;,\u0026#39;blue\u0026#39;,\u0026#39;red\u0026#39;] sizes = [\u0026#39;S\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;L\u0026#39;] # 先按颜色循环再按size循环，内外层循环的关系 tshirts = [(color,size) for color in colors for size in sizes] 生成器表达式 我们可以使用列表推导来初始化元组、数组、或者其他的数据类型，但是生成器表达式符合了迭代器的协议，可以逐个的产出元素，而不是先建立一个完整的列表，能够节省内存\n语法上和列表推导差不多，只不过把方括号换成圆括号而已\n1 2 3 tuple(ord(symbol) for symbol in symbols) import array array.array(\u0026#39;I\u0026#39;,ord(symbol) for symbol in symbols) 利用生成器表达式来计算笛卡尔积\n1 2 3 4 # 这样可以更好的体现逐个生成的特性？但是实际上列表推导式也可以把？ # 但是总之是由这样的特性的，能够避免额外的内存占用 for tshirt in (\u0026#39;%s %s\u0026#39; %(c,s) for c in colors for s in sizes): print(tshirt) 元组不仅是不可变的列表 列表的基本操作 列表的条件加和 有不少类似和条件语句相关的操作，列举一些基本实例如下：\n1 2 3 4 5 6 7 # np.random.randint? A = np.random.randint(0,3,5) B = np.random.randint(0,3,5) print(\u0026#39;origin A　is {} \\n And B is {}\u0026#39;.format(A,B)) # style 1 相当于转换成一个ToF的list，然后对这样的list直接进行sum same = (A == B).sum() print(\u0026#39;\\nthe num of same element in same posi is\u0026#39;, same) 1 2 \u0026#39;\u0026#39;\u0026#39;列表的+=，也就是简单拼接操作\u0026#39;\u0026#39;\u0026#39; [1,2,3]+[2,3,4] 列表的数乘 列表的数乘是对列表的项数进行一个重复性的扩充，但是注意这种重复不能针对那种特殊类型（也就是赋值会直接基于地址的：引用？） 所以这是对于项数的操作而不是对列表中数值的直接操作，参考变量赋值的部分\n1 2 3 4 value = 5 unlist = [value] outlist = unlist * 5 print(\u0026#39;the output is like that : {}\u0026#39;.format(outlist)) range函数常用操作 https://docs.python.org/zh-cn/3.7/library/stdtypes.html?highlight=range#range range生成的并不是列表，而是一个range组而已 1 2 3 4 reallist = list(range(20)) # range的步长设置 for i in range(0,20,5): print(i) Universal Method Sort（）对列表进行排序 sort用于对源列表进行排序，如果指定参数，则使用指定的比较函数 参考资料：https://www.runoob.com/python/att-list-sort.html\n1 2 3 4 5 6 # 纯数字的情况就按基本方式进行排列 list1 = [1,2,4,5,6,23,4] list1.sort() list1 # 类似的string就按找字母表进行逐项排序吧，我是这样理解的 队列queue \u0026amp; deque SET集合 https://www.runoob.com/python3/python3-set.html {}可以定义字典，也可以用于创建集合 但是空的集合只能用set()定义（因为{}定义的是空字典） 基本的method：\nadd、remove、discard（也是移除，但是假如元素不存在的话也不会报错） len，clear 主要是可以利用其中不会重复的元素的特性来进行特殊的操作\n1 2 3 basker = {\u0026#39;apple\u0026#39;, \u0026#39;organge\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;} print(\u0026#39;basker:\u0026#39;, basker) \u0026#39;orange\u0026#39; in basker 1 2 a = set(\u0026#39;go straight forward\u0026#39;) # 可以在集合中做交并等等集合的操作 利用set进行去重 如何利用set对unhashable的data structure进行去重，这里采取的方式是使用tuple对数组进行变换；\n实际上unhashable的原因在于对象是可变对象：比如np.array，所以我们将其转换为不可变的tuple之后就可以进行hash的计算从而进行去重了。\n1 2 3 4 5 6 7 8 9 # 二维数组为例 array1 = np.random.rand(3,4) array1_t = tuple(map(tuple,array1)) resume = np.array(array1_t) # 进行转换的时候注意不要进行过度的拆分，上述的方法只适用于二维数组的情况， text = [\u0026#39;abcsd\u0026#39;,\u0026#39;dsdc\u0026#39;,\u0026#39;cdsda\u0026#39;] text = tuple(text) # 即可，不然可能会将其中的文本全部拆分出来 # 后续补充一下map的其他用法。[func,iterator?] Dict，Hashmap 实际上python中的字典就是hashmap的具体实现，是一个无序的结构\n判断字典中的key是否存在的方法 首先如果我们调用的key不存在的话： keyerror\n1 2 \u0026gt;\u0026gt;\u0026gt; \u0026#39;key1\u0026#39; in dict1 false 或者使用get方法，能给不存在的key赋予默认的value,在这个时候出现的则是nameerror\n1 2 3 \u0026gt;\u0026gt;\u0026gt; d.get(\u0026#39;key1\u0026#39;) \u0026gt;\u0026gt;\u0026gt; d.get(\u0026#39;key1\u0026#39;, -1) -1 字典中的常用方法 …\ncollections.defaultdict 指定dict中未定义key的value 通过指定的默认值，在一些使用场景下可以对dict进行简化的定义 同时也能针对一些特殊的情况，比如说未见数据的情况，进行定义 1 2 3 4 5 6 7 8 9 # 指定list类型用于未定义类别的填充 from collections import defaultdict dict1 = {} dict2 = defaultdict(list) try: print(dict1[\u0026#39;a\u0026#39;]) except: print(\u0026#39;dict1 print key error\u0026#39;) print(\u0026#39;dict2 is like \u0026#39;, dict2[\u0026#39;a\u0026#39;]) dict1 print key error\rdict2 is like [] 1 2 3 4 5 6 7 8 # 用法2，避免keyerror更容易对其进行赋值 from collections import defaultdict bags = [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;apple\u0026#39;,\u0026#39;apple\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;blueberry\u0026#39;] count = defaultdict(int) for fruit in bags: count[fruit] += 1 print(\u0026#39;the count output is like \\n\u0026#39;, count) # print(locals().keys()) the count output is like\rdefaultdict(\u0026lt;class \u0026#39;int\u0026#39;\u0026gt;, {\u0026#39;apple\u0026#39;: 3, \u0026#39;orange\u0026#39;: 1, \u0026#39;cherry\u0026#39;: 2, \u0026#39;blueberry\u0026#39;: 1}) 1 2 3 4 5 6 # 用法3：可以自定义函数作为初始化的函数参数 # 基于这样的方法我们可以定义各种各样的默认值 from collections import defaultdict def defaultvalue(value=2): return value dict3 = defaultdict(defaultvalue) dict3[\u0026#39;hello\u0026#39;] Vars（） vars() 函数返回对象object的属性和属性值的字典对象。\nPython中的数字日期时间计算 @Aiken 2020\n@Source：《Python Cookbook》 Chapter3 数字日期和时间\n主要针对Python中的数字数字运算的运算做一个笔记\n获取本机时间的几种方法 主要为了方便格式化时间输出，我们需要将机器时间转换成指定的年月日之类的。 分别来自于time 和 datatime，这两种方式的时间复杂度好像实际上并没有太大的差别，姑且用着把暂时。\n1 2 3 4 5 6 7 import time from datetime import datetime def get_time(type=1): if type == 0: now = time.strftime(\u0026#39;%m/%d:%H:%M\u0026#39;) else: now = datetime.now().strftime(\u0026#39;%m/%d:%H:%M\u0026#39;) return now get_time(0) 精确数字运算 我们知道python中的计算不是绝对精准的， 浮点的精度是有限的，但是当我们需要进行金融领域或者数学领域的一些高精度要求的计算，可以为其牺牲一定的复杂度的时候👉decimal模块\n1 2 3 4 5 6 7 8 9 10 11 from decimal import Decimal a = Decimal(\u0026#39;4.2\u0026#39;) b = Decimal(\u0026#39;2.1\u0026#39;) print(a + b, a+b==Decimal(\u0026#39;6.3\u0026#39;)) # 注意数据的类型实际上也是Decimal # 能控制计算的每一方面，包括数字位数和四舍五入之类的，需要创建一个本地的上下文 from decimal import localcontext # 精确度控制 with localcontext() as ctx: ctx.prec = 3 print(a/b) 计算方法中的大数吃小数的情况\n(运算中的量纲差异超过17位的浮点数精度的情况)使用math.fsum()函数\n1 2 3 4 import math nums = [1.23e+18，1，-1.23e+18] assert sum(nums) != math.fsum(nums), \u0026#39;the correct ans is fsum {}, error ans is sum {}\u0026#39;.format(math.fsum(nums),sum(nums)) # we can find it what we meet and waht we want. 数字的格式化输出 控制输出的格式（精确度，对齐，千分位分割符）format\n1 2 3 4 x = 1234.56789 anslist = [] value = format(x, \u0026#39;0.2f\u0026#39;) # 👈 两位小数 anslist.append(value) Untitled 进制转换：\n2,8,16 -\u0026gt; bin（） oct（） hex（） OR format(x, ‘b’) format(x, ‘o’) format(x, ‘h’)\n复数运算\ncomplex(real, imag)``numpy好像能处理复数cmath一些math无法处理的复数运算\n正负无穷于NaN（非数字）\ninf，-inf，nan， 可以使用float(‘inf’)创建验证 math.isinf()\n分数运算\nFractions（5，4）==5/4.numerator 分子 .denominator 分母\n迭代器 主要包括迭代的模块和解包的一些相关操作：\nenumerate 、items、zip enumerate可以将可迭代对象，除了dict，解压出来，并自带序号（多加入一个维度）。\n字典的解包主要靠items（）\nzip将可迭代对象作为参数，把每一项可迭代对象中取出一个值，组合成一个个元组，，然后返回。\n1 2 for a,b,c in zip(A,B,C): ... 元编程 Some Rules -\u0026gt;in python: 常常出现在python函数定义的函数名后面，为函数添加元数据，描述函数的返回类型，从而方面开发人员使用。\n拓展：进行函数内的参数定义的时候也可以用冒号指定类型，以及默认值\n1 def func(isPre: bool = True): pass -\n装饰器模块 装饰器在我个人的理解里面更像是一个嵌套的函数结构，编写装饰器实际上是为了给函数套壳，最根本的目的仍然是为了repeat coding，而这样的写法最直接适用的有以下的几种情况：\nTiming or Logging 当成函数指针进行函数的传递（但是这点上实际上用类传递的方式可能会更常见一点） Basic Type 最基本的编写样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time from functional import wraps def timethis(func): \u0026#39;\u0026#39;\u0026#39;Decorator that report the execution time. this Decorator can not accept parameters\u0026#39;\u0026#39;\u0026#39; # 通过下面这个内置的装饰器来保留func的元信息 __name__ __doc___之类的 @wraps(func) def wrapper(*args,**kwargs): # * ** 来保证可以对func传入各种参数 start = time.time() result = func(*args, **kwargs) end = time.time() print(func.__name__, end - start) return result return wrapper 接受参数传递 但是这个装饰器实际上不满足我们的需求，我们希望装饰器能接受传入的参数，这样的话，我们才能更好的进行print或者是使用logging这个模块。\nThen we can write it like this :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 实际上直观的理解的话，就是在外面再多嵌套一层函数，通过这个函数来对我们的decorator传递需要的参数 from functional import wraps import logging # 实现对装饰器的参数传递，同时和 def logged(level, name=None,message=None): \u0026#39;\u0026#39;\u0026#39;通过最外层接受参数并将其传递到内层的装饰器中\u0026#39;\u0026#39;\u0026#39; def decorate(func): # setting paramter we passing here logname = name if name else func.__moudule__ log = logging.getLogger(logname) logmsg = message if message else func.__name__ @wraps(func) def wrapper(*args,**kwargs): log.log(level,logmsg) return func(*args,**kwargs) return wrapper return decorate # 但是实际上我们要传递的就是一些输出结果，所以我们不需要用到这一点，只要再内部赋予logging就行了，所以这里我们设定的就是基本的level和logger_nanme 修改装饰器参数 对上面这个装饰器模块进行简单的改进，就能使得用包装器包装的函数，能够调用附加函数来修改装饰器的参数\n（相当于赋予被装饰方法一个对装饰器的类外访问函数）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # 这里有个模块就比较猎奇了，以前倒是没见过 from functional import wraps,partial import logging # utility decorator to attach a functional as an attribute of obj def attach_wrapper(obj, func=None): if func is None: return partial(attach_wrapper, obj) setattr(obj, func.__name__,func) return func #原有装饰器上面添加东西即可 def logged(level, name=None,message=None): \u0026#39;\u0026#39;\u0026#39;通过最外层接受参数并将其传递到内层的装饰器中\u0026#39;\u0026#39;\u0026#39; def decorate(func): # setting paramter we passing here logname = name if name else func.__moudule__ log = logging.getLogger(logname) logmsg = message if message else func.__name__ @wraps(func) def wrapper(*args,**kwargs): log.log(level,logmsg) return func(*args,**kwargs) \u0026#39;\u0026#39;\u0026#39;使用nonlocal添加属性修改的模块\u0026#39;\u0026#39;\u0026#39; @attach_wrapper(wrapper) def set_level(newlevel): nonlocal level level = newlevel @attach_wrapper(wrapper) def set_message(newmsg): nonlocal logmsg logmsg = newmsg return wrapper return decorate @logged(logging.DEBUG) def add(x,y): return x + y @logged(logging.CRITICAL,\u0026#39;example\u0026#39;) def spam(): print(\u0026#39;Spam\u0026#39;) # 使用范例:可以再类外调用内内的属性设置了 add.set_message(\u0026#39;add called\u0026#39;) add(2,3) add.set_level(logging.WARNING) add(2,3) 带可选参数的修饰器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 感觉没太理解这个文章中说到的不带参数的意思，难道可以不传入函数吗 # 先把模板放在这 def logged(func = None, *, level=logging.DEBUG,name=None, message=None): if func is None: return partial(logged,level=level,name=name,message=message) logname = name if name else func.__moudule__ log = logging.getLogger(logname) logmsg = message if message else func.__name__ @wraps(func) def wrapper(*args,**kwargs): log.log(level,logmsg) return func(*args,**kwargs) return wrapper @property的用法 将类别方法转换为类别属性，可以直接用.获取属性值或者对属性进行赋值。\n具体的实现和要求在后面再看看\nException @Aiken 2020\nPython的异常处理操作：主要内容包括捕捉异常，抛出异常，基于异常进行判断处理等。 基本原理:\n参考资料： python3_错误和异常 、 python3_错误和异常2 Python3 错误和异常 **错误：**一般语法解析器的解析错误，换句话说也就是基本的语法错误。 **异常：**语法正确，但是运行期间出现的错误，\n异常有很多种类：未定义，类型异常，除数0异常，etc. \u0026hellip;在附录附加常用常见的错误类型\n异常捕捉try except 通过try exception 捕捉可能会出现的异常，然后用except，指定当该异常出现时候要执行的命令，可以指定多种异常。\n基本的算法流程是：\n首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。 如果没有异常发生，忽略 except 子句，try 子句执行后结束。 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。 完整的算法逻辑如图所示👇，通常可以指使用t-e部分即可\nImage1\n1 2 3 #主要依赖模块 import time import sys 写法的优点\n在可预见的Exception出现的时候不会中断程序的进行， 可以以指定的方式进行规避，或者针对该情况进行特定的异常处理。 else的优势\n如果try中出现了多个异常，我们可能会忽视其中的一些异常。 可以针对性的进行异常算法设计，这样会使得可读性和便于分析。 1 2 3 4 5 6 7 8 9 10 11 # 用try except的方式最好的一点在于，他不会终端程序的执行。 try: x = int(input(\u0026#34;please type in NUMBER \u0026#34;)) except ValueError: print(\u0026#39;your input is not NUMBER\u0026#39;) # if we donot use t-e x = int(input(\u0026#34;repeat you input\u0026#34;)) # 通过对比，我们可以知道这样执行的好处，在一些无关紧要的地方， # 可以让程序继续运行而不必因为这些而中断。 exception的多种写法和多异常分支 try中的语句可能有多种异常抛出的情况：\n针对不同的异常进行处理。 统一处理不同异常。 统一处理所有类型 以上面的代码为例：\ntry except except \u0026hellip; EXCEPT (TUPLE) except不带任何参数 1 2 3 4 5 6 7 8 9 10 11 12 13 # type 1 try: x = 123 except ValueError: t = 123 except TypeError: y = 123 # type 2 try: x = int(input(\u0026#34;please type in NUMBER \u0026#34;)) except (ValueError,TypeError,NameError): print(\u0026#39;your input is not NUMBER\u0026#39;) Try Import 使用try的结构来避免import过程中出现的问题：\nPython try import (programcreek.com) 1 2 3 4 5 6 7 def try_import(package, message=None): try: return __import__(package) except ImportError as e: if not message: raise e raise ImportError(m) 抛出异常 Raise Exception 使用raise 语句能够抛出指定类型的异常，从而终止程序的运行，和assert断言起到相似的作用。\n**关键用法：**设置异常抛出，然后用try except捕捉，然后进行指定的分支操作。 raise [Exception [, args [, traceback]]]\nraise_exception\n1 2 3 x = 10 if x \u0026gt;= 5: raise Exception(\u0026#39;x 不能大于5，当前值为 {} \u0026#39;.format(x)) Numpy Tips reshape 和numpy格式的reshape的相关内容整合\n基本reshape的使用 reshape不改变原数据 1 2 3 4 5 6 7 8 bk1_a = np.array([1,2,3,4,5,6,7,8]) bk1_b = np.array([[1,1,1,1],[2,2,2,2]]) bk1_c = bk1_a.reshape(bk1_b.shape) print(\u0026#34;b\u0026#39;s datashpe is {}\u0026#34;.format(bk1_b.shape)) print(\u0026#34;reshape by b。shape is ↓ \\n {}\u0026#34;.format(bk1_c)) # 测试是否改变原数据 print(\u0026#34;b\u0026#39;s shape is {} \u0026#34;.format(bk1_b.shape)) assert bk1_a == bk1_c, \u0026#39;do not change the origin data, a is like {}\u0026#39;.format(bk1_a) tolist numpy array 和list之间的互相转换，在大规模编程中有比较广泛的应用场景。\n**有^次方的意思 arange 包含下限，不包含上线 1 2 3 4 bk2_a= (2 ** np.arange(4,6)) # bk2_a bk2_b = bk2_a.tolist() # bk2_b 用array给list中的元素赋值 以下是这种方式建立一个类似one-hot的函数介绍 可以很容易的从输出看出规律，而且最外层仍然是列表，也就是其中的元素是array\n1 2 3 4 5 6 list1 = [1,2,3,4,12,3,4] for i in range(len(list1)): temp = list1[i]-1 list1[i] = np.zeros(13) list1[i][temp] = 1 list1 flatten \u0026amp; flat operation flatten：将数据摊开降维成一维的数组/矩阵，以副本形式生成，不影响原数据 flat，生成一个迭代器，按行的形式迭代\n1 2 3 4 5 6 7 8 9 10 11 # A:flatten function B:flat function bk3_a = np.random.rand(2,3) print(\u0026#39;A is just like\\n {}\u0026#39;.format(bk3_a)) bk3_a2 = bk3_a.flatten() print(\u0026#39;A2 is just like\\n {}\u0026#39;.format(bk3_a2)) printz(\u0026#39;********************clip*************************\u0026#39;) bk3_b = np.random.rand(2,3) print(\u0026#39;B is just like \\n{}\u0026#39;.format(bk3_b)) print(bk3_b.flat, \u0026#39;as we can see, this is a iter\u0026#39;) for i in bk3_b.flat: print(i) Numpy.pad pad，就是拓展原本数据的维度，方便后面机器学习中的其他步骤，主要用处包括：\n维度保持 增加对图像边界的重视 1 2 3 4 5 6 7 8 9 10 11 12 ## numpy.pad x = np.random.randint(0,5,(3,4,4)) x = np.pad(x,2) print(x.shape) h,w = x.shape[1:] new_h,new_w = 3,3 top = np.random.randint(0,h-new_h) left = np.random.randint(0,w-new_w) x = x[:,top: top+new_h,left:left+new_w] x.shape :: Numpy 索引中双冒号的实际用途 参照该文章进行分析，主要用途包括：对图像进行反转等操作 https://blog.csdn.net/GracePro/article/details/102079331 1 2 3 4 5 a = np.random.rand(3,2,2) print(a) print(\u0026#39;----------------------------\u0026#39;) a = a[:,::-1] print(a) Argpartition() 借助于 argpartition()，Numpy 可以找出 N 个最大数值的索引，也会将找到的这些索引输出。\n然后我们根据需要对数值进行排序。\n1 2 3 4 5 x = np.array([12, 10, 12, 0, 6, 8, 9, 1, 16, 4, 6, 0]) index_val = np.argpartition(x, -5)[-5:] index2 = np.argmin(x) print(index2) index_val 基于numpy的sort函数，输出找出的最大的几个数，要全体排序的话，还是考sort\n1 np.sort(x[index_val]) Allclose() allclose() 用于匹配两个数组，并得到布尔值表示的输出。如果在一个公差范围内（within a tolerance）两个数组不等同，\n则 allclose() 返回 False。该函数对于检查两个数组是否相似非常有用。\n1 2 3 4 5 6 array1 = np.array([0.12,0.17,0.24,0.29]) array2 = np.array([0.13,0.19,0.26,0.31]) # with a tolerance of 0.1, it should return False: print(np.allclose(array1,array2,0.1)) # with a tolerance of 0.2, it should return True: print(np.allclose(array1,array2,0.2)) Clip() 使得一个数组中的数值保持在一个区间内。有时，我们需要保证数值在上下限范围内。为此，我们可以借助 Numpy 的 clip() 函数实现该目的。给定一个区间，则区间外的数值被剪切至区间上下限（interval edge）。\n1 2 x = np.array([3, 17, 14, 23, 2, 2, 6, 8, 1, 2, 16, 0]) np.clip(x,2,5) extract() 顾名思义，extract() 是在特定条件下从一个数组中提取特定元素。 借助于 extract()，我们还可以使用 and 和 or 等条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 array = np.random.randint(20, size=12) print(\u0026#39;basic array is {} \u0026#39;.format(array)) # Divide by 2 and check if remainder is 1 cond = np.mod(array, 2)==1 print(\u0026#39;是否符合条件的list，条件list\\n {}\u0026#39;.format(cond)) # Use extract to get the values # 提取出表现为True的哪些元素 print(\u0026#39;按照条件提取出元素:\\n {}\u0026#39;.format(np.extract(cond, array))) # Apply condition on extract directly # 更直接的指定条件 print(\u0026#39;复杂条件下的表现情况\u0026#39;) print(np.extract(((array \u0026lt; 3) | (array \u0026gt; 15)), array)) where() Where() 用于从一个数组中返回满足特定条件的元素。比如，它会返回满足特定条件的数值的索引位 Where() 与 SQL 中使用的 where condition 类似，如以下示例所示：\n1 2 3 4 5 6 y = np.array([1,5,6,8,1,7,3,6,9]) # Where y is greater than 5, returns index position print(np.where(y\u0026gt;5)) # First will replace the values that match the condition, # second will replace the values that does not print(np.where(y\u0026gt;5, \u0026#34;Hit\u0026#34;, \u0026#34;Miss\u0026#34;)) DEBUG 记录一些典型错误，便于后续Debug的时候查找原因\n避免重复/冲突的import 在工程实现中，对于同一个module。最好能做到不需要重复的import，但是在跨文件的工程项目中，或者说是一些跨文件调用的情况下，可能有一些基本的module会需要这样的时候，那我们最好做到不冲突，以同样的形式来进行import，不然有时候这样的重定义方式会出现一定的问题或者bug。 for example from time import time 和 import time同时出现的情况。\n内存调用与Method的定义 在较为复杂的工程项目中，应该使用Method（Function）模块化的解决问题；这样做的优势可以从一下几点来看：\n易于阅读分析，写好相关method的Doc，然后做好注释，方便阅读和后续修改 能够在迭代过程中有效的释放暂态的变量，节约在主进程中无效的参数存储空间，节省内存或者显存。 TypeError： 一：cannnot unpack not-iterable NoneType object（无法解包非迭代类型的NoneType对象）\n1 2 3 4 5 6 def test(): if value == 1: a=b=1 return a, b a,b = test() print(a,b) 原因分析，当python函数没有确定的return的时候默认的返回值是None，这样在进行检查的时候，就会到导致编译的错误\n解决：指定默认的return，或者使用else方法完善所有情况下的return值的个数是一致的\n二：missing 1 required positional argument： “self”\n对象的声明需要括号，我们可能在调用类内函数的时候，用错了变量，用了类而不是类的实例去调用这个函数，导致执行出现了错误。\n三：builtin_function_or_method error\n很多时候都是由于前面的数据操作少加了()导致的问题\n四：bad operand type for unary -: ‘NoneType’\n输入的数据存在着值为空的情况，可能没定义之类的，问题要根据后面的具体报错来进行分析。\n","permalink":"https://hugotest-phi.vercel.app/posts/python/","summary":"\u003cp\u003e个人的《Python Cookbook》 \u0026amp;\u0026amp; 《Fluent Python》阅读笔记。\u003c/p\u003e\n\u003ch1 id=\"数据模型python结构的通用范式\"\u003e数据模型（Python结构的通用范式）\u003c/h1\u003e\n\u003cp\u003e（Magic method）dunder method：Python特有的双下划线方法，这些方法能够支持Python进行特殊的调用，实现通用方法在新定义的数据结构上的使用，比如最典型的:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e__len__()\u003c/code\u003e后可以支持\u003ccode\u003elen()\u003c/code\u003e，获得结构的长度\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e__getitem__()\u003c/code\u003e后可以支持\u003ccode\u003edata[index]\u003c/code\u003e来获取相应的元素，切片，等等数组的操作；\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 也可以支持类似如下的一些操作\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 从数据结构中随机选出一个items\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003erandom\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003echoice\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003echoice\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edatas\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 也可以支持迭代方法和反迭代方法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003edatas\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003ereversed\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edatas\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 也可以支持sort函数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e到这里也就说明了，只要我们在数据结构（class）中定义了相应的dunder method，该class就能支持相应的一系列操作，getitems就可以类比为列表，相应的操作都能够在python解释器下自动的赋予支持。\u003c/p\u003e\n\u003cp\u003e还有一些好用但不常用的方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__contain__\u003c/code\u003e实现的是\u003ccode\u003ein\u003c/code\u003e ，当没有实现contain的方法的时候会按照顺序在list中进行搜索\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__abs__\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__repr__\u003c/code\u003e实现的是输出的format设置，也就是print的时候的输出形式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__eq__\u003c/code\u003e 实现的是  == 命令，同时in调用的是__eq__\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e下面附上一张特殊方法表：\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch3 id=\"基本命名规范\"\u003e基本命名规范\u003c/h3\u003e\n\u003cp\u003e相关的文件和函数等命名规则。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"Python%20Notebook%20ad3f0aafe5a54942bdcc3694a9a88976/%E5%91%BD%E5%90%8D%E6%A0%B7%E4%BE%8B%E8%A1%A8%2039d2a928f8bf4624afc2e0006ffcd528.csv\"\u003e命名样例表\u003c/a\u003e\n\u003c/p\u003e\n\u003ch1 id=\"变量赋值传递时的引用和拷贝\"\u003e变量赋值传递时的引用和拷贝\u003c/h1\u003e\n\u003cp\u003ePython 变量的传递类型：（赋值过程）\n\u003ca href=\"https://www.runoob.com/w3cnote/python-variable-references-and-copies.html\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.runoob.com/w3cnote/python-variable-references-and-copies.html\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003ePython 赋值过程中不明确区分拷贝和引用，一般对静态变量的传递为拷贝，对动态变量的传递为引用。（注，对静态变量首次传递时也是引用，当需要修改静态变量时，因为静态变量不能改变，所以需要生成一个新的空间存储数据）。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e•  字符串，数值，元组 均为静态变量\r\n• 列表，字典为动态变量。\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以用id（）查看指向的地址\u003c/p\u003e","title":"Python01 数据模型和常用数据结构"},{"content":"Debug 配置Launch.json 能够帮助我们更好的进行debug的操作，有一些比较特别的文件名和相关编码。\n${workspaceFolder} 指代当前运行目录 ${file}指代当前文件 找到launch文件并打开，自定义JSON：执行工作文件夹下的main.py进行调试。\n1 2 3 4 5 6 7 8 9 { \u0026#34;name\u0026#34;: \u0026#34;experiment\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/main.py\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;--data_path\u0026#34;,\u0026#34;${workspaceFolder}/data\u0026#34;, \u0026#34;--mode\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;--resume\u0026#34;,\u0026#34;false\u0026#34;] }, 默认 JSON：执行当前文件\n1 2 3 4 5 6 7 { \u0026#34;name\u0026#34;: \u0026#34;current file\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${file}\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; } Snippets 学会编写VsCode的用户代码片段，实际上也就是snippets，在我们编写代码的时候用来输出。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 { // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the // same ids are connected. // Example: // \u0026#34;Print to console\u0026#34;: { // \u0026#34;prefix\u0026#34;: \u0026#34;log\u0026#34;, // \u0026#34;body\u0026#34;: [ // \u0026#34;console.log(\u0026#39;$1\u0026#39;);\u0026#34;, // \u0026#34;$2\u0026#34; // ], // \u0026#34;description\u0026#34;: \u0026#34;Log output to console\u0026#34; // } \u0026#34;Print to console\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;tencent-header\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;/*===============================================================\u0026#34;, \u0026#34;* Copyright (C) 2019 Tencent Technology Company Limited.\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;* Name：$TM_FILENAME\u0026#34;, \u0026#34;* Author：aikenhong@tencent.com\u0026#34;, \u0026#34;* Date：$CURRENT_YEAR年$CURRENT_MONTH月$CURRENT_DATE日\u0026#34;, \u0026#34;* Desc：$1\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;* Update History：\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;================================================================*/\u0026#34;, \u0026#34;#ifndef $TM_FILENAME\u0026#34;, \u0026#34;#define $TM_FILENAME\u0026#34;, \u0026#34;#pragma once\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;#include \u0026lt;map\u0026gt;\u0026#34;, \u0026#34;#include \u0026lt;math.h\u0026gt;\u0026#34;, \u0026#34;#include \u0026lt;string\u0026gt;\u0026#34;, \u0026#34;#include \u0026lt;studio.h\u0026gt;\u0026#34;, \u0026#34;#include \\\u0026#34;label_helper.h\\\u0026#34;\u0026#34;, \u0026#34;#include \\\u0026#34;feature_select.h\\\u0026#34;\u0026#34;, \u0026#34;#include \\\u0026#34;sgame_ai_src/common/util.h\\\u0026#34;\u0026#34;, \u0026#34;#include \\\u0026#34;sgame_ai_src/common/target_finder.h\\\u0026#34;\u0026#34;, \u0026#34;#include \\\u0026#34;game_ai_src/tactics/tactics_multi_task_two_hand_action.h\\\u0026#34;\u0026#34; ], \u0026#34;description\u0026#34;: \u0026#34;header for the humanlike indicator development\u0026#34; } } 其中 $\u0026lt;number\u0026gt; 是按下光标后跳转的位置，$ \u0026lt;keyword\u0026gt; 可以有诸多表达式，建议去上网查一下。\nTodo Tree 打开设置-打开json文件（设置右上角）\n添加如下内容：（颜色和关键词可自定义）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026#34;todo-tree.tree.showScanModeButton\u0026#34;: true, \u0026#34;todo-tree.highlights.enabled\u0026#34;: true, \u0026#34;todo-tree.highlights.defaultHighlight\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text and comment\u0026#34;, }, \u0026#34;todo-tree.highlights.customHighlight\u0026#34;: { \u0026#34;TODO\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#2f3542\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#f6b93b\u0026#34;, \u0026#34;iconColour\u0026#34;: \u0026#34;#f39c12\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;issue-opened\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;line\u0026#34; }, \u0026#34;FIXME\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#2f3542\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#e55039\u0026#34;, \u0026#34;iconColour\u0026#34;: \u0026#34;#e55039\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;flame\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;line\u0026#34; }, \u0026#34;NOTE\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#2f3542\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#9980FA\u0026#34;, \u0026#34;iconColour\u0026#34;: \u0026#34;#6c5ce7\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;eye\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;line\u0026#34; }, \u0026#34;RECORD\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#2f3542\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#7bed9f\u0026#34;, \u0026#34;iconColour\u0026#34;: \u0026#34;#2ed573\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;info\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;line\u0026#34; } }, \u0026#34;todo-tree.general.tags\u0026#34;: [ \u0026#34;TODO\u0026#34;, \u0026#34;FIXME\u0026#34;, \u0026#34;NOTE\u0026#34;, \u0026#34;RECORD\u0026#34; ], Plugins introduce some plugins or special usage\nMonokai Pro 切换到目录user/aiken/.vscode/extensions/monokaipro/js/app.js 类似的文件，\n找到key: \u0026quot;isValidLicense\u0026quot;\n将下方的if和return的判定值1即可\n最终代码如下：\n1 2 3 4 5 6 7 8 9 10 key: \u0026#34;isValidLicense\u0026#34;, value: function () { var e = arguments.length \u0026gt; 0 \u0026amp;\u0026amp; void 0 !== arguments[0] ? arguments[0] : \u0026#34;\u0026#34;, t = arguments.length \u0026gt; 1 \u0026amp;\u0026amp; void 0 !== arguments[1] ? arguments[1] : \u0026#34;\u0026#34;; if (!e || !t) return 1; var o = s()(\u0026#34;\u0026#34;.concat(i.APP.UUID).concat(e)), r = o.match(/.{1,5}/g), n = r.slice(0, 5).join(\u0026#34;-\u0026#34;); return t === 1 } List 列出已经安装的插件列表可以靠以下的命令：\n1 code --list-extensions \u0026gt; extensions.txt 插件列表和配置文件可以在我的 dotfile 仓库获取。\n","permalink":"https://hugotest-phi.vercel.app/posts/vscode/","summary":"\u003ch2 id=\"debug\"\u003eDebug\u003c/h2\u003e\n\u003cp\u003e配置Launch.json 能够帮助我们更好的进行debug的操作，有一些比较特别的文件名和相关编码。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e${workspaceFolder}\u003c/code\u003e 指代当前运行目录\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e${file}\u003c/code\u003e指代当前文件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e找到launch文件并打开，自定义JSON：执行工作文件夹下的main.py进行调试。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;experiment\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;python\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;request\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;launch\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;program\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;${workspaceFolder}/main.py\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;console\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;integratedTerminal\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;args\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;--data_path\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;${workspaceFolder}/data\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"s2\"\u003e\u0026#34;--mode\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;0\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;--resume\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;false\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"err\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e默认 JSON：执行当前文件\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;current file\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;python\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;request\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;launch\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;program\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;${file}\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026#34;console\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;integratedTerminal\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"snippets\"\u003eSnippets\u003c/h2\u003e\n\u003cp\u003e学会编写VsCode的用户代码片段，实际上也就是snippets，在我们编写代码的时候用来输出。\u003c/p\u003e\n\u003cp\u003e例子：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e45\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"c1\"\u003e// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// same ids are connected.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// Example:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// \u0026#34;Print to console\u0026#34;: {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// \t\u0026#34;prefix\u0026#34;: \u0026#34;log\u0026#34;,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// \t\u0026#34;body\u0026#34;: [\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// \t\t\u0026#34;console.log(\u0026#39;$1\u0026#39;);\u0026#34;,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// \t\t\u0026#34;$2\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// \t],\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// \t\u0026#34;description\u0026#34;: \u0026#34;Log output to console\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// }\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"nt\"\u003e\u0026#34;Print to console\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026#34;prefix\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;tencent-header\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026#34;body\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;/*===============================================================\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;*   Copyright (C) 2019 Tencent Technology Company Limited.\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;*\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;*   Name：$TM_FILENAME\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;*   Author：aikenhong@tencent.com\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;*   Date：$CURRENT_YEAR年$CURRENT_MONTH月$CURRENT_DATE日\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;*   Desc：$1\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;*\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;*   Update History：\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;*\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;================================================================*/\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#ifndef $TM_FILENAME\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#define $TM_FILENAME\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#pragma once\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#include \u0026lt;map\u0026gt;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#include \u0026lt;math.h\u0026gt;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#include \u0026lt;string\u0026gt;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#include \u0026lt;studio.h\u0026gt;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#include \\\u0026#34;label_helper.h\\\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#include \\\u0026#34;feature_select.h\\\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#include \\\u0026#34;sgame_ai_src/common/util.h\\\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#include \\\u0026#34;sgame_ai_src/common/target_finder.h\\\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"s2\"\u003e\u0026#34;#include \\\u0026#34;game_ai_src/tactics/tactics_multi_task_two_hand_action.h\\\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026#34;description\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;header for the humanlike indicator development\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e其中\u003ccode\u003e $\u0026lt;number\u0026gt;\u003c/code\u003e 是按下光标后跳转的位置，\u003ccode\u003e$ \u0026lt;keyword\u0026gt;\u003c/code\u003e 可以有诸多表达式，建议去上网查一下。\u003c/p\u003e","title":"VsCode's Configuration"},{"content":"this is the Note record the vimtutor (the basic usage of vim.) @Aiken 2021\nwrite some word and we can use shift+a to insert in the end. the doc with Chinese delete command skip words and lines undo and resume replace and change location and file status search command find the matched parentheses 找到对应的括号 substitute command 替换命令 EXECUTE AN ECTERNAL COMMAND THE OPEN COMMAND COPY AND PASTE SET OPTION KEYSHORT delete command Most of the command can use NUM to repeat it. d num command means delete num times with args below: c means del and change mode to insert:\nw delete next num words e delete cur word d delete this line which is not support \u0026lsquo;c\u0026rsquo; $ delete to the end of the line x means delete this cur\nskip words and lines e means jump the end of the word 3e: means skip 3word distance 2w: means skip 2word the num can be decide by ourself.(in the most commands)\nundo and resume u means undo. U undo the line.\nctrl+r means resume which is contrast undo.\nreplace and change r replace char with new input R become replace mode, replace word by input util we press esc\nlocation and file status ctrl+g will show the location in file and the file status.\ngg: move to the head of the file. G: move to the end of the file. idx + G: jump 2 the line. shift+6: jump 2 the head of the line. search command typing: / \u0026lt;word_we_want\u0026gt; to search it. if we want to search same word, just type n, in another order N using ctrl+o to go back the cursor location, ctrl+i to go next using ? instand of / if we want search in the inverse order. find the matched parentheses 找到对应的括号 typing % near the ( { [, it\u0026rsquo;ll jump to another. this is very useful in debugging a program\nsubstitute command 替换命令 :idx0,idx1s/old/new/g replace old with new in the line between [idx0,idx1]\n:%s/old/new/g replace all the old with new in whold file\n:%s/old/new/gc find out all old and we willdecide change it or not manually.\nEXECUTE AN ECTERNAL COMMAND how to execute an command like shell command?\n1 using :![command] -[args] :w [filename] can save this file in this position or save change or it. :!rm [filename] :v choose those text or code we want to save(not all this file, just what we selected) and :w [filename] to save it :r [filename] will resume the txt of the file in this cursor. :r !dir will read the command output and puts it below the cursor THE OPEN COMMAND o means will insert a line UNDER the cursor O will insert ABOVE the cursor COPY AND PASTE y copy command. yw copy a word p paste(put) command v visual mode, select those char we want. $ jump to the end of the line SET OPTION set an option so a search or subsititute ignore case\nafter type in \u0026lsquo;:/ignore\u0026rsquo; then type in ::set ic will ignore case :set is 部分显示匹配的搜索短语 :set hls 高亮显示所有匹配的短语 :set no+\u0026lt;command\u0026gt; 前置no可以关闭选项 KEYSHORT Ctrl + f/b : 往下/上翻页 Ctrl + e/y : 往下/上滚动 V: 列选择模式 U/u: 选中的单词变成大/小写 Ctrl + w: 光标窗口切换 ","permalink":"https://hugotest-phi.vercel.app/posts/vimtutor/","summary":"\u003cp\u003ethis is the Note record the vimtutor (the basic usage of vim.)\n@Aiken 2021\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewrite some word and we can use shift+a to insert in the end.\n\u003ca href=\"https://github.com/HanielF/VimTutor\" target=\"_blank\" rel=\"noopener\"\u003ethe doc with Chinese\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- vim-markdown-toc GFM --\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#delete-command\"\u003edelete command\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#skip-words-and-lines\"\u003eskip words and lines\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#undo-and-resume\"\u003eundo and resume\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#replace-and-change\"\u003ereplace and change\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#location-and-file-status\"\u003elocation and file status\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#search-command\"\u003esearch command\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#find-the-matched-parentheses-%e6%89%be%e5%88%b0%e5%af%b9%e5%ba%94%e7%9a%84%e6%8b%ac%e5%8f%b7\"\u003efind the matched parentheses 找到对应的括号\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#substitute-command-%e6%9b%bf%e6%8d%a2%e5%91%bd%e4%bb%a4\"\u003esubstitute command 替换命令\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#execute-an-ecternal-command\"\u003eEXECUTE AN ECTERNAL COMMAND\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-open-command\"\u003eTHE OPEN COMMAND\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#copy-and-paste\"\u003eCOPY AND PASTE\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#set-option\"\u003eSET OPTION\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#keyshort\"\u003eKEYSHORT\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- vim-markdown-toc --\u003e\r\n\u003ch2 id=\"delete-command\"\u003edelete command\u003c/h2\u003e\n\u003cp\u003eMost of the command can use \u003ccode\u003eNUM\u003c/code\u003e to repeat it.\n\u003ccode\u003ed num\u003c/code\u003e command means delete \u003ccode\u003enum\u003c/code\u003e times with args below:\n\u003ccode\u003ec\u003c/code\u003e means del and change mode to insert:\u003c/p\u003e","title":"Vim 00 Basic Opeation"},{"content":"@Aiken 2021 this file is use to record how to config out vim\u0026rsquo; by spacevim.\nI\u0026rsquo;ll write this doc with three Parts:\nInstall and envs, Plugins(including the LSP), KeyShort Attention: we have much to do if we want to install some other plugins. maybe it not a good way to set the vim. INSTALL SPACEVIM AND CONFIG IT INSTALL LANGs\u0026rsquo; COCNVIM KEYSHORT and special USAGE SPLIT WINDOWS and CHECKOUT Plugins INSTALL SPACEVIM AND CONFIG IT Install: SpaceVim via the offical websize:\nspacevim layers colorscheme 1 2 The COMMAND is like: curl -sLf https://spacevim.org/cn/install.sh | bash After that, the spacevim will install for the vim and neovim.\nBasic Configuration:\nmodify the spacevim configuration in the file below ~/.SpaceVim.d/init.toml\nAnd enable some layers we need: which can select from spc + h + l after enable those layer, DEIN will install those plugins we need use GLOBAL VPN to download plugins.\nsomething like set: wrap will be add in ~/.SpaceVim/vimrc (end of it)\nINSTALL LANGs' This is the most important part for coding: lint,autocomplete,warning..\nAt the same time, this part is hardest to install, because the coc.nvim which is not design for spacevim.\nFIRST OF ALL: enable those langs\u0026rsquo; layer: python(first), markdown, c++;\nWe can install those module according to the Docs, then install sth like pynvim(pip), node js, yarn, neovim, make\u0026hellip;\nTHEN: run :CheckHealth after install coc to check the env status.\nNEXT: try install debug, c++, c, for the future dev.\nCOCNVIM Using Python As a example to show how to install this.\nHardest Part here: CPP with Coc , Coc Offical Coc_issues Install nodejs and yarn: 1 2 3 4 5 6 7 8 9 10 # add \u0026amp; update apt source before install nodejs. curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get update # install nodejs after that. sudo apt-get install -y nodejs # install yarn in shell refer to the hint like: curl --compressed -o- -L https://yarnpkg.com/install.sh | bash Install Coc in SpaceVim by dein in init.toml: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [options] autocomplete_method = \u0026#39;coc\u0026#39; [[layers]] name = \u0026#39;lsp\u0026#39; filetype = [ \u0026#39;c\u0026#39;, \u0026#39;cpp\u0026#39;, \u0026#39;dart\u0026#39;] [layers.override_cmd] c = [\u0026#39;ccls\u0026#39;] cpp = [\u0026#39;ccls\u0026#39;] python = [\u0026#39;pyls\u0026#39;] [[cusiom_plugins]] repo = \u0026#34;neoclide/coc.nvim\u0026#34; merge = 0 rev = \u0026#39;release\u0026#39; after install using :checkhealth \u0026lsquo;CocInfo\u0026rsquo; to comfirm.\nInstall some basic part(jedi): 1 2 3 4 conda install jedi :CocInstall coc-jedi coc-python coc-snippets :CocInstall coc-python :CocInstall coc-clangd coc_keyword: some basic coc command we may use often\nCocInstall [PackageName] CocUninstall [PackageName] KEYSHORT and special USAGE reinstall some plugins can use: SPReinstall coc.nvim. running/debug info will record in SPDebugInfo to_tree will show in spc a o after we save the modify of file SPLIT WINDOWS and CHECKOUT split windows to show more info and make it easily to code.\nsp [filename] to splite windows with new files. u-d vsp [filename] to splite windows with new files. l-r spc [num] checkout cursor in diff windows g t checkout from tag to tag Plugins This part is depending the DEIN, so we can reference this plugins. Many useful plugins had been add in those layers, learn it from offical website.\nrecommand1 ","permalink":"https://hugotest-phi.vercel.app/posts/spacevim/","summary":"\u003cp\u003e@Aiken 2021 this file is use to record how to config out vim\u0026rsquo; by spacevim.\u003cbr\u003e\nI\u0026rsquo;ll write this doc with three Parts:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInstall and envs, Plugins(including the LSP), KeyShort\u003c/li\u003e\n\u003cli\u003eAttention: we have much to do if we want to install some other plugins.\nmaybe it not a good way to set the vim.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- vim-markdown-toc GFM --\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#install-spacevim-and-config-it\"\u003eINSTALL SPACEVIM AND CONFIG IT\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#install-langs\"\u003eINSTALL LANGs\u0026rsquo;\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#cocnvim\"\u003eCOCNVIM\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#keyshort-and-special-usage\"\u003eKEYSHORT and special USAGE\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#split-windows-and-checkout\"\u003eSPLIT WINDOWS and CHECKOUT\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#plugins\"\u003ePlugins\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- vim-markdown-toc --\u003e\r\n\u003chr\u003e\n\u003ch2 id=\"install-spacevim-and-config-it\"\u003eINSTALL SPACEVIM AND CONFIG IT\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eInstall:\u003c/strong\u003e SpaceVim via the offical websize:\u003c/p\u003e","title":"Vim Configuration 03 Spacevim Setup"},{"content":"@ Article: ICML from Microsoft \u0026amp; Huazhong Keda @ Code: Github @ Noteby: Aikenhong @ Time: 20210914\nAbstrast and Intro in the session we will using describe the main idea of this article.\n这篇文章的重点在于Soft Teacher，也就是用pseudo label做为弱标注，逐步提高伪标签的可靠性。\n不同于多阶段的方法，端到端的方法再训练中逐步的提升伪标签的质量从而再去benifit目标检测的质量。 这样E2E的框架主要依赖于两部分技术:\nsoft teacher: 每个未标记边界框的分类损失由教师网络产生的分类分数进行加权 box jitter 窗口抖动: 选择可靠的伪框来学习框回归 在目标检测上获得SOTA的效果;\nMulti-Stage 在半监督的情况下，关注的主要是基于伪标签的方法，是目前的SOTA，以往的方法采用多阶段的方式。\n使用标记数据训练初始检测器 未标记数据的伪标记，同时基于伪标签进行重新训练 局限：初始少量标注的局限，初始的检测器的伪标签质量\nEnd to End Soft Teacher基本思路：对未标记的图像进行标记，然后通过标记的几个伪标签训练检测器.\n具体而言：\n采样标注和未标注图片形成Batch 双模型：检测（student）、标记（teacher） EMA：T模型是S模型的EMA 这种方式避免了多阶段方案实现上的复杂，同时实现了飞轮效应==S、T相互加强;\n此外Soft Teacher直接对学生模型生成的所有候选框进行评估，而不是使用伪框来为这些候选框进行分类回归。 这样能使用更多的直接监督信息\n具体而言：\n使用高阈值来分割前景，确保不会错误的将背景分类成前景，确保正伪标签的高精度； 使用可靠性度量来加权背景候选的损失； 教师模型产生的检测分数可以很好的作为可靠性度量 Box Jitter为了更可靠的训练学生网络的本地分支，指的是：\n我们对前景框候选进行多次抖动 根据教师模型的位置分支对这些候选进行回归 将回归框的方差作为可靠性度量 可靠性高的用来训练 Related works Semi-Supervised Learning in Image Classification \u0026amp; object detection\nconsistency based pesudo-label based new idea：使用弱数据增强生成伪标签和强增强来学习检测模型，区分两部分工作\nObject Detection\nBased on Faster R-CNN to compare with other method\nMethodology 可以从下面的图中看出基础的实现逻辑：\nFramework 训练（Loss）是基于Batch进行，对于标记数据和未标记数据的损失处理时分开的， 对于未标记数据，我们需要通过教师模型来得到一个softlabel，包括分类和回归两个任务，然后得到最终的损失值。\n$$ L = L_s + \\alpha L_u\r$$\r两者都要通过各自的图像数量进行归一化，以标注数据为例\n$$ L_s = \\frac{1}{N_l}\\sum_{i=1}^{N_l}(L_{cls}(I_l^i)+(L_{reg}(I_l^i))\r$$\r如何启动教师模型：\n随机初始化学生模型和教师模型，后续通过学生模型的EMA来进行教师模型的更新。\n目标检测的伪标签定义：\n教师模型检测后NMS消除冗余，然后使用阈值来抑制非前景的候选；\n获取高质量的伪标签：\n对教师模型的伪标记使用弱增强，学生模型训练使用强增强\nSoft Teacher 检测器的性能取决于伪标签的质量，如果在前景分数上使用较高的阈值过滤掉大部分学生生成的低置信度候选框可以得到更好的结果，当阈值设置为0.9时性能最佳，但是召回率迅速下降。\n一般方法：使用学生生成的候选框和教师生成的候选框的IoU来分配前景和背景，可能会损坏性能。 软教师：我们评估学生生成的候选框作为真实背景的可靠性，用于衡量背景分类损失； $$ b^{fg}_i $$\r、 $$ b^{bg}_i $$\r分别是分配为前景的框和分配为背景的框，具有可靠权重的伪标记图像的分类损失定义为：\r$$ \\mathcal{L}_{u}^{\\mathrm{cls}}=\\frac{1}{N_{b}^{\\mathrm{fg}}} \\sum_{i=1}^{N_{b}^{\\mathrm{fg}}} l_{\\mathrm{cls}}\\left(b_{i}^{\\mathrm{fg}}, \\mathcal{G}_{\\mathrm{cls}}\\right)+\\sum_{j=1}^{N_{b}^{\\mathrm{b}_{b}}} w_{j} l_{\\mathrm{cls}}\\left(b_{j}^{\\mathrm{bg}}, \\mathcal{G}_{\\mathrm{cls}}\\right)\r$$\r$$ w_j = \\frac{\\gamma_j}{\\sum_{k=1}^{N_b^{bg}}\\gamma_k}\r$$\r$$ \\mathcal{G}_{cls} $$\r表示用于分类（教师生成的）伪框集， $$ l_{cls}() $$\r是框分类损失， $$ r_j $$\r是第j个背景的可靠性分数；\r我们通过教师模型产生的背景分数可以很好的代替可靠性：\n使用教师模型（BG-T）通过检测头来获取样本的背景分数 还研究了：学生模型，学生模型和学生模型之间的差异\nBox Jittering 图三b可以看到，候选框的定义准确率和前景分数不是一个正相关的关系，他不一定能提供准确的定位信息。\n需要更好的候选框，在教师生成的候选框bi上做抖动采样，将抖动框输入教师模型获得调整后的框\n$$ \\hat{b_i} = refine(jitter(b_i)).\r$$\r抖动 $N_{jittle}$ 次后得到 ${\\hat{b}_{i,j}}$ 集合，然后将可靠性定义为box回归方差：\n$$ \\overline{\\sigma}_i = \\frac{1}{4}\\sum_{k=1}^4\\hat{\\sigma}_k\r$$\r其中：\n$$ \\hat{\\sigma}_k = \\frac{\\sigma_k}{0.5(h(b_i)) + w(b_i)}\r$$\r较小的框回归方差表示较高的本地可靠性，但是大量的计算也是不可忍受的，所以我们一般只计算前景分数大于0.5的框的可靠性\n回归方差计算：\n$$ \\mathcal{L}_{u}^{\\mathrm{rcg}}=\\frac{1}{N_{b}^{\\mathrm{fg}}} \\sum_{i=1}^{N_{b}^{\\mathrm{f}_{8}}} l_{\\mathrm{reg}}\\left(b_{i}^{\\mathrm{fg}}, \\mathcal{G}_{\\mathrm{reg}}\\right)\r$$\r$$ \\mathcal{L}_{u}=\\frac{1}{N_{u}} \\sum_{i=1}^{N_{u}}\\left(\\mathcal{L}_{u}^{\\mathrm{cls}}\\left(I_{u}^{i}, \\mathcal{G}_{\\mathrm{cls}}^{i}\\right)+\\mathcal{L}_{u}^{\\mathrm{rcg}}\\left(I_{u}^{i}, \\mathcal{G}_{\\mathrm{rcg}}^{i}\\right)\\right)\r$$\rExperiment 实验细节\n","permalink":"https://hugotest-phi.vercel.app/posts/ss_od_softteacher/","summary":"\u003cp\u003e@ Article: ICML from Microsoft \u0026amp; Huazhong Keda\n@ Code: \u003ca href=\"https://github.com/microsoft/SoftTeacher\" target=\"_blank\" rel=\"noopener\"\u003eGithub\u003c/a\u003e\n\n@ Noteby: Aikenhong\n@ Time: 20210914\u003c/p\u003e\n\u003ch2 id=\"abstrast-and-intro\"\u003eAbstrast and Intro\u003c/h2\u003e\n\u003cp\u003ein the session we will using describe the main idea of this article.\u003c/p\u003e\n\u003cp\u003e这篇文章的重点在于Soft Teacher，也就是用pseudo label做为弱标注，逐步提高伪标签的可靠性。\u003c/p\u003e\n\u003cp\u003e不同于多阶段的方法，端到端的方法再训练中逐步的提升伪标签的质量从而再去benifit目标检测的质量。\n这样E2E的框架主要依赖于两部分技术:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esoft teacher: 每个未标记边界框的分类损失由教师网络产生的分类分数进行加权\u003c/li\u003e\n\u003cli\u003ebox jitter 窗口抖动: 选择可靠的伪框来学习框回归\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在目标检测上获得SOTA的效果;\u003c/p\u003e\n\u003ch3 id=\"multi-stage\"\u003eMulti-Stage\u003c/h3\u003e\n\u003cp\u003e在半监督的情况下，关注的主要是基于伪标签的方法，是目前的SOTA，以往的方法采用多阶段的方式。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e使用标记数据训练初始检测器\u003c/li\u003e\n\u003cli\u003e未标记数据的伪标记，同时基于伪标签进行重新训练\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e局限\u003c/strong\u003e：初始少量标注的局限，初始的检测器的伪标签质量\u003c/p\u003e\n\u003ch3 id=\"end-to-end\"\u003eEnd to End\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eSoft Teacher\u003c/strong\u003e基本思路：对未标记的图像进行标记，然后通过标记的几个伪标签训练检测器.\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e具体而言：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e采样标注和未标注图片形成Batch\u003c/li\u003e\n\u003cli\u003e双模型：检测（student）、标记（teacher）\u003c/li\u003e\n\u003cli\u003eEMA：T模型是S模型的EMA\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这种方式避免了多阶段方案实现上的复杂，同时实现了飞轮效应==S、T相互加强;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e此外Soft Teacher\u003c/strong\u003e直接对学生模型生成的所有候选框进行评估，而不是使用伪框来为这些候选框进行分类回归。\n这样能使用更多的直接监督信息\u003c/p\u003e\n\u003cp\u003e具体而言：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e使用高阈值来分割前景，确保不会错误的将背景分类成前景，确保正伪标签的高精度；\u003c/li\u003e\n\u003cli\u003e使用可靠性度量来加权背景候选的损失；\u003c/li\u003e\n\u003cli\u003e教师模型产生的检测分数可以很好的作为可靠性度量\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eBox Jitter\u003c/strong\u003e为了更可靠的训练学生网络的本地分支，指的是：\u003c/p\u003e","title":"SS_OD_SoftTeacher"},{"content":"@Aikenhong 2021\nVim is a important consistant for editing file in shell. It\u0026rsquo;s Hightly Customized for Everyone, In this part I\u0026rsquo;ll Show my personal Vim comfigurations\nAnd I\u0026rsquo;ll Discuss about the diff between Spacevim \u0026amp; Neovim.\nGive a conclusion in advance: Recommand Config the Vim for Yourself\nYou only need to config once, then you should save it in the cloud. You will Know all the Keyshot you setting up, and you can customize it as you want. Based on neovim 基于NeoVim进行配置，不采用SpaveVim的配置文件，这里需要建议采用最新的测试版的NeoVim(\u0026gt;= 0.5)，Stable的NVim已经很久没有更新，对一些新的插件缺乏支持。\nInstall Installing Neovim Download NeoVim Package and Install from source\nor Install from neovim-ppa Like Following:\n1 2 3 sudo add-apt-repository ppa:neovim-ppa/unstable sudo apt-get update sudo apt-get install neovim 在安装了Python之后安装对NVim的适配\n1 2 pip install neovim pip install pynvim 同时在配置文件中设置\n1 2 let g:python3_host_prog=\u0026#39;/home/aikenhong/anaconda3/bin/python\u0026#39; \u0026#34; the path to your python\u0026#34; 检查python配置情况：\n1 2 3 ” check lang suppose for neovim “ focus on the python part :CheckHealth Update if we Install the old version of neovim(5.0 which install before add ppa), we can update by apt.\n1 2 3 4 5 6 # add the stable or unstable source for new nvim sudo add-apt-repository ppa:neovim-ppa/unstable sudo apt-get update # update your nvim sudo apt-get install --only-upgrade neovim Where is Config File 可以在vim中使用:version然后在其中调用:echo $MYVIMRC查看对应的vimrc存放的地址\nvim的配置文件地址：\n1 2 3 4 5 # this time is in ls -l /etc/vim/vimrc # or we can touch one in ls -l ~/.vim/vimrc nvim的配置文件的地址：\n1 2 ls -l ~/.config/nvim/init.vim # if not, touch one 有了配置文件以后就可以开始对Nvim进行配置\nBasic Config this part I\u0026rsquo;ll explain those basic configurations in Vim(NVim). Besides I will simplely introduce the syntax of .ini for writing config.\nBasic Setting nvim初始情况就是完全没有配置的记事本，但是相应的定制化程度高，下面这些是一些固定的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026#34;===========================基本配置 set nowrap \u0026#34; 不自动换行 set nu \u0026#34;显示行号 set clipboard=unnamed \u0026#34;共享剪切板 set nocompatible \u0026#34; 不适配vi避免不兼容 set backup \u0026#34;生成临时文件（maybe we should make it no） set noswapfile \u0026#34; i dont like swap files set history=1000 \u0026#34; 文件在外部被修改过，就重新读入 set sessionoptions+=globals \u0026#34; 延迟绘制提升性能 set lazyredraw \u0026#34; 显示确认 set confirm \u0026#34;set paste autocmd InsertLeave * set nopaste \u0026#34;结束插入模式的时候关闭paste 配置搜索视图：\n1 2 3 4 5 6 7 8 \u0026#34; 高亮搜索结果，逐词高亮 set hlsearch set incsearch \u0026#34; 搜索忽视大小写 set ignorecase set smartcase \u0026#34; 显示匹配的括号 set showmatch 配置Tab和Indent：\n1 2 3 4 5 6 7 8 ” tab 和indent设置 set tabstop=4 \u0026#34; Tab键的宽度 set expandtab set smarttab set shiftwidth=4 set autoindent set cindent set si 设置修改配置文件直接应用\n1 autocmd BufWritePost $MYVIMRC source $MYVIMRC 配置调试python,cpp,sh：使用F5执行输出，默认删除编译的c++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 set showcmd \u0026#34;show the cmd before carry out on vim map \u0026lt;F5\u0026gt; :call CompileRunGcc()\u0026lt;CR\u0026gt; func! CompileRunGcc() exec \u0026#34;w\u0026#34; if \u0026amp;filetype == \u0026#39;cpp\u0026#39; exec \u0026#39;!g++ % -o %\u0026lt;\u0026#39; exec \u0026#39;!time ./%\u0026lt;\u0026#39; exec \u0026#39;!rm ./%\u0026lt;\u0026#39; elseif \u0026amp;filetype == \u0026#39;python\u0026#39; exec \u0026#39;!python %\u0026#39; elseif \u0026amp;filetype == \u0026#39;sh\u0026#39; :!time sh % endif endfunc\u0026lt;Paste\u0026gt; \u0026#34;running python in nvim \u0026#34;nnoremap \u0026lt;F5\u0026gt; :echo system(\u0026#39;python3 \u0026#34;\u0026#39; . expand(\u0026#39;%\u0026#39;) . \u0026#39;\u0026#34;\u0026#39;)\u0026lt;cr\u0026gt; \u0026#34; running cpp in nvim \u0026#34; map \u0026lt;F8\u0026gt; :w \u0026lt;CR\u0026gt; :!g++ % -o %\u0026lt; \u0026amp;\u0026amp; ./%\u0026lt; \u0026lt;CR\u0026gt; \u0026#34; nnoremap \u0026lt;silent\u0026gt; \u0026lt;F8\u0026gt; :!clear;g++ % -o % \u0026amp;\u0026amp; ./%\u0026lt; \u0026lt;CR\u0026gt; 支持中文编码：\n1 2 3 set encoding=utf-8 set termencoding=utf-8 set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 支持鼠标操作：\n1 2 3 set mouse=a set selection=exclusive set selectmode=mouse,key Folding Setting THE RESULT AFTER SETTING WILL BE LIKE THIS\nAnd the Folding can be ：mark,indent,syntax\nThis is not the final version of folding setting, we will contiune complete it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026#34; https://www.cnblogs.com/zlcxbb/p/6442092.html \u0026#34; set foldmethod=indent set foldlevel=1 \u0026#34;预设开始时不收起 autocmd FileType vim set foldmarker={{{,}}} autocmd FileType vim set foldmethod=marker autocmd FileType vim set foldlevel=0 autocmd FileType python,cpp set foldmethod=indent autocmd FileType python,cpp set foldlevel=1 \u0026#34;autocmd FileType cpp set foldmethod=marker \u0026#34;autocmd FileType cpp set foldmarker={,} \u0026#34;autocmd FileType cpp set foldlevel=1 \u0026#34; let php_folding=1 set foldnestmax=3 Color And Theme(basic) Trending vim color schemes | vimcolorschemes 1 2 mkdir ~/.config/nvim/colors # them we dowmload theme in this dir 在Plug同级目录下创建colors文件夹，将对应的配色文件放到colors，autoload中，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 set wildmenu set background=dark colorscheme NeoSolarized highlight Visual cterm=NONE ctermbg=236 ctermfg=NONE guibg=Grey40 highlight LineNr cterm=none ctermfg=240 guifg=#2b506e guibg=#000000 \u0026#34; 背景透明 \u0026#34;hi Normal ctermfg=252 ctermbg=none \u0026#34;背景透明 autocmd vimenter * hi Normal guibg=NONE ctermbg=NONE \u0026#34; transparent bg “ 语法高亮，高亮当前行，当前列 syntax on set cul \u0026#34;highlight cursorline set cuc \u0026#34; set termguicolors set t_Co=256 \u0026#34; 设置状态栏 set laststatus=2 set ruler \u0026#34; set themes \u0026#34; gruvbox \u0026#34; colorscheme gruvbox ” =====================指定的主题设置 \u0026#34; NeoSolarized colorscheme NeoSolarized let g:neosolarized_termtrans=1 runtime ./colors/NeoSolarized.vim \u0026#34; Onedark \u0026#34; https://github.com/joshdick/onedark.vim \u0026#34; we should change this in the airline setting \u0026#34; colorscheme onedark \u0026#34; let g:airline_theme = \u0026#39;onedark\u0026#39; \u0026#34; space-vim-dark \u0026#34; https://github.com/liuchengxu/space-vim-dark \u0026#34; colorscheme space-vim-dark \u0026#34; hi Comment cterm=italic \u0026#34; hi LineNr ctermbg=NONE guibg=NONE \u0026#34; one-half \u0026#34; https://github.com/sonph/onehalf/tree/master/vim \u0026#34; colorscheme onehalfdark Mapping Shortcut 快捷键映射是配置自定义的核心内容，这一块会分享一些比较特别的映射。\nShortcut key mapping is the core content of configuration customization. This section will share some special mappings.\n快捷键配置 修改位置和方法 插件的默认配置 .config/nvim/plugins/NAME/PLUG.vim 1. 修改对应的快捷键\n2. 主配置文件中duplicate 对应的命令 默认的配置文件 在不同的命令下分别对应\n1. 普通模式下的映射\n2. 可视模式下的映射 配置使用\u0026lt;Alt\u0026gt;进行windows的切换\n1 2 3 4 5 \u0026#34; https://vim.fandom.com/wiki/Switch_between_Vim_window_splits_easily nmap \u0026lt;silent\u0026gt; \u0026lt;A-Up\u0026gt; :wincmd k\u0026lt;CR\u0026gt; nmap \u0026lt;silent\u0026gt; \u0026lt;A-Down\u0026gt; :wincmd j\u0026lt;CR\u0026gt; nmap \u0026lt;silent\u0026gt; \u0026lt;A-Left\u0026gt; :wincmd h\u0026lt;CR\u0026gt; nmap \u0026lt;silent\u0026gt; \u0026lt;A-Right\u0026gt; :wincmd l\u0026lt;CR\u0026gt; 配置tab和shift tab来实现vscode中的行缩进配置\n1 2 3 4 nmap \u0026lt;tab\u0026gt; V\u0026gt; nmap \u0026lt;S-tab\u0026gt; V\u0026lt; vmap \u0026lt;tab\u0026gt; Vg\u0026gt; vmap \u0026lt;S-tab\u0026gt; Vg\u0026lt; 特殊命令：\n1 2 3 4 \u0026#34; del the end space of line nnoremap \u0026lt;leader\u0026gt;de :%s/\\s\\+$//\u0026lt;cr\u0026gt;:let @/=\u0026#39;\u0026#39;\u0026lt;CR\u0026gt; \u0026#34; edit the nvim config file nnoremap \u0026lt;leader\u0026gt;ev :vsp $MYVIMRC\u0026lt;CR\u0026gt; 复制粘贴全选：\n1 2 3 4 5 map \u0026lt;C-A\u0026gt;ggVGY map! \u0026lt;C-A\u0026gt; \u0026lt;Esc\u0026gt;ggVGY map \u0026lt;F12\u0026gt; gg=G ” 选中状态下ctrl+c复制 vmap \u0026lt;C-c\u0026gt; \u0026#34;+y Plugs 插件是个性化配置的另一个核心点；Plugs is another core of personalized configuration\n使用插件来支持语法，外观，补全，文件管理 ；Use plugins to support syntax, appearance, completion, and file management ；\n安装插件的时候，如果遇到一些安装失败的时候，我们可以通过以下的命令来获取对应的详细信息:messages VIM-PLUG junegunn/vim-plug: Minimalist Vim Plugin Manager (github.com) 你只需打开终端并运行以下命令：\n1 curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim Neovim 用户可以使用以下命令安装 Vim-plug：\n1 curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 安装完插件管理器，我们可以在配置文件中通过一下的操作来安装插件：\n1 2 3 4 # 设置存放插件的地址 call plug#begin(\u0026#39;~/.config/nvim/plugged\u0026#39;) # 添加我们需要的插件 call plug#end() 常用的一些命令：\nCommand Desc PlugInstall Install Package PlugUpdate Update those packages PlugStatus Show The Status of all the package PlugClean Clean the error Plug or del those Plug not Define any more PlugUpgrade Update Vim-Plug itself 常用的一些命令优化下载速度更换源：\n加速vim-plug安装 ，cnpm，github 1 2 3 # 在调用call plug之前设置下载的源地址 # 这里实际上可以参考各种镜像站去写 let g:plug_url_format=\u0026#39;https://git::@hub.fastgit.org/%s.git\u0026#39; 或者我们借助Windows主机的代理服务器来对Github进行加速，如果存在稳定的代理的话，这个方式可能是更优的一个 参考[[Envs/Windows.md]]中的Proxy\nLangs Support 这一部分介绍各种语言的支持LSP，以及对应的配置操作。\nAppendix Add Header for Langs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 “ head can write like this \u0026#34; 新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.py exec \u0026#34;:call SetTitle()\u0026#34; \u0026#34;\u0026#34;定义函数SetTitle，自动插入文件头 func SetTitle() \u0026#34;如果文件类型为.sh文件 if \u0026amp;filetype == \u0026#39;sh\u0026#39; call setline(1, \u0026#34;##########################################################################\u0026#34;) call append(line(\u0026#34;.\u0026#34;), \u0026#34;# File Name: \u0026#34;.expand(\u0026#34;%\u0026#34;)) call append(line(\u0026#34;.\u0026#34;)+1, \u0026#34;# Author: AikenHong \u0026#34;) call append(line(\u0026#34;.\u0026#34;)+2, \u0026#34;# mail: h.aiken.970@gmail.com\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+3, \u0026#34;# Created Time: \u0026#34;.strftime(\u0026#34;%c\u0026#34;)) call append(line(\u0026#34;.\u0026#34;)+4, \u0026#34;\u0026#34;) endif if \u0026amp;filetype == \u0026#39;cpp\u0026#39; call setline(1, \u0026#34;/*\u0026#34;) call append(line(\u0026#34;.\u0026#34;), \u0026#34;# File Name: \u0026#34;.expand(\u0026#34;%\u0026#34;)) call append(line(\u0026#34;.\u0026#34;)+1, \u0026#34;# Author: AikenHong \u0026#34;) call append(line(\u0026#34;.\u0026#34;)+2, \u0026#34;# mail: h.aiken.970@gmail.com\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+3, \u0026#34;# Created Time: \u0026#34;.strftime(\u0026#34;%c\u0026#34;)) call append(line(\u0026#34;.\u0026#34;)+4, \u0026#34; */\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+5, \u0026#34; \u0026#34;) call append(line(\u0026#34;.\u0026#34;)+6, \u0026#34;#include \u0026lt;iostream\u0026gt;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+7, \u0026#34;#include \u0026lt;algorithm\u0026gt;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+8, \u0026#34;#include \u0026lt;vector\u0026gt;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+9, \u0026#34;#include \u0026lt;stack\u0026gt;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+10, \u0026#34;#include \u0026lt;queue\u0026gt;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+11, \u0026#34;#include \u0026lt;list\u0026gt;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+12, \u0026#34;#include \u0026lt;map\u0026gt;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+13, \u0026#34;#include \u0026lt;cmath\u0026gt;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+14, \u0026#34;#include \u0026lt;set\u0026gt;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+15, \u0026#34;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+16, \u0026#34;using namespace std;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+17, \u0026#34;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+18, \u0026#34;int main()\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+19, \u0026#34;{\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+20, \u0026#34; \u0026#34;) call append(line(\u0026#34;.\u0026#34;)+21, \u0026#34; \u0026#34;) call append(line(\u0026#34;.\u0026#34;)+22, \u0026#34; return 0;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+23, \u0026#34;}\u0026#34;) endif if \u0026amp;filetype == \u0026#39;python\u0026#39; call setline(1, \u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34;) call append(line(\u0026#34;.\u0026#34;), \u0026#34;# File Name: \u0026#34;.expand(\u0026#34;%\u0026#34;)) call append(line(\u0026#34;.\u0026#34;)+1, \u0026#34;# Author: AikenHong \u0026#34;) call append(line(\u0026#34;.\u0026#34;)+2, \u0026#34;# mail: h.aiken.970@gmail.com\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+3, \u0026#34;# Created Time: \u0026#34;.strftime(\u0026#34;%c\u0026#34;)) call append(line(\u0026#34;.\u0026#34;)+4, \u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34;) call append(line(\u0026#34;.\u0026#34;)+5, \u0026#34;\u0026#34;) endif \u0026#34;新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal G endfunction Dependency This Session I’ll intrduce some dependency for those PLUGs and the env\nReference Yggdroot/LeaderF : basic config and keyshort setting liuchengxu/vim-which-key Config your which key vim-airline-themes Vim Awesome plasticboy/vim-markdown Neovim+Coc.nvim配置 目前个人最舒服终端编辑环境(Python\u0026amp;C++) - zprhhs - 博客园 (cnblogs.com) init.vim · SpringHan/nvim - Gitee.com Python ； C ：Using g++ instead of gcc will support C++ Configuration File COC安装注意事项 安装npm，node\n1 npm install -g neovim build/index.js not found, please install dependencies and compile coc.nvim by: yarn insta\n切换到coc目录，yarn install，\n1 2 3 cd ~/.config/nvim/plugged/coc.nvim yarn install yarn build 安装clang：\nGetting started (llvm.org) Airline Install Powerline Font powerline/fonts: Patched fonts for Powerline users. (github.com) Tagbar 该安装依赖于ctags为了支持Markdown情况下的Tagbar,这里推荐安装Universal Ctags\n使用镜像站clone\n1 2 3 cd .install/ sudo git clone https://github.com.cnpmjs.org/universal-ctags/ctags.git cd ctags 安装前置依赖\n1 2 3 4 5 6 7 8 9 10 11 12 sudo apt-get install make \\ autoconf \\ ppkg-config sudo apt install \\ gcc make \\ pkg-config autoconf automake \\ python3-docutils \\ libseccomp-dev \\ libjansson-dev \\ libyaml-dev \\ libxml2-dev 在ctags目录下安装\n1 2 3 4 ./autogen.sh ./configure --prefix=/where/you/want # defaults to /usr/local make sudo make install 验证安装成功与否\n1 2 3 ctags # sueecess will output # ctags: No files specified. Try \u0026#34;ctags --help\u0026#34; support markdown Add those into vimrc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 let g:tagbar_type_markdown = { \\ \u0026#39;ctagstype\u0026#39; : \u0026#39;markdown\u0026#39;, \\ \u0026#39;kinds\u0026#39; : [ \\ \u0026#39;c:chapter:0:1\u0026#39;, \\ \u0026#39;s:section:0:1\u0026#39;, \\ \u0026#39;S:subsection:0:1\u0026#39;, \\ \u0026#39;t:subsubsection:0:1\u0026#39;, \\ \u0026#39;T:l4subsection:0:1\u0026#39;, \\ \u0026#39;u:l5subsection:0:1\u0026#39;, \\ ], \\ \u0026#39;sro\u0026#39; : \u0026#39;\u0026#34;\u0026#34;\u0026#39;, \\ \u0026#39;kind2scope\u0026#39; : { \\ \u0026#39;c\u0026#39; : \u0026#39;chapter\u0026#39;, \\ \u0026#39;s\u0026#39; : \u0026#39;section\u0026#39;, \\ \u0026#39;S\u0026#39; : \u0026#39;subsection\u0026#39;, \\ \u0026#39;t\u0026#39; : \u0026#39;subsubsection\u0026#39;, \\ \u0026#39;T\u0026#39; : \u0026#39;l4subsection\u0026#39;, \\ }, \\ \u0026#39;scope2kind\u0026#39; : { \\ \u0026#39;chapter\u0026#39; : \u0026#39;c\u0026#39;, \\ \u0026#39;section\u0026#39; : \u0026#39;s\u0026#39;, \\ \u0026#39;subsection\u0026#39; : \u0026#39;S\u0026#39;, \\ \u0026#39;subsubsection\u0026#39; : \u0026#39;t\u0026#39;, \\ \u0026#39;l4subsection\u0026#39; : \u0026#39;T\u0026#39;, \\ }, \\ } Startify 起始页设置 Code Yarns – How to create ASCII art of text using FIGlet Vim project switcher using Startify (ricostacruz.com) Improve NPM download Download Npm Improve 临时设置：\n1 npm --registry https://registry.npm.taobao.org install express 全局使用：\n1 npm config set registry https://registry.npm.taobao.org 验证配置是否成功:\n1 npm config get registry 通过cnpm使用：\n1 npm install -g cnpm --registry=https://registry.npm.taobao.org Vim中执行程序 Markdown Preview WSL 在WSL中无法调出preview的问题，运行时使用message查看err，若为\u0026rsquo;Cannot find module \u0026rsquo;tslib\u0026rsquo;':\n到插件目录执行`yarn install`或者`npm install`\rSplit Windwos 窗口切分 this part is about windows split which is like tmux. vim的窗口切分命令,在命令行的模式下执行\n1 2 3 4 :vsp filepath/filename # 垂直切分屏幕 :sp filepath/filename # 横向切分屏幕 窗口,缓冲区切换快捷键\n1 2 3 4 5 6 # cursor change in diff windows ctrl + \u0026lt;- -\u0026gt; ctrl + w + direction # change buffer in diff tabs alt + \u0026lt;- -\u0026gt; Vim Folding 折叠 vim折叠快捷键 Vim Grammer 特殊用法 Using Vim KEYSHORT like write an article with special grammar. In the way, there\u0026rsquo;ll be some interesting usage. 这里有一些有趣的用法，通过vim的语法可以列出来\nVoice 语态 动词：r replace, d delete, y yank, f find, v visual 介词: i in, a around, t to, f forward 名词: w word, p paragraph, t tag, s sentence\n","permalink":"https://hugotest-phi.vercel.app/posts/vimconfig/","summary":"\u003cp\u003e@Aikenhong 2021\u003c/p\u003e\n\u003cp\u003eVim is a important consistant for editing file in shell. It\u0026rsquo;s Hightly Customized for Everyone, In this part I\u0026rsquo;ll Show my personal Vim comfigurations\u003c/p\u003e\n\u003cp\u003eAnd I\u0026rsquo;ll Discuss about the diff between Spacevim \u0026amp; Neovim.\u003c/p\u003e\n\u003cp\u003eGive a conclusion in advance: \u003cstrong\u003eRecommand Config the Vim for Yourself\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou only need to config once, then you should save it in the cloud.\u003c/li\u003e\n\u003cli\u003eYou will Know all the Keyshot you setting up, and you can customize it as you want.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20211014192437083.png\"\u003e\r\n    \u003cimg alt=\"image-20211014192437083\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20211014192437083.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20211014192437083.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20211014192437083\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Vim Configuration 02 Nvim的插件配置"},{"content":" 该配置笔记于 20230521 重新整理。默认的 Vimrc 位置为 /usr/share/vim/vimrc，也可以在 vim 界面使用 :echo $MYVIMRC 查看当前的配置文件，默认使用的配置文件地址为 ~/.vimrc\n参考文献地址：Good VimRC | Backspace | AutoCmd | VIM配置入门 配置文件地址：AikenDotfile ，本文这里只介绍部分配置，一些过于常见的配置等等这里就不再介绍，在 dotfile 中对每行配置均有的细致的注释。\n基于 VimScript） 该 blog 主要记录基础 vim 的配置文件编写，旨在使用基础 vim 的时候也能有一个较好的代码编辑体验，同时提供部分 keymap 集成一些简单的功能，方便文档编写时候的格式转换等。这个配置文件在后续配置 nvim 的时候部分配置也会沿用。\nVim 的基础配置 自动检测文件修改，以及对多个文件的 workspace 自动切换\n1 2 3 \u0026#34; \u0026gt;\u0026gt;0-1 state detection. set autoread \u0026#34; when file change outside, we will know set autochdir \u0026#34; change workspace when we swtich file, when we open multi-file in one session. 鼠标和剪切板功能 设置 vim 对鼠标的支持，支持鼠标选择等\n1 2 3 4 5 6 \u0026#34; reference the web get the best setting and use it always \u0026#34; suppose the mouse operation \u0026#34; but this function not work well in the weterm, we disable this part for work. set mouse=a \u0026#34;set selection=exclusive \u0026#34;set selectmode=mouse,key 设置和系统同步的剪切板，WSL 下的剪切板设置可以参考下面文章 WSL2 clipboard not shared between Linux and Windows || Reddit - Dive into anything 1 2 3 4 5 6 7 8 9 10 11 \u0026#34; set the clipboard set clipboard+=unnamed \u0026#34; WSL yank support let s:clip = \u0026#39;/mnt/c/WINDOWS/system32/clip.exe\u0026#39; \u0026#34; change this path according to your mount point if executable(s:clip) augroup WSLYank autocmd! autocmd TextYankPost * if v:event.operator ==# \u0026#39;y\u0026#39; | call system(s:clip, @0) | endif augroup END endif 设置撤销历史记录 多次编辑同一个文件的时候保持 Undo 的历史记录，便于对同一个文件进行编辑。\n1 2 3 4 \u0026#34; \u0026gt;\u0026gt;0-2 keep file history set undofile \u0026#34; keep the undo history in file. set undodir=~/.vim/.undo// set history=1000 通过上述命令启用 undofile 的选项，并设置存储目录，这里需要注意的是，存储目录需要手动创建，undo 的历史记录才能生效。\n搜索选项 搜索部分主要有以下的几个事：显示匹配的括号，逐字搜索，搜索高亮，忽略大小写\n1 2 3 4 5 \u0026#34; \u0026gt;\u0026gt;1-3 Search Setting set showmatch \u0026#34; highlight match parentheses set incsearch \u0026#34; search as characters are entered set hlsearch \u0026#34; highlight the search result. set ignorecase \u0026#34; ignore cases when searching 其中需要注意的是，vim 中的搜索高亮不会自动关闭，因此我们需要设置快捷键映射来关闭搜索的高亮。\n1 nnoremap \u0026lt;leader\u0026gt;ss :nohlsearch\u0026lt;CR\u0026gt; \u0026#34; turn off the highlight, bcus it will not auto close. 其他设置 1 set backspace=indent,eol,start \u0026#34; help to del special character.(or =2) 基本用户界面设置 设置滚动行和上下的间距：\n1 set scrolloff=10 设置折行及折行不破坏单词完整性：\n1 2 3 set wrap \u0026#34; wrap line and if line is too long set linebreak \u0026#34; Line breaks do not break the word. \u0026#34; set textwidth=80 \u0026#34; how many chacter in oneline 状态栏设置 首先设置命令窗口的大小，并使得状态栏仅在多文件窗口时打开，便于区分不同文件\n1 2 3 4 5 6 7 \u0026#34; \u0026gt;\u0026gt;2-3 Status Line Setting set cmdheight=2 \u0026#34; set the cmd line height set laststatus=1 \u0026#34; enable:2 only in multi windows:1 off:0 set ruler \u0026#34; show row,col of cursor in status line. \u0026#34; reference : https://blog.csdn.net/strategycn/article/details/7620261 set statusline=%F%m%r%h%w\\ [FORMAT=%{\u0026amp;ff}]\\ [TYPE=%Y]\\ [POS=%04l,%04v][%p%%]\\ [LEN=%L]\\ [TIME=%{strftime(\u0026#39;%c\u0026#39;)}] 设置 VIm 的 CMD 指令显示状态以及补全办法：\n1 2 3 4 5 6 \u0026#34; \u0026gt;\u0026gt;2-4 Command hint. set showcmd \u0026#34; show the command we just type in. like 2d set showmode \u0026#34; show insert or command mode now (seems like not working) \u0026#34; \u0026gt;\u0026gt;2-5 show Bottom CMD Menu set wildmenu \u0026#34; show completion list. 光标位置记录 1 2 3 4 5 6 7 \u0026#34; \u0026gt;\u0026gt;2-7 return to last edit pos when open same files. autocmd BufReadPost * \\ if line(\u0026#34;\u0026#39;\\\u0026#34;\u0026#34;) \u0026gt; 0 \u0026amp;\u0026amp; line(\u0026#34;\u0026#39;\\\u0026#34;\u0026#34;) \u0026lt;= line(\u0026#34;$\u0026#34;) | \\ exe \u0026#34;normal! g`\\\u0026#34;\u0026#34; | \\ endif \u0026#34; Remember info about open buffers on close set viminfo^=% 缩进方法和折叠 这里只以 Python 为例介绍默认的 indent 方案，同时 folder 这里只介绍 marker 方法，用 {{{}}} 来进行折叠，不同文件的 indent 方案用 filetype 和 autocmd 实现，具体参见配置文件中的 Part8.\n缩进 1 2 3 4 5 6 7 8 9 10 \u0026#34; \u0026gt;\u0026gt;3.1 Indent (c-style) set ai \u0026#34;autoindent, keep same indent with prev line. set si \u0026#34;smartindent, add {, # special situation of ai. (for c or java) \u0026#34; \u0026gt;\u0026gt;3.2 Tab(better using autocmd) set tabstop=4 \u0026#34;tab==\u0026lt;n\u0026gt; space set softtabstop=4 \u0026#34;when we type in tab == \u0026lt;n\u0026gt; space set shiftwidth=4 \u0026#34;the auto indet(when change line or using \u0026gt; or \u0026lt; ) will be \u0026lt;n\u0026gt; better keep it same with tab. set smarttab \u0026#34;will change \u0026lt;n\u0026gt; basis on others in this file. set expandtab \u0026#34;make all tab as space 这里的 \u0026lt;n\u0026gt; 指的是空格的个数，具体的设置和注释如上，后续基于不同的文件类型进行配置的需要打开如下的内容：\n1 2 3 4 5 6 \u0026#34; \u0026gt;\u0026gt;3.3 specific indent file. \u0026#34; load filetype-specific indent files. \u0026#34; *.py will load ~/.vim/indent/python.vim file filetype on filetype plugin on filetype indent on 其他内容参见 dotfile，使用 autocmd 对不同文件的缩进进行区分设置。\n折叠 1 2 3 4 5 6 \u0026#34; -----------------------6.Folder{{{----------------------------- set foldenable \u0026#34; enable fold function set foldlevelstart=10 \u0026#34; fold level at start. 0: all be closed; 99: always open. set foldnestmax=10 \u0026#34; 10 nested fold max set foldmethod=marker \u0026#34; could be indent. mark should use {{{}}} \u0026#34;try help foldmethod 将折叠全开后的效果如下：\n快捷键和函数 快捷键和函数的数量较多，这里不详细说，具体查看 dotfile，这里简要说明以下主要实现了哪些 KeyMap。\n这里通过快捷键和函数实现了如下的一些功能。\n用 TAB 和 SHIFT-TAB 调整缩进 Toggle Wrap、Spell、Number、Paste 快捷编辑配置文件 Windows、Tab 切换 快捷注释 Tailing 和 Retab 编译和执行当前代码文件 自动添加指定的文件头（如 blog 的 meta 文件） 由于篇幅限制就不再赘述。\n自动注释 感谢大神 KarimElghamry 提供的方案，可以直接将其代码拷贝到自己的 vmrc 中来实现行注释和块注释，也可以很轻易的添加不同后缀的处理方式。\nFI 该版本的 Vimrc 应该是个人的最终版本了，如果有其他的点子和需求的话，欢迎到评论区讨论，如果有更新的话也会在这个 dotfile 上更新。\n","permalink":"https://hugotest-phi.vercel.app/posts/vimconfigdf/","summary":"\u003cblockquote\u003e\n\u003cp\u003e该配置笔记于 20230521 重新整理。默认的 Vimrc 位置为 \u003ccode\u003e/usr/share/vim/vimrc\u003c/code\u003e，也可以在 vim 界面使用 \u003ccode\u003e:echo $MYVIMRC\u003c/code\u003e 查看当前的配置文件，默认使用的配置文件地址为 \u003ccode\u003e~/.vimrc\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e参考文献地址：\u003ca href=\"https://dougblack.io/words/a-good-vimrc.html\" target=\"_blank\" rel=\"noopener\"\u003eGood VimRC\u003c/a\u003e\n | \u003ca href=\"https://segmentfault.com/a/1190000021029480\" target=\"_blank\" rel=\"noopener\"\u003eBackspace\u003c/a\u003e\n | \u003ca href=\"https://zhuanlan.zhihu.com/p/98360630\" target=\"_blank\" rel=\"noopener\"\u003eAutoCmd\u003c/a\u003e\n | \u003ca href=\"https://www.ruanyifeng.com/blog/2018/09/vimrc.html\" target=\"_blank\" rel=\"noopener\"\u003eVIM配置入门\u003c/a\u003e\n\n配置文件地址：\u003ca href=\"https://github.com/AikenH/aikenh-dotfile/tree/main/vim-dot\" target=\"_blank\" rel=\"noopener\"\u003eAikenDotfile\u003c/a\u003e\n，本文这里只介绍部分配置，一些过于常见的配置等等这里就不再介绍，在 dotfile 中对每行配置均有的细致的注释。\u003c/p\u003e\n\u003cp\u003e基于 VimScript） 该 blog 主要记录基础 vim 的配置文件编写，旨在使用基础 vim 的时候也能有一个较好的代码编辑体验，同时提供部分 keymap 集成一些简单的功能，方便文档编写时候的格式转换等。这个配置文件在后续配置 nvim 的时候部分配置也会沿用。\u003c/p\u003e\n\u003ch2 id=\"vim-的基础配置\"\u003eVim 的基础配置\u003c/h2\u003e\n\u003cp\u003e自动检测文件修改，以及对多个文件的 workspace 自动切换\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-vim\" data-lang=\"vim\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026#34; \u0026gt;\u0026gt;0-1 state detection.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eset\u003c/span\u003e \u003cspan class=\"nx\"\u003eautoread\u003c/span\u003e \u003cspan class=\"c\"\u003e\u0026#34; when file change outside, we will know\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eset\u003c/span\u003e \u003cspan class=\"nx\"\u003eautochdir\u003c/span\u003e \u003cspan class=\"c\"\u003e\u0026#34; change workspace when we swtich file, when we open multi-file in one session.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"鼠标和剪切板功能\"\u003e鼠标和剪切板功能\u003c/h3\u003e\n\u003cp\u003e设置 vim 对鼠标的支持，支持鼠标选择等\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-vim\" data-lang=\"vim\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026#34; reference the web get the best setting and use it always\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026#34; suppose the mouse operation\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026#34; but this function not work well in the weterm, we disable this part for work.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eset\u003c/span\u003e \u003cspan class=\"nx\"\u003emouse\u003c/span\u003e\u003cspan class=\"p\"\u003e=\u003c/span\u003e\u003cspan class=\"nx\"\u003ea\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026#34;set selection=exclusive\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026#34;set selectmode=mouse,key\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e设置和系统同步的剪切板，WSL 下的剪切板设置可以参考下面文章 \u003ca href=\"https://github.com/microsoft/WSL/issues/4440\" target=\"_blank\" rel=\"noopener\"\u003eWSL2 clipboard not shared between Linux and Windows\u003c/a\u003e\n || \u003ca href=\"https://www.reddit.com/r/bashonubuntuonwindows/comments/be2q3l/comment/el2vx7u/?utm_source#\" target=\"_blank\" rel=\"noopener\"\u003eReddit - Dive into anything\u003c/a\u003e\n\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-vim\" data-lang=\"vim\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026#34; set the clipboard\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eset\u003c/span\u003e \u003cspan class=\"nx\"\u003eclipboard\u003c/span\u003e\u003cspan class=\"p\"\u003e+=\u003c/span\u003e\u003cspan class=\"nx\"\u003eunnamed\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026#34; WSL yank support\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003es\u003c/span\u003e:\u003cspan class=\"nx\"\u003eclip\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;/mnt/c/WINDOWS/system32/clip.exe\u0026#39;\u003c/span\u003e  \u003cspan class=\"c\"\u003e\u0026#34; change this path according to your mount point\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nx\"\u003eexecutable\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003es\u003c/span\u003e:\u003cspan class=\"nx\"\u003eclip\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003eaugroup\u003c/span\u003e \u003cspan class=\"nx\"\u003eWSLYank\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eautocmd\u003c/span\u003e\u003cspan class=\"p\"\u003e!\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eautocmd\u003c/span\u003e \u003cspan class=\"nx\"\u003eTextYankPost\u003c/span\u003e * \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nx\"\u003ev\u003c/span\u003e:\u003cspan class=\"nx\"\u003eevent\u003c/span\u003e.\u003cspan class=\"nx\"\u003eoperator\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e# \u003cspan class=\"s1\"\u003e\u0026#39;y\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"nx\"\u003ecall\u003c/span\u003e \u003cspan class=\"nx\"\u003esystem\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003es\u003c/span\u003e:\u003cspan class=\"nx\"\u003eclip\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e @\u003cspan class=\"m\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"k\"\u003eendif\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003eaugroup\u003c/span\u003e \u003cspan class=\"nx\"\u003eEND\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eendif\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"设置撤销历史记录\"\u003e设置撤销历史记录\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e多次编辑同一个文件的时候保持 Undo 的历史记录，便于对同一个文件进行编辑。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-vim\" data-lang=\"vim\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026#34; \u0026gt;\u0026gt;0-2 keep file history\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eset\u003c/span\u003e \u003cspan class=\"nx\"\u003eundofile\u003c/span\u003e \u003cspan class=\"c\"\u003e\u0026#34; keep the undo history in file.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eset\u003c/span\u003e \u003cspan class=\"nx\"\u003eundodir\u003c/span\u003e\u003cspan class=\"p\"\u003e=~\u003c/span\u003e\u003cspan class=\"sr\"\u003e/.vim/\u003c/span\u003e.\u003cspan class=\"nx\"\u003eundo\u003c/span\u003e\u003cspan class=\"sr\"\u003e//\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eset\u003c/span\u003e \u003cspan class=\"nx\"\u003ehistory\u003c/span\u003e\u003cspan class=\"p\"\u003e=\u003c/span\u003e\u003cspan class=\"m\"\u003e1000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e通过上述命令启用 undofile 的选项，并设置存储目录，这里需要注意的是，\u003cstrong\u003e存储目录需要手动创建\u003c/strong\u003e，undo 的历史记录才能生效。\u003c/p\u003e","title":"Vim Configuration 01 vim的无插件基础设置"},{"content":"StyleGAN V1 @AikenHong 2020 10.8\n《A Style-Based Generator Architecture for Generative Adversarial Networks》\nRelated Work： 继承的文献工作： ProGAN 参考解读：\n《其中子链接值得一看》 （包括源码解析啥的）（甚至还有GAN的笔记） 《StyleGan源码解析和拓展应用》 《秃头生成器1》 《秃头生成器2》 NO.3 Contribution（Problem）：\n解纠缠：Mapping Network Noise Generator AdaIN before all conv Structure： Part1：AdaIN 复习一下IN（inception normalization）\n$$ AdaIN(x_i,y) = y_{s,i}\\frac{x_i-\\mu(x_i)}{\\sigma(x_i)}+y_{b,i}\r$$\rPart2：Noise Generator 通过独立分辨率的高斯误差生成器，独立生成误差，然后控制例如毛发，胡须，雀版等等的随机生成。\nPart3 解纠缠（Mapping Function） 解纠缠定义：由线性空间组成的潜在空间，使得每个线性子空间控制一个变化因子。\n如果使用原始输入的话，潜在空间各种因子的采样概率需要与训练数据集中的分布匹配，各factor就还是纠缠在一起，不能使得较好的独立性存在。\n解决方法：\n通过Mapping Network，将input Z -\u0026gt; W，在 W这个latent layer中提取出来的factor，就不需要遵循既有的分布，实现了解纠缠，使得各个变量能够独立的对特征进行控制。\n附加问题：\n如何衡量解纠缠效果，空间因子的分离程度：“线性空间中的插值可能对图像产生非线性变化”基于latent space中的变化和图像发生的变化来衡量分离的效果，潜伏空间中较小的变化也应该导致的是图像上较小（平滑）的变化。\n度量标准：\n基于感知的图像对距离**：**\n（通过2个加权VGG16 Embedding 之间的距离），假如我们再潜在空间的分割时线性的，也就是每一段都是线性路径，就能使得线性变化成立，理论上无限细分是可行的，实际上使用Σ = 1e-4,所以Z中平均的感知距离为：Lz，同理求得W中的Lw\n线性可分离性**：**\n\u0026ldquo;如果充分的解纠缠，则应该找到始终和各个变化因素相对应的方向向量\u0026rdquo;。该度量标准是通过量化线性超平面，能够将隐含空间的点分成两个独立的集合的程度。这样每个集合能够对应图像的特定二值属性。（男女）\n在判别过程中使用和判别器又相同架构的分类器：保留属性，生成图像，进行分类，去除低置信度，得到带标签的钱再空间向量，svm预测标签，进行分类，计算条件熵\n球面插值是归一化输入隐层空间中进行插值的最佳方法。\n没有归一化的情况下就使用线性插值就好了\nV2 Analyzing and Improving the Image Quality of StyleGAN Relted Work：Based on styleGAN.\n中文译文 Contribution（Problem）：\n重新设计了生成器归一化方法，改善了图像的质量： 同时路径长度调节器使得生成器的过程可逆，从而实现了网络可视化和方便对网络结构进行分析。 解决生成图像中水滴伪影的问题，将StyleGAN中的感知路径作为新的正则化器。\nPart1：修改AdaIN的具体执行，消除伪像**\n架构变化主要是：B-\u0026gt;C-\u0026gt;D\n","permalink":"https://hugotest-phi.vercel.app/posts/stylegan/","summary":"\u003ch1 id=\"stylegan-v1\"\u003eStyleGAN V1\u003c/h1\u003e\n\u003cp\u003e@AikenHong 2020 10.8\u003c/p\u003e\n\u003cp\u003e《A Style-Based Generator Architecture for Generative Adversarial Networks》\u003c/p\u003e\n\u003ch2 id=\"related-work\"\u003eRelated Work：\u003c/h2\u003e\n\u003cp\u003e继承的文献工作： ProGAN\n参考解读：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/a312863063/article/details/88795147\" target=\"_blank\" rel=\"noopener\"\u003e《其中子链接值得一看》\u003c/a\u003e\n（包括源码解析啥的）（甚至还有GAN的笔记）\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.gwylab.com/pdf/Note_StyleGAN.pdf\" target=\"_blank\" rel=\"noopener\"\u003e《StyleGan源码解析和拓展应用》\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://cuijiahua.com/blog/2020/07/dl-22.html\" target=\"_blank\" rel=\"noopener\"\u003e《秃头生成器1》\u003c/a\u003e\n\u003ca href=\"https://cloud.tencent.com/developer/article/1658228\" target=\"_blank\" rel=\"noopener\"\u003e《秃头生成器2》 \u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/swlh/hairstyle-transfer-semantic-editing-gan-latent-code-b3a6ccf91e82\" target=\"_blank\" rel=\"noopener\"\u003eNO.3\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eContribution（Problem）：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e解纠缠：Mapping Network\u003c/li\u003e\n\u003cli\u003eNoise Generator\u003c/li\u003e\n\u003cli\u003eAdaIN before all conv\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"structure\"\u003eStructure：\u003c/h2\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210930135941.png\"\u003e\r\n    \u003cimg alt=\"image-20210930135938114\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210930135941.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210930135941.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210930135938114\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210930161259.png\"\u003e\r\n    \u003cimg alt=\"image-20210930161258031\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210930161259.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210930161259.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210930161258031\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"StyleGAN"},{"content":"@Aiken 2021\n框架撞车系列，主要看看这一篇论文中怎么解决如下的问题👇，并从中借鉴和优化的我框架设计\n思路分析 Motivation 模型实现的主要的两个TASK：\nOpen Set Learning ： 在没有明确监督的时候，将尚未引入的目标类别识别为未知 Incremental Learning：类别增量学习 实现这两个问题的主要思路：\n自动标注：借鉴RPN的class-agnostic，以及检测和分类的显著性指标的差异，找到并自动标注NewClass **对比聚类：**使用prototype feature来进行聚类，同时计算Distance损失 it seems like contain a unknown prototype. **energy based：**亥姆霍兹自由能公式？ ENERGY BASED Feature： $F$ , Label: $L$ , Energy: $E(F,l)$\n能量函数倾向于将已知的类别分类到低熵的分布上，然后我们可以根据特征在能量空间上的划分来区分新类和旧类。然后我们可以根据logits表达的softmax形式，找到输出和Gibbs distribution的相关性：\n$$ p(l \\mid \\boldsymbol{f})=\\frac{\\exp \\left(\\frac{g_{l}(\\boldsymbol{f})}{T}\\right)}{\\sum_{i=1}^{\\mathrm{C}} \\exp \\left(\\frac{g_{i}(\\boldsymbol{f})}{T}\\right)}=\\frac{\\exp \\left(-\\frac{E(\\boldsymbol{f}, l)}{T}\\right)}{\\exp \\left(-\\frac{E(\\boldsymbol{f})}{T}\\right)}\r$$\r通过这个相关性，我们对自由能进行一个定义，以logits的形式表达\n$$ E(f:g) = -T log\\sum_{i=1}^{C}exp(\\frac{g_i(f)}{T})\r$$\rg实际上表示特征最后输出的logits，通过能量的映射函数，我们将聚类转移到能量域上做，置信度较高的类别和未知的新类实际上有一个比较明显区分的分界线。\n实际上我觉得就是类似熵的形式，在本文中将softmax的形式和gibis自由能做了一个对比，然后相当于对logits映射到了能量的维度去做特征的对比聚类，同时也能看出，在能量这个隐层空间中，在能级上能对已知类别和未知类别之间有一个明显的区分，所以在能级上进行划分是一个比较合理的空间映射形式。\nAlleviating Forgetting 参数正则化方法：exemplar replay：动态扩张网络；元学习\n增量学习中提到的一些贪婪的参数选择策略好像对SOTA的方法都有很大的优势；后续又有人发现存储少量的示例和replay的有效性在相关的Few-Shot Detect中式有效的。\n本文采用相对简单的ORE方法来减缓灾难性遗忘的问题，也就是说存放了一组平衡的范例，在每个增量步骤后对模型进行微调，确保每个类最少有 $N_{ex}$ 个示例出现在例子集中。\n实际上说的就是每次增量学习之后都会进行数据集的混合然后朝着原本的方向进行一定的微调；好像也没有什么特别的把，具体的实现可能要参见代码。\nWorkflow 我认为是通过RPN和class-aware之间的插值直接直接标注的一个未知的类别，然后在后续直接让人类区标注感兴趣的样本，可能是从少到多的，并没有一个特定的POOL，原本的模型可能有预留的Unknown Class或者说是相应的预留输出节点，然后在获得新的数据标注之后，进行更新模型的训练，然后使用避免灾难性遗忘的策略去做，从而使得模型对新的类别存在认知，也不会忘记旧的类别的知识。\n","permalink":"https://hugotest-phi.vercel.app/posts/ow-od/","summary":"\u003cp\u003e@Aiken 2021\u003c/p\u003e\n\u003cp\u003e框架撞车系列，主要看看这一篇论文中怎么解决如下的问题👇，并从中借鉴和优化的我框架设计\u003c/p\u003e\n\u003ch2 id=\"思路分析\"\u003e思路分析\u003c/h2\u003e\n\u003ch3 id=\"motivation\"\u003eMotivation\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e模型实现的主要的两个TASK：\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eOpen Set Learning ： 在没有明确监督的时候，将尚未引入的目标类别识别为未知\u003c/li\u003e\n\u003cli\u003eIncremental Learning：类别增量学习\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e实现这两个问题的主要思路：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e自动标注\u003c/strong\u003e：借鉴RPN的class-agnostic，以及检测和分类的显著性指标的差异，找到并自动标注NewClass\u003c/li\u003e\n\u003cli\u003e**对比聚类：**使用prototype feature来进行聚类，同时计算Distance损失\nit seems like contain a unknown prototype.\u003c/li\u003e\n\u003cli\u003e**energy based：**亥姆霍兹自由能公式？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210412171723896.png\"\u003e\r\n    \u003cimg alt=\"image-20210412171723896\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210412171723896.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210412171723896.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210412171723896\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch3 id=\"energy-based\"\u003e\u003cstrong\u003eENERGY BASED\u003c/strong\u003e\u003c/h3\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003eFeature： $F$ , Label: $L$ ,  Energy: $E(F,l)$\u003c/p\u003e\n\u003cp\u003e能量函数倾向于将已知的类别分类到低熵的分布上，然后我们可以根据特征在能量空间上的划分来区分新类和旧类。然后我们可以根据logits表达的softmax形式，找到输出和Gibbs distribution的相关性：\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\np(l \\mid \\boldsymbol{f})=\\frac{\\exp \\left(\\frac{g_{l}(\\boldsymbol{f})}{T}\\right)}{\\sum_{i=1}^{\\mathrm{C}} \\exp \\left(\\frac{g_{i}(\\boldsymbol{f})}{T}\\right)}=\\frac{\\exp \\left(-\\frac{E(\\boldsymbol{f}, l)}{T}\\right)}{\\exp \\left(-\\frac{E(\\boldsymbol{f})}{T}\\right)}\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e通过这个相关性，我们对自由能进行一个定义，以logits的形式表达\u003c/p\u003e","title":"OW Object Detector"},{"content":"@Aiken 2020.9.16\n对基本注意力机制的一些资料和理解做一些简单的汇总，着重分析基本思想原理，应用和实现（即 structure），还有一些Weakness和相应的解决方案。\n1.TODO-List：\n根据Lil’Log的Attention？Attention！进行初步的整理 各个分类的具体含义分开整理，理解一部分整理一部分，可能结合实际的应用去整理吧。 其中很重要的一点是数学分析的部分，需要对数学原理进行整理和领会。 What’s Attention In Deep Learning 在某种程度上，注意力是由我么如何关注视觉图像的不同区域或者我们如何关联同一个句子中的不同单词所启发的：针对于问题的不同，我们会对图像的某些具体的区域重视（某些区域在视觉中呈现高分辨率，而另一些则是低分辨率的情况），或者句子中的某些词重视的情况。\n可以解释一个句子中紧密的上下文单词之间的关系，比如我们看到eating就会期待看到food，而color对于我们来说就没有那么重要。\n简而言之，深度学习中的注意力就是针对不同问题下的重要性权重的向量，比如我们根据关联性，给上面的每个单词赋予一个相关性的向量权重，然后基于注意力加权后的总和作为目标的近似值。\nWhat’s Wrong with Seq2Seq Model seq2swq旨在将再encoder-decoder的架构下，将输入序列转换为新序列，对两个序列的长度没有要求。\nEncoder：将输入序列转换成固定长度的context vector，用来概括整个源序列的信息 Decoder：使用context vector初始化，来进行解码（转换） 这样的Encoder和Decoder架构都是Recurrent Neural Networks，就像LSTM和GRU架构。\n缺陷：固定长度的context vector可能会导致序列信息的缺失，同时可能会无法记住长句子，同时也会丢失时序的对齐信息。所以Attention就诞生了。\n:question:\nBorn for Translation 这几个部分的研究都是基于NMT自然机器翻译，来进行分析的（文本非图像）\n原本的E-D是通过Encoder的最后一个hidden states构建单个Context Vector，而Attention 做的就是在Context Vec和Source之间建立一个Shortcut（简单的Feed Forword Network），而源和目标的对齐由上下文向量来学习和控制。而上下文中应该consumes（包含）几个维度的信息\nEncoder的hidden States；\nDecoder的hidden States；\nSource 和 Target之间的对齐信息；\nEncoder Decoder实际上都是RNN的架构，S实际上就是H，隐层状态，Decoder对EOS输出了一个初始的预测Y以后，推进Decoder的进程。\n双向的recurrent network（bidirectional RNN）使得Encoder隐态同时考虑前后单词。而在Decoder中\ns_t = f(s_{t-1},y_{t-1},c_t)\n其中上下文向量c_t是输入序列的隐态之和，通过alignment score来进行加权。\n$a_{t,i}$ 将作为输入i对输出t的隐态加权（相关性），在网络中共同训练，通过tanh来进行激活处理。Score则使用下面的策略：\n$$ score(st,hi)=v_a^Ttanh(Wa[st;hi])\r$$\r其中V, W都是对齐模型中学到的参数\n最终对齐完成以后就会是：\nA Family of Attention Mechanism Summary 由于这个良好的理论基础和实现效果，以及对序列的良好兼容性，这样的算法就被很快的拓展到了计算机视觉的领域中。（学 科 交 叉）\n这些不同的score方法实际上就是对每个position上的input和当前位置（通常用上一个时刻的state）来进行相关性建模，针对这些相关性建模，来确定输入对于下一个状态的影响因子，也就是得到一个context向量。这实际上就是注意力机制的核心理念把。\nReferred to as “concat” in Luong, et al, 2015 and as “additive attention” in Vaswani, et al, 2017.(^) It adds a scaling factor 1/n−−√1/n, motivated by the concern when the input is large, the softmax function may have an extremely small gradient, hard for efficient learning.\n下面对一些更广泛类型的注意力机制做一个摘要性的总结\nSelf-Attention 这个已经在我的Onenote中整理过了，大概看看就好。这里只讲了一些应用上的点，\n自我注意，内部注意力，也就是自我内部关联的注意力关系获取；\nSoft vs Hard Attention Image Caption《show, attend and tell》，CNN获取特征，LSTM解码器利用卷积功能来逐一生成单词。通过Attention 来学习权重，可视化如下：\n根据注意力是访问整个图像还是访问图像的一个patch来定义hard和soft attention。\n**Soft Attention：**就是普通的全图Attention，将权重放在图像的所有色块上，基本没啥区别\nPro: 模型平滑容易微分 Con：expensive when the source image is large **Hard Attention：**一次只处理一小块图像，其实就相当于用0/1去对图像区域进行硬编码 ，只对一部分的图像进行处理，但是这种方式的技术实现我还是没什么概念，后面可以专门研究一下。\nPro：推理计算需求比较小 Con：不可微分，需要用更复杂的技术来进行训练（例如variance reduction or reinforcement learning） Global vs Loacal Attention Global实际上就和soft是类似的，而局部注意力机制更像是hard和soft之间的一个融合，对改进hard使其可以微分；\nthe model first predicts a single aligned position for the current target word and a window centered around the source position is then used to compute a context vector.\n后面提到了一些神经图灵机的内容就是一些基本的计算机制，实际上可能是启发LSTM设计擦除算法设计的根源。\nNeural Turing Machines Attention Mechanisms 可以将权重的看作一个神经图灵机的寻址权重：（基于位置或者基于内容的两种方式）\nContent-based addressing:\n基于内容寻址的权重设置从输入行和存储行提取的键值向量之间的相似度来创建关注向量：权重的具体计算通过余弦相似度后进行softmax归一化来进行权重的分配。\n另外通过β系数来放大或者减弱分布的焦点。\nInterpolation 通过interpolation gate scalar $g_t$ 将生成的上下文向量和上一步生成的注意力权重进行混合\n$$ w^g_t = g_tw^c_t + (1-g_t)w_{t-1}\r$$\rLocation-baesd addressing 基于位置的寻址，对注意力向量中不同位置的值进行求和，通过对允许的整数偏移位置中的权重来进行参数加权。这相当于是一个一维卷积来测试偏移量。\n然后对注意力的分布进行锐化处理，使用γ参数\n完整的注意力workflow为：\nPointer Network 解决的是输入输出都是顺序数据的问题。\nTransformer Introduction Attention is all u need ：提出的重要的Transformer的这种架构，使得算法能够完全基于注意力机制，而不需要序列对齐的recurrent Network。\nKey,Value and Query 这一块还是详细解读一下，这里说的太粗略了，没讲清楚。\nTransformer的主要重要的架构在于multi-head和self-attention，Transformer将输入堪称一个key-value pairs，均为输入长度n。\n$$ Attention(Q,K,V)=softmax(\\frac{Q K^⊤} {\\sqrt{n}})V\r$$\rKey Value Query 到底都是些什么东西。\nEncoder-Decoder and Taxonomy of Attention 基本的encoder-decoder是基于对序列处理的问题提出的，通常情况下针对的是输入输出都是序列的计算模型。下图a展示了典型的E-D机制，以及加入了self-attention的情况b。（文中提到了一些E-D机制的问题）\nSeq2Seq的RNN序列模型Encoder需要把之前的输入最终转化成单一的ht（定长），可能会造成序列信息的丢失，同时他只能平权的考虑输入，不能有所重点。同时对于时序对齐信息也会丢失，这对结构化特别重要\n注意力机制，在实现上就是通过在体系架构中，嵌入一个额外的前馈神经网络，来进行学习额外的参数（作为Decoder的补充输入，作为序列和之前信息的补充），而且通常，这个前馈的神经网络是需要和encoder-decoder协同训练的，也就是需要和整体网络共同训练。\n训练层面是否存在一些特殊的情况，对于一些特殊的Attention 模型，是否需要一些特殊的训练机制。这点如果看到的话，建议需要整理一下\n在Survey中，对注意力机制基于多种标准进行了分类，具体的分类情况可以依下图所示，还有一些具体方法的实现。\n对于几种分类方式，可以参考几个译文的解读，但是我觉得说的并不清楚，后续就分别针对各种方法进行分析吧。\nBTW：在RNN等循环结构不能并行化处理的条件下，提出的类似AM的Transformer（Attention is all u need）结构，他的encoder和decoder由两个子层堆叠而来：Feed Forward Network 和 Multi-head self attention。\nPosition-wise FFN：获取输入的顺序，在encoder阶段，对于每一个token既生成content embedding也生成position encoding。\nMulti-Head Self-Attention：在每个子层中使用self - attention来关联标记及其在相同输入序列中的位置，几个注意力层并行堆叠，对于相同的输入有不同的线性转换。这使得模型能够捕获输入的不同方面，提高表达能力。\nTransformer and Self-Attention 参考论文以及参考资料1 AND 《Attention is all you need》\nSelf-Attention ：\n下图这一段整的明明白白，把整个框架说的比较明白，对输入的embedding（分别做3次卷积，图像输入的情况），分成Query，Key，Value，然后如图进行后续的操作\n图2就表示了在CV领域，为什么需要将输入做完卷积以后再成进去，而其中的scale由于图片和序列是不一致的，他们的size本来就是统一的（基本规范的数据集中），那么就可以省略掉这一步，从而直接进行softmax，相当于在预处理的时候已经进行了这样的归一操作。\nself-attention 是 Transformer的基础，通过多个Self-Attention组成的Multi-head Attention 就是Transformer模型的基本结构。\nMulti-head Attention\nReference 参考资料\nAttention机制详解2：self-attention \u0026amp; Transformer origin document of ↑ Attention的数学原理 Survey:\n《An Attentive Survey of Attention Models》 mendeley\n论文翻译和解读1 :zap:\n论文解读和翻译2 论文解读和翻译3 Transformer:\n《Attention is all you need》Mendeley \u0026amp;OneNote ","permalink":"https://hugotest-phi.vercel.app/posts/attention/","summary":"\u003cp\u003e@Aiken 2020.9.16\u003c/p\u003e\n\u003cp\u003e对基本注意力机制的一些资料和理解做一些简单的汇总，着重分析基本思想原理，应用和实现（即 structure），还有一些Weakness和相应的解决方案。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e\u003cstrong\u003e1.TODO-List：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e根据Lil’Log的Attention？Attention！进行初步的整理\u003c/li\u003e\n\u003cli\u003e各个分类的具体含义分开整理，理解一部分整理一部分，可能结合实际的应用去整理吧。\u003c/li\u003e\n\u003cli\u003e其中很重要的一点是数学分析的部分，需要对数学原理进行整理和领会。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"whats-attention-in-deep-learning\"\u003eWhat’s Attention In Deep Learning\u003c/h2\u003e\n\u003cp\u003e在某种程度上，注意力是由我么如何关注视觉图像的不同区域或者我们如何关联同一个句子中的不同单词所启发的：针对于问题的不同，我们会对图像的某些具体的区域重视（某些区域在视觉中呈现高分辨率，而另一些则是低分辨率的情况），或者句子中的某些词重视的情况。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911182724.png\"\u003e\r\n    \u003cimg alt=\"image-20210118210915289\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911182724.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911182724.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210118210915289\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e可以解释一个句子中紧密的上下文单词之间的关系，比如我们看到eating就会期待看到food，而color对于我们来说就没有那么重要。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911182729.png\"\u003e\r\n    \u003cimg alt=\"image-20210118210936862\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911182729.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911182729.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210118210936862\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Attention Mechanism"},{"content":"Tags: Paper URL1: https://arxiv.org/pdf/1905.11946.pdf URL2: https://arxiv.org/pdf/2104.00298.pdf 提出了一种模型缩放策略，如何更高效的平衡网络的深度、宽度、和图片分辨率 1. Efficient Net: Rethinking Model Scaling for Convolutional Neural Networks 2. EfficientNetV2: Smaller Models and Faster Training\n@Aiken H 2021 find detail to code his\nEfficient Net V1 除了提出了缩放策略以外，还使用神经架构搜索还建立了一个新的baseline network，得到了一系列模型。\n平衡网络宽度、深度、分辨率至关重要，这种平衡可以通过简单的恒定比率缩放维度来实现，于是我们提出了一种简单有效的复合缩放方法。\n复合缩放的物理意义：输入图像更大的话就需要更多层来增加感受野和更多通道，从而能在更大的图像上捕获更多细粒度的图案，而宽度和深度（对于表达能力来说很重要）之间也存在着一定的关系，“我们”是第一个对此进行了建模的。\n从各个维度单独的进行缩放能发现都存在着增益瓶颈，如何去得到这么一个合适的等比缩放增益\nMotivation and Method 一些直观上的motivation，以及假想\n不同的缩放维度不是独立的 直观上，对于更高分辨率的图像我们应该增加网络深度。 这样更大的感受野可以帮助捕捉更大图像中包含的更多像素的相似特征 相应的，更高分辨率的图像也应该增加网路的深度以便再高分辨率图像中捕获具有更多像素的更细粒度的图案。 基于实验最终得到了这样的结果：\n$$ depth: d = \\alpha^\\phi $$\r$$ width: w = \\beta^\\phi $$\r$$ resolution: r = \\gamma^\\phi $$\r$$ s.t. \\alpha · \\beta^2 · \\gamma^2 \\approx 2 $$\r$$ \\alpha \\geq 1, \\beta \\geq 1, \\gamma \\geq 1 $$\r求解方法：\n固定φ，然后通过网格搜索得到最基本的模型 Efficient Net-B0 固定α、β、γ的值，使用不同的φ，得到相应的B1 -B7 Experience Detail github.surf github.surf EfficientNet网络结构图_LYS_1129的博客-CSDN博客_efficientnet网络结构 图解EfficientNet模型的完整细节 EfficientNet网络解析_bblingbbling的博客-CSDN博客_efficientnet网络结构 EfficientNet B0-B7 网络参数_繁华落尽，寻一世真情的博客-CSDN博客 从第三个连接中，我们可以整理出那些需要input的相关参数，然后输入网络中去建立该Model。\n实现中的问题： blockN\nstride和padding在各个重复组合层中间的变化（只有DW卷积改变Imageview）（堆叠的层不改变相应的HW），也是由第一个层去进行处理 channel，在各个组合层之间的变化（堆叠的层刚好不改变channel数目） ","permalink":"https://hugotest-phi.vercel.app/posts/efficientnet/","summary":"\u003cp\u003eTags: Paper\nURL1: \u003ca href=\"https://arxiv.org/pdf/1905.11946.pdf\" target=\"_blank\" rel=\"noopener\"\u003ehttps://arxiv.org/pdf/1905.11946.pdf\u003c/a\u003e\n\nURL2: \u003ca href=\"https://arxiv.org/pdf/2104.00298.pdf\" target=\"_blank\" rel=\"noopener\"\u003ehttps://arxiv.org/pdf/2104.00298.pdf\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e提出了一种模型缩放策略，如何更高效的平衡网络的深度、宽度、和图片分辨率\n\u003cstrong\u003e1. Efficient Net: Rethinking Model Scaling for Convolutional Neural Networks\n2. EfficientNetV2: Smaller Models and Faster Training\u003c/strong\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e@Aiken H 2021 find detail to code his\u003c/p\u003e\n\u003ch1 id=\"efficient-net-v1\"\u003eEfficient Net V1\u003c/h1\u003e\n\u003cp\u003e除了提出了缩放策略以外，还使用神经架构搜索还建立了一个新的baseline network，得到了一系列模型。\u003c/p\u003e\n\u003cp\u003e平衡网络宽度、深度、分辨率至关重要，这种平衡可以通过简单的恒定比率缩放维度来实现，于是我们\u003cstrong\u003e提出了一种简单有效的复合缩放\u003c/strong\u003e方法。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210610180603496.png\"\u003e\r\n    \u003cimg alt=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210610180603496.png\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210610180603496.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210610180603496.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210610180603496.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e复合缩放的物理意义：输入图像更大的话就需要更多层来增加感受野和更多通道，从而能在更大的图像上捕获更多细粒度的图案，而宽度和深度（对于表达能力来说很重要）之间也存在着一定的关系，“我们”是第一个对此进行了建模的。\u003c/p\u003e\n\u003cp\u003e从各个维度单独的进行缩放能发现都存在着增益瓶颈，如何去得到这么一个合适的等比缩放增益\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"motivation-and-method\"\u003eMotivation and Method\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e一些直观上的motivation，以及假想\u003c/strong\u003e\u003c/p\u003e","title":"EfficientNet"},{"content":"A* 是一种在平面图形上计算最优路径的方法，通常用来做 2D 游戏的最短寻路，该算法是一种 Dijkstra 算法的变体，使用启发式的策略来提高算法的搜索效率。\nwikipedia ；medium ；pythonf 基本思想 基于启发式的方法，基于BFS去做最短路径搜索，借助类似Manhattan距离作为启发，每次加入后续的多个点，然后按照后续点的属性去排序，不断的加入close的区间，直到第一次遍历到终点就是最短的路径。\n$$ f(n) = g(n) + h(n) $$\rf代表的是经过当前点，从起点到最终点的距离，g代表的是从起点到当前节点的距离，h代表的是启发式方法到终点的距离。\n维护三个list：open(候选列表)、close（状态确定的列表）、children（等待操作的列表）\n首先用 bfs 的方法，找到当前节点的可达后续节点，将这些节点加入 children，确定 child 不在 close_list 中后（即在 open 中）则判断哪个是最优解，然后更新 openlist 和 closelist 。\n即：每次遍历的当前节点都从 open 中总距离最小的选，然后放入 close。直到 openlist 为空。\n相关类别定义 1 2 3 4 5 6 7 8 9 10 11 class node(): def __init__(self, parent=None, position=None): self.parent = parent self.position = position self.g = 0 self.h = 0 self.f = 0 def __eq__(self, o: object) -\u0026gt; bool: return o.position == self.position 具体代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def asterS(map,slope,start,end): # 在astar算法的基础上，我们需要加入的是高度的约束 # 阻碍的条件是高度不同同时没有slope的存在，这种就是wall # 其余的和Astar算法应该是一样的 # init the start and end node start_node = node(None,start) end_node = node(None,end) # init the open and closed lists open_list = [] close_list = [] # add the start node to the open list open_list.append(start_node) # loop util find the end_node while len(open_list)\u0026gt;0: # make the best node as current_node # init 1 current_node = open_list[0] current_index = 0 for index, nod in enumerate(open_list): if nod.f\u0026lt;current_node.f: current_node = nod current_index = index # pop the curr node off open list, add to close list open_list.pop(current_index) close_list.append(current_node) # terminal conditions (reach the end node ) if current_node == end_node: path = [] while(current_node is not None): path.append(current_node.position) current_node = current_node.parent # return the path we find. return path[::-1] # the body of the loop: update the nodes # find the available children nodes children = [] # define the adjacent squares positions = [(-1,0),(1,0),(0,-1),(0,1)] for pos in positions: # get childrens positions node_pos = (current_node.position[0]+pos[0], current_node.position[1]+pos[1]) # make sure within range if node_pos[0] \u0026lt; 0 or node_pos[0] \u0026gt;= map.shape[0] or node_pos[1] \u0026lt; 0 or node_pos[1] \u0026gt;= map.shape[1]: continue # mkae sure walkab mapflag = map[current_node.position[0], current_node.position[1]] != map[node_pos[0], node_pos[1]] slopeflag1 = slope[node_pos[0], node_pos[1]] == 0 or slope[current_node.position[0], current_node.position[1]] == 0 slpopeflag2 = slope[node_pos[0], node_pos[1]] != slope[current_node.position[0], current_node.position[1]] if mapflag and (slopeflag1 or slpopeflag2): continue # we need creat node first to find out if it is in the openlist or closed list new_node = node(current_node, node_pos) children.append(new_node) # loop those children # using the __eq__ to judge if it\u0026#39;s already traveled. for child in children: if child in close_list: continue # create f,g,h for the legal child child.g = current_node.g + 1 child.h = manhattan(child.position, end_node.position) child.f = child.g + child.f # if the child is already in the open list, compare it if child in open_list: open_index = open_list.index(child) open_node = open_list[open_index] if child.g \u0026gt; open_node.g: continue open_list.pop(open_index) # if it is not in the open/closelist or better than that in open list, we add it. open_list.append(child) ","permalink":"https://hugotest-phi.vercel.app/posts/astar/","summary":"\u003cp\u003eA* 是一种在平面图形上计算最优路径的方法，通常用来做 2D 游戏的最短寻路，该算法是一种 Dijkstra 算法的变体，使用启发式的策略来提高算法的搜索效率。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\"\u003ewikipedia\u003c/a\u003e\n；\u003ca href=\"https://medium.com/@nicholas.w.swift/easy-a-star-pathfinding-7e6689c7f7b2\" target=\"_blank\" rel=\"noopener\"\u003emedium\u003c/a\u003e\n；\u003ca href=\"https://www.pythonf.cn/read/123915\" target=\"_blank\" rel=\"noopener\"\u003epythonf\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"基本思想\"\u003e基本思想\u003c/h2\u003e\n\u003cp\u003e基于启发式的方法，基于BFS去做最短路径搜索，借助类似Manhattan距离作为启发，每次加入后续的多个点，然后按照后续点的属性去排序，不断的加入close的区间，直到第一次遍历到终点就是最短的路径。\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ f(n) = g(n) + h(n) $$\r\n\u003c/div\u003e\r\n\u003cp\u003ef代表的是经过当前点，从起点到最终点的距离，g代表的是从起点到当前节点的距离，h代表的是启发式方法到终点的距离。\u003c/p\u003e\n\u003cp\u003e维护三个list：open(候选列表)、close（状态确定的列表）、children（等待操作的列表）\u003c/p\u003e\n\u003cp\u003e首先用 bfs 的方法，找到当前节点的可达后续节点，将这些节点加入 children，确定 child 不在 close_list 中后（即在 open 中）则判断哪个是最优解，然后更新 openlist 和 closelist 。\u003c/p\u003e\n\u003cp\u003e即：每次遍历的当前节点都从 open 中总距离最小的选，然后放入 close。直到 openlist 为空。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch3 id=\"相关类别定义\"\u003e相关类别定义\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e():\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__init__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eparent\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"kc\"\u003eNone\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"kc\"\u003eNone\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eparent\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eparent\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eposition\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eg\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__eq__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eo\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"nb\"\u003eobject\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"nb\"\u003ebool\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eo\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"具体代码实现\"\u003e具体代码实现\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e55\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e56\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e57\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e58\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e59\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e60\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e61\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e62\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e63\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e64\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e65\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e66\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e67\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e68\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e69\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e70\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e71\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e72\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e73\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e74\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e75\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e76\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e77\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e78\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e79\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e80\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e81\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e82\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e83\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e84\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e85\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e86\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e87\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003easterS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eslope\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# 在astar算法的基础上，我们需要加入的是高度的约束\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# 阻碍的条件是高度不同同时没有slope的存在，这种就是wall\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# 其余的和Astar算法应该是一样的\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# init the start and end node\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estart_node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kc\"\u003eNone\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eend_node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kc\"\u003eNone\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# init the open and closed lists\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eclose_list\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# add the start node to the open list\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estart_node\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# loop util find the end_node \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"nb\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# make the best node as current_node\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# init 1 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecurrent_index\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enod\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"nb\"\u003eenumerate\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003enod\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enod\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003ecurrent_index\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eindex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# pop the curr node off open list, add to close list \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epop\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_index\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eclose_list\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# terminal conditions (reach the end node )\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eend_node\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003epath\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e \u003cspan class=\"ow\"\u003eis\u003c/span\u003e \u003cspan class=\"ow\"\u003enot\u003c/span\u003e \u003cspan class=\"kc\"\u003eNone\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003epath\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eparent\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# return the path we find.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003epath\u003c/span\u003e\u003cspan class=\"p\"\u003e[::\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# the body of the loop: update the nodes\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# find the available children nodes\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003echildren\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# define the adjacent squares \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003epositions\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[(\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e),(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e),(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e),(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003epos\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003epositions\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# get childrens positions\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003epos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003epos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# make sure within range  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"ow\"\u003eor\u003c/span\u003e \u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eshape\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"ow\"\u003eor\u003c/span\u003e \u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"ow\"\u003eor\u003c/span\u003e \u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eshape\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# mkae sure walkab\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003emapflag\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eslopeflag1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eslope\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e  \u003cspan class=\"ow\"\u003eor\u003c/span\u003e \u003cspan class=\"n\"\u003eslope\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eslpopeflag2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eslope\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003eslope\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003emapflag\u003c/span\u003e \u003cspan class=\"ow\"\u003eand\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eslopeflag1\u003c/span\u003e \u003cspan class=\"ow\"\u003eor\u003c/span\u003e \u003cspan class=\"n\"\u003eslpopeflag2\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# we need creat node first to find out if it is in the openlist or closed list\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003enew_node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enode_pos\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003echildren\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enew_node\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# loop those children\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e# using the __eq__ to judge if it\u0026#39;s already traveled.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003echild\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003echildren\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003echild\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eclose_list\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# create f,g,h for the legal child\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eg\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eg\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emanhattan\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eend_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eposition\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eg\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# if the child is already in the open list, compare it\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003echild\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eopen_index\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eopen_node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eopen_index\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eg\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eopen_node\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eg\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epop\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eopen_index\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e# if it is not in the open/closelist or better than that in open list, we add it.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eopen_list\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Astar"},{"content":"@Aiken 2020\n在使用Google Colab的时候会有一些常见的使用错误，然后我们记录一些常见的错误的解决方案，方便后续使用。\nINDEX：\n命令行参数的输入问题\ntensorboard的执行方法\n1 2 3 # 在colab中写的时候要把前面的符号也写上 %load_ext tensorboard %tensorboard --logdir \u0026#39;./runs\u0026#39; command命令的使用：包括库安装和卸载之类的。 主要就是在命令前+！\n1 2 3 4 5 !/opt/bin/nvidia-smi # 下面顺便解决了一下 # ImportError: cannot import name \u0026#39;PILLOW_VERSION\u0026#39;(版本问题) !pip uninstall pillow !pip install pillow==5.2.0 ","permalink":"https://hugotest-phi.vercel.app/posts/googlecolab/","summary":"\u003cp\u003e@Aiken 2020\u003c/p\u003e\n\u003cp\u003e在使用Google Colab的时候会有一些常见的使用错误，然后我们记录一些常见的错误的解决方案，方便后续使用。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eINDEX：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e命令行参数的输入问题\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003etensorboard的执行方法\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在colab中写的时候要把前面的符号也写上\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e%load_ext tensorboard  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e%tensorboard --logdir \u003cspan class=\"s1\"\u003e\u0026#39;./runs\u0026#39;\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ecommand命令的使用：包括库安装和卸载之类的。\n主要就是在命令前+！\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e!/opt/bin/nvidia-smi\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 下面顺便解决了一下\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# ImportError: cannot import name \u0026#39;PILLOW_VERSION\u0026#39;(版本问题)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e!pip uninstall pillow\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e!pip install \u003cspan class=\"nv\"\u003epillow\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e5.2.0\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"Colab 使用的问题记录"},{"content":"基于 WSL2 对于 Docker 的适配，本文介绍 Windows 下利用 WSL2 对 Docker 的安装和部署，对于 WSL2 的安装可以参考上篇文章： Windows Configuration01 WSL2 - AikenH Blogs Install Docker on Windows 该部分主要介绍以下几内容：安装，存储盘迁移，连接 WSL2 发行版，完成了这几步之后就可以畅游 Docker 世界了。\n前置：先安装好一个 WSL2 的发行版\n首先，官网 Docker: 下载 Docker Desktop for windows，安装基于 WSL2 的 docker，安装完成后 Docker 的发行版和存储目录会默认存放在，该地址可以用来确认后续的迁移状态。\nDocker-Desktop/data：%LOCALAPPDATA%/Docker/wsl WSL2：%LOCALAPPDATA%/packages/c......./local_state 安装完后首先打开 docker 确认没有其他异常问题报警，然后就可以对存储空间和 Desktop 进行迁移（option），迁移的方式可以参考上文中对 WSL2 的迁移。下面给出脚本便于使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 wsl --shutdown # 系统导出 wsl --export docker-desktop-data \u0026#34;D:\\docker\\docker-desktop-data.tar\u0026#34; wsl --export docker-desktop \u0026#34;D:\\docker\\docker-desktop.tar\u0026#34; # 删除原系统 wsl --unregister docker-desktop-data wsl --unregister docker-desktop # 挂载新目录 wsl --import docker-desktop D:\\docker\\docker-desktop D:\\docker\\docker-desktop.tar wsl --import docker-desktop-data D:\\docker\\docker-desktop-data D:\\docker\\docker-desktop-data.tar 迁移完成后重启 docker 即可，至此，安装就算完成了。\nBasic Setting 为了发挥完整的性能，以及更容易执行 volume 参数进行 data 的挂载，这边强烈建议在 wsl2 中使用 docker！为此，在 docker-desktop 中需要设置如下的几个地方：\n例如 alist 镜像，在 wsl2 中设置好了 volume 参数，把 data 准确的挂载出来后，数据就不会再 docker 重启的时候丢失了。\n设置完成后，在 WSL2 中就可以识别和执行 Docker 命令了，后续对 docker、docker-compose 的操作都在 WSL2 中完成即可，接下来就可以在 docker 的应用市场中愉快的淘金了。\nDocker Apps( personal recommand ) 后续会对其中的一些来做简单的部署和讲解，其实很多都挺适合在 NAS 上部署的，结合内网穿透技术能有一个更好的体验，后面也可以简单介绍以下内网穿透。\nAlist 个人云管理中心，统一管理，访问，在线观看等，强力推荐 Immich 局域网图片备份和管理中心，有移动端 APP，自动备份，权限隔离， Talebook 图书、PDF 管理中心（还在找更好的 pdf 中心） wikijs 个人 wikipage foamzou/melody：音乐资源搜索和自动上传网易云云盘 memos：个人备忘录中心 想要一个能够同时管理书籍和论文的 PDF 管理中心，最好能够集成一个比较好的 PDF 阅读和标记工具（比如直接用 Edge 把），不知道有没有类似的。\nTroubleshoot Executable file not found (WSL 2) 参考资料： exec: \u0026ldquo;docker-credential-desktop.exe\u0026rdquo;: executable file not found in $PATH 具体的修改方式(1/2)：\nDelete the line with credsStore from ~/.docker/config.json 改成 credStore 路径也可能会是在/root/.Docker 的地方。\n","permalink":"https://hugotest-phi.vercel.app/posts/docker/","summary":"\u003cp\u003e基于 WSL2 对于 Docker 的适配，本文介绍 Windows 下利用 WSL2 对 Docker 的安装和部署，对于 WSL2 的安装可以参考上篇文章： \u003ca href=\"https://aikenh.cn/cn/WSL2/\" target=\"_blank\" rel=\"noopener\"\u003eWindows Configuration01 WSL2 - AikenH Blogs\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"install-docker-on-windows\"\u003eInstall Docker on Windows\u003c/h2\u003e\n\u003cp\u003e该部分主要介绍以下几内容：安装，存储盘迁移，连接 WSL2 发行版，完成了这几步之后就可以畅游 Docker 世界了。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e前置：先安装好一个 WSL2 的发行版\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e首先，官网 \u003ca href=\"https://www.docker.com/\" target=\"_blank\" rel=\"noopener\"\u003eDocker:\u003c/a\u003e\n 下载 Docker Desktop for windows，安装基于 WSL2 的 docker，安装完成后 Docker 的发行版和存储目录会默认存放在，该地址可以用来确认后续的迁移状态。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDocker-Desktop/data：\u003ccode\u003e%LOCALAPPDATA%/Docker/wsl\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eWSL2：\u003ccode\u003e%LOCALAPPDATA%/packages/c......./local_state\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"Docker Configuration00 Install on WSL2"},{"content":"WSL（Windows Subsystem Linux） 将 Linux 环境部署在 Windows 中，Linux 环境在补全了 Windows 开发上的不足之外（Bash 等），还有以下的几个特性极大的便利开发和日常使用，因此强烈推荐启用并安装。\nwin11 中 wsl2 已经支持相应主机的 cuda，便利了机器学习的开发； 子系统中通过/mnt 挂载了 windows 的磁盘，可以通过子系统访问和管理 windows 环境； windows 资源管理器可访问和管理子系统中的文件 支持 windows 打开子系统中的 GUI 应用 无论是将 windows 和 linux 分别作为日常和开发的环境来隔离，还是两个协同去做开发和日常，都是一个比较不错的选择，下面就介绍一下如何安装和使用 WSL2。\n开始之前可以参考 windows terminal 安装一下这个官方的终端模拟器，在 windows 上的表现是比较优秀的 如果是考虑在 windows 环境开发的话，也可以参考这个[windows]，里面有我个人推荐的一些应用。 启用并安装 WSL2 安装和启用 WSL2 需要在 windows 的服务中勾选 Hyper-V 和 Windows Subsystem Linux 支持两个选项，具体操作如下：\nWin + S 搜索 \u0026ldquo;功能\u0026rdquo;，打开启用或关闭 windows 功能 启用对应功能，功能安装完毕后即可 安装 linux 发行版可以在 windows store 安装，也可以通过如下的命令进行安装： 1 2 3 4 5 6 7 # 列出对应的发行版 wsl -l -o # 选择相应的发行版进行安装 wsl --install -d \u0026lt;Distribution Name\u0026gt; # 如果当前的WSL是1版本，更新到2 wsl -l -v wsl --set-default-version 2 安装完发行版之后，WindowsTerminal 中应该会自动出现其配置文件，如果没有出现也不要紧，可以先迁移其存储位置后再添加配置文件。\nMount And Move WSL 的默认存储路径：%LOCALAPPDATA%/packages/c......./local_state 搜索 Ubuntu 文件夹\n而通常 windows 都会有分区，如果是 C 盘较小的（建议是可以不用分区），可以修改 WSL 的默认存储路径，将磁盘挂载在别的地方，操作如下：\n首先关闭对应的 wsl 服务，并查看关闭的状态：\n1 2 wsl --shutdown wsl -l -v # 查看状态 确认已经关闭后我们可以将该子系统文件导出，并将原有的系统注销删除\n1 2 3 4 5 6 # 导出wsl2 system； docker-desktop \u0026amp; docker-desktop-data # 导出系统 wsl --export \u0026lt;DistroName\u0026gt; \u0026lt;PathToTarArchive\u0026gt; wsl --export Ubuntu-20.04 E:\\WSLWorkspace\\ubuntu.tar # 删除（注销）系统 wsl --unregister Ubuntu-20.04 最后在我们希望的地方重新注册该系统：\n1 2 # 导入系统到指定的新位置(使用新路径导入新系统) wsl --import Ubuntu-20.04 E:\\WSLWorkspace E:\\WSLWorkspace\\ubuntu.tar 通常来说，wsl 会自动为系统生成配置文件，这里在 terminal 中可能会出现两个 ubuntu 的 unid，那么我们就把第一个配置文件删掉，然后修改新的配置文件为（主要是在后面添加-u user_name）在指定启动的用户：\n1 \u0026lt;...wsl.exe\u0026gt; -d ubuntu -u \u0026lt;user_name\u0026gt; or 修改注册表，可以参考以下的方法： wsl2系统迁移到非系统盘 or 尝试，但是注意这种方式就不急着注销系统，因为他可能会重新安装在 C 盘，所以最后在注销。\n1 ubuntu2204 config --default-user \u0026lt;user_name\u0026gt; 删除多余的所有 tar，over\nDocker（based on wsl2） 基于 WSL2 安装的 Docker 也能用这种方式迁移相应的存储地点。就仅给出大概的操作流程，不在赘述。\n1 2 3 4 5 6 7 # export wsl --export docker-desktop-data \u0026#34;D:\\docker\\docker-desktop-data.tar\u0026#34; wsl --export docker-desktop \u0026#34;D:\\docker\\docker-desktop.tar\u0026#34; # unresiester # import # restart SSH wsl2启用SSH ，ssh功能应该默认是启用的，如果ssh没有启用的话\n1 vim /etc/ssh/sshd_config 修改如下的几个配置\nPort = 22 去掉这行的 #，代表启用端口号 22 ListenAddress 0.0.0.0 去掉这行的#，代表监听所有地址 PasswordAuthentication yes，将这行的no改成yes，代表支持账号密码形式的登录\n重启服务\n1 sudo service ssh restart 此时还不能支持root用户密码登录,默认情况下，root用户只支持用RSA登录，但是可以修改配置的,切换到root用户打开SSH的配置文件\n找到行PermitRootLogin prohibit-password保留这行的#，这意味着：允许root登录，但是禁止root用密码登录，所以这行要注释掉。 需要添加一行:\n1 PermitRootLogin yes 剩下的其余配置按照Linux文档进行文件的配置\nPROXY Update 由于 WSL 2 中许多 CLI 工具都需要额外的进行代理设置，还有一些代码中也需要指定代理，令人不厌其烦，因此这里更新对于诸多 CLI 的额外设置。\n参考资料（从前到后）：\nUbuntu「一键」设置代理 | Sukka\u0026rsquo;s Blog (skk.moe) WSL2 的一些网络访问问题 | Artin\u0026rsquo;s Blog (cat.ms) TUN 模式 | Clash for Windows WSL 开发环境代理设置 - sulinehk\u0026rsquo;s blog WSL2 配置代理 (kiritoghy.cn) 推荐）通用方案：使用 Clash 的 TUN 模式，该方案会设置一个虚拟网卡，自动接管该方案设置完毕后无需配置 WSL 中任意 CLI 的代理。\n首先基于 server 旁边的地球按钮安装需要的依赖，安装完后就可以打开 tun 模式。\n备选）基础方案：使用脚本设置各个常用 CLI 的代理，需要设置代理的主要有以下这些：npm, yarn 等专用软件。\nwget 和 curl 这种使用的是全局的代理，所以不需要额外的设置， 但是像 npm 之类的专有软件一般有命令或者对应的配置文件；\n基于参考资料，个人基于需求进行修改，提供脚本如下：\n除了上述文章提到的这些，还有一个很容易遇到的问题就是 pip 的安装问题，设置 pip 的代理的方式有以下几种：\n使用 pip 的 --proxy 选项设置代理：pip install libname --proxy http://127.0.0.1:7890 直接编辑pip的配置文件pip.ini，在其中的[global]下面添上一行proxy = http://127.0.0.1:7890 使用 pip 的 config 命令来写配置文件：pip config set global.proxy http://127.0.0.1:7890 参考文献：pip：ProxyError(‘Cannot connect to proxy. - CodeAntenna Basic set the proxy for the WSL from windows, so we can update the packages ez.\n首先获取windows IP: 1 2 cat /etc/resolv.conf|grep nameserver|awk \u0026#39;{print $2}\u0026#39; # 假设获取的windows ip 为170.20.0.1 查看代理软件的端口设置，开启局域网 LAN 链接，开启防火墙 添加入站规则 -\u0026gt; 新建规则 类型：自定义 程序：所有程序 协议和端口：默认 作用域： 本地为任何 ip 远程为下列 IP，把 WSL2 获取到的 ip 添加进去（比如上面就是 172.20.0.0/20）（掩码一般是 20 位） 操作：允许链接 配置文件：三个全选 名称：自定义 Clash 开启 LAN 和端口, WSL2 中设置代理 1 2 export https_proxy=172.20.0.1:8890 export http_proxy=172.20.0.1:8890 Reference： proxy配置参考 这里提供一下 WSL 的代理设置脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # show and set proxy for WSL function GetHostIp(){ ip=$(cat /etc/resolv.conf|grep nameserver|awk \u0026#39;{print $2}\u0026#39;) echo \u0026#34;the host ip is: $ip, then we ping it to test fireware\u0026#34; ping $ip } function SetProxy(){ ip=$(cat /etc/resolv.conf|grep nameserver|awk \u0026#39;{print $2}\u0026#39;) export http_proxy=http://$ip:8890 export https_proxy=https://$ip:8890 } function unsetProxy(){ unset http_proxy unset https_proxy } alias getip=GetHostIp alias proxyon=SetProxy alias proxyoff=unsetProxy SETTING WSL在Windows Terminal的启动目录设置\n1 //wsl$/Ubuntu-20.04/home/aikenhong Vmmem 内存占用问题 Windows 使用 Wsl2 \u0026amp; 基于 Wsl2 的 Docker 时会发现 Vmmem 占用了系统大量的内存（15g/32g），且同时 Docker Dashboard 和 Linux 中的 Top 命令都显示占用并不高。\nVmmem 进程是 Windows 系统为 WSL2 系统预留的虚拟进程，为 WSL2 向系统申请内存和 CPU 资源，即使在 WSL2 并不需要的时候也会保留大量的内存，其默认消耗总内存的50% (20175之前的版本则是80%) 或者 8G，选择其中较小的一个执行。\n如果需要使用内存且无需 WSL2 时可以使用 wsl --shutdown 命令关闭 WSL2； 进入用户文件夹后，新建 or 打开 .wslconfig 文件\npowershell cd ~ WIN+R %UserProfile% 资源管理器 %UserProfile% 在其中可以编辑 wsl2 的 memory 选项，手动其内存使用的上限：\n1 2 3 # Settings apply across all Linux distros running on WSL 2 [wsl2] memory=8GB 重启 WSL 或者直接重启电脑即可。\n","permalink":"https://hugotest-phi.vercel.app/posts/windows-wsl2/","summary":"\u003cp\u003eWSL（Windows Subsystem Linux） 将 Linux 环境部署在 Windows 中，Linux 环境在补全了 Windows 开发上的不足之外（Bash 等），还有以下的几个特性极大的便利开发和日常使用，因此强烈推荐启用并安装。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewin11 中 wsl2 已经支持相应主机的 cuda，便利了机器学习的开发；\u003c/li\u003e\n\u003cli\u003e子系统中通过/mnt 挂载了 windows 的磁盘，可以通过子系统访问和管理 windows 环境；\u003c/li\u003e\n\u003cli\u003ewindows 资源管理器可访问和管理子系统中的文件\u003c/li\u003e\n\u003cli\u003e支持 windows 打开子系统中的 GUI 应用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e无论是将 windows 和 linux 分别作为日常和开发的环境来隔离，还是两个协同去做开发和日常，都是一个比较不错的选择，下面就介绍一下如何安装和使用 WSL2。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e开始之前可以参考 \u003ca href=\"\"\u003ewindows terminal\u003c/a\u003e\n 安装一下这个官方的终端模拟器，在 windows 上的表现是比较优秀的\u003c/li\u003e\n\u003cli\u003e如果是考虑在 windows 环境开发的话，也可以参考这个[windows]，里面有我个人推荐的一些应用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"启用并安装-wsl2\"\u003e启用并安装 WSL2\u003c/h2\u003e\n\u003cp\u003e安装和启用 WSL2 需要在 windows 的服务中勾选 Hyper-V 和 Windows Subsystem Linux 支持两个选项，具体操作如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWin + S 搜索 \u0026ldquo;功能\u0026rdquo;，打开启用或关闭 windows 功能\u003c/li\u003e\n\u003cli\u003e启用对应功能，功能安装完毕后即可\n\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230305091044.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230305091044.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230305091044.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\n\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230305091150.png\"\u003e\r\n    \u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230305091150.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/3070PC/20230305091150.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/li\u003e\n\u003cli\u003e安装 linux 发行版可以在 windows store 安装，也可以通过如下的命令进行安装：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e# 列出对应的发行版\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ewsl\u003c/span\u003e \u003cspan class=\"n\"\u003e-l\u003c/span\u003e \u003cspan class=\"n\"\u003e-o\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e# 选择相应的发行版进行安装\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ewsl\u003c/span\u003e \u003cspan class=\"p\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003e-install\u003c/span\u003e \u003cspan class=\"n\"\u003e-d\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eDistribution\u003c/span\u003e \u003cspan class=\"n\"\u003eName\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e# 如果当前的WSL是1版本，更新到2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ewsl\u003c/span\u003e \u003cspan class=\"n\"\u003e-l\u003c/span\u003e \u003cspan class=\"n\"\u003e-v\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ewsl\u003c/span\u003e \u003cspan class=\"p\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003e-set-default-version\u003c/span\u003e \u003cspan class=\"mf\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c!-- more --\u003e\r\n\u003cp\u003e安装完发行版之后，WindowsTerminal 中应该会自动出现其配置文件，如果没有出现也不要紧，可以先迁移其存储位置后再添加配置文件。\u003c/p\u003e","title":"Windows Configuration01 WSL2"},{"content":"@AikenHong 2020\n本文介绍个人的 windows 开发环境搭建（包括一些环境安装、功能启用）以及一些使用的小 tips。\n软件推荐 Windows 的账号同步功能善用，减少在环境迁移的时候对浏览器插件和 Vscode 插件的繁琐同步步骤。\n同时对 Onedrive 和外接硬盘的应用可以很好的减轻备份的负担，在网络环境对 Onedrive 友好的时候还是推荐使用，在 Mac 和 Windows 上都有一个比较好的体验。\n一些基础的软件 Software Type Free? \u0026amp; source Powertorys system enhance y \u0026amp; github Translucent beautify y \u0026amp; Microsoft Store Snipaste system enhance y \u0026amp; offical site Clash for windows proxy y \u0026amp; github everything search-file y \u0026amp; offical site Potplayer Player y \u0026amp; offical site Twinkle Tray screen control y \u0026amp; offical site 7 zip system enhanc y \u0026amp; offical site Zerotier NAT y \u0026amp; offical site Nerd Font Font y \u0026amp; offical site Wallpaper Engine beautify n \u0026amp; steam MyDockerFinder beautify n \u0026amp; steam IDM Download n \u0026amp; offical site 开发工具 Software Type Free? \u0026amp; source Windows Terminal Terminal Simulator y \u0026amp; Microsoft Store Powershell 7 Shell y \u0026amp; Github VsCode Editor y \u0026amp; Offical Site Visual Studio IDE y \u0026amp; Offical Site Interllij IDEA IDE n \u0026amp; Offical Site Git - - Nodejs - - Anaconda - - 文档编写 Software Type Free \u0026amp; Source Obsidian Markdown Editor y \u0026amp; offical-site Typora Markdown Editor n \u0026amp; offical-site Picgo Image Upload y \u0026amp; offical-site CopyTranslate Translate y \u0026amp; offical-site Mathpix Snipping Tool Latex Formulate - \u0026amp; offical-site Daily Software Free \u0026amp; Source Office n \u0026amp; offical-site Tim y \u0026amp; offical-site WeChat y \u0026amp; offical-site OneDrive y \u0026amp; offical-site Steam - \u0026amp; offical-site Epic - \u0026amp; offical-site yy y \u0026amp; offical-site uu n \u0026amp; offical-site 网易云 y \u0026amp; offical-site 开发环境配置 安装 python：直接去 https://www.anaconda.com 下载，安装的时候使其添加到路径中 安装 Node：windows 直接去 nodejs 官网下载安装，详细文档请参考Node Version Manage - AikenH Blogs 安装 Window Terminal： Win11 中自带 Win10 可以在 windows store 中安装，也可以去 Github 界面安装 配置请参考 WindowsTerminal - AIkenH Blogs 安装 PowerShell7 该部分安装 PS7 并在 WindowsTerminal 中设置其配置文件：\n安装部分：在 PowerShell 的 Github Releases 界面下载 msi 版本 PowerShell/PowerShell: PowerShell for every system! (github.com) 直接安装即可，自己选择安装位置。\n配置参考文档：Powershell- Aikenh Blogs 启用 WSL2 这里简单介绍如何启用和安装 WSL2，后续相关的配置等信息参考 WSl2 - Aikenh Blogs ;\n安装和启用 WSL2 需要在 windows 的服务中勾选 Hyper-V 和 Windows Subsystem Linux 支持两个选项，具体操作如下：\nWin + S 搜索 \u0026ldquo;功能\u0026rdquo;，打开启用或关闭 windows 功能 启用对应功能，功能安装完毕后即可 在 windows store 中安装需要的 Linux 发行版 参考上述所说博文迁移存储位置，配置 windows terminal 等。 其他操作 粘滞键关闭问题 Sometimes, we could not disable the sticky key which enable for some reason. We could only disable this by click shift 5 time in LAPTOP ORIGIN KEYBOARD other than the EXTERNAL KEYBOARD.\n百度网盘倍速播放 百度网盘的网页版倍速播放的技巧：\n1 videojs.getPlayers(\u0026#34;video-player\u0026#34;).html5player.tech_.setPlaybackRate(2) Office 恢复自动保存的文件 首先在设置（选项）界面找到自动保存的 asd 文件的地址 在信息-管理文档中选择 ASD 进行对文档的恢复 Install Nerd Font 在 Nerd Fonts 中下载字体后直接右键安装即可，推荐安装，无论是进行编程开发的时候还是针对命令行的美化，或者是 windows terminal 的体验，都是一个必不可少的环节。\nClash 设置微软相关应用不启用 在主界面的 UWP Loopback 中选中启用代理后出现问题的应用如商店和便笺等\nOneDrive 路径切换 将 OneDrive 设置中的账户选项卡里取消链接此电脑，然后将 OneDrive 的文件夹移动到新的存储位置，最后重新设置 OneDrive，直到到达显示文件夹位置的窗口，选择更改位置，然后选择新的存储位置即可。\n文件夹的默认位置在：c:\\user\\\u0026lt;username\u0026gt;\\OneDrive\n","permalink":"https://hugotest-phi.vercel.app/posts/windows/","summary":"\u003cp\u003e@AikenHong 2020\u003c/p\u003e\n\u003cp\u003e本文介绍个人的 windows 开发环境搭建（包括一些环境安装、功能启用）以及一些使用的小 tips。\u003c/p\u003e\n\u003ch2 id=\"软件推荐\"\u003e软件推荐\u003c/h2\u003e\n\u003cp\u003eWindows 的账号同步功能善用，减少在环境迁移的时候对浏览器插件和 Vscode 插件的繁琐同步步骤。\u003c/p\u003e\n\u003cp\u003e同时对 Onedrive 和外接硬盘的应用可以很好的减轻备份的负担，在网络环境对 Onedrive 友好的时候还是推荐使用，在 Mac 和 Windows 上都有一个比较好的体验。\u003c/p\u003e\n\u003ch3 id=\"一些基础的软件\"\u003e一些基础的软件\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eSoftware\u003c/th\u003e\n          \u003cth\u003eType\u003c/th\u003e\n          \u003cth\u003eFree? \u0026amp; source\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePowertorys\u003c/td\u003e\n          \u003ctd\u003esystem enhance\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; github\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eTranslucent\u003c/td\u003e\n          \u003ctd\u003ebeautify\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; Microsoft Store\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSnipaste\u003c/td\u003e\n          \u003ctd\u003esystem enhance\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eClash for windows\u003c/td\u003e\n          \u003ctd\u003eproxy\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; github\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eeverything\u003c/td\u003e\n          \u003ctd\u003esearch-file\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePotplayer\u003c/td\u003e\n          \u003ctd\u003ePlayer\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eTwinkle Tray\u003c/td\u003e\n          \u003ctd\u003escreen control\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e7 zip\u003c/td\u003e\n          \u003ctd\u003esystem enhanc\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eZerotier\u003c/td\u003e\n          \u003ctd\u003eNAT\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eNerd Font\u003c/td\u003e\n          \u003ctd\u003eFont\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eWallpaper Engine\u003c/td\u003e\n          \u003ctd\u003ebeautify\u003c/td\u003e\n          \u003ctd\u003en \u0026amp; steam\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMyDockerFinder\u003c/td\u003e\n          \u003ctd\u003ebeautify\u003c/td\u003e\n          \u003ctd\u003en \u0026amp; steam\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eIDM\u003c/td\u003e\n          \u003ctd\u003eDownload\u003c/td\u003e\n          \u003ctd\u003en \u0026amp; offical site\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"开发工具\"\u003e开发工具\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eSoftware\u003c/th\u003e\n          \u003cth\u003eType\u003c/th\u003e\n          \u003cth\u003eFree? \u0026amp; source\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eWindows Terminal\u003c/td\u003e\n          \u003ctd\u003eTerminal Simulator\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; Microsoft Store\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePowershell 7\u003c/td\u003e\n          \u003ctd\u003eShell\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; Github\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVsCode\u003c/td\u003e\n          \u003ctd\u003eEditor\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; Offical Site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVisual Studio\u003c/td\u003e\n          \u003ctd\u003eIDE\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; Offical Site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eInterllij IDEA\u003c/td\u003e\n          \u003ctd\u003eIDE\u003c/td\u003e\n          \u003ctd\u003en \u0026amp; Offical Site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGit\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eNodejs\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAnaconda\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"文档编写\"\u003e文档编写\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eSoftware\u003c/th\u003e\n          \u003cth\u003eType\u003c/th\u003e\n          \u003cth\u003eFree \u0026amp; Source\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eObsidian\u003c/td\u003e\n          \u003ctd\u003eMarkdown Editor\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eTypora\u003c/td\u003e\n          \u003ctd\u003eMarkdown Editor\u003c/td\u003e\n          \u003ctd\u003en \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePicgo\u003c/td\u003e\n          \u003ctd\u003eImage Upload\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCopyTranslate\u003c/td\u003e\n          \u003ctd\u003eTranslate\u003c/td\u003e\n          \u003ctd\u003ey \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMathpix Snipping Tool\u003c/td\u003e\n          \u003ctd\u003eLatex Formulate\u003c/td\u003e\n          \u003ctd\u003e- \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"daily\"\u003eDaily\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eSoftware\u003c/th\u003e\n          \u003cth\u003eFree \u0026amp; Source\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eOffice\u003c/td\u003e\n          \u003ctd\u003en \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eTim\u003c/td\u003e\n          \u003ctd\u003ey  \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eWeChat\u003c/td\u003e\n          \u003ctd\u003ey  \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eOneDrive\u003c/td\u003e\n          \u003ctd\u003ey  \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSteam\u003c/td\u003e\n          \u003ctd\u003e-  \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eEpic\u003c/td\u003e\n          \u003ctd\u003e-  \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eyy\u003c/td\u003e\n          \u003ctd\u003ey  \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003euu\u003c/td\u003e\n          \u003ctd\u003en  \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e网易云\u003c/td\u003e\n          \u003ctd\u003ey   \u0026amp; offical-site\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"开发环境配置\"\u003e开发环境配置\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e安装 python\u003c/strong\u003e：直接去 \u003ca href=\"https://www.anaconda.com/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.anaconda.com\u003c/a\u003e\n 下载，安装的时候使其添加到路径中\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安装 Node\u003c/strong\u003e：windows 直接去 \u003ca href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\"\u003enodejs\u003c/a\u003e\n 官网下载安装，详细文档请参考\u003ca href=\"https://aikenh.cn/cn/Nodes/\" target=\"_blank\" rel=\"noopener\"\u003eNode Version Manage - AikenH Blogs\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e安装 Window Terminal：\n\u003cul\u003e\n\u003cli\u003eWin11 中自带\u003c/li\u003e\n\u003cli\u003eWin10 可以在 windows store 中安装，也可以去 Github 界面安装\u003c/li\u003e\n\u003cli\u003e配置请参考 \u003ca href=\"\"\u003eWindowsTerminal - AIkenH Blogs\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Windows Configuration00 系统初始配置"},{"content":"Gitbook命令行工具，基于Markdown编写文档，后续基于Github发布该Blog\n笔记的构建流程：\nChapter1 Install 安装Gitbook之前我们需要安装node.js和npm的依赖，使用npm安装gitbook\n首先安装Install Nodejs，Npm\nWindows：Node.js (nodejs.org) Linux:\n1 2 3 4 5 6 # add \u0026amp; update apt source before install nodejs. curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get update # install nodejs after that. sudo apt-get install -y nodejs 然后安装gitbook\n1 2 3 4 npm install gitbook-cli -g gitbook fetch beta # 安装历史版本 gitbook ls-remote # 列举可以下载的版本 检查Gitbook版本\n1 gitbook -V 安装Gitbook插件 安装插件主要有两种方式：一种是直接通过book和gitbook的安装来实现，另一种是基于Npm预先安装\n1 npm install gitbook-plugin-PACKAGE 基于book的安装方式\n插件和相关的配置在book.json中指定，关键词plugins \u0026amp; pluginsConfig为对应的插件的配置信息\n添加插件通过修改book.json如下：\n1 2 3 4 5 6 7 8 9 { \u0026#34;plugins\u0026#34;: [ \u0026#34;-summary\u0026#34;,\u0026#34;-katex\u0026#34;,\u0026#34;mathjax-pro\u0026#34;,\u0026#34;anchor-navigation-ex-toc\u0026#34;, \u0026#34;search-plus\u0026#34;,\u0026#34;-lunr\u0026#34;,\u0026#34;-search\u0026#34;,\u0026#34;splitter\u0026#34;,\u0026#34;copy-code-button\u0026#34;,\u0026#34;github\u0026#34;, \u0026#34;theme-comscore\u0026#34;,\u0026#34;-latex-codecogs\u0026#34;,\u0026#34;tbfed-pagefooter\u0026#34;,\u0026#34;-expandable-chapters-small\u0026#34;, \u0026#34;-edit-link-plus\u0026#34;,\u0026#34;expandable-chapters\u0026#34;,\u0026#34;pageview-count\u0026#34;,\u0026#34;-editlink\u0026#34;, \u0026#34;lightbox\u0026#34;,\u0026#34;-highlight\u0026#34;,\u0026#34;prism\u0026#34;,\u0026#34;disqus\u0026#34; ], } 添加完新的插件配置之后，运行gitbook install ./来安装新的插件\ngitbook-plugin-mathjax-pro - npm (npmjs.com) ；PrismJS/prism-themes: A wider selection of Prism themes (github.com) 1 2 3 4 # gitbook-plugin-mathjax-pro 安装方式 npm install mathjax@2.7.7 npm install gitbook-plugin-mathjax-pro # and editor the book.json as below 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 { \u0026#34;author\u0026#34;: \u0026#34;AikenHong\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Aiken\u0026#39;s Blogs\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;zh-hans\u0026#34;, \u0026#34;plugins\u0026#34;: [ \u0026#34;-summary\u0026#34;,\u0026#34;-katex\u0026#34;,\u0026#34;mathjax-pro\u0026#34;,\u0026#34;anchor-navigation-ex-toc\u0026#34;, \u0026#34;search-plus\u0026#34;,\u0026#34;-lunr\u0026#34;,\u0026#34;-search\u0026#34;,\u0026#34;splitter\u0026#34;,\u0026#34;copy-code-button\u0026#34;,\u0026#34;github\u0026#34;, \u0026#34;theme-comscore\u0026#34;,\u0026#34;-latex-codecogs\u0026#34;,\u0026#34;tbfed-pagefooter\u0026#34;,\u0026#34;-expandable-chapters-small\u0026#34;, \u0026#34;-edit-link-plus\u0026#34;,\u0026#34;expandable-chapters\u0026#34;,\u0026#34;pageview-count\u0026#34;,\u0026#34;-editlink\u0026#34;, \u0026#34;lightbox\u0026#34;,\u0026#34;-highlight\u0026#34;,\u0026#34;prism\u0026#34;,\u0026#34;disqus\u0026#34; ], \u0026#34;pluginsConfig\u0026#34;: { \u0026#34;insert-logo\u0026#34;:{ \u0026#34;url\u0026#34;: \u0026#34;https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210927180958.png\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;background: none; max-height: 120px; min-height: 120px\u0026#34; }, \u0026#34;github\u0026#34;:{ \u0026#34;url\u0026#34;: \u0026#34;https://aikenh.github.io/about/\u0026#34; }, \u0026#34;tbfed-pagefooter\u0026#34;: { \u0026#34;copyright\u0026#34;:\u0026#34;\u0026amp;copy AikenHong\u0026#34;, \u0026#34;modify_label\u0026#34;: \u0026#34;该文件修订时间：\u0026#34;, \u0026#34;modify_format\u0026#34;: \u0026#34;YYYY-MM-DD HH:mm:ss\u0026#34; }, \u0026#34;mathjax-pro\u0026#34;:{ \u0026#34;version\u0026#34;: \u0026#34;2.7.7\u0026#34; }, \u0026#34;prism\u0026#34;:{ \u0026#34;css\u0026#34;: [ \u0026#34;prismjs/themes/prism-tomorrow.css\u0026#34; ], \u0026#34;lang\u0026#34;:{ \u0026#34;flow\u0026#34;: \u0026#34;typescript\u0026#34; } }, \u0026#34;disqus\u0026#34;:{ \u0026#34;shortName\u0026#34;: \u0026#34;aikensdoc\u0026#34; } } } 安装Disqus的时候，要到Disqus官网进行账号注册，并安装个人评论的网站，记录唯一的个人标识符，然后再配置中引入即可；\n使用prism代替\nChapter2 Configure gitbook init会初始化文件目录，文件夹会包含如下的结构：目录中的文件对应有如下的作用\n1 2 3 4 5 6 7 8 9 10 11 . ├── _book # 自动生成的html ├── book.json # 配置文件 ├── README.md # 电子书的前言或者简介 ├── SUMMARY.md # 电子书的目录 ├── chapter-1/ | ├── README.md # 章节的描述 | └── something.md └── chapter-2/ ├── README.md # 章节的描述 └── something.md 编辑对应的SUMMARY同时可以按照文件夹结构进行组织，基本的组织结构可以按照下面的来进行部署\n1 2 3 4 5 6 7 8 9 # 概要 * [卷 I](part1/README.md) * [写作很棒](part1/writing.md) * [GitBook很酷](part1/gitbook.md) * [卷 II](part2/README.md) * [期待反馈](part2/feedback_please.md) * [更好的写作工具](part2/better_tools.md) Chapter3 Deploy 在本地部署和运行一个样本书，设置gitbook的配置文件\n初始化 将书籍创建到当前的目录或者指定的目录中\n1 2 gitbook init gitbook init ./directory # 在指定的目录中生成 构建 使用下面的命令会在当前目录下或者指定目录里生成_book目录，里面的内容是静态站点的资源文件：\n1 gitbook build Debugging 您可以使用选项 --log=debug 和 --debug 来获取更好的错误消息（使用堆栈跟踪）。例如：\n1 gitbook build ./ --log=debug --debug 启动服务 使用下列服务在LocalHost 可以预览我们的的本地书籍\n1 gitbook serve Chapter4 Publish 希望可以不借助gitbook服务来可视化界面，全靠git \u0026amp; cmd \u0026amp; github来进行一系列操作，这样就能通过我的onedrive来进行比较好的统一管理\n托管到Github Pages optional: 创建username.github.io的个人repo,可以通过jekyll 来init该githubpage\n创建note\u0026rsquo;s repo, 用来存储自己的所有Liture 调用gitbook serve之后将_book的文件推送到repo的gh-pages分支 就可以在下列的url中看到自己的文档：aikenh.github.io/REPONAME/ 修改io文件夹中的_layout中的Default.html如下 1 \u0026lt;a href=\u0026#34;https://aikenh.github.io/Docs/\u0026#34;\u0026gt;Blog\u0026lt;/a\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # enter the right dir # we need to excute gitbook serve int terminal first cd _book # using condtional rules to control the update actions if [ -d \u0026#34;.git\u0026#34; ];then echo \u0026#34;exist git files\u0026#34; else git init fi # update those blogs using git git add . git commit -m \u0026#34;update those blogs\u0026#34; echo \u0026#34;update the local git log\u0026#34; # push the update to the remote repo git remote add origin git@github.com:AikenH/Docs.git git push -f origin master:gh-pages echo \u0026#34;finish pushing files\u0026#34; Reference 集成GitHub | GitBook文档（中文版） (gitbooks.io) GitBook插件整理 - book.json配置 gitbook-notes (gitbooks.io) 内含github部署资料 Katex 测试验证 Gitbook-plugin-summary 实用配置及插件介绍 gitbook 入门教程之主题插件 Gitbook插件和主题 GitBook相关配置及优化 打造完美写作系统：Gitbook+Github Pages+Github Actions - phyger - 博客园 (cnblogs.com) 插件 ","permalink":"https://hugotest-phi.vercel.app/posts/gitbook/","summary":"\u003cp\u003eGitbook命令行工具，基于Markdown编写文档，后续基于Github发布该Blog\u003c/p\u003e\n\u003cp\u003e笔记的构建流程：\u003c/p\u003e\n\u003ch2 id=\"chapter1-install\"\u003eChapter1 Install\u003c/h2\u003e\n\u003cp\u003e安装\u003ccode\u003eGitbook\u003c/code\u003e之前我们需要安装\u003ccode\u003enode.js\u003c/code\u003e和\u003ccode\u003enpm\u003c/code\u003e的依赖，使用\u003ccode\u003enpm\u003c/code\u003e安装\u003ccode\u003egitbook\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e首先安装Install Nodejs，Npm\u003c/p\u003e\n\u003cp\u003eWindows：\u003ca href=\"https://nodejs.org/zh-cn/download/\" target=\"_blank\" rel=\"noopener\"\u003eNode.js (nodejs.org)\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003eLinux:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# add \u0026amp; update apt source before install nodejs.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecurl -sL https://deb.nodesource.com/setup_14.x \u003cspan class=\"p\"\u003e|\u003c/span\u003e sudo -E bash -\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# install nodejs after that.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install -y nodejs\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e然后安装gitbook\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm install gitbook-cli -g \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egitbook fetch beta \u003cspan class=\"c1\"\u003e# 安装历史版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egitbook ls-remote \u003cspan class=\"c1\"\u003e# 列举可以下载的版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e检查Gitbook版本\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egitbook -V\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- more --\u003e\r\n\u003ch3 id=\"安装gitbook插件\"\u003e安装Gitbook插件\u003c/h3\u003e\n\u003cp\u003e安装插件主要有两种方式：一种是直接通过book和gitbook的安装来实现，另一种是基于Npm预先安装\u003c/p\u003e","title":"Build Gitbook"},{"content":"Desc: GAME, RL Finished?: Yes Tags: Paper URL1: https://arxiv.org/abs/2106.06135 URL2: https://github.com/kwai/DouZero URL3: https://github.com/datamllab/rlcard-showdown ）\n使用蒙特卡洛方法进行自我对弈不断更新预测模型的方法，这实际上也是普通人对于强化学习如何在self-play中实现自我更新的最基础的想法把： 自我对弈（记录动作序列）- 用最终的胜负（价值）更新网络。\n算法的设计和思路 算法的目标是学习一个价值网路。网络的输入是当前状态和一个动作，输出是在当前状态做这个动作的期望收益（比如胜率）。简单来说，价值网络在每一步计算出哪种牌型赢的概率最大，然后选择最有可能赢的牌型。蒙特卡罗方法不断重复以下步骤来优化价值网络：\n用价值网络生成一场对局 记录下该对局中所有的状态、动作和最后的收益（胜率） 将每一对状态和动作作为网络输入，收益作为网络输出，用梯度下降对价值网络进行一次更新 其实，所谓的蒙特卡罗方法就是一种随机模拟，即通过不断的重复实验来估计真实价值。\n如下图所示，斗零采用一个价值神经网络，其输入是状态和动作，输出是价值。首先，过去的出牌用 LSTM 神经网络进行编码。然后 LSTM 的输出以及其他的表征被送入了 6 层全连接网络，最后输出价值。\n系统训练的主要瓶颈在于模拟数据的生成，因为每一步出牌都要对神经网络做一次前向传播。斗零采用多演员（actor）的架构，在单个 GPU 服务器上，用了 45 个演员同时产生数据，最终数据被汇集到一个中央训练器进行训练。比较有趣的是，斗零并不需要太多的计算资源，仅仅需要一个普通的四卡 GPU 服务器就能达到不错的效果。这可以让大多数实验室轻松基于作者的代码做更多的尝试。\n该方法的设计和实现上听起来都挺简单的，可以找个时间自己测试一下，玩一玩这个东西，对于我来说，看看他们怎么用这个lstm去进行历史编码的，以及在对transformer了解后，看看如何用transformer去替代这样的lstm是我这边的研究重点。\n蒙特卡洛方法存在的问题 蒙特卡罗方法在强化学习领域中被大多数研究者忽视。学界普遍认为蒙特卡罗方法存在两个缺点：\n蒙特卡罗方法不能处理不完整的状态序列\n蒙特卡罗方法有很大的方差，导致采样效率很低。\n但是斗地主中，可以产生转正的状态序列，同时很容易通过并行来采集大量的样本降低方差，主要是实现上简单，但是可能也是需要大量的数据把。\n蒙特卡洛方法在该任务上存在的优势 很容易对动作进行编码。斗地主的动作与动作之前是有内在联系的。以三带一为例：如果智能体打出 KKK 带 3，并因为带牌带得好得到了奖励，那么其他的牌型的价值，例如 JJJ 带 3，也能得到一定的提高。这是由于神经网络对相似的输入会预测出相似的输出。动作编码对处理斗地主庞大而复杂的动作空间非常有帮助。智能体即使没有见过某个动作，也能通过其他动作对价值作出估计。 不受过度估计（over-estimation）的影响。最常用的基于价值的强化学习方法是 DQN。但众所周知，DQN 会受过度估计的影响，即 DQN 会倾向于将价值估计得偏高，并且这个问题在动作空间很大时会尤为明显。不同于 DQN，蒙特卡罗方法直接估计价值，因此不受过度估计影响。这一点在斗地主庞大的动作空间中非常适用。 蒙特卡罗方法在稀疏奖励的情况下可能具备一定优势。在斗地主中，奖励是稀疏的，玩家需要打完整场游戏才能知道输赢。DQN 的方法通过下一个状态的价值估计当前状态的价值。这意味着奖励需要一点一点地从最后一个状态向前传播，这可能导致 DQN 更慢收敛。与之相反，蒙特卡罗方法直接预测最后一个状态的奖励，不受稀疏奖励的影响。 Reference 快手开源斗地主AI，入选ICML，能否干得过「冠军」柯洁？ DouZero: Mastering DouDizhu with Self-Play Deep Reinforcement Learning GitHub - kwai/DouZero: [ICML 2021] DouZero: Mastering DouDizhu with Self-Play Deep Reinforcement Learning | 斗地主AI ","permalink":"https://hugotest-phi.vercel.app/posts/rl-douzero/","summary":"\u003cp\u003eDesc: GAME, RL\nFinished?: Yes\nTags: Paper\nURL1: \u003ca href=\"https://arxiv.org/abs/2106.06135\" target=\"_blank\" rel=\"noopener\"\u003ehttps://arxiv.org/abs/2106.06135\u003c/a\u003e\n\nURL2: \u003ca href=\"https://github.com/kwai/DouZero\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/kwai/DouZero\u003c/a\u003e\n\nURL3: \u003ca href=\"https://github.com/datamllab/rlcard-showdown\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/datamllab/rlcard-showdown\u003c/a\u003e\n）\u003c/p\u003e\n\u003cp\u003e使用蒙特卡洛方法进行自我对弈不断更新预测模型的方法，这实际上也是普通人对于强化学习如何在self-play中实现自我更新的最基础的想法把：\n自我对弈（记录动作序列）- 用最终的胜负（价值）更新网络。\u003c/p\u003e\n\u003ch2 id=\"算法的设计和思路\"\u003e算法的设计和思路\u003c/h2\u003e\n\u003cp\u003e算法的目标是学习一个价值网路。网络的输入是当前状态和一个动作，输出是在当前状态做这个动作的期望收益（比如胜率）。简单来说，价值网络在每一步计算出哪种牌型赢的概率最大，然后选择最有可能赢的牌型。蒙特卡罗方法不断重复以下步骤来优化价值网络：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用价值网络生成一场对局\u003c/li\u003e\n\u003cli\u003e记录下该对局中所有的状态、动作和最后的收益（胜率）\u003c/li\u003e\n\u003cli\u003e将每一对状态和动作作为网络输入，收益作为网络输出，用梯度下降对价值网络进行一次更新\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其实，所谓的蒙特卡罗方法就是一种随机模拟，即通过不断的重复实验来估计真实价值。\u003c/p\u003e\n\u003cp\u003e如下图所示，斗零采用一个价值神经网络，其输入是状态和动作，输出是价值。首先，过去的出牌用 LSTM 神经网络进行编码。然后 LSTM 的输出以及其他的表征被送入了 6 层全连接网络，最后输出价值。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911211016\"\u003e\r\n    \u003cimg alt=\"img\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911211016\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911211016\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"img\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e系统训练的主要瓶颈在于模拟数据的生成，因为每一步出牌都要对神经网络做一次前向传播。斗零采用多演员（actor）的架构，在单个 GPU 服务器上，用了 45 个演员同时产生数据，最终数据被汇集到一个中央训练器进行训练。比较有趣的是，斗零并不需要太多的计算资源，仅仅需要一个普通的四卡 GPU 服务器就能达到不错的效果。这可以让大多数实验室轻松基于作者的代码做更多的尝试。\u003c/p\u003e\n\u003cp\u003e该方法的设计和实现上听起来都挺简单的，可以找个时间自己测试一下，玩一玩这个东西，对于我来说，看看他们怎么用这个lstm去进行历史编码的，以及在对transformer了解后，看看如何用transformer去替代这样的lstm是我这边的研究重点。\u003c/p\u003e\n\u003ch2 id=\"蒙特卡洛方法存在的问题\"\u003e蒙特卡洛方法存在的问题\u003c/h2\u003e\n\u003cp\u003e蒙特卡罗方法在强化学习领域中被大多数研究者忽视。学界普遍认为蒙特卡罗方法存在两个缺点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e蒙特卡罗方法不能处理不完整的状态序列\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e蒙特卡罗方法有很大的方差，导致采样效率很低。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但是斗地主中，可以产生转正的状态序列，同时很容易通过并行来采集大量的样本降低方差，主要是实现上简单，但是可能也是需要大量的数据把。\u003c/p\u003e","title":"RL-DouZero"},{"content":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r@Aiken 2021 简明的描述相应的框架和提醒分析，不输出冗余内容，结合笔记和跳转链接进行具体的复习，该文只作为大纲使用。\n适用的情况分析 算法的具体框架和思路 特殊情况描述 怎么读取命令行的输入，在笔试的时候可能会需要 C++笔试读取输入的操作 待整理：\nLink1 ；Link2 输入通常使用while+cin\u0026raquo;来进行，这种方式也可以直接读入整行的string；\n需要注意的是，这种方式的话，如果使用的是getline，当遇到换行符的时候cin会直接停止继续输入；\n1 2 3 4 5 6 7 8 while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b); // 主要是按照类型来进行cin，操作应该是通过空格来分割的。 // 按照我们执行的次数来进行指定次数的读取操作 以指定符号分割的字符串输入 char str[3][11]; cin.getline(str[0], 11, \u0026#39;,\u0026#39;); //接收最多10个字符 ,以‘，’作为结束符 cin.getline(str[1], 11, \u0026#39;,\u0026#39;); cin.getline(str[2], 11); //默认结束符 enter 常见数据类型和特殊专题 经常在那种预设值出问题，导致不会更新后续的max or min\n随机数问题 470：用rand7 实现rand10：\n拒绝采样 实际上就是使用7进制来实现10，拒绝多余的选项，继续进行采样\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int rand10() { int col, row, idx; do { row = rand7(); col = rand7(); idx = (row-1) * 7 + col; } while (idx \u0026gt; 40); return 1 + idx % 10; } }; 环形问题： 涉及到环形的问题的时候，如果我们是需要进行遍历操作的话，可以考虑通过取余的方式去解决；\n如果是进行是否是环的判断，我们可以考虑双指针的问题（快慢指针），然后让一个先行之类的策略。\n单调栈模板 下一个更大的xxx的问题；同样，单调的队列也是一个意思(可能就是有窗口的长度约束之类的)\n还有像什么字典序的排列，这一题值得一做，是一个比较灵活的情况\n是一种保持栈中的数据从大到小的结构，当下一个比当前的数据更大的值出现的时候，我们就需要对数据进行记录，然后进行重排。\n设计到环形的数据，也就是更大的下一个最终可能在前面的情况，我们考虑通过原长度的双倍长度去遍历，然后通过取余去取值即可\nindex % n = new index; 需要注意的是index和取值之间的关系也就是我们到底应该存index还是存值；\n窗口是K，那么index到k-1就需要开始判断了，也就是第k个，可能这个时候就需要进行弹出之类的（这种情况是否应该使用双端队列）\n特殊取值问题，我们要考虑输入如果只有一个数字的情况下，还有两个size不等的情况下到底怎么做\n链表问题 这里有两类题需要我自己再揣摩一下，一个是K个一组反转（使用迭代+递归的方式），还有一个是求回文链表的两种技巧（快慢指针同时能判断奇偶的特性）\n其中典型的技巧就是双指针技巧和前序后续遍历技巧，以及快慢技巧 类通用的额外head来实现正向和后序遍历同时进行的过程。(比如判断回文链表) 二叉树问题 二叉树问题很多情况下表现为一个遍历和递归的问题，同时其中最重要的是3种遍历方式的特性：前序、中序、后序，典型的就是重建二叉树；下面这一题是比较有启发性的：\n二叉树中的最大路径和（142） return的值和中间进行判断，以及最终结果的统计值是不同的 所以维护一个全局的ans，来区分这个过程。 经典难题 序列化和反序列化 这种用字符串来表示树的，一定要记得间隔和结尾是两个不同的符号来表征；\n动态规划问题 WORKFLOW：明确状态（DP表各个index对应的子状态含义）、明确状态转移的过程、通过状态转移判断迭代的方向、根据方向和题解确定base cases、根据状态的转移过程优化压缩dp表的空间\n题型方面实际上应该主要是下面的几类问题：\n能分成子问题的最优解问题 序列匹配问题 “逐步”的过程：博弈 难点：实际上就是动态转移方程的构建和dp表的建立，我们要明确这样一个状态转移的过程。\n思路：和递归是一样的，假设子问题解决了，到新问题，\n压缩：要注意我们在删除维度的时候是不是会导致新的数据覆盖掉了需要的数据（决定好迭代的方向）\n闫式DP分析法： 状态表示（把集合表现为数） \u0026amp; 状态计算 （化整为零，划分成若干个子集去做，）\n属性：max，min，count；（题目问的是什么）\n划分子集依据：寻找最后一个不同点\nLINK1 ； Link2 选择问题： 每一个维度是一个条件\n第一个维度：我只考虑前i个问题（物品），第二个维度一般都是限制，存放属性（也就是最大的xxx）\n最后一个不同点：对最后一个物品i，做出的不同选择，来进行状态转移\n正则表达式问题： 永远的痛，我们怎么把他归化到小问题，也就是为什么我们最多只需要往回退一次\n考虑当前组合：匹配并丢弃（往前规划的时候j-2） j-1 匹配不丢弃（往前归化的时候j不变） i-1 不匹配。j-2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: bool isMatch(string s, string p) { // 考虑两种情况：普通的匹配和*号匹配 // 建立DP-table 考虑初始情况 int m = s.size() + 1; int n = p.size() + 1; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; DP(m, vector\u0026lt;bool\u0026gt;(n, false)); DP[0][0] = true; // 下面这个可以转换成\u0026amp;\u0026amp;语句可能会更好看点 for (int i = 2; i \u0026lt; n; i+=2) { if(p[i-1] == \u0026#39;*\u0026#39;) DP[0][i] = DP[0][i-2]; } // 下面开始状态转移 for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (p[j - 1] == \u0026#39;*\u0026#39;) { // 其实就是考虑两种情况: 最后的不同，第一个方式是我们抛弃前一个元素，第二个方式就是正常匹配，用了且过，第三个方式是我们用了且保留，那么就会出现一种情况，也就是在i的上一个时刻，已经和我们当前的*匹配了，但是我们还在继续匹配，这里要注意，这里不是和dp[i-1][j-1]比，和这个比的话，实际上就是正常的对比了，看下面的else，i-1 *中包含了i-2 * ，所以前面的我们就不需要再重复考虑了 DP[i][j] = DP[i][j - 1] || DP[i][j - 2] || DP[i - 1][j] \u0026amp;\u0026amp; (p[j - 2] == s[i - 1] || p[j - 2] == \u0026#39;.\u0026#39;); } else { // 如果没有*号的特殊情况下的时候，考虑就是前面的相等以及当前的相等，或者说就是. DP[i][j] = DP[i - 1][j - 1] \u0026amp;\u0026amp; (p[j - 1] == s[i - 1] || p[j-1] == \u0026#39;.\u0026#39;); } } } return DP[m - 1][n - 1]; } }; 编辑距离 这一题的二维很好写，也是一个帮助理解DP方法的一个很好的例子，但是在压缩成一维的时候有很多的细节这里要注意\n首先是初始化的问题，还有在内层循环要将第一个数的初始化在这里进行赋值，（第一行，和第n行的第一个需要被初始化） 这里i-1，j-1的形式就比较老生常谈了； 这里的if else 就变成必要的了！（所以能表达的更清楚的时候，大多数时候我们还是不要省略else，这样的话也能减少不必要的运算）（暂时还没搞清楚），同时这里的和自己进行min的方式就不能用了，因为我们原本是初始化成一个很大的数，但是在这里的象征意义就已经被改变了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int minDistance(string word1, string word2) { // 实际上这题已经很熟悉了，这里需要做的就是构建一个DP table，以及状态转移 // 切分的状态就是string的index if(word1.empty()) return word2.size(); if(word2.empty()) return word1.size(); // 建立dp table size_t len1 = word1.size(); size_t len2 = word2.size(); vector\u0026lt;int\u0026gt; dp(len2+1); // 初始化base-case，当一个是空，另一个不是空的情况 for(int i =0; i\u0026lt;=len2;i++) dp[i] = i; // 通过转移方程确定搜索的方向，从而确定遍历的方向，建立状态转移方程 int prec, temp; for(int i =1; i\u0026lt;=len1;i++){ prec = dp[0]; dp[0] = i; for(int j =1; j\u0026lt;=len2;j++){ // dp i,j 象征着word1到i 变换到word2 需要的变换操作数， // 当当前的值相等的时候 temp = dp[j]; if(word1[i-1] == word2[j-1]) dp[j] = prec; else{ // 插入一个才能变道j dp[j] = min(min(dp[j-1],dp[j]),prec)+1; } prec = temp; } } return dp[len2]; } }; 俄罗斯套娃： 这种两个维度，然后相互嵌套的问题，为了让其中的一个等大被抵消掉，所以一个逆序，另一个正序，然后寻找最长递增子序列。（找最长子序列的时候要找对搜索方向）\n子序列问题： 一维的DP数组：这种子序列问题（子序列不同于子串），需要的一般都是以i为结尾的情况下，取得的最值，这样才符合我们需要归纳 的条件。\n1 2 3 4 5 6 7 8 9 // 基础的算法模板如下 int n = array.length; int[] dp = new int[n]; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { dp[i] = 最值(dp[i], dp[j] + ...) } } 在子数组array[0..i]中，以**array[i]**结尾的目标子序列（最长递增子序列）的长度是dp[i]。\n二维的DP数组:这种思路其实用的更多，尤其是涉及到数组，两个字符串这样的问题的情况下，这种思路实际上涵盖了，包含一个字符串和两个字符串的情况\n1 2 3 4 5 6 7 8 9 10 11 int n = arr.length; int[][] dp = new dp[n][n]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; n; j++) { if (arr[i] == arr[j]) dp[i][j] = dp[i][j] + ... else dp[i][j] = 最值(...) } } 涉及两个字符串/数组时（比如最长公共子序列），dp 数组的含义如下：\n在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为dp[i][j]。\n可以参考的是编辑距离和最长公共子序列两个文章\n只涉及一个字符串/数组时（比如本文要讲的最长回文子序列），dp 数组的含义如下：\n在子数组array[i..j]中，我们要求的子序列（最长回文子序列）的长度为dp[i][j]。\n最长回文子序列\n假设i+1，j-1已经是最好的情况，当现在的两端不是相同，就没办法同时产生增益，也就是要么是左侧的最大值要么是右侧的最大值两种情况\n最长公共子序列\n实际上考虑下来和最长回文子序列是一样的问题，两边相同，同时产生增益，但是如果两边不同的话，就是两侧的其中一个max了。\n四键键盘问题\n实际上实现上和最长递增子序列稍微有点像，但是思路上的差别还是比较多的：要么就是一直按ａ，要么就是在某个地方开始ｃｖ所以我们存放的还是当前的最长值，然后通过一个内层循环，判断从哪开始cv就行。\n股票问题 简单的直接贪婪的计算正向差就完事了，或者通过迭代来计算前向的最大和；\n动态规划方法的计算框架：定义两个维度，当天我们是否持有股票，然后进行状态的转移方程；（空间复杂度未优化的计算情况如下）（可以优化成4个值，实际上3个就好）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); // 根据受伤是否持有股票来进行运算，存放第i天能获取的最大利益； vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(2, 0)); // 可以先将购买消耗掉 dp[0][1] = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { // 容易出错的就是买卖的最终价格计算 dp[i][0] = max(dp[i - 1][1] + prices[i], dp[i - 1][0]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } }; 限制交易次数（最通用的情况）： 使用动态规划的话，+次数约束：把pair分开，变成两个加了k约束的dptable；188题，可以再看看\n资金冻结一天，就将交易时间稍微修改一下，卖出后的那个值变成i-2就行了\n每次需要手续费，我们只需要在购买的时候扣除手续费就行。\n状态机解法\n实际上也就第三题只进行两次交易的情况好一些，也就是说，当我们只进行一次买入的时候是s1，然后我们进行一次买入一次卖出的时候是s2，以此类推，然后再上一个s的情况下进行状态的更新就性了没什么特殊的地方。\n打家劫舍问题：\n实际上像二叉树那样的题目可以和股票一样分成两个状态去做，也能够和之前是一摸一样的，用递归的方法加上备忘录去做，但是递归的方法实际上就是dfs，我们先递归到最底层然后加入备忘录然后进行计算，这样我们在递归的时候就要确定现在的这个值我们之前是不是已经计算过了。\n最坏情况下的最好 高楼扔鸡蛋问题 : 通过碎或不碎来对问题切割成子问题，然后两个单调序列使用二分法查找；\n戳气球问题 这题比较难就另外提出来说了：实际上思路就是假设i，j是戳破i，j这个开区间以后能够得到的最大的res，然后我们遍历每个k，其中的最大值就是i，j的最大值了。然后这就是个动态归化的问题，搜索方向其实也比较简单，写起来就没啥\nKMS字符串匹配算法： 基本想要实现的就是让指针i不走回头路，不会进行重复的扫描，理论上这样需要一个影子指针去做。\n实际上就是设计一个delay，然后同步进行状态的推进，然后base case就是当匹配到i个字符的时候进行加1，然后main遇到每个元素后要跳转到哪，全问delay，只有匹配的时候进行下一个状态的演变\n博弈问题 实际上是一种特殊的动态规划问题，这里的技巧是使用pair，然后将dp中的值定义为first：先手能取到的最高总分； sec：后手能取到的最值总分；\n然后我们就能通过先后手和当前的状态图来计算得到一个状态传递方程了\n背包问题 实际上是动态规划的子问题，但是这里我们还是独立出来说一下\n（核心）状态的选择：分别是重量、对应的item，存储当前的value，然后每次对item做0，1选择来做状态转移。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int knapsack(int W, int N, vector\u0026lt;int\u0026gt;\u0026amp; wt, vector\u0026lt;int\u0026gt;\u0026amp; val) { // vector 全填入 0，base case 已初始化 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(N + 1, vector\u0026lt;int\u0026gt;(W + 1, 0)); for (int i = 1; i \u0026lt;= N; i++) { for (int w = 1; w \u0026lt;= W; w++) { if (w - wt[i-1] \u0026lt; 0) { // 当前背包容量装不下，只能选择不装入背包 dp[i][w] = dp[i - 1][w]; } else { // 装入或者不装入背包，择优 dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], dp[i - 1][w]); } } } return dp[N][W]; } 分割等和子集： 需要注意，当我们进行bool转化和压缩的时候，为了防止被更新覆盖掉，所以我们最好还是使用反向的迭代方式\n零钱兑换问题：状态转移实际上还是和分割子集是一样的，就是如何将用不用这个item（因为可以是无数个），给归化出来。\n用其他硬币到j 用所有硬币到[j-coint[i]]\n贪心算法 实际上就是一种极端的思想，取各个最优的情况进行选择的这种思想：\n最长上升子序列：让子序列的末尾尽可能的小： 当我们大于数组的结尾的时候就给数组的结尾加长，不然就找到第一个比他小的数组后面那个数字给替换掉。在这里使用二分查找的思路。 区间重叠、破气球问题：按照区间结束得早来排序，最终归纳出重叠区间即可 跳跃游戏：没啥好说的就，贪，然后找到最远的地方，然后这个时候要注意一下，我们改如何去更新步数，就好（每一次的最远的边界更新一次距离即可） 回溯算法（backtrack） 解决一个回溯问题，实际上就是一个决策树的遍历过程。只需要考虑三个问题\n1、路径：也就是已经做出的选择。\n2、选择列表：也就是你当前可以做的选择。\n3、结束条件：也就是到达决策树底层，无法再做选择的条件。\n具体代码框架：其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」 我觉得这里应该就是存储一个中间结果来做把。通过具体的代码来看看\n1 2 3 4 5 6 7 8 9 10 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 全排列问题、组合问题、n皇后问题、子集问题、数独（主要是棋盘格子中的坐标转换，其他的和n皇后没什么区别）、合成括号生成（也就是分别对左右进行回溯，然后其他的也没什么区别了）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; backtrack(res, nums, 0, nums.size()); return res; } void backtrack(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; res, vector\u0026lt;int\u0026gt;\u0026amp; output, int first, int len) { if (first == len) { res.emplace_back(output); return; } for (int i = first; i \u0026lt; len; i++) { swap(output[i], output[first]); backtrack(res, output, first + 1, len); swap(output[i], output[first]); } } }; BFS算法： 其他的也不多说了，实际上就一个重点，那就是要使用队列这个数据结构来做，BFS也有一个特点就是，找到的路径一般是最短的， 也就是和七点的最短距离，但是相应的我们会需要更多的空间复杂度。\n在BFS需要深度的时候，我们可以\n同时用pair来维护一个深度信息. 每次把queue中的数据清空再来size++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 计算从起点 start 到终点 target 的最近距离 int BFS(Node start, Node target) { Queue\u0026lt;Node\u0026gt; q; // 核心数据结构 Set\u0026lt;Node\u0026gt; visited; // 避免走回头路 q.offer(start); // 将起点加入队列 visited.add(start); int step = 0; // 记录扩散的步数 while (q not empty) { int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ for (int i = 0; i \u0026lt; sz; i++) { Node cur = q.poll(); // 访问队列中的当前节点 /* 划重点：这里判断是否到达终点 */ if (cur is target) return step; /* 将 cur 的相邻节点加入队列 */ for (Node x : cur.adj()) if (x not in visited) { q.offer(x); visited.add(x); } } /* 划重点：更新步数在这里 */ step++; } } 转盘锁问题 实际上我们可以看成每个状态有8个可能的前进方向，然后用BFS就能优先遍历到。如果是回溯的话也差不多的写，但是问题是这样的搜索时间是一定需要遍历完所有的可能性的。实际上回溯就是我们每一步的变换+4就行了，基本的答题代码还是一致的。\n用HASH来避免重复的遍历\n双向的bfs优化：维护两个set（用来交替进行）和一个visited。\n滑动谜题：实际上也能分析成是一个树一样的决策结构，然后我们希望找到最低的深度，这样的话，关键还是遍历还有一个避免重复。\nTrick：转化为维度1来节省空间和时间，也可以直接将邻居列出来\n1 2 3 4 5 6 7 8 9 // 记录一维字符串的相邻索引 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; neighbor = { { 1, 3 }, { 0, 4, 2 }, { 1, 5 }, { 0, 4 }, { 3, 1, 5 }, { 4, 2 } }; 分治算法 实际上和回溯，动态规划都是特殊的递归：\n回溯算法就一种简单粗暴的算法技巧，说白了就是一个暴力穷举算法，比如让你 用回溯算法求子集、全排列、组合 ，你就穷举呗，就考你会不会漏掉或者多算某些情况。\n动态规划是一类算法问题，肯定是让你求最值的。因为动态规划问题拥有 最优子结构 ，可以通过状态转移方程从小规模的子问题最优解推导出大规模问题的最优解。\n分治算法呢，可以认为是一种算法思想，通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。这里有点类似动态规划，所以说运用分治算法也需要满足一些条件，你的原问题结果应该可以通过合并子问题结果来计算。\n基本框架：\n1 2 3 4 5 6 7 8 9 10 void sort(int[] nums, int lo, int hi) { int mid = (lo + hi) / 2; /****** 分 ******/ // 对数组的两部分分别排序 sort(nums, lo, mid); sort(nums, mid + 1, hi); /****** 治 ******/ // 合并两个排好序的子数组 merge(nums, lo, mid, hi); } 双指针\u0026amp;\u0026amp;二分查找\u0026amp;\u0026amp;滑动窗口 一些常见的用法：（实际上要么就是两个方向，要么就是两个步调）\n是否有环：相遇可以判定有环； 找到环的起始点：相遇后，把一个调到头，同速前进，再次相遇即是起始点。 链表的中点：快慢指针，快指针到达终点。 延申问题：对链表进行归并排序，通过快慢指针实现二分的操作，合并两个有序链表。 起始点偏差：先让一个指针走k步，另一个指针再出发，寻找链表的倒数第k个元素 类型题总结\n快慢指针：链表操作，归并排序找中点，链表成环搞判定； 左右指针：反转数组，二分搜索 滑动窗口：字串问题，左右指针滑动，前后并进 快慢指针的常见用法：\n二分查找算法，没啥好说的 子数组之和：只要数组有序，就要想到双指针技巧。通过调节left和right来调整sum的大小。找到对应的区间 反转数组：从前或从后出发，然后直接互换。 下面讲的滑动窗口 27.移除元素那一题，我原本写法的优越性，这里可以掌握一下，为啥用while的方式的话，效果反而不好呢\n移除0 这个题还是有一些细节的，普通的写很容易出错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.empty()) return; // 直接进行值的改变是不是好一点，然后在后面进行添加就好了 int index1 = 0; int index2 = 0; while(index2 \u0026lt; nums.size()) { if (nums[index2] != 0) { nums[index1] = nums[index2]; if (index1 != index2) nums[index2] = 0; index1++; } index2++; } return; } }; 二分查找：(了解了，问题不大，晚上再来看下就好) 三种情况：找到值，左侧边界，右侧边界（）\n找到值的方式就没什么好说的：我们直接当相等的时候返回就行，我们主要分析一下左侧边界和右侧边界的情况到底是什么含义：\n左侧边界：满足某个条件的最左边（最小值），比如大于等于二的边界（最左边的那个2）； 右侧边界：满足某个条件的最右边（最大值），比如小于等于二的边界（最右边的那个2）； 结论1：两侧的边界是对称的：实际上画一下还是很容易分析出来的（\u0026gt;= / **\u0026lt;=**的direction）：\n1 2 3 4 5 左侧边界： \u0026gt;= \u0026lt;: l=mid+1 \u0026gt;= : r = mid-1 检测左侧边界是否合理 return l； 右侧边界： \u0026lt;=\r\u0026lt;=: l=mid+1 \u0026gt; : r = mid-1\r检测右侧边界是否合理\rreturn r； 结论2：**\u0026gt;= 换成\u0026gt; :**或者小\u0026lt;=换成\u0026lt;:只需要换一下相等的情况即可：\n1 2 3 4 5 左侧边界：\u0026gt; \u0026lt;=: l=mid+1 \u0026gt; : r = mid-1 检测左侧边界是否合理 return l； 1 2 3 4 5 右侧边界：\u0026lt; \u0026lt;: l=mid+1 \u0026gt;= : r = mid-1 检测右侧边界是否合理 return r； 使用二分查找来解决数组的题目\n存在如下的遍历架构显然是使用二分查找的方法来优化的：koko吃香蕉，货物运输\n1 2 3 for (int i = 0; i \u0026lt; n; i++) if (isOK(i)) return answer; nsum问题 （2-sum）这种问题的关键在于，排序后指针双向而行的时候，怎么排除重复的元素（可以使用while直接跳过当前的指即可）\n（3-4sum）首先取第一个值，然后对剩下的部分求n sum 穷举，（还是需要sort的）\n滑动窗口： 基本的框架思想：\n左闭右开称为窗口； 先增大right到满足，再缩减left直到不满足，每次增加left都要更新一次结果； 重复2，直到r-\u0026gt;end; 具体的实现框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* 滑动窗口算法框架 */ void slidingWindow(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; // 初始化状态，便于搜索 int left = 0, right = 0; int valid = 0; // 统计满足情况的数有多少，和需要的匹配时更新答案 while (right \u0026lt; s.size()) { // c 是将移入窗口的字符 char c = s[right]; // 右移窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(\u0026#34;window: [%d, %d)\\n\u0026#34;, left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) { // d 是将移出窗口的字符 char d = s[left]; // 左移窗口 left++; // 进行窗口内数据的一系列更新 ... } } } 典型例题（76）最小覆盖字串：实现代码后续再做一次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: string minWindow(string s, string t) { if (s.empty() || t.empty()) return {}; // 考虑到出现重复字符的情况，所以需要有一个int进行计数 unordered_map\u0026lt;char, int\u0026gt; need, windows; int l = 0, r = 0, n = s.size(); // 统计需要的每个字符的数量 for (char c : t) need[c]++; int valid = 0, needv = need.size(); int start = 0, lens = INT_MAX; while (r \u0026lt; n) { char temp = s[r]; r++; // 每次就进行所有的缩减边界的行为 if (need.count(temp)) { windows[temp]++; // 只在这里进行状态的变换，不进行判断 if (windows[temp] == need[temp]) { valid++; } } // cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34;now , l \u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;endl; // 左闭右开区间 while (valid == needv \u0026amp;\u0026amp;l \u0026lt; r) { if (r - l \u0026lt; lens) { start = l; lens = r - l; cout\u0026lt;\u0026lt;lens\u0026lt;\u0026lt;endl; } char temp2 = s[l]; if (need.count(temp2)) { if (windows[temp2] == need[temp2]) valid--; windows[temp2]--; } l++; } } return lens==INT_MAX?\u0026#34;\u0026#34;:s.substr(start,lens); } }; 567题的实现细节要看懂：因为是排列，所以长度一定要相同，所以我们每一次递进right的时候同时收紧left就行\n盛水最多的容器 这一题的思路实际上还是典型的如何去缩减这样的问题规模上比较巧妙\n也就是怎么去排除不可能的项，来确定我们的移动方向\nUnion-Find 并查算法 判断连通性的算法：具体实现上，我们实际上就是通过父节点是否相同去判断的；这实际上是一种反向的链表，也就是我们的指针是parent而不是指向next的；\n指针指向父节点，根节点指向子集\n如果要通过这种方式去判断联通的话，那么树的平衡性就是特别重要的问题，也就是我们每次进行接入的时候，我们最好都对该森林进行指向性优化：\n如果我们的parent有parent，我们就直接指向parent？is that right？ 每次将小树接到大树后面，而不是反过来； 需要实现的方法：\nfind（par == self，在find的时候进行压缩）、 connect（是否联通）、 Union（链接，需要优化）\n被围绕的区域130：实际上是一个DFS的题目，我们可以展开成一维去实现，同时在这种情况下使用UF也是可以的，需要注意到的是，每次的四个方向的边界判断。（这应该是这题的难点）\n排序算法总结： 各类时间复杂度，思想，实现 （最后进行正合理和分析）\n参考链接1很直观 ；参考链接2 一、插入排序： 实现：实际上就是对index前面的数据进行从后往前的遍历，遍历过程\u0026gt;index的情况下直接后移，找到合适的位置的时候就将index-\u0026gt;value 放到new index中\n思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。 关键问题：在前面已经排好序的序列中找到合适的插入位置。 方法： 直接插入排序、二分插入排序、希尔排序 直接插入排序 插入排序的最好情况是数组已经有序，此时只需要进行n-1次比较，时间复杂度为O(n)\n最坏情况是数组逆序排序，此时需要进行n(n-1)/2次比较以及n-1次赋值操作（插入）\n平均来说插入排序算法的复杂度为O(n2)\n空间复杂度上，直接插入法是就地排序，空间复杂度为(O(1))\n二分插入排序 ：实际上就是修改了前面的搜索过程 最坏情况：每次都在有序序列的起始位置插入，则整个有序序列的元素需要后移，时间复杂度为O(n2)\n最好情况：待排序数组本身就是正序的，每个元素所在位置即为它的插入位置，此时时间复杂度仅为比较时的时间复杂度，为O(log2n)\n平均情况：O(n2)，实际上就是将搜索的过程变成了logN\n空间复杂度上，二分插入也是就地排序，空间复杂度为(O(1))。\n希尔排序：缩小增量排序 实际上就是根据一个增量序列将原数组切分成一个个子序列然后进行插入排序，然后增量越来越小，最后增量为一进行i一次整体的排序（利用的是直接插入排序在小数组上时间效率高的特点）\n增量排序的时间复杂度依赖于所取增量序列的函数，但是到目前为止还没有一个最好的增量序列.有人在大量的实验后得出结论;当n在某个特定的范围后希尔排序的比较和移动次数减少至n^1.3 不管增量序列如何取值，都应该满足最后一个增量值为1。 有文献指出，当增量序列为d[k]=2^(t-k+1)^时，希尔排序的时间复杂度为O(n^1.5), 其中t为排序趟数。 空间复杂度上，SHELL插入也是就地排序，空间复杂度为(O(1))。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // shell 排序 # include\u0026lt;vector\u0026gt; using namespace std; const int INCRGAP = 2; void shellsort(vector\u0026lt;int\u0026gt;nums) { int insertNum = 0; // 首先计算出各个GAP，然后基于GAP进行插入排序 unsigned int gap = nums.size()/INCRGAP; // GAP\u0026gt;=1 while(gap){ // 实现插入排序；每一个树按照gap去找其前面的数 for(unsigned int i = gap; i\u0026lt;nums.size();i++ ){ int temp = nums[i]; unsigned int j = i; while(j\u0026gt;=gap \u0026amp;\u0026amp; nums[j-gap]\u0026gt;temp){ nums[j] = nums[j-gap]; j-=gap; } // 当数字到了最前面或者第一个比他小的时候，插入 nums[j] = temp; } gap /= INCRGAP; } } int main(){ vector\u0026lt;int\u0026gt; a = {1,3,41,23,5,23,53,123,1}; shellsort(a); for(auto i:a)\tcout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } 二、选择排序： 直接选择排序： 思想：每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最后（tail）位置，直到全部排完。 关键问题：在剩余的待排序记录序列中找到最小关键码记录。 实际上很明（显就是遍历求最值，O（n^2）\n堆排序 由于堆我们知道可以通过VECTOR，然后下标*2 \\ *2+1来索引树结构，然后我们把大顶堆和末尾的数字交换位置，并重新建堆，重复这样的过程即可。\n时间复杂度主要来自：1. 建堆 2. 调整堆\n堆排序的时间复杂度主要由两部分组成：初始化建堆和每次弹出堆顶元素后重新建堆的过程 初始化建堆过程的时间复杂度O(n)：假设堆的高度为k，则从倒数第二层右边的节点开始，这一层的节点都要进行子节点比较然后选择是否交换，倒数第三层类似，一直到第一层(即层数从k-1到1)；那么总的时间为 $(2^{(i-1)})*(k-i)$ ，其中i表示第i层(范围是k-1到1)，2^(i-1)表示该层上有多少元素，(k-i)表示子树上要比较的次数，即 $S = 2^{(k-2)}*1 + 2^{(k-3)}2 + 2^{(k-4)}3 + \u0026hellip; + 2^1(k-2) + 2^0(k-1)$ ，使用错位相减法(用常数2来辅助转换，两边都乘以2再减去原等式)得到S = 2^(K-1) + 2^(K-2) + 2^(K-3) + \u0026hellip; + 2 - (K-1)，忽略最后一项常数项就是等比数列，即 $S=2^k-2-(k-1)=2^k-k-1$ ，又因为k为完全二叉树的深度，所以有 2^k \u0026lt;= n \u0026lt; 2^k-1，可以认为k = logn，综上所述S = n - logn -1，所以时间复杂度为O(n) 弹出堆顶元素后重建堆过程的时间复杂度O(nlogn)：循环n-1次，每次都从跟节点往下循环查找所以每一次时间都是logn，总时间为(n-1)*logn = nlogn - logn 故堆排序的时间复杂度为O(n) + O(nlogn) = O(nlogn) 堆排序是接地排序，所以空间复杂度为常数O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void abjust_heap(vector\u0026lt;int\u0026gt;\u0026amp; nums, int index, int lens) { // 根据二叉树的性质，索引到子节点的坐标 // TODO:但是还要判断越不越界(这里由于我们不是堆，而是一个排序的过程，长度在变，所以需要这个参数的输入) int n = lens; int left = (2 * index) \u0026lt; n ? 2 * index : index, right = (2 * index + 1) \u0026lt; n ? (2 * index + 1) : index; // 如果越界就赋予原值，也就是不改变。 int max_child = nums[left] \u0026gt; nums[right] ? left : right; // 和其中比较大的那个值互换，如果越界了是自己，和自己换 if (nums[index] \u0026lt; nums[max_child]) { swap(nums[index], nums[max_child]); // FIXME: 如果位置变了，要对变换的位置进行继续的递归 abjust_heap(nums, max_child, n); } return; } void heapsort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 通过下标索引来建立堆 // 由于二叉树的叶节点一定是总数的一半左右（len/2 or len/2+1） // 然后再根据数值和坐标的映射关系-1.可以知道非叶子节点的坐标是(len/2-1) int n = nums.size(); // 首先进行建堆的过程 for (int i = (n \u0026gt;\u0026gt; 1) - 1; i \u0026gt;= 0; i--) { // 从倒数第二层开始一个个的进行交换 abjust_heap(nums, i,n); } // 然后依次弹出头部元素进行测试； for (int i = n - 1; i \u0026gt;= 0; i--) { swap(nums[0], nums[i]); abjust_heap(nums, 0, i); } } 三、交换排序： 冒泡排序： 就是对相邻的两个数进行比较，然后将大数往后放，把小数放到前面，第一次冒泡到n-i，递减排序完就行。\n最坏情况：冒泡排序要进行n-1轮排序循环，每轮排序循环中序列都是非正序的，则每轮排序循环中要进行n-i次比较(1\u0026lt;=i\u0026lt;=n-1)，即其外循环执行n-1次，内循环最多执行n次，最少执行1次，由于内循环执行次数是线性的，故内循环平均执行(n+1)/2次，时间复杂度计算为((n-1)(n+1))/2=(-1)/2 ，时间复杂度为O(n2) 最好情况：待排序数组本身就是正序的，一轮扫描即可完成排序，此时时间复杂度仅为比较时的时间复杂度，为O(n) 平均情况：O(n2) 空间复杂度就是在交换元素时那个临时变量所占的内存空间，最优的空间复杂度就是开始元素顺序已经排好了，则空间复杂度为0，最差的空间复杂度就是开始元素逆序排序了，则空间复杂度为O(n)，平均的空间复杂度为O(1) 快速排序： **基本思想：**选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一轮扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分，直到各区间只有一个数。\n最好情况：是每轮划分都将待排序列正好分为两部分，那么每部分需要的时间为上一轮的1/2。如果排序n个元素的序列，其递归树深度为[logn]+1即仅需递归logn次，需要总时间为T(n)的话，第一次需要扫描整个序列，做n次比较，然后将序列一分为二，这两部分各自还需要T(n/2)的时间，依次划分下去：T(n) = 2T(n/2)+n T(n) = 2(2*(T(n/4)+n/2)+n = 4T(n/4)+2n 等等，且T(1) = 0，所以T(n) = nT(1) + n*logn = O(nlogn) 最坏情况：当待排序列为有序序列(正序或倒序)，每次划分后得到的情况是一侧有1个元素，另一侧是其余元素，则最终要进行n-1轮循环，且第i次循环要进行n-i次比较，总比较次数为n-1 + n-2 + \u0026hellip; + 1 = n(n-1)/2，即时间复杂度为O(n2) 空间复杂度待补充。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 int quickSortPartition(vector\u0026lt;int\u0026gt;\u0026amp; s, int l, int r) { //Swap(s[l], s[(l + r) / 2]); //若以中间数为基准，则先将中间的这个数和第一个数交换即可 int i = l, j = r, x = s[l]; //将最左元素记录到x中 while (i \u0026lt; j) { // 从右向左找第一个\u0026lt;x的数 // 无需考虑下标越界（有i的约束） while (i \u0026lt; j \u0026amp;\u0026amp; s[j] \u0026gt;= x) j--; if (i \u0026lt; j) // 满足这个条件实际上就是说，已经找到了。不满足就是没找到、 s[i++] = s[j]; //直接替换掉最左元素，如果没找到的话，就不需要换。因为上面有约束 // 从左向右找第一个\u0026gt;x的数 while (i \u0026lt; j \u0026amp;\u0026amp; s[i] \u0026lt;= x) i++; if (i \u0026lt; j) //替换掉最右元素(已在最左元素中有备份） //最左元素一定被覆盖过，若没有，则表明右侧所有元素都\u0026gt;x，那么算法将终止 s[j--] = s[i]; } s[i] = x; //i的位置放了x，所以其左侧都小于x，右侧y都大于x return i; } void quickSort(vector\u0026lt;int\u0026gt;\u0026amp; s, int l, int r) { //数组左界\u0026lt;右界才有意义，否则说明都已排好，直接返回即可 if (l \u0026gt;= r) { return; } // 划分，返回基准点位置 int i = quickSortPartition(s, l, r); // 递归处理左右两部分，i处为分界点，不用管i了 quickSort(s, l, i - 1); quickSort(s, i + 1, r); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def QuickSort(list_): if len(list_) \u0026lt;= 1: return list_ # 左边数组 left = [] # 右边数组 right = [] # 基准数 base = list_.pop() # 对原数组进行划分 for x in list_: if x \u0026lt; base: left.append(x) else: right.append(x) # 递归调用 return QuickSort(left) + [base] + QuickSort(right) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 my version quicksort int quickSortPartition(vector\u0026lt;int\u0026gt;\u0026amp; s, int l, int r) { //Swap(s[l], s[(l + r) / 2]); //若以中间数为基准，则先将中间的这个数和第一个数交换即可 int i = l, j = r, x = s[l]; //将最左元素记录到x中 while (i \u0026lt; j) { // 从右向左找第一个\u0026lt;x的数 // 无需考虑下标越界（有i的约束） while (i \u0026lt; j \u0026amp;\u0026amp; s[j] \u0026gt;= x) j--; // 从左向右找第一个\u0026gt;x的数 while (i \u0026lt; j \u0026amp;\u0026amp; s[i] \u0026lt;= x) i++; if (i \u0026lt; j) swap(s[i], s[j]); } swap(s[i],s[l]); //i,j的位置放了x，所以其左侧都小于x，右侧y都大于x,可以分析，当前的地方存放的一定是小于base的数字，所以直接和base进行一个交换，然后返回当前的坐标即可 return i; } void quickSort(vector\u0026lt;int\u0026gt;\u0026amp; s, int l, int r) { //数组左界\u0026lt;右界才有意义，否则说明都已排好，直接返回即可 if (l \u0026gt;= r) { return; } // 划分，返回基准点位置 int i = quickSortPartition(s, l, r); // 递归处理左右两部分，i处为分界点，不用管i了 quickSort(s, l, i - 1); quickSort(s, i + 1, r); } 四 归并排序 时间复杂度：归并排序主要分为拆分和对有序数组进行排序，拆分操作的时间复杂度为logn，排序的复杂度为n，所以归并排序的时间复杂度为O(nlogn) 归并排序的空间复杂度就是那个临时数组和递归时压如栈的数据占用的空间：n + logn，所以空间复杂度为O(n) (1)基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。归并排序中第二步，对两个有序数组排序法则非常简单，同时对两个数组的第一个位置比较大小，将小的放入一个空数组，然后被放入空数组的那个位置的指针往后移一个，然后继续和另一个数组的上一个位置进行比较，以此类推。直到最后任何一个数组先出栈完，就将另外一个数组里的所有元素追加到新数组后面。\n​ 归并排序和快速排序有那么点异曲同工之妙，快速排序：是先把数组粗略的排序成两个子数组，然后递归再粗略分两个子数组，直到子数组里面只有一个元素，那么就自然排好序了，可以总结为先排序再递归；归并排序：先什么都不管，把数组分为两个子数组，一直递归把数组划分为两个子数组，直到数组里只有一个元素，这时候才开始排序，让两个数组间排好序，依次按照递归的返回来把两个数组进行排好序，到最后就可以把整个数组排好序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void _sort(int n,int a[],int l,int r){ int mid = (l+r)/2; int tem[n]; if(l == r) return; _sort(n,a,l,mid); _sort(n,a,mid+1,r); //归并，将l→mid 和 mid+1→r 两部分有序的数组归并成一个数组 int la = l,lb = mid+1;int k=l; while(la\u0026lt;=mid \u0026amp;\u0026amp; lb\u0026lt;=r){ if(a[la]\u0026lt;a[lb]) { tem[k] = a[la];k++;la++;} else { tem[k] = a[lb];k++;lb++;} } while(la\u0026gt;mid \u0026amp;\u0026amp; lb\u0026lt;=r){ tem[k] = a[lb];k++;lb++;} while(lb\u0026gt;r \u0026amp;\u0026amp; la\u0026lt;=mid){ tem[k] = a[la];k++;la++;} for(int i=l;i\u0026lt;=r;i++){ a[i] = tem[i]; } } ———————————————— 版权声明：本文为CSDN博主「驰骋光束」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/qq_37184747/article/details/72764628 五 基数排序 快排亲兄弟：快速选择算法 数组中的第k个最大的元素：\n自己实现一个二叉堆，（优先队列） 使用快速查找的方法 各种数据结构的模拟编写： 红黑树？平衡树？B+树 hash 冲突解决的方法 开放定址法、再hash法、链地址、公共溢出区\nStack栈，队列的实现 通过vector或者链表，维护一个头部的指针就行\n队列也式类似的实现原理\n二叉堆 通过vector和index*2的关系来实现，主要是一个插入和一个重排两部分算法\nHash的实现 待补充\n一些其他的问题 区间问题 也就是先使用排序，然后进行画图分析就行了；\n其中986：区间有重叠区域的判断 b2\u0026gt;a1 \u0026amp;\u0026amp; b1\u0026gt;a2 （画图看看就知道了）\n计算器 乘除法就使用和栈顶元素先结合，使用栈解决最终的加减法；括号进递归。\n随机算法 1/i 保留原有选择。\n差分数组和前缀和 差分数组主要用于一段区域内的统一加减运算\n快速求素数 从下往上搭建false表\n快速幂运算 模幂运算 这一题自己推导一下，然后自己写，印象更深\n判断括号的合法性： 使用STACK，在出栈的时候进行匹配\n如果带通配符的：双向进行查找，左到右的时候把*当成++ 右到左的时候也把*当成++,在遍历过程中只要小于0了就直接失效 这题实际上也可以使用DP，但是怎么做呢\n状态转移：\n算法： 如果且仅当间隔 s[i], s[i+1], \u0026hellip;, s[j] 能组成有效的括号时，dp[i][j]为 true。只有在下列情况下，dp[i][j] 才为 true：\ns[i] 是 \u0026lsquo;*\u0026rsquo; 号, 且在 s[i+1], s[i+2], \u0026hellip;, s[j] 这个范围能够组成有效的括号 或者，s[i] 为 \u0026lsquo;(\u0026rsquo;，并且在 [i+1，j] 中有一些 k，使得 s[k] 为 \u0026lsquo;)\u0026rsquo;，且(s[i+1:k] 和 s[k+1:j+1])截断的两个间隔可以构成有效的括号；\n批量判断是子序列还是字串 先统计出现的位置，然后针对位置进行二分搜索\n一些常用操作的复习 LINUX：LINK1 GIT：Onenote\nDocker：Markdown\n","permalink":"https://hugotest-phi.vercel.app/posts/intview_%E7%AC%94%E8%AF%95%E9%A2%98%E5%9E%8B%E5%92%8C%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","summary":"\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"aikenhong_blog\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003cp\u003e@Aiken 2021 简明的描述相应的框架和提醒分析，不输出冗余内容，结合笔记和跳转链接进行具体的复习，该文只作为大纲使用。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e适用的情况分析\u003c/li\u003e\n\u003cli\u003e算法的具体框架和思路\u003c/li\u003e\n\u003cli\u003e特殊情况描述\u003c/li\u003e\n\u003cli\u003e怎么读取命令行的输入，在笔试的时候可能会需要\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"c笔试读取输入的操作\"\u003eC++笔试读取输入的操作\u003c/h2\u003e\n\u003cp\u003e待整理：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/e01528/article/details/99206024\" target=\"_blank\" rel=\"noopener\"\u003eLink1\u003c/a\u003e\n；\u003ca href=\"https://blog.csdn.net/weixin_41506062/article/details/106888825?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control\u0026amp;dist_request_id=\u0026amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control\" target=\"_blank\" rel=\"noopener\"\u003eLink2\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e输入通常使用while+cin\u0026raquo;来进行，这种方式也可以直接读入整行的string；\u003c/p\u003e\n\u003cp\u003e需要注意的是，这种方式的话，如果使用的是getline，当遇到换行符的时候cin会直接停止继续输入；\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 主要是按照类型来进行cin，操作应该是通过空格来分割的。\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 按照我们执行的次数来进行指定次数的读取操作\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"err\"\u003e以指定符号分割的字符串输入\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003estr\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e][\u003c/span\u003e\u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetline\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estr\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"sc\"\u003e\u0026#39;,\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e//接收最多10个字符 ,以‘，’作为结束符\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetline\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estr\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"sc\"\u003e\u0026#39;,\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetline\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estr\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e     \u003cspan class=\"c1\"\u003e//默认结束符 enter\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c!-- more --\u003e\r\n\u003ch2 id=\"常见数据类型和特殊专题\"\u003e常见数据类型和特殊专题\u003c/h2\u003e\n\u003cp\u003e经常在那种预设值出问题，导致不会更新后续的max or min\u003c/p\u003e\n\u003ch3 id=\"随机数问题\"\u003e随机数问题\u003c/h3\u003e\n\u003cp\u003e470：用rand7 实现rand10：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e拒绝采样\u003c/strong\u003e 实际上就是使用7进制来实现10，拒绝多余的选项，继续进行采样\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSolution\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003erand10\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecol\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003erow\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eidx\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003edo\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003erow\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003erand7\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ecol\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003erand7\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eidx\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erow\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e7\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ecol\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eidx\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e40\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eidx\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"环形问题\"\u003e环形问题：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e涉及到环形的问题的时候，如果我们是需要进行遍历操作的话，可以考虑通过取余的方式去解决；\u003c/p\u003e","title":"Leetcode 题型和框架代码总结"},{"content":"DownSampling：Pooling的全面调研 @Aiken 2021 笔记摘录：\n深度神经网络中的池化方法：全面调研（1989-2020） - 知乎 ；相同论文的简单中文Version 16页综述，共计67篇参考文献。网络千奇百怪，但基础元素却大致相同！本文全面调研了1989至2020年一些著名且有用的池化方法，并主要对20种池化方法进行了详细介绍（这些方法，你都知道么？） 注1：文末附【计算机视…\n来自 https://zhuanlan.zhihu.com/p/341820742 原文：《Pooling Methods in Deep Neural Networks, a Review》\n整合2 池化的根本目的（Motivation） 卷积神经网络是DNN的一种特殊类型，它由几个卷积层组成，每个卷积层后都有一个激活函数和一个池化层。\n池化层是重要的层，它对来自上一层的特征图执行下采样，并生成具有简化分辨率的新feature maps 。该层极大地减小了输入的空间尺寸。 它有两个主要目的。 首先是减少参数或权重的数量，从而减少计算成本。 第二是控制网络的过拟合。\n池化可以增加网络对于平移（旋转，伸缩）的不变性，提升网络的泛化能力。 增大感受野； 降低优化难度和参数数目， 理想的池化方法应仅提取有用的信息，并丢弃无关的细节。\n特征不变性、特征降维、在一定程度上防止过拟合，更方便优化\n主流的池化方法 Average Pooling 平均池化 没啥好说的，就是每个block取一个均值。如下图所示：更关注全局特征\nMax Pooling 最大值池化 更关注重要的局部特征\nimage-20210219153154458\nMixed pooling 在max、average pooling中进行随机选择，来组合pooling\nL_p pooling 作者声称这个泛化能力比Max Pooling要好，输入的平均值权重（也就是和分之一）来进行，算是推广的公式。\n$$ s_j = (\\\\frac{1}{|R_j|}\\\\sum_{i \\\\in R_j}{a_i^p})^{1/p}\r$$\rStochastic Pooling feature_map中的元素按照其概率值大小随机选择，元素被选中的概率与数值大小正相关，这就是正则化操作了。\nimage-20210219160011182\nSpatial Pyramid Pooling （SPP） SPPNet在RCNN之后提出的，用于解决重复卷积计算和固定输出的问题，具体的方法是：在Feature_Map中通过Selective Search获得窗口然后输入CNN中。\n这个池化方法实际上就是多个空间池化的组合，对不同的输出尺度采用不同的划窗大小和步长来确保输出的尺度相同，同时能够融合多种尺度特征，提供更丰富的语意信息，常用于：\n多尺度训练 目标检测中的RPN 实际上也就是（全图pooling一次，全图分成22块Pooling，全图分成44块以后 做Pooling，然后就是固定尺寸的了，前面的输出是256-d 然后就是（4+16+1）* 256 最后的特征\nimage-20210219160238878\nYOLO v3 变体 在YOLO v3中，有一个网络结构中的yolo-v3-spp比原本的准确率更高，具体的cfg如下：\n### SPP ###\r[maxpool]\rstride=1\rsize=5\r[route]\rlayers=-2\r[maxpool]\rstride=1\rsize=9\r[route]\rlayers=-4\r[maxpool]\rstride=1\rsize=13\r[route]\rlayers=-1,-3,-5,-6\r### End SPP ### 这里的SPP是原本的SPPNet的变体，通过多个Kernel Size的maxpool 将最终得到的feature map进行concate，得到新的特征组合：\nSPP有效的原因分析 从感受野角度来讲，之前计算感受野的时候可以明显发现，maxpool的操作对感受野的影响非常大，其中主要取决于kernel size大小。在SPP中，使用了kernel size非常大的maxpool会极大提高模型的感受野，笔者没有详细计算过darknet53这个backbone的感受野，在COCO上有效很可能是因为backbone的感受野还不够大。\n第二个角度是从Attention的角度考虑，这一点启发自CSDN@小楞（链接在参考文献中），他在文章中这样讲：\n出现检测效果提升的原因：通过spp模块实现局部特征和全局特征（所以空间金字塔池化结构的最大的池化核要尽可能的接近等于需要池化的featherMap的大小）的featherMap级别的融合，丰富最终特征图的表达能力，从而提高MAP。\nAttention机制很多都是为了解决远距离依赖问题，通过使用kernel size接近特征图的size可以以比较小的计算代价解决这个问题。另外就是如果使用了SPP模块，就没有必要在SPP后继续使用其他空间注意力模块比如SK block，因为他们作用相似，可能会有一定冗余。\nRegion of Interest Pooling （ROI Pooling） 参考链接：原理以及代码实现 ；Some Detail 以及Align的改进 ；Best One 对于ROI pooling 的讲解首先要从目标检测的框架出发，帮助理解，\n目标检测分为两步：\nregion proposal：输入image，找到所有可能的object的位置（bounding box），也就是ROI，在这过程中可能用到滑窗和selective search。 final classification：确定上阶段的每个region proposal是否是目标类别，或者背景 这样的框架存在问题：\n大量的ROI要进行计算，就很难实时监测，也无法做到E2E 使用ROI Pooling进行简化，输入和作用如下：\n从多个具有卷积核池化的深度网络中获得固定大小的Feature-Map； 对不同尺寸的ROI进行处理，能得到统一的尺寸。 一个表示所有ROI的N*5的尺寸，N是数目，5维度分别是Index，左上角坐标，右下角坐标 具体实现的操作：\n根据输入image，将ROI映射到feature map对应位置； 将映射后的区域划分为相同大小的sections（sections数量与输出的维度相同）； 对每个sections进行max pooling操作； 这样我们就可以从不同大小的方框得到固定大小的相应 的feature maps。值得一提的是，输出的feature maps的大小不取决于ROI和卷积feature maps大小。ROI pooling 最大的好处就在于极大地提高了处理速度。\n下图大黑框是对应的ROI，输出最后的要求是2*2，基于下面的划分再进行maxpooling即可。\nROI Align的改进 ROI pooling在映射的时候出现小数，这是第一次量化，在每个roi中选取多少个采样点进行max pooling也会出现小数。这样的处理可能会丢失数据，降低了模型的精度\nROI Align并不需要对两步量化中产生的浮点数坐标的像素值都进行计算，而是设计了一套优雅的流程。如图2，其中虚线代表的是一个feature map，实线代表的是一个roi(在这个例子中，一个roi是分成了2*2个bins)，实心点代表的是采样点，每个bin中有4个采样点。我们通过双线性插值的方法根据采样点周围的四个点计算每一个采样点的值，然后对着四个采样点执行最大池化操作得到当前bin的像素值。\n**RoI Align做法：**假定采样点数为4，即表示，对于每个2.97 x 2.97的bin，平分四份小矩形，每一份取其中心点位置，而中心点位置的像素，采用双线性插值法进行计算，这样就会得到四个小数坐标点的像素值。\n实际上就是用双线性插值来取代了ROI Pooling的量化过程。\n新颖特殊的池化方法 这一部分的池化方法存在着一些特殊的特性，在实际需要的时候再进行仔细的研究，但是可以将大体的特征简单的描述一下，方便后续寻找。\n中值池化 与中值滤波特别类似，但是用的特别少，中值池化也具有学习边缘和纹理结构的特性，抗噪声能力比较强。\n组合池化 就是将max 和 average concate或者add起来。\nMulti-scale order-less Pooling MOP池化 基于多尺度的池化方式，提升了卷积网络的不变性同时没有破坏卷积网络的可鉴别性，分布从全局与局部池化中提取特征，图示与说明如下：\nNetVLAD Pooling NetVLAD是论文《NetVLAD: CNN Architecture for Weakly Supervised Place Recognition》提出的一个局部特征聚合的方法。\n双线性池化 Bilinear Pooling是在《Bilinear CNN Models for Fine-grained Visual Recognition》被提出的，主要用在细粒度分类网络中。双线性池化主要用于特征融合，对于同一个样本提取得到的特征x和特征y, 通过双线性池化来融合两个特征(外积)，进而提高模型分类的能力。\nUnPooling上采样操作 1.在Pooling（一般是Max Pooling）时，保存最大值的位置。\n2.中间经历若干网络层的运算。\n3.上采样阶段，利用第1步保存的Max Location，重建下一层的feature map。\nUnPooling不完全是Pooling的逆运算，Pooling之后的feature map，要经过若干运算，才会进行UnPooling操作；对于非Max Location的地方以零填充。然而这样并不能完全还原信息。\n光谱池化 图像池化不光发生在空间域，还可以通过DFT变换，在频域空间实现池化，一个使用光谱池化最大池化的例子如下：\n基于排名的均值池化 Rank-based Average Pooling\n这种池化方式的好处事可以克服最大池化与均值池化方式的不足\n$$ S_j = \\\\frac{1}{t}\\\\sum_{i\\\\in R_{j,r_i","permalink":"https://hugotest-phi.vercel.app/posts/pooling/","summary":"\u003ch1 id=\"downsamplingpooling的全面调研\"\u003eDownSampling：Pooling的全面调研\u003c/h1\u003e\n\u003cp\u003e@Aiken 2021 笔记摘录：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/341820742\" target=\"_blank\" rel=\"noopener\"\u003e深度神经网络中的池化方法：全面调研（1989-2020） - 知乎\u003c/a\u003e\n ；\u003ca href=\"https://www.sohu.com/a/442710521_823210\" target=\"_blank\" rel=\"noopener\"\u003e相同论文的简单中文Version\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e16页综述，共计67篇参考文献。网络千奇百怪，但基础元素却大致相同！本文全面调研了1989至2020年一些著名且有用的池化方法，并主要对20种池化方法进行了详细介绍（这些方法，你都知道么？） 注1：文末附【计算机视…\u003c/p\u003e\n\u003cp\u003e来自 \u003ca href=\"https://zhuanlan.zhihu.com/p/341820742\" target=\"_blank\" rel=\"noopener\"\u003ehttps://zhuanlan.zhihu.com/p/341820742\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e原文：《Pooling Methods in Deep Neural Networks, a Review》\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/112216409\" target=\"_blank\" rel=\"noopener\"\u003e整合2\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"池化的根本目的motivation\"\u003e池化的根本目的（Motivation）\u003c/h2\u003e\n\u003cp\u003e卷积神经网络是DNN的一种特殊类型，它由几个卷积层组成，每个卷积层后都有一个激活函数和一个池化层。\u003c/p\u003e\n\u003cp\u003e池化层是重要的层，它对来自上一层的特征图执行下采样，并生成具有简化分辨率的新feature maps 。该层\u003cstrong\u003e极大地减小了输入的空间尺寸\u003c/strong\u003e。 它有两个主要目的。 首先是减少参数或权重的数量，从而减少计算成本。 第二是控制网络的过拟合。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e池化可以增加网络对于平移（旋转，伸缩）的不变性，提升网络的泛化能力。\u003c/li\u003e\n\u003cli\u003e增大感受野；\u003c/li\u003e\n\u003cli\u003e降低优化难度和参数数目，\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e理想的池化方法应仅提取有用的信息，并丢弃无关的细节。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e特征不变性、特征降维、在一定程度上防止过拟合，更方便优化\u003c/strong\u003e\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"主流的池化方法\"\u003e主流的池化方法\u003c/h2\u003e\n\u003ch3 id=\"average-pooling-平均池化\"\u003eAverage Pooling 平均池化\u003c/h3\u003e\n\u003cp\u003e没啥好说的，就是每个block取一个均值。如下图所示：更关注全局特征\u003c/p\u003e\n\u003ch3 id=\"max-pooling-最大值池化\"\u003eMax Pooling 最大值池化\u003c/h3\u003e\n\u003cp\u003e更关注重要的局部特征\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210219153154458.png\"\u003e\r\n    \u003cimg alt=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210219153154458.png\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210219153154458.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210219153154458.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210219153154458.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Pooling"},{"content":"@Aiken 2021 究极万恶的撞车论文\nIntro Motivation ：Tackle the problem of 发现无标注数据中与给定（已知）类别不相交的新类。\nRelated Research：\n现有的方法通常1. 使用标记数据对模型进行预训练； 2. 无监督聚类在未标记的数据中识别新的类\n作者认为label带来的essential knowledge在第二步中没有被充分学习利用到，这样模型就只能从第一步的现成知识中获益，而不能利用标记数据和未标记数据之间的潜在关系\nHypothesis：\n有标记的类别和无标记的类别之间没有Overlap，这样导致在两个类别之间很难建立学习关系，（为啥我感觉这个说的都是屁话）\nSolution：\nOpenmix：将标注的数据和未标注的数据同时混合起来得到一个联合标签的分布中，用两种方式来动态合成示例：\n我们混合标记和未标记数据作为Training Img，混合了已知类别的先验生成的伪标签会比无监督情况下生成的伪标签跟家的可靠？防止在错误的伪标签前提下发生过拟合 在第一步的时候我们鼓励具有高类别置信度的无标记example作为可考虑的类别，然后我们将这些samples作为anchor，并将它们进一步的和无标注的samples整合，这使得我们能够对无标注数据产生更多的组合，并发现更精细的新类关系。 Detail 果然在混合的方式上和MixUp的策略进行比对了，就是diss了Mixup使用伪标签的情景可能会进一步的引入不确定性，导致算法的效果反向优化，就是再label和unlabeled数据上混用mixup，而不是单纯的对unlabel数据集进行混合。\n首先将没有overlap的标签表现为联合标签分布再进行混合，也就是加长onehot，这样的标签的优越性在？对于unlabelled data引入了确定性，防止标签容易过拟合。也就是给伪标签加入了一个锚定，让他能够变化的更平滑\n这尼玛这张图看了不久完事了，bibi一大堆啥的呢。主要分析一下三个损失函数代表的是什么意思。\n对其中的 $L_{ppl}$ 进行特殊的说明：\n由于输入的是pair，所以添加的一个损失也就是分类是否属于同一类，二分类ce 使用的是cos similarity，通过threshold 来判断是否是同一类， 实际上应该也是一个预训练的模块，在实际进行的过程中由于是对无标注数据进行处理，讲道理是无法计算损失的，也没有开源代码。 异同点分析 初步分析结果：\n不使用无监督聚类的方法对新类进行发现，而是使用其他的策略 好像没有使用增量学习的方法进行class-incremental的增量处理，主要的motivation好像是Discovering，并没有Incremental的部分 新数据的组合方式是怎么样的这点好像值得研究一下 ","permalink":"https://hugotest-phi.vercel.app/posts/ow-openmix/","summary":"\u003cp\u003e@Aiken 2021 究极万恶的撞车论文\u003c/p\u003e\n\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eMotivation\u003c/strong\u003e ：Tackle the problem of 发现无标注数据中与给定（已知）类别不相交的新类。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRelated Research：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e现有的方法通常1. 使用标记数据对模型进行预训练； 2. 无监督聚类在未标记的数据中识别新的类\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e作者认为label带来的essential knowledge在第二步中没有被充分学习利用到，这样模型就只能从第一步的现成知识中获益，而不能利用标记数据和未标记数据之间的潜在关系\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e\u003cstrong\u003eHypothesis：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e有标记的类别和无标记的类别之间没有Overlap，这样导致在两个类别之间很难建立学习关系，（为啥我感觉这个说的都是屁话）\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSolution：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOpenmix：将标注的数据和未标注的数据同时混合起来得到一个联合标签的分布中，用两种方式来动态合成示例：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e我们混合标记和未标记数据作为Training Img，混合了已知类别的先验生成的伪标签会比无监督情况下生成的伪标签跟家的可靠？防止在错误的伪标签前提下发生过拟合\u003c/li\u003e\n\u003cli\u003e在第一步的时候我们鼓励具有高类别置信度的无标记example作为可考虑的类别，然后我们将这些samples作为anchor，并将它们进一步的和无标注的samples整合，这使得我们能够对无标注数据产生更多的组合，并发现更精细的新类关系。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"detail\"\u003eDetail\u003c/h2\u003e\n\u003cp\u003e果然在混合的方式上和MixUp的策略进行比对了，就是diss了Mixup使用伪标签的情景可能会进一步的引入不确定性，导致算法的效果反向优化，就是再label和unlabeled数据上混用mixup，而不是单纯的对unlabel数据集进行混合。\u003c/p\u003e\n\u003cp\u003e首先将没有overlap的标签表现为联合标签分布再进行混合，也就是加长onehot，这样的标签的优越性在？对于unlabelled data引入了确定性，防止标签容易过拟合。也就是给伪标签加入了一个锚定，让他能够变化的更平滑\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210414225637547.png\"\u003e\r\n    \u003cimg alt=\"image-20210414225637547\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210414225637547.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210414225637547.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210414225637547\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e这尼玛这张图看了不久完事了，bibi一大堆啥的呢。主要分析一下三个损失函数代表的是什么意思。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210414231455696.png\"\u003e\r\n    \u003cimg alt=\"image-20210414231455696\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210414231455696.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210414231455696.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210414231455696\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"OW-openmix"},{"content":"Desc: RL Finished?: Yes Tags: Paper\n通用人工智能，是否能通过强化学习的奖励机制就实现\n实现AGI，强化学习就够了？Sutton、Silver师徒联手：奖励机制足够实现各种目标 对reward构建AGI的可行性的分析和探讨 这篇文章实际上没有给出一个很好的方案通过reward来实现各种AGI的设计，但是给出了在每一种场景下的AGI的reward设计的设想把。和对用reward进行设计的可行性分析。 同时分析了：感知、社交、语言、泛化、模仿，这几个方面\n类似地，如果人工智能体的经验流足够丰富，那么单一目标（例如电池寿命或生存）可能隐含地需要实现同样广泛的子目标的能力，因此奖励最大化应该足以产生一种通用人工智能。\n这不久回到了最基础的问题，没有这种长线以及大量数据交互以及全面场景的经验流，来支撑这样一个AGI的学习，所以这不也是在现阶段上纸上谈兵嘛？\n对这篇论文我的总结是，我不推荐详细阅读，我觉得收益有限，太理想化，其实和强化学习本身的假设也没有太多新东西，我们可以假设强化学习能带来一个AGI，但是对应的约束和限制确实是有点多了。\n","permalink":"https://hugotest-phi.vercel.app/posts/rl-reward_is_enough/","summary":"\u003cp\u003eDesc: RL\nFinished?: Yes\nTags: Paper\u003c/p\u003e\n\u003cp\u003e通用人工智能，是否能通过强化学习的奖励机制就实现\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s/XTNyLjZ9KfdtHY4Omb9_4w\" target=\"_blank\" rel=\"noopener\"\u003e实现AGI，强化学习就够了？Sutton、Silver师徒联手：奖励机制足够实现各种目标\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"对reward构建agi的可行性的分析和探讨\"\u003e对reward构建AGI的可行性的分析和探讨\u003c/h2\u003e\n\u003cp\u003e这篇文章实际上没有给出一个很好的方案通过reward来实现各种AGI的设计，但是给出了在每一种场景下的AGI的reward设计的设想把。和对用reward进行设计的可行性分析。\n同时分析了：感知、社交、语言、泛化、模仿，这几个方面\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e类似地，如果人工智能体的经验流足够丰富，那么单一目标（例如电池寿命或生存）可能隐含地需要实现同样广泛的子目标的能力，因此奖励最大化应该足以产生一种通用人工智能。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这不久回到了最基础的问题，没有这种长线以及大量数据交互以及全面场景的经验流，来支撑这样一个AGI的学习，所以这不也是在现阶段上纸上谈兵嘛？\u003c/p\u003e\n\u003cp\u003e对这篇论文我的总结是，我不推荐详细阅读，我觉得收益有限，太理想化，其实和强化学习本身的假设也没有太多新东西，我们可以假设强化学习能带来一个AGI，但是对应的约束和限制确实是有点多了。\u003c/p\u003e","title":"Reward is Enough"},{"content":"Created by: Aiken H Desc: GAME, RL Finished?: Yes Tags: Paper\n《Master Complex Control in MOBA Games with Deep Reinforcement Learning》 论文阅读笔记\n@Aiken H 2021.06\nIntroduction and Related Research. MOBA游戏的复杂度和状态空间都远比以前的围棋之类的运动更大，所以难度会更大一些\n早一些的游戏ai使用的是（2015） Deep Q-Network 通过 supervised learning and self-play 结合的训练策略在围棋上击败了专业人类，而最近更多的使用了DRL（Deep Reinforcement Learning）的方法在近几年被进一步的应用。\nNeural Network Architecture Include Contributions the encoding of Multi-modal inputs 多模态输入 the decoupling of inter-correlations in controls 控制内关联解码 exploration pruning mechanism 剪枝设置 Action mask for efficient exploration ❓效率 attack attention(for target selection) Attention机制做目标选择 LSTM for learning skill combos LSTM 机制做技能释放和链接 Optimize by multi-label proximal policy algorithm(improved PPO) dual-clip PPO 帮助训练的收敛 present a systematic and thorough study\ndevelop a deep reinforcement learning framework which provides scalable and off-policy training\nwe develop an actor-critic neural network\n跳转上面的网络架构\nFramework Design (S.O.A.P, $\\gamma$ , $\\tau$ , $\\rho_0$ ) to denote infinite-horizon ： 使用元组去模拟整个动态强化的过程,过程主要的是最大化累计reward\nS 状态空间 O 观察状态空间 A 动作空间 $\\rho_0$ 初始状态分布 $\\gamma$ 折扣系数\n目标MAX： $\\mathbb{E}[\\sum_{t = 0}^{T} \\gamma^t \\tau(s_t,\\alpha_t)]$\n$\\tau: S \\times A \\rightarrow \\mathbb{R}$ 奖励函数\n$\\pi： O \\times A \\rightarrow [0,1]$ 策略\n$P:S\\times A \\rightarrow S$ 状态转移分布\nSUMMARY: This Part is about the basic rule of the RL setting.\nSystem Design The whole system and workflow design will be shown on this part\n由于MOBA游戏复杂的Agent（Players和Characters） 会带来高方差的随机梯度，所以再这种模型的训练中，我们可能会需要一个大的Batach Size来防止Invariant Shift的这种现象，同时并加速训练的有效和收敛性。于是我们设计了一个规模可变，弱耦合的网络架构。\n模型整体由四个部分组成：RL-Learner、AI-Server、Dispatch-Module（调度）、Memory-Pool（记忆池）\nAI-Server:：与环境进行交互模拟（self-play） RL Learning：核心学习网络 Memory Pool：数据存储，为RL提供训练和搜索的实例 Dispatch：数据的收集，压缩，传输 模块之间相互解耦，可以灵活配置， Module Detail AI-Server 传统策略：提供了游戏环境和AI模型之间的交互逻辑，通过相互镜像的策略来进行self-play，从而生成episodes. 对手策略：基于游戏状态中提取的特征使用玻尔兹曼搜索，预测英雄行文（基于softmax的分布采样，发送给CPU执行），返回reward和下一个state CPU版本的FeatherCNN，转换到LOCAL上进行inference Dispatch Module 和多个AI-Service绑定，是一个收集数据样本的服务器，主要包括：奖励，特征，动作概率等 将这些数据压缩和打包，然后发到内存池中 Memory Pool 服务器：内部实现为用于数据存储的内存高效循环队列 支持不同长度的样本，以及基于生成时间的数据采样 RL Learner 分布式训练环境，为了使用Big Batch，使用多个RL Learner并行的从Memory Pool 获取数据，然后通过ring allreduce算法来集成梯度 通过共享内存（而不是socket）和pool来进行数据交换，从而减少IO需求 P2P的在策略更新和AI service进行快速同步 SUMMARY: 经验生成和参数学习是分离的，以及Memory和Dispath的架构，能够使得算法能够很容易的拓展到百万歌CPU内核和数千个GPU。\nAlgorithm Design An Actor-Critic Network 用来建模游戏中的动作依赖关系\n网络架构 由下图说明了网络的状态和动作，为了有效的训练这个网络，提出了一些新颖的策略：目标注意力机制（选择目标）；LSTM用来学习技能combo，和动作选择；控制依赖解耦来建立一个PPO；（先验引入）基于游戏知识的剪枝（Action mask）；优化PPO成dual-clipped PPO 保证大批次和大偏差的收敛性\n对图像、Unit、GameInfo分别提取特征后整合成固定长度的Feature，通过LSTM（考虑时间维度的表征）得到最终的表征，然后通过FC对特征进行分类解码（也可以说是预测把），同时基于状态编码的注意力机制来整合出对象预测，\n$$ 目标注意力：p(t|a) = Softmax(FC(h_{LSTM}·h_{key}^T) $$\rp(t|a)是units上的注意力分布，维度是状态中的单元数。 为了解决多标签策略网络中，同一个动作不同标签之间的关联显示建模困难的问题，独立处理一个动作中的每个标签解耦他们的相互关联。 原始的PPO objective：E:有限批次的经验平均值，其余的参见上面的对照表\n$$ \\max_{\\theta} \\hat{\\mathbb{E}}_{s\\sim \\pi_{\\theta_{old}}}[\\frac{\\pi_{\\theta}(a_t|s_t)}{\\pi_{\\theta_{old}}(a_t|s_t)}]\\hat{A_t} $$\r参数解耦之后可以看到：\n$$ \\max_{\\theta}\\sum_{i=0}^{N_a-1} \\hat{\\mathbb{E}}_{s\\sim \\pi_{\\theta_{old}}}[\\frac{\\pi_{\\theta}(a_t^i|s_t)}{\\pi_{\\theta_{old}}(a_t^i|s_t)}]\\hat{A_t} $$\r有两个优点：简化策略的结构（不考虑相关性）；增加策略的多样性，为了多样性，我们开始的训练过程中，随机了初始化agent的位置。\n缺点：进一步增加的策略训练的复杂度，所以通过action mask来进行简化，在最终输出层来合并动作元素之间的相关性，从而修建需要的策略搜索空间，\nDual-clip PPO 令 $\\tau_t(\\theta) = [\\frac{\\pi_{\\theta}(a_t|s_t)}{\\pi_{\\theta_{old}}(a_t|s_t)}]$ ,由于这个值可能会很大，导致过大的策略偏差，为了缓解这个问题，我们引入\n$$ L^{CLIP}(\\theta)\\hat{\\mathbb{E}}_t[\\min(\\tau_t(\\theta)\\hat{A_t},clip(\\tau_t(\\theta),1-\\epsilon,1+\\epsilon)\\hat{A_t})] $$\r来惩罚政策的极端变化，但是另一种情况下的极端值也会带来无界偏差，所以还有另一端的优化,其中c\u0026gt;1是一个下线常数\n$$ \\hat{\\mathbb{E}_t}[\\max(\\min(\\tau_t(\\theta)\\hat{A_t},clip(\\tau_t(\\theta),1-\\epsilon,1+\\epsilon)\\hat{A_t}),c\\hat{A_t})] $$\r","permalink":"https://hugotest-phi.vercel.app/posts/rl-mobaai_tencent/","summary":"\u003cp\u003eCreated by: Aiken H\nDesc: GAME, RL\nFinished?: Yes\nTags: Paper\u003c/p\u003e\n\u003cp\u003e《Master Complex Control in MOBA Games with Deep Reinforcement Learning》 论文阅读笔记\u003c/p\u003e\n\u003cp\u003e@Aiken H 2021.06\u003c/p\u003e\n\u003ch2 id=\"introduction-and-related-research\"\u003eIntroduction and Related Research.\u003c/h2\u003e\n\u003cp\u003eMOBA游戏的复杂度和状态空间都远比以前的围棋之类的运动更大，所以难度会更大一些\u003c/p\u003e\n\u003cp\u003e早一些的游戏ai使用的是（2015） Deep Q-Network  通过 supervised learning and self-play 结合的训练策略在围棋上击败了专业人类，而最近更多的使用了DRL（Deep Reinforcement Learning）的方法在近几年被进一步的应用。\u003c/p\u003e\n\u003ch3 id=\"neural-network-architecture-include\"\u003e\u003cstrong\u003eNeural Network Architecture Include\u003c/strong\u003e\u003c/h3\u003e\n\u003ch3 id=\"contributions\"\u003e\u003cstrong\u003eContributions\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ethe \u003cstrong\u003eencoding\u003c/strong\u003e of \u003cstrong\u003eMulti-modal inputs 多模态输入\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003ethe \u003cstrong\u003edecoupling\u003c/strong\u003e of inter-correlations in controls \u003cstrong\u003e控制内关联解码\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eexploration \u003cstrong\u003epruning\u003c/strong\u003e mechanism  \u003cstrong\u003e剪枝设置\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAction mask\u003c/strong\u003e for efficient exploration ❓\u003cstrong\u003e效率\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eattack \u003cstrong\u003eattention\u003c/strong\u003e(for target selection) \u003cstrong\u003eAttention机制做目标选择\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLSTM\u003c/strong\u003e for learning skill combos \u003cstrong\u003eLSTM 机制做技能释放和链接\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOptimize\u003c/strong\u003e by multi-label proximal policy algorithm(\u003cstrong\u003eimproved PPO\u003c/strong\u003e)\n\u003cul\u003e\n\u003cli\u003edual-clip PPO 帮助训练的收敛\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003c!-- more --\u003e\r\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003epresent a systematic and thorough study\u003c/p\u003e","title":"RL-MobaAI"},{"content":"Created by: Aiken H Detail: survey Finished?: No Tags: Paper URL1: https://www.cnblogs.com/pinard/category/1254674.html URL2: https://github.com/ljpzzz/machinelearning URL3: https://datawhalechina.github.io/easy-rl/#/ Chapter1 模型基础 强化学习（一）模型基础 强化学习是介于监督和无监督学习之间的，强化学习没有输出值，但是有reward： 同时这个reward是事后给出的，而不是及时回馈的。而无监督学习是只有数据特征，同时数据之间是独立的，没有前后依赖的关系。\nTheory理论基础 简化模型介绍：\n上面的大脑代表我们的算法执行个体，我们可以操作个体来做决策，即选择一个合适的动作（Action）At。下面的地球代表我们要研究的环境,它有自己的状态模型，我们选择了动作At后，环境的状态(State)会变，我们会发现环境状态已经变为St+1,同时我们得到了我们采取动作At的延时奖励(Reward)Rt+1。然后个体可以继续选择下一个合适的动作，然后环境的状态又会变，又有新的奖励值。。。这就是强化学习的思路。\n强化学习的模型关键要素：\n环境的状态S：t时刻环境的状态 $S_t$ 是它环境状态集中的某一个状态 个体的动作A：个体在某个时刻可能做出的动作集合 环境的奖励R：个体在某个时刻对应状态下做出的动作 $A_t$ 得到的奖励会在t+1时刻得到 个体的策略 $\\pi$ ：个体根据当前的环境选择采取动作的策略分布（函数），一般表示为一个条件概率分布的形式，概率大的动作被个体选择的概率显然更高 $$ \\pi(a|s)= P(A_t = a | S_t = s) $$\r在策略 $\\pi$ 和状态s采行动后的价值 $v_\\pi(s)$ ：一般是一个期望函数，因为我们不能每次只能选择当前的reward最大的策略，而是需要考虑大局，所以我们要有一个综合的（当前和后续）的延时奖励。 $$ v_\\pi(s) = \\mathbb{E}(R_{t+1} + \\gamma R_{t+2} + \\gamma ^2 R_{t+3} + ... |S_t = s) $$\r奖励衰减因子 $\\gamma$ ：也就是上式的权重，极端值考虑贪婪和一致等同，范围在[0,1] 环境的状态转移模型：也就是环境从s经过a后转化下一个状态的状态机，也可以表示为一个概率模型 $P_{ss^‘}^a$ (s→s\u0026rsquo; , a) 探索率 $\\epsilon$ ：主要用于训练迭代中，我们一般选择当前价值最大的动作，但是为了搜索空间的完备，我们会用 $\\epsilon$ 的概率去选择非最大价值的动作，来提升训练的鲁棒性 SUMMARY：主要介绍了强化学习模型的workflow以及其中需要考虑的8个主要参数和函数架构。最主要的机制还是Policy和reward设计这一块\nChapter2 马尔可夫决策过程（MDP） 强化学习（二）马尔科夫决策过程(MDP) Easy-RL 在这里可能需要补充一下马尔可夫链的相关理论知识，先粗略的看完这部分再说\n马尔可夫性简化 环境的真实转化状态可能和之前的多个时刻相关，这样会导致建模困难，于是我们对环境的状态转移模型进行马尔可夫性假设。也就是：\n转化到下一个状态s\u0026rsquo;只和当前的状态s相关，与之前的状态无关\n同样的我们对Policy、价值函数也做了同样的马尔可夫性假设来简化。\n其中： $G_t$ 代表收获（return），是从某一个状态开始采样直到终止状态时所有奖励的有衰减的和。\n$$ 1.\\ P_{ss'}^a = \\mathbb{E}(S_{t+1} = s'|S_t=s,A_t=a) $$\r$$ 2. \\ \\pi(a|s) = P(A_t = a | S_t = s) $$\r$$ 3. \\ v_\\pi(s) =\\mathbb{E}_\\pi(G_t|S_t =s) = \\mathbb{E}(R_{t+1} + \\gamma R_{t+2} + \\gamma ^2 R_{t+3} + ... |S_t = s) $$\rSUMMARY：由于环境的复杂时序关系，我们需要进行相应的马尔可夫性的假设，让下一个时刻的状态或者预测值只和当前时刻有关，从而简化并假设出模型\nMDP的价值函数和贝尔曼方程 在上述价值表达式的基础上，加入考虑动作a带来的价值影响，我们就可以得到下面的动作价值函数：\n$$ q_{\\pi}(s, a)=\\mathbb{E}_{\\pi}\\left(G_{t} \\mid S_{t}=s, A_{t}=a\\right)=\\mathbb{E}_{\\pi}\\left(R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} R_{t+3}+\\ldots \\mid S_{t}=s, A_{t}=a\\right) $$\r我们可以通过价值函数的公式得到价值函数的递推关系（贝尔曼方程）：\n$$ \\begin{aligned}\rv_{\\pi}(s) \u0026=\\mathbb{E}{\\pi}\\left(R{t+1}+\\gamma R_{t+2}+\\gamma^{2} R_{t+3}+\\ldots \\mid S_{t}=s\\right) \\\\\r\u0026=\\mathbb{E}{\\pi}\\left(R{t+1}+\\gamma\\left(R_{t+2}+\\gamma R_{t+3}+\\ldots\\right) \\mid S_{t}=s\\right) \\\\\r\u0026=\\mathbb{E}{\\pi}\\left(R{t+1}+\\gamma G_{t+1} \\mid S_{t}=s\\right) \\\\\r\u0026=\\mathbb{E}{\\pi}\\left(R{t+1}+\\gamma v_{\\pi}\\left(S_{t+1}\\right) \\mid S_{t}=s\\right)\r\\end{aligned} $$\r一个状态的价值由该状态的奖励以及后续状态价值按照一定衰减比例联合而成，同样的有：\n$$ q_{\\pi}(s, a)=\\mathbb{E}_{\\pi}\\left(R_{t+1}+\\gamma q_{\\pi}\\left(S_{t+1}, A_{t+1}\\right) \\mid S_{t}=s, A_{t}=a\\right) $$\rSUMMARY：基于马尔可夫假设之后，我们可以将价值函数（动作、状态）表示一个递推的形式，这个递推的形式也被叫做贝尔曼方程。\n状态价值函数和动作价值函数的递推关系 基于状态价值函数的定义以及动作价值函数的定义，我们很容易得到两个价值函数之间的转化关系：\n状态价值函数是动作价值函数对于所有可能动作对于policy的期望。\n利用贝尔曼方程，我们也能反推得状态价值函数来表示动作价值函数：\n当前的reward和可能转移到所有后续状态的价值函数的加权和\n$$ v_\\pi(s) = \\sum_{a\\in A} \\pi({a|s}) q_\\pi(s,a) $$\r$$ q_\\pi(s,a) = R_s^a + \\gamma \\sum _ {s'\\in S} P_{ss'}^a v_\\pi(s') $$\r将上述两个式子互相结合起来，我们可以得到如下的简化（变量）算式（只包含一种价值函数）\n$$ \\begin{gathered}v_{\\pi}(s)=\\sum_{a \\in A} \\pi(a \\mid s)\\left(R_{s}^{a}+\\gamma \\sum_{J \\in S} P_{s s^{\\prime}}^{a} v_{\\pi}\\left(s^{\\prime}\\right)\\right) \\\\q_{\\pi}(s, a)=R_{s}^{a}+\\gamma \\sum_{s^{\\prime} \\in S} P_{s s^{\\prime}}^{a} \\sum_{a^{\\prime} \\in A} \\pi\\left(a^{\\prime} \\mid s^{\\prime}\\right) q_{\\pi}\\left(s^{\\prime}, a^{\\prime}\\right)\\end{gathered} $$\r最优价值函数 这一部分看原文，结合相应的例子一起看，后续可能需要看EasyRL中的markov的相关解读来进行深入的理解和计算的分析。\n解决一个强化学习的问题意味着要找一个最有的policy（策略），让Argent在和环境交互的过程中获得比其他所有策略都更多的收获，找到这个策略，也就意味着我们解决了这样一个强化学习的问题。\n求解最优策略→ 求解最优的价值函数，使得（动作、状态）价值函数获取到最大值的策略就是最优策略。\n对于最优策略我们将动作函数定义为：\n$$ \\pi_{*}(a \\mid s)=\\left\\{\\begin{array}{ll}1 \u0026 \\text { if } a=\\arg \\max _{a \\in A} q_{*}(s, a) \\\\0 \u0026 \\text { else }\\end{array}\\right. $$\r有：\n$$ v_*(s) = \\max_a q_*(s,a)\\\\q_{*}(s, a)=R_{s}^{a}+\\gamma \\sum_{s^{\\prime} \\in S} P_{s s}^{a} v_{*}\\left(s^{\\prime}\\right) $$\r这样我们就可以最终得到：\n$$ \\begin{gathered}v_{*}(s)=\\max _{a}\\left(R_{s}^{a}+\\gamma \\sum_{g^{\\prime} \\in S} P_{s s^{\\prime}}^{a} v_{*}\\left(s^{\\prime}\\right)\\right) \\\\q_{*}(s, a)=R_{s}^{a}+\\gamma \\sum_{s^{\\prime} \\in S} P_{s s^{\\prime}}^{a} \\max _{a^{\\prime}} q_{*}\\left(s^{\\prime}, a^{\\prime}\\right)\\end{gathered} $$\rChapter3 动态规划（DP）求解 强化学习（三）用动态规划（DP）求解 用动态规划来求解强化学习是自然的\n关键的两点：\n问题的最优解可以由递归的最优解来得到 子问题状态间的转移 从上面推出的贝尔曼方程，这个递推公式实际上就是DP求解的状态转移等式，然后相应的Value什么的也和DP求解过程的需求是一一对应的。\n关键的方程，通过这种递推公式，我们可以通过上一个迭代周期的状态价值去计算当前迭代周期状态S的状态价值，这也就是动态规划的一个求解的自然过程。\n基于贝克曼方程推导出来，推导过程已经在上面了\n$$ v_{\\pi}(s)=\\sum_{a \\in A} \\pi(a \\mid s)\\left(R_{s}^{a}+\\gamma \\sum_{J \\in S} P_{s s^{\\prime}}^{a} v_{\\pi}\\left(s^{\\prime}\\right)\\right) $$\r已知条件：状态集S, 动作集A, 模型状态转化概率矩阵P, 即时奖励R，衰减因子γ, 给定策略π\n策略评估求解预测问题 策略评估：求解给定策略的状态价值函数的问题，即强化学习的预测问题。\n求解思路： 从任何一个状态价值函数开始，按照给定的策略，结合关键的贝尔曼递推期望方程，状态转移，reward，更新状态价值函数，直至最终收敛。\n具体而言：\n假设第k轮我们已经计算出了所有的状态的状态价值，然后再k+1轮的时候利用k轮的值通过贝尔曼方程来进行更新。\n$$ v_{k+1}(s)=\\sum_{a \\in A} \\pi(a \\mid s)\\left(R_{s}^{a}+\\gamma \\sum_{s' \\in S} P_{s s^{\\prime}}^{a} v_{\\pi}\\left(s^{\\prime}\\right)\\right) $$\r具体案例上面的网站中去看：（很容易理解）\n策略迭代求解控制问题 控制问题：需要同时求解状态价值函数和策略\n策略迭代：从一个初始任意的策略状态，不断地迭代，调整我们的策略，从而得到一个最优的策略。\n求解思路：贪婪法\n具体而言：\n个体在某个状态下选择的行为，是其能够达到后续所有可能的状态中，状态价值最大的那个状态，\n策略迭代过程的演示：逐步的迭代策略和相应的价值函数，最终使得两者同时收敛\n价值迭代求解控制问题 和上述的策略迭代的问题一样，如果我们使用贪婪的策略去及时调整策略，而不是等到收敛了才调整策略的话，就能很快的减少迭代次数，这样我们状态价值的更新方法也会不太一样，也能更快的收敛\n$$ v_{k+1}(s)=\\max_{a \\in A} \\left(R_{s}^{a}+\\gamma \\sum_{s' \\in S} P_{s s^{\\prime}}^{a} v_{\\pi}\\left(s^{\\prime}\\right)\\right) $$\r异步动态规划算法 在前几节我们讲的都是同步动态规划算法，即每轮迭代我会计算出所有的状态价值并保存起来，在下一轮中，我们使用这些保存起来的状态价值来计算新一轮的状态价值。 另一种动态规划求解是异步动态规划算法，在这些算法里，每一次迭代并不对所有状态的价值进行更新，而是依据一定的原则有选择性的更新部分状态的价值，这类算法有自己的一些独特优势，当然有额会有一些额外的代价。 常见的异步动态规划算法有三种： 第一种是原位动态规划 (in-place dynamic programming)， 此时我们不会另外保存一份上一轮计算出的状态价值。而是即时计算即时更新。这样可以减少保存的状态价值的数量，节约内存。代价是收敛速度可能稍慢。 第二种是优先级动态规划 (prioritised sweeping)：该算法对每一个状态进行优先级分级，优先级越高的状态其状态价值优先得到更新。通常使用贝尔曼误差来评估状态的优先级，贝尔曼误差即新状态价值与前次计算得到的状态价值差的绝对值。这样可以加快收敛速度，代价是需要维护一个优先级队列。 第三种是实时动态规划 (real-time dynamic programming)：实时动态规划直接使用个体与环境交互产生的实际经历来更新状态价值，对于那些个体实际经历过的状态进行价值更新。这样个体经常访问过的状态将得到较高频次的价值更新，而与个体关系不密切、个体较少访问到的状态其价值得到更新的机会就较少。收敛速度可能稍慢。\nSUMMARY 动态规划是我们讲到的第一个系统求解强化学习预测和控制问题的方法。它的算法思路比较简单，主要就是利用贝尔曼方程来迭代更新状态价值，用贪婪法之类的方法迭代更新最优策略。\n动态规划的缺点：实际上是一种遍历的方式\n动态规划算法使用全宽度（full-width）的回溯机制来进行状态价值的更新，也就是说，无论是同步还是异步动态规划，在每一次回溯更新某一个状态的价值时，都要回溯到该状态的所有可能的后续状态，并利用贝尔曼方程更新该状态的价值。这种全宽度的价值更新方式对于状态数较少的强化学习问题还是比较有效的，但是当问题规模很大的时候，动态规划算法将会因贝尔曼维度灾难而无法使用。因此我们还需要寻找其他的针对复杂问题的强化学习问题求解方法。\nChapter 4 用蒙特卡罗法求解 强化学习（四）用蒙特卡罗法（MC）求解 ❓ 由 1. DP方法的全回溯机制（完全遍历）带来的过度的计算复杂度，对于复杂问题的求解困难 2. 很多时候对于状态转化模型P的未知\nDP中问题预测和控制问题的定义是在P已知的情况下定义的，这种称之为：基于模型的强化学习问题 而一般性预测和控制，也就是在状态转化概率矩阵P未知的情况下求解1. 状态价值函数 和2. 1+最优策略的问题 我们需要考虑其他的方法，而不能使用DP方法来求解这样的RL问题——Monto-Calo是一种可行的方法\n已知条件：状态集S, 动作集A, 即时奖励R，衰减因子γ，探索率ε\nMonto-Calo 求解 基于采样的思路：蒙特卡罗法通过采样若干经历完整的状态序列(episode)来估计状态的真实价值。\n经历完整就是这个序列必须是达到终点的。比如下棋问题分出输赢，驾车问题成功到达终点或者失败。 有了很多组这样经历完整的状态序列，我们就可以来近似的估计状态价值，进而求解预测和控制问题了。\n关键公式回顾：\n$$ v_\\pi(s) = \\mathbb{E}(R_{t+1} + \\gamma R_{t+2} + \\gamma ^2 R_{t+3} + ... |S_t = s) $$\rMC求解预测问题（策略评估） 思路：求解某个s的状态价值：对所有采样到的状态序列中，出现该状态之后的收获再取平均值来近似求解。\n$$ G_t = R_{t+1} + \\gamma R_{t+1} + ...+ \\gamma ^{T-t+1}R_T \\\\\rV_\\pi (s) \\approx average(G_t), s.t. S_t = s $$\r一个状态在一个状态序列中多次出现的处理\n主要有两种解决方式：\nFirst Visit： 只统计第一次出现的来进行均值的计算 Every Visit：每一次出现都加入均值的计算，这种方式更适合样本量少的情况，但是计算量要更大一些。 累进更新平均值（Incremental mean）\n如果我们将每个状态序列的值都记录下来在最后进行更新的话，会耗费大量的存储空间，所以我们使用累计更新均值的方法来进行不同轮次之间的迭代。\n换言之：统计当前的均值和状态遍历到的次数。\n$$ \\mu_k = \\frac{1}{k} \\sum_{j=1}^{k}x_j = \\frac{1}{k}(x_k+\\sum_{j=1}^{k-1}x_j) = \\frac{1}{k}(x_k+(k-1)\\mu_{k-1}) = \\mu_{k-1} + \\frac{1}{k}(x_k-\\mu_{k-1}) $$\r然后我们就可以将状态价值公式的更新过程修改成：\n$$ N(S_t) = N(S_t)+1\\\\\rV(S_t) = V(S_t) + \\frac{1}{N(S_t)}(G_t-V(S_t)) $$\r这种情况下的存储空间（内存消耗）就是固定的了。\n对海量数据做分布式迭代的时候 $N(S_t)$ 计算不确定的情况\n$$ V(S_t) = V(S_t) + \\alpha(G_t-V(S_t)) $$\r动作价值函数也是类似的方法。\nMC求解控制问题（策略迭代） 和策略迭代的方式也是类似的，也是先做策略评估，然后通过一定的方法（比如贪婪策略）更新策略。\n和DP相比的不同有如下几点： 策略评估的方法不同 MC优化最优动作价值函数而不是状态价值函数 DP一般使用贪婪法，MC使用 $\\epsilon$ -贪婪法 $\\epsilon$ -贪婪法：\n一般设置一个较小的值，然后用1- $\\epsilon$ 来选择最大行为价值的行为，然后剩下的就随机在m个可行行为中随机选择\n$$ \\pi(a \\mid s)=\\left\\{\\begin{array}{ll}\\epsilon / m+1-\\epsilon \u0026 \\text { if } a^{*}=\\arg \\max _{a \\in A} Q(s, a) \\\\\\epsilon / m \u0026 \\text { else }\\end{array}\\right. $$\r为了使得算法收敛； $\\epsilon$ 会逐渐减小，并趋于0。\n这样会得到一个和动态规划类似的图\n具体的算法流程：\n在这里总结下蒙特卡罗法求解强化学习控制问题的算法流程，这里的算法是在线(on-policy)版本的,相对的算法还有离线(off-policy)版本的。在线和离线的区别我们在后续的文章里面会讲。同时这里我们用的是every-visit,即个状态序列中每次出现的相同状态，都会计算对应的收获值。\n输入：状态集S, 动作集A, 即时奖励R，衰减因子γ, 探索率ϵ　输出：最优的动作价值函数q∗和最优策略π∗　初始化所有的动作价值Q(s,a)=0， 状态次数N(s,a)=0，采样次数k=0，随机初始化一个策略π　k=k+1, 基于策略π进行第k次蒙特卡罗采样，得到一个完整的状态序列:S1,A1,R2,S2,A2,\u0026hellip;St,At,Rt+1,\u0026hellip;RT,ST\n对于该状态序列里出现的每一状态行为对(St,At)，计算其收获Gt, 更新其计数N(s,a)和行为价值函数Q(s,a)：\n$$ G_t = R_{t+1} + \\gamma R_{t+1} + ...+ \\gamma ^{T-t+1}R_T \\\\N(S_t,A_t) = N(S_t,A_t)+1\\\\\rQ(S_t,A_t) = Q(S_t,A_t) + \\frac{1}{N(S_t,A_t)}(G_t-Q(S_t,A_t)) $$\r基于新计算出的动作价值，更新当前的ϵ−贪婪策略： $$ \\epsilon = \\frac{1}{k}\\\\\\pi(a \\mid s)=\\left\\{\\begin{array}{ll}\\epsilon / m+1-\\epsilon \u0026 \\text { if } a^{*}=\\arg \\max _{a \\in A} Q(s, a) \\\\\\epsilon / m \u0026 \\text { else }\\end{array}\\right. $$\r如果所有的Q(s,a)收敛，则对应的所有Q(s,a)即为最优的动作价值函数q∗。对应的策略π(a|s)即为最优策略π∗。否则转到第二步。 SUMMARY:实际上MC方法就是一个简单的采样渐进求平均的方法，在不断的迭代过程中找到相应的槿近似值。\nChapter5 用时序差分法（TD）求解 强化学习（五）用时序差分法（TD）求解 蒙特卡洛法虽然灵活，不需要环境转化概率模型，但是也有限制：所有的采样序列都需要是完整的状态序列，如果没有完整的状态序列，就不能使用Monto-Calo了。\n在不完整的状态序列的情况下，可以使用时序差分算法（Temporal-Difference，TD），这也是一种不基于模型的算法（也就是没有环境转移的情况下）\n关键公式回顾：\n$$ 蒙特卡洛：G_t = R_{t+1} + \\gamma R_{t+1} + ...+ \\gamma ^{T-t+1}R_T \\\\\r贝尔曼（TD）：v_{\\pi}(s) = =\\mathbb{E}{\\pi}\\left(R_{t+1}+\\gamma v_{\\pi}\\left(S_{t+1}\\right) \\mid S_{t}=s\\right) $$\n由于如果使用G的公式的话，我们需要有T时刻的R来进行计算分析， 为了简化这个过程，我们使用贝尔曼的递推式来进行时序差分的分析（实际上是同个等式）\n也就是：\n使用 $R_{t+1} + \\gamma v(S_{t+1})$ （也称为TD目标值） 来代替收获 $G_t$ ，同时令 $R_{t+1} + \\gamma v(S_{t+1}) - V(S_t)$ 称为TD误差，用TD目标值来代替收获G的过程称为引导。这样的话我们只需要两个连续的状态和对应的奖励，就可以尝试求解强化学习的问题了。\nTD预测问题求解 预测问题的求解思路大体上是类似的，但是和MC有两个主要的不同点:\n一个是 $G_t$ 收获的表达式不同\n$$ G(t) = R_{t+1} + \\gamma v(S_{t+1}) $$\r二是迭代的系数稍微有些不同，因为没有完整的序列，所以就没有对应的次数N，所以就用一个[0,1]的系数来代替\n$$ V\\left(S_{t}\\right)=V\\left(S_{t}\\right)+\\alpha\\left(G_{t}-V\\left(S_{t}\\right)\\right) $$\r具体的例子请参考相应的链接，这里写的特别的清楚！GO TO URL\n从例子中我们可以看到MC和TD主要的几点区别：\n时序差分法在知道结果之前就可以学习，也可以在没有结果时学习，还可以在持续进行的环境中学习，而蒙特卡罗法则要等到最后结果才能学习，时序差分法可以更快速灵活的更新状态的价值估计，这在某些情况下有着非常重要的实际意义。‘ 时序差分法在更新状态价值时使用的是TD 目标值，即基于即时奖励和下一状态的预估价值来替代当前状态在状态序列结束时可能得到的收获，是当前状态价值的有偏估计，而蒙特卡罗法则使用实际的收获来更新状态价值，是某一策略下状态价值的无偏估计，这一点蒙特卡罗法占优。 虽然时序差分法得到的价值是有偏估计，但是其方差却比蒙特卡罗法得到的方差要低，且对初始值敏感，通常比蒙特卡罗法更加高效。 所以后续的主流的强化学习方法都是基于时序差分的，后面的文章也会主要基于时序差分来拓展讨论。\nSUMMARY: 实际上TD和对应的DP最大的区别就在于G(t)的计算，从这里可以体现出DP主要依靠的是当前值再所有出现的序列中的状态值的平均，而TD可以依靠其他变量进行递推的这点优势。\nn步时序差分 前面我们的递推式只考虑了一步差分来进行近似，但是实际上我们可以将差分式子变形，变成二次差分项\n$$ G_t^{(2)} = R_{t+1} + \\gamma R_{t+2} + \\gamma^2 V(S_{t+1}) $$\r也可以一次类推到n步的差分项，当n趋于无穷的时候，实际上就等价于MC方法了。\nTD（ $\\lambda$ ） n步时序差分选择多少步数是一个超参数调优的过程，为了再不增加计算复杂度的时候综合考虑所有步数的预测，引入一个新的[0,1]的参数λ，定义λ-收获是n从1到∞所有步的收获*权重的和，每一步的权重带有一定的比例，如下：\n$$ G_t^\\lambda = (1-\\lambda)\\sum_{n=1}^\\infin \\lambda^{n-1}G_t^{(n)} $$\r因此我们就能得到TD（λ）的迭代公式：Q也是类似的，就不重新写一次了\n$$ V(S_t) = V(S_t)+\\alpha(G_t^\\lambda - V(S_t)) $$\r权重衰减的原因如下，随着n增大，权重成集合级数衰减，在T时刻把所有剩余的权重给最终状态，这样可以使得权重嘉禾为1，里当前越远权重越小。\n从前向来看TD(λ)， 一个状态的价值V(St)由Gt得到，而Gt又间接由所有后续状态价值计算得到，因此可以认为更新一个状态的价值需要知道所有后续状态的价值。也就是说，必须要经历完整的状态序列获得包括终止状态的每一个状态的即时奖励才能更新当前状态的价值。这和蒙特卡罗法的要求一样，因此TD(λ)有着和蒙特卡罗法一样的劣势。当λ=0 时,就是第二节讲到的普通的时序差分法，当λ=1 时,就是蒙特卡罗法。\n从反向来看TD(λ)，它可以分析我们状态对后续状态的影响。比如老鼠在依次连续接受了3 次响铃和1 次亮灯信号后遭到了电击，那么在分析遭电击的原因时，到底是响铃的因素较重要还是亮灯的因素更重要呢？如果把老鼠遭到电击的原因认为是之前接受了较多次数的响铃，则称这种归因为频率启发(frequency heuristic) 式；而把电击归因于最近少数几次状态的影响，则称为就近启发(recency heuristic) 式。\n如果给每一个状态引入一个数值：效用(eligibility, E) 来表示该状态对后续状态的影响，就可以同时利用到上述两个启发。而所有状态的效用值总称为效用迹(eligibility traces,ES)。定义为：\n$$ \\begin{gathered}E_{0}(s)=0 \\\\E_{t}(s)=\\gamma \\lambda E_{t-1}(s)+1\\left(S_{t}=s\\right)=\\left\\{\\begin{array}{ll}0 \u0026 t","permalink":"https://hugotest-phi.vercel.app/posts/rl-c1/","summary":"\u003cp\u003eCreated by: Aiken H\nDetail: survey\nFinished?: No\nTags: Paper\nURL1: \u003ca href=\"https://www.cnblogs.com/pinard/category/1254674.html\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.cnblogs.com/pinard/category/1254674.html\u003c/a\u003e\n\nURL2: \u003ca href=\"https://github.com/ljpzzz/machinelearning\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/ljpzzz/machinelearning\u003c/a\u003e\n\nURL3: \u003ca href=\"https://datawhalechina.github.io/easy-rl/#/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://datawhalechina.github.io/easy-rl/#/\u003c/a\u003e\n\u003c/p\u003e\n\u003ch1 id=\"chapter1-模型基础\"\u003eChapter1 模型基础\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.cnblogs.com/pinard/p/9385570.html\" target=\"_blank\" rel=\"noopener\"\u003e强化学习（一）模型基础\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e强化学习是介于监督和无监督学习之间的，强化学习没有输出值，但是有\u003cstrong\u003ereward：\u003c/strong\u003e 同时这个reward是事后给出的，而不是及时回馈的。而无监督学习是只有数据特征，同时数据之间是独立的，没有前后依赖的关系。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911210000.png\"\u003e\r\n    \u003cimg alt=\"https://images2018.cnblogs.com/blog/1042406/201807/1042406-20180729163058011-290427357.png\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911210000.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911210000.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"https://images2018.cnblogs.com/blog/1042406/201807/1042406-20180729163058011-290427357.png\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"theory理论基础\"\u003eTheory理论基础\u003c/h2\u003e\n\u003c!-- more --\u003e\r\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e简化模型介绍：\u003c/p\u003e\n\u003cp\u003e上面的大脑代表我们的算法执行个体，我们可以操作个体来做决策，即选择一个合适的动作（Action）At。下面的地球代表我们要研究的环境,它有自己的状态模型，我们选择了动作At后，环境的状态(State)会变，我们会发现环境状态已经变为St+1,同时我们得到了我们采取动作At的延时奖励(Reward)Rt+1。然后个体可以继续选择下一个合适的动作，然后环境的状态又会变，又有新的奖励值。。。这就是强化学习的思路。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e强化学习的模型关键要素：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e环境的状态S：t时刻环境的状态 $S_t$ 是它环境状态集中的某一个状态\u003c/li\u003e\n\u003cli\u003e个体的动作A：个体在某个时刻可能做出的动作集合\u003c/li\u003e\n\u003cli\u003e环境的奖励R：个体在某个时刻对应状态下做出的动作 $A_t$ 得到的奖励会在t+1时刻得到\u003c/li\u003e\n\u003cli\u003e个体的策略 $\\pi$ ：个体根据当前的环境选择采取动作的策略分布（函数），一般表示为一个条件概率分布的形式，概率大的动作被个体选择的概率显然更高\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv\u003e\r\n$$ \\pi(a|s)= P(A_t = a | S_t = s) $$\r\n\u003c/div\u003e\r\n\u003col start=\"5\"\u003e\n\u003cli\u003e在策略 $\\pi$ 和状态s采行动后的价值 $v_\\pi(s)$ ：一般是一个期望函数，因为我们不能每次只能选择当前的reward最大的策略，而是需要考虑大局，所以我们要有一个综合的（当前和后续）的延时奖励。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv\u003e\r\n$$ v_\\pi(s) = \\mathbb{E}(R_{t+1} + \\gamma R_{t+2} + \\gamma ^2 R_{t+3} + ... |S_t = s) $$\r\n\u003c/div\u003e\r\n\u003col start=\"6\"\u003e\n\u003cli\u003e奖励衰减因子 $\\gamma$ ：也就是上式的权重，极端值考虑贪婪和一致等同，范围在[0,1]\u003c/li\u003e\n\u003cli\u003e环境的状态转移模型：也就是环境从s经过a后转化下一个状态的状态机，也可以表示为一个概率模型 $P_{ss^‘}^a$ (s→s\u0026rsquo; , a)\u003c/li\u003e\n\u003cli\u003e探索率 $\\epsilon$ ：主要用于训练迭代中，我们一般选择当前价值最大的动作，但是为了搜索空间的完备，我们会用 $\\epsilon$ 的概率去选择非最大价值的动作，来提升训练的鲁棒性\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eSUMMARY：主要介绍了强化学习模型的workflow以及其中需要考虑的8个主要参数和函数架构。最主要的机制还是Policy和reward设计这一块\u003c/strong\u003e\u003c/p\u003e","title":"RL Notebook 01"},{"content":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\rLINK1 深度学习部分 DenseNet 任意的两层之间都存在直接的链接，每一层的输入都是前面的所有层的输出的并集，而该层学习的特征图也会是后面所有层的输入，DenseBlock中需要Feature_map保持一致；\nBlock与Block之间的降采样则使用transition layer，使用BN，1*1的 conv，Pooling来降维\n优缺点：\n省参数，省计算 抗过拟合，泛化能力强 需要保存Feature占显存 EfficientNet 针对卷积神经网络的模型拓展，可以通过：1\n增加网络规模可以、 增加模型宽度，增加模型深度，增加输入图像的分辨率，但是如何去人工调整这个比例和参数，比较麻烦， 实验发现ConvNet缩放过程中平衡网络宽度、深度、和分辨率的维度是很重要的 EfficientNet就是对这些的合理组合，复合型的模型扩展技术集合神经结构搜索技术获得 关键技术复合扩张技术\n所以本文提出了复合扩张方法，这也是文章核心的地方，\n$$ \\alpha,\\beta,\\gamma $$\r是我们需要求解的一组参数，如下图公式，带约束的最优参数求解。 $$ \\alpha,\\beta,\\gamma $$\r分别衡量着depth, width和 resolution的比重，其中 $$ \\beta,\\gamma $$\r在约束上会有平方，是因为如果增加宽度或分辨率两倍，其计算量是增加四倍，但是增加深度两倍，其计算量只会增加两倍。\r固定公式中的φ=1，然后通过网格搜索（grid search）得出最优的α、β、γ，得出最基本的模型EfficientNet-B0. 固定α、β、γ的值，使用不同的φ，得到EfficientNet-B1, \u0026hellip;, EfficientNet-B7 φ的大小对应着消耗资源的大小，相当于：\n当φ=1时，得出了一个最小的最优基础模型； 增大φ时，相当于对基模型三个维度同时扩展，模型变大，性能也会提升，资源消耗也变大。 bottleneck Bottleneck layer又称之为瓶颈层，使用的是1*1的卷积神经网络。之所以称之为瓶颈层，是因为长得比较像一个瓶颈。\n中间比较细，像一个瓶颈\n如上图所示，经过 $11 conv$ ，中间那个看起来比较细。像一个瓶颈一样。使用 $11$ 网络的一大好处就是可以大幅减少计算量。深度可分离卷积中，也有这样的设计考虑。如果想具体了解如何大幅减少计算量的话，可以参考参考资料[2]\nXavier参数初始化方法 已经写在笔记上了，但是还要补充的，或者说是理清楚的是怎么推导的或者为什么这么干的，还有其他的初始化方法之间的区别什么的\n模型压缩 为了研究小而快的机器学习模型：1. 对复杂模型进行压缩 2. 直接设计小模型得到训练\n轻量网络：MobileNet 主要的网络架构：是使用depthwise separable convolution也就是xception中提到的这种，双分离的卷积\n然后使用：ReLU6激活函数（限制最大输出为6）\n过程中不使用pooling直接使用stride=2进行下采样\n基本的组件如图所示： 最后用avg pooling从 $771024 $ 到 $111024$\n对其进行瘦身：\n按比例缩放特征图的大小 按比例缩放通道数 核心的计算量实际上在 $1*1 conv$ 这个全通道密集卷积的操作上\nV2：\n引入了shortcut（残差结构）\n在进行depthwise之前先用 $1*1$ 扩张feature_map的通道数\n是为了提升效果，参数量比1还是稍微增加了，\n这里的1*1和resnet中的是完全相反的：\n残差模块：11降维 33卷积 11升维 反残差模块：11升维，33卷积，11降维\n原因：因为depthwise卷积不能改变通道数，因此特征提取受限于输入的通道数，所以将通道数先提升上去。文中的扩展因子为6。\npointwise之后的relu改成了Linear激活函数，防止relu破坏特征\n原因：relu造成的低维度数据塌陷\nhttps://www.sohu.com/a/307566264_100024677 就是当低维信息映射到高维，经过ReLU后再映射回低维时，若映射到的维度相对较高，则信息变换回去的损失较小；若映射到的维度相对较低，则信息变换回去后损失很大。因此，认为对低维度做ReLU运算，很容易造成信息的丢失。而在高维度进行ReLU运算的话，信息的丢失则会很少。\n因为relu函数小于0时候，值为0，是有信息损耗的，而线性激活函数没有信息损耗\n轻量网络：Shufflenet V1 带Pytorch ShuffleNet的核心是采用了两种操作：pointwise group convolution和channel shuffle，这在保持精度的同时大大降低了模型的计算量。\n缓解 $1*1 conv$ 的计算量，也使用channel sparse connection，但是这种group convolution 也有弊端：特征图之间不通信，所以我们就channel shuffle（均匀打乱）\n图3.(a)是一个普通的带有残差结构的深度可分离卷积，例如，MobileNet [5], Xception [6]。ShuffleNet v1的结构如图3.(b)，3.(c)。其中3.(b)不需要降采样，3.(c)是需要降采样的情况。\nV2:\nG1). 使用输入通道和输出通道相同的卷积操作； G2). 谨慎使用分组卷积； G3). 减少网络分支数； G4). 减少element-wise操作。 通道分割在每个单元开始前将通道的输入分成两个，不再使用group卷积，然后concat两个channel并channel shuffle\n轻量网络：squeezeNET 利用Fire module 来实现了：Link Knowledge Distiall 实际上很简单，就是用小模型逼近大模型的输出，用大模型来做小模型的监督，也就是让小模型尽量去适应大模型的输出分布（原本应该只是一个类别标签），这其实已经偏向于一个无监督的驯良过程了，或者说是自监督。\n训练大模型 计算大模型的soft output 训练小模型，在类别的监督信息以外再加上soft target的loss，用lambda来调节传中 使用小模型进行预测。 超参数搜索的方法 网格搜索，随机搜索，贝叶斯优化方法（这种方法实际上还不是太清楚，后面可能还需要看看），AutoML\n激活函数的稀疏性 适应性强，针对不同的情况有不同的激活单元 简洁的模型，计算更快 更好的预测能力和更不容易过拟合 更可分 梯度消失与爆炸 消失：sigmoid ，tanh，\n误差的反向传播造作，我们可以看出这种连乘的形式涉及到了很多的参数和导数，这种时候无论是放大还是缩小的效应都很容易累加起来产生梯度的消失或者膨胀，\n当对当前层的w进行求导的时候，我们需要先对上一层的x求导，就会得到wt+1 与梯度连乘这样的式子，这也是导致梯度爆炸的原因\nsigmoid的最大输出只有1/4所以sigmoid中梯度消失实际上是更常见的时候\n再RNN中BPTT这种反向传播的时候也是类似的思路，但是它是以一个n维矩阵的方式向后传播的，这样当雅可比矩阵的特征值小于1的时候，这样的梯度传播会呈现指数级的变化，要么梯度消失要么梯度爆炸\nResNet 缓解深层网络中梯度消失的问题，实际并不是真正的解决这样的问题，只是给出了一个传播的shortcut，所以掩盖了梯度消失的情况出现，实际上ResNet解决更多的是模型退化的问题，也就是\n梯度爆炸也可以使用梯度裁剪的方法进行解决：当梯度的范数大于阈值的时候，我们对梯度进行等比的搜索，\n损失函数的反向推导 常见的几个损失函数和误差之间的关系（推一下grad的公式）\nSoftmax CE 过拟合欠拟合的判断和处理方式 过拟合的训练方法：\n获取更多数据\n降低模型的复杂度\n正则化方法：实际上这就是权重衰减的方法这里药剂的L1（直接减少有效参数的数量），L2正则化结构风险（减少权值过大带来的过拟合的风险）的那些具体定义；dropout等等。\ndrop可以理解成bagging的办法的继承实现\n集成学习方法，通过多个模型的集成来降低单一模型的过拟合风险\nearly-stop\nDROPOUT rescale\n使用 pretraining 方法也可以帮助 dropout 训练参数，在使用 dropout 时，要将所有参数都乘以 $ 1/p$\n开始时随机删除，一半P的神经元 在剩下的一般中更新， recycle，然后，最后学出来的参数的存在概率只有（1-P)所以要*概率。 欠拟合降低的方法：\n添加新特征：特征与标签之间的相关性太差，我们可能需要挖掘新的特征； 增加模型的复杂度：简单模型的学习能力可能太差了，比如在线性模型中添加高次项，增加网络的深度或者神经元个数 减少正则化参数 有监督学习中涉及到的损失函数 LINKLINE 0，1损失函数： $max{0,1-fy}$ ,标签，二分类问题 hinge损失（0，1的进化）：max{0,1-fy} 卷积 卷积的矩阵加速：https://www.mobibrw.com/2019/17787\n转置卷积：LInk1 ；LInk2 转置卷积上采样带来的棋盘效应：https://www.cnblogs.com/hellcat/p/9707204.html\n空洞卷积也会带来棋盘效应，也就是采样不均匀，有些点被重复采样，有些点没有被采样到，这样就会像棋盘一样，两种颜色分离的这种情况。\n上采样 下采样：\nSVD：https://www.cnblogs.com/endlesscoding/p/10033527.html\n正则化的具体函数和内在含义 KEYPOINT：https://www.cnblogs.com/alexanderkun/p/6922428.html\n实际上我们可以发现这也是一个权重衰减的操作，如果从导数去分析的话，或者我们数形结合，我们会发现这样的w和我们的函数曲线的交点实际上是偏向\nRegularization：在目标函数中添加惩罚项，对复杂度高的模型进行惩罚，于是考虑从W的向量出发，\n0范数：非零元素的个数，在机器学习中是个NP完全问题，很难求\n1范数：绝对值之和\n2范数，通常意义上的模，实际上从分布上来看\nL2范数是指向量各元素的平方和然后求平方根。我们让L2范数的正则项||W||2最小，可以使得W的每个元素都很小，都接近于0，但与L1范数不同，它不会让它等于0，而是接近于0，这里是有很大的区别的哦；所以大家比起1范数，更钟爱2范数。\nNormalization 重要参考资料 ；参考资料2向东的回答 权重伸缩不变性，可以有效的提高反向传播的效率，也有参数正则化的效果；\n数据伸缩不变性；减少梯度弥散，简化对学习率的选择\ncovariate shift 协方差偏移，实际上是训练集和测试集中，变量的分布的不同带来的问题，这样就会导致模型的效果收到影响，也会印象网络的迭代速度，通过BN就可以将每个mini-batch的数据都拉回到标准正态分布，把带有偏差的数据拉回标准分布，拉回模型擅长的领域中，使得梯度变大，避免梯度小时的问题出现，也能加快收敛的速度。\n帮助理解covariate shift ，更确切的来说，实际上是source domain和Target domain的数据分布不一致，他们的条件概率相同，但是边缘概率不同：\n这样会导致不再是独立同分布：\n需要不断适应输入的分布，降低学习速度\n下端的变化可能趋向于变大或者变小，容易使得上层落入饱和区，学习过早的停止\n会相互影响。\nBN，IN，LN，WN Normalization的基本框架就是 $h=f(g·\\frac{x-\\mu}{\\sigma} + b)$\n再次进行平移和缩放是为了模型的表达能力不因规范化而下降；这两个缩放因子是可以学习的，用来对底层的学习结果有所价值，这也会将数据变换到基本在非饱和区中（线性区），然后通过再次的缩放和偏移，提供了非线性。\nBNnormalization纵向\n是对同一个batch的所有图的逐channel进行的\n使用mini-batch来计算相关的均值和方差，element-wised；但是BN是独立的对每个维度（channel）进行统计的，这样的话，如果原始分布差距很大的话，会导致不同的数据训练，这样可能会增加模型的训练难度。\n适用场景：每个mini-batch比较大，数据分布比较接近，所以我们需要进行充分的shuffle，不然效果会差很多。再运行中需要统计一阶和二阶统计量，所以不适用动态的网络架构和RNN，；相应的改造就不说了\n适用于判别模型中，\nInstance Normalization\n是对单张图片的单个通道单独进行的Normalization，适用于生成模型中，比如风格迁移，主要依赖的是单张图片的实例，所以不适宜对整个batch进行归一化，这样可以加速模型收敛和保证实例之间的独立性\nGroup Normalization\n实际上就是一个normalization的变体：\nLayer Normalization 横向\n是指对同一张图片的同一层的所有通道进行的normalization，所以和公式不一样的就是不需要求M的均值了，是对同一张图片的所有channel进行的\nWegiht Normalization参数规范化\nCosineNormalization\n解释一下attention 在某种程度上，注意力是由我么如何关注视觉图像的不同区域或者我们如何关联同一个句子中的不同单词所启发的：针对于问题的不同，我们会对图像的某些具体的区域重视（某些区域在视觉中呈现高分辨率，而另一些则是低分辨率的情况），或者句子中的某些词重视的情况。\n比如我们看到eating就对food有更高的attention，与此同时color的权重就会比较低。\n因为传统的RNN架构，固定的context vector可能会导致序列信息的缺失，可能无法记住长句子和时序对齐的信息，所以诞生了attention.\ncontent vector和 attention weight加权，然后和上一个时刻的target和y，生成现在的y。\nself-attention：https://zhuanlan.zhihu.com/p/47282410；\n内部注意力，也就是内部的自我关联的获取，QKV的关系\nTransformer 的基本架构 Transformer 的 Multi-Head 实际上就是有不同的QKV表示，然后我们将其表示起来。\nmask屏蔽未来的信息\nPooling的反向传播： Pooling层的主要作用\n1、特征不变性，使模型更加关注是否存在某些特征而不是特征具体的位置，对于一些旋转和平移具有不变性 2、特征降维，使模型可以抽取更广泛围的特征，减小了下一层输入大小，进而减小计算量和参数个数\n3、在一定程度防止过拟合，更方便优化\n4、扩大感受野\navg pooling：均分后回传\nMaxPooling：只传给最大的一项，其他项的反向传播值为0\nAnchor-based和 Anchor-free的理解和辨析 实际上就是把五百问的内容再巩固一下，然后整理过来，这里还有两个比较相关的链接，到时候还不清楚就可以看下。\nhttps://www.zhihu.com/question/356551927/answer/926659692 https://zhuanlan.zhihu.com/p/62372897 Anchor-based方法：在选练之前在训练集熵使用K-Means等聚类方法聚类出一组矩形框，代表主要的长宽，然后在推理时用这些Anchor滑动提取proposal之后在对这些Anchor进行回归和分类，比如扩张和中心点预测\nAnchor-free:就是没有预先定义这样的BoundingBox，直接通过网络来预测相应的边框，比如左上角右下角，中心点这样的预测；中心点+长宽\n机器学习部分 回归任务为什么难以训练 目标更难，需要适应所有的点 损失函数的角度，MSE之类的，下降与Value相关，对Outline敏感 Selective Search HOG SIFT HOG: 手机知乎\nSelective Search：https://zhuanlan.zhihu.com/p/27467369\nSIFT：概览 ； 开贴细说 LR怎么处理低维线性不可分问题 特征工程或者使用多项式核和高斯核，将样本映射到可分的空间去进行逻辑回归；\n线性回归和逻辑回归的异同点\n实际上都是一个函数映射的问题，就是离散化和连续化的区别而已，还有其中的损失函数的设计等等\n线性回归和逻辑回归实际上都是线性模型，但是最终一个映射到连续域做拟合，另一个映射到离散域做分类，最主要的区别就在于目的，输出值域，以及损失函数的设计上。\n本质上都是一个一个线性映射函数的选择。\nLR对连续值特征是怎么处理的 离散化的作用和优势：https://notes.001.io/lian-xu-te-zheng-li-san-hua/\nLR本质上属于广义线性模型，通过进行值域的划分，相当于引入了非线性，从而提升了模型的表达能力；\n进行离散化后对异常值不敏感，能对轻微的扰动有一定的鲁棒性，但是这还是比较考验特征划分技术的\n可以对离散的特征值进行组合，进一步引入非线性\n相当于简化了逻辑回归的模型，引入模型复杂度的正则化，这样能够减少过拟合的风险。\nLR为什么要归一化 LR的求解过程不就是是梯度下降的方式，那么就是归一化的作用了没什么好说的\n集成学习方法 Boosting 基学习器，做错的样本受到更多的关注，然后调整后的样本分布进行下一个基学习器的训练（AdaBoost）\n对特定的数据分布进行学习，实际上就像是re-weighting的这样的操作；如果不能使用这种方法的模型我们就使用re-sampling的操作来处理。\n过程中如果不满足比随机猜测好，这种模型就直接停止 可以看出这种方法主要关注降低偏差，可以对弱学习器构建出很强的集成 Bagging与随机森林 又放回的随机抽取样本构建包含m个的数据集，采样出T个这样的数据集，然后对这些基学习器进行结合，（简单投票做分类，简单平均做回归）\n随机森林是在以决策树为基础构建的基学习器，在bagging的基础上，引入了随机的属性选择（原本是选择最优的），也就是先选择一个随机的子集，然后在子集中选择最优的用来划分。\nGBDT和XGBoost GBDT实际上就是BOOSTing的一种方法\n都是通过损失函数相对于模型的负梯度方向来对当前的模型进行更新，但是在梯度下降里，我们的模型是通过参数表示的，而在梯度提升，是在函数空间中直接表示的。\n通俗一点的说的话，实际上就是梯度下降是在更新梯度来进行梯度下降，梯度提升通过累加弱学习器来梯度下降。\n关键：实际上在梯度提升中，梯度最终会被计算为（当作）残差，也就是用损失函数的负梯度去模拟残差\n参考链接，里面也有提到区别 ；简单的实例分析 GBDT：Gradient Boosting Descend Tree\nGBDT分类和回归时的基学习器都是CART分类回归LINK 树，每轮迭代在上一个基学习器结果的残差至上进行训练，（弱分类器）；\n这里的残差可以更改为损失函数，然后最后还是会变成对残差的一个拟合，模型的残差实际上也不是这么好弄的，用损失函数的负梯度，来拟合本轮损失的近似值。然后就是从上到下一个个基学习器过去\n不同的损失函数针对的是不同的问题（分类回归）\n分类问题：指数损失函数和对数损失函数 回归问题：均方差损失函数，绝对值损失函数 GBDT的正则化：\n给每个模型乘上一个弱化系数，降低每个模型对拟合损失的贡献 通过按比例来随机抽取样本训练模型，bagging，减少方差但是会增加偏差，可以使用交叉验证 控制CART的复杂度，可以使用剪枝正则化 优缺点：\n灵活，准确率高，使用健壮的损失函数可以处理异常值 难以并行化处理，受限于基学习器之间的依赖关系 XGBoost\n详细讲解XGBoost ；\n和残差然后用CART拟合不同，我们是通过SCORE来确定结构，然后通过梯度的值来计算结构中应该有的值， 所以在我们计算完二阶梯度的时候，我们能同步的进行划分和复制，这样，但是还有为为什么要排序后去做，我有点没搞明白\n两种方法的区别：\n正则化防止过拟合，提升泛化能力 L1+L2 还可以使用线性分类器 使用了二阶导数信息来进行对代价函数的优化 采用和随机森林类似的策略，能对数据进行采样，降低过拟合和减少计算 有缩减项，类似weight decay 能计算出缺失值的分裂方向 可并行计算 划分的方式改成了一个Score（根据两阶段梯度数据） SVM细节 在SVM推导部分的后面添加最终的形式以及整理一下KKT条件，通过这些特性对一些问题进行分析\n为什么将原问题转化成对偶问题 对偶问题将原始问题中的不等式约束转为了对偶问题中的等式约束 方便核函数的引入,输入最终会转化从恒一种内积的形式 改变了问题的复杂度。由求特征向量w转化为求比例系数a，在原始问题下，求解的复杂度与样本的维度有关，即w的维度。在对偶问题下，只与样本数量有关。 怎么转化到多分类的场景 不是逐个二分吗？\nhinge损失的多分类形式：https://www.turingtopia.com/article/details/e2492b497a144bf6b3cd1fc62df60bbd\nLagrange乘数法，对偶问题 二次型函数 A是实对称矩阵\n$$ f(x)=x^TAx\r$$\r在 $R^N$ 上是凸函数和A是半正定矩阵是充要的关系；\n凸规划：目标函数是凸函数，约束空间是凸集\nMP是凸规划的条件：满足。。。\n为什么凸规划是重要的，因为凸规划的任意局部最优值都是他的整体最优解\n凸优化问题Lagrange：\n引入松弛变量/kkt乘子，将不等式约束转化为等式约束， 引入拉格朗日乘子将等式约束转为无约束优化 KKT条件：MP（非线性规划）问题，可微可行点 $x^*$ 是整体最有解的条件 实际上是在凸规划的最优值求解过程中，使用拉格朗日乘数法，其中的不等式约束（\u0026lt;=0）需要满足的条件，其中：\n求解Largrange，KT条件的时候我们通常使用互补松紧条件入手来求解（分情况讨论，但是这种时候要考虑分类的完备性来进行求解。）\n对偶条件的引出 在线性规划的过程中可以使用对偶问题来进行转化，将求最大转化为求最小值；如果LP问题又最优解，则对偶问题也有最优解，且解相同\nSVM的具体推导以及核函数 再生希尔伯特空间，\n于是我们可以选择多项式核，高斯核，拉普拉斯核之类的来做这个核函数映射\n核函数的记忆\n相关的面试问题 SVM和LR的联系与区别：\n他们都是分类算法，都是监督学习的模型\n都是判别模型，如果不考虑核函数的话，都是线性分类算法\nLR采用log损失，SVM采用合页（hinge）损失\nLR基于概率理论，使用sigmoid和MLE来估计出参数的值；SVM基于几何的边界最大化原理\nLR对异常值敏感，SVM不\n对海量数据来说LR效率高，在低纬度的时候LR的准确率高，但是维度上升就被反超\n处理线性不可分：LR靠特征构造（组合交叉特征，特征离散化），SVM 还可以核函数\nLR是经验风险最小化，SVM自带结构风险最小化（自带了L2正则项所以）\n将数据向SVM求得的超平面进行投影后，是否仍然线性可分？（数学推导，这里的推导我放弃）\n显然不，从支持向量的角度分析，最优的结论必然是两点的中垂线，那么这种情况本身并不是线性可分的，但是如果超平面不是这个中出现的话，那么就不满足SVM求解条件中的最优分界面了。\n70页开始，但是我决定先推导SVM，这一部分的内容再说吧\n是否一定存在一组参数使得SVM的训练误差为0？\n训练误差为0的SVM分类器一定存在吗？\n加入松弛变量的SVM训练误差可以为0吗？\n决策树 3种分支计算的方法：信息增益，增益率，gini指数\n预剪枝，后剪枝\n是否会重复利用连续值或者离散值特征来分树？\n离散特征不行，比如用西瓜的纹理来说：就是有没有了\n连续特征可以，阈值切割，我们可以不断的往下细分，比如\u0026lt;100 \u0026lt;50这样。\nPCA与LDA 优化的目标：最大化投影方差， 在主轴上的投影方差最大，包含更多的信息量（信噪比的概念）。\n通过这个思想去设计一个求解过程：中心化（为了使得投影后均值为0），然后求方差，然后推导出最大化问题，然后通过largrange乘数法，推出实际上就是特征值。\nLDA投影到的是便于分类的，PCA是方差最大信息量最大的去除冗余的信息维度；无监督有监督\nBoosting与Bagging bagging 解决的是过拟合，boosting解决的是欠拟合的方法\n这里需要重新再去温习一下基本的定义\nMAP、MLE、Bayesian https://blog.csdn.net/u011508640/article/details/72815981/ https://zhuanlan.zhihu.com/p/61593112 从数学意义上和模型上区分 显然基于bayesian公式我们可以区分后验和先验，以及使用贝叶斯公式去获得估计的基本依据是啥。（要看清楚似然的主体是啥，也就是求解的参数是那个）\n$$ P(\\theta | D)(后验概率 ) = \\frac{P(D|\\theta)(似然函数)P(\\theta)(先验)}{\\sum P(D|\\theta)P(\\theta)}\r$$\r这里的P实际上可以看成一个概率分布模型，一个推断模型（其中的D和θ一个是模型的数据一个是模型的参数）\n前两者将\n那么MLE（极大似然）：（频率学派，假设为定制）\n我们把模型参数设置成θ（变量）然后，我们计算当θ等于多少的时候出现D这个数据的概率最大，（这样的话也就会引出我们对大量数据的需求，实际上是一个概率估计模型）\n而MAP（最大后验概率）（和👇一样是贝叶斯学派，θ是随机数）\n是贝叶斯估计的一种近似\n也就是我们考虑了参数发生或者出现的先验概率以后再进行计算，由于上式的分母P(D)是个确定的值，所以不影响最大化的过程，我们通常再计算的时候将其忽略，然后最大化分子，就是MAP了，在这里这一步的prior是非常重要的，和我们之后的模型估计息息相关。\n最后Bayesian估计\n其中MAP估计的是后验的最大值，而贝叶斯估计是去近似这个后验函数，基于贝叶斯公式去做这个估计。（去看看数据挖掘中的这部分的题目来帮助理解）\n朴素贝叶斯问题 看看数据挖掘中的那个讲稿，就很清楚，实际上就是类关系条件独立假设；\n可以使用laplace校准来避免0概率对决策造成影响\n那什么是朴素贝叶斯学习呢？\n交叉熵 KL散度 信息熵 https://blog.csdn.net/b1055077005/article/details/100152102 无监督方法 K均值聚类的有优缺点：\n受离群值影响，通常是局部最优解，类别量级和密度的问题没法解决 需要人工确定k 样本只能被划分到单一的类中 如何调优：\n数据归一化，离群点处理 合理选择K值 核函数 证明K means 收敛：和EM算法实际上是一个框架，这里看一下关系\nGMM：高斯混合模型 假定不同簇种的样本各自符合不同的高斯分布，这种得到的聚类算法就是高斯混合模型；\n$$ P(x) = \\sum_{i=1}{K}\\pi_iN(x|\\mu_i,)\r$$\r核心思想是：每个单独的分模型都是标准高斯模型，我们需要估计高斯分布的双参数，还有一个额外参数（权重或者生成数据的概率），实际上和K均值聚类是一样的操作过程，这里要记得EM。\n使用极大似然（很难求解）去寻找均值方差和权重，所以最后使用EM去做\n随机初始化参数， E：根据当前参数，计算每个点由某个分模型生成的概率 M：根据概率，来改进每个分模型的均值方差和权重 SOM：自组织映射神经网络 nah\n聚类算法的评估：\n轮廓系数；霍普金斯统计量；R方\n数据清洗 没用到就不说了，在数据挖掘中主要是：缺失数据，错误数据，和噪声数据\n错误数据：分析更改删除和忽略\n缺失数据：忽略，手工，填充（全局常量，属性或者中位数，基于贝叶斯等等方法（这个不提））\n噪声数据：分箱（均值平滑，中值平滑，边界平滑），聚类，回归，人工检查\n图像增强策略 torchvision.transformers的库里面有很多，还有unbalance_image中有一些经典的unbalance_image的一些策略\n还有PIL中的Image.Enhance(这里可能要注意图像维度的转换)\n1、对比度：白色画面(最亮时)下的亮度除以黑色画面(最暗时)下的亮度；\n2、色彩饱和度：：彩度除以明度，指色彩的鲜艳程度，也称色彩的纯度；\n3、色调：向负方向调节会显现红色，正方向调节则增加黄色。适合对肤色对象进行微调；\n4、锐度：是反映图像平面清晰度和图像边缘锐利程度的一个指标。\nMixUp的操作实际上就不要在赘述了，而Sharpen的操作实际上就是对分子分母都做一个1/T的乘方的这样一个锐化的操作，突出显著的样例，这样能够使得：？（需要加强记忆）\n评估模块 ROC、PR、F1 PR曲线就比较清楚是根据Precision和recall区划分的，然后根据判定为正负样本的阈值去区分这个曲线的情况。\nROC曲线是根据 TPR和FPR真阳性率（正样本中有多少被判定为真）和伪阳性率（负样本中有多少被判定为真），依据score的阈值来绘制曲线\nAUC越大，说明分类器越可能把真正的正样本放在前面\n还有F1，是综合反应一个排序模型的性能(调和平均值)：\n$$ F1 = \\frac {2*precision * recall}{precision + recall}\r$$\rROC比起PR来说，对于正负样本数据量的分布比较不敏感，所以在这种数据不均衡的大数据场景，ROC更合适，更广泛。如果是针对特定数据集上的表现的话实际上PR曲线的话能更直观的反应性能\nRMSE 离群点可能导致效果一直很差，可以用归一化的百分比来看\n余弦相似度 实际上就是将问题从距离转换到了角度上，用1-cos(A,B)表示余弦距离，实际上这种距离比起欧氏距离来说，能够适应更高的维度，比较相对差异的时候我们可以考虑用余弦相似度来衡量\n不满足三角不等式：等腰直角三角形\n在机器学习领域，还有kl距离，相对熵，也能衡量两个分布之间的距离，但是也不满足对称性和三角不等式\n训练集和测试集的划分机制 K次交叉验证法；\n首先描述一下什么是k次交叉验证，k次交叉验证的作用是：评估模型的预测性能，训练好的模型再新数据上的表现，在一定程度上减少过拟合，从有限数据中获取尽可能多的有效信息，使得模型对于数据的划分不那么敏感\nHandout检验：实际上就是7：3的随机划分的方式；其中还有留一划分的策略；\n自助法（bootstrap）：有放回的随机抽样，总数为n的集合，抽样n次作为训练集，剩下的没有被抽样出来的数据作为测试集，这就是自助法的验证过程\n当抽样次数趋向于无穷的时候，有多少数据没有被选择过， $(1-\\frac{1}{n})^n$ 取极限，根据重要极限 $(1+\\frac{1}{n})^n$ 的极限是e，可以推得大概是1/e的概率没被选中，也就是大概百分之36%， （59页） 语言部分 Python部分 深拷贝浅拷贝 概念上是一致的，但是具体实现深拷贝上，是不一样的，python 应该是自带的.copy函数\nhttps://www.jianshu.com/p/a71c09798123 )\n修饰符的作用 修饰符的作用python函数修饰符@的作用是为现有函数增加额外的功能，常用于插入日志、性能测试、事务处理等等。\n实际上就是讲函数作为作为输入参数，然后对函数进行包装，在执行函数之前或者之后增加一些操作，通常用来指示函数执行进程，也可以用来添加数据预处理等等\nLINK REFERENCE 1 2 3 4 5 6 7 8 9 10 11 12 def log(func): def wrapper(): print(\u0026#39;log开始 ...\u0026#39;) func() print(\u0026#39;log结束 ...\u0026#39;) return wrapper @log def test(): print(\u0026#39;test ..\u0026#39;) test() 多线程处理 一些基本的概念： 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。\n指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。\n线程可以被抢占（中断）。 在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） \u0026ndash; 这就是线程的退让。 使用threading作为线程处理模块： run start join([timr])：等待至线程终止；isAlive() getName() setName()\nappend():添加到线程列表，使用for i in threads: i.join() 来等待所有线程完成。\n首先通过继承threading.thread创建子类，实现run操作； 实例化之后使用start启动进程； 线程同步（Lock） Lock和Rlock 都有相应acquire和release，\n防止多个线程同时对某个数据进行修改，就需要对多个线程进行同步；\nPython 中多线程和多进程的区别 这一点还是需要补充，好像是使用什么来着\n主要从进程和线程本身的区别来谈，然后Python中的多线程是收到了Cpython的GIL约束的，所以稍微有点鸡肋，可能还是要用多进程去了解\n[参考链接](\n文件IO部分 文件处理： 读取键盘输入：a = input('请输入：')；\n打开和关闭文件：open()，一般需要按照指定的格式打开一个文件才能对其进行修改或者读取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 fo = open(\u0026#34;foo.ext\u0026#34;,\u0026#34;w\u0026#34;) fo.close() # 相应的文件的读写实际上应该是 fo.write(\u0026#34;dadsad\u0026#34;) res = fo.read(10) # 使用tell 和seek输出和定位当前的文件位置， # 实际上经常和with命令一起使用 with open(path,\u0026#34;w\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) as f : # record the dir name (depth=1) f.writelines(authorres) # record all the video for element in result: f.write(element) 补充说明： 这里with语句的解析 OS命令 chmod，chdir，chown，mkdir，path（一系列常用操作，exist之类的），getcwd（返回当前工作区），listdir（返回文件夹包含的文件或者文件夹的列表）\nC++部分 实际上c++对于编写的顺序是有上下关系的，如果我们定义的时候遇到了一些上面和下面的差别的时候，我们可以考虑在上面先进行declaration，在后面在具体的进行definition。\n文件操作： 基本读写 写文件步骤如下：\n包含头文件 #include \u0026lt;fstream\\\u0026gt;\n创建流对象 ofstream ofs;\n打开文件ofs.open(\u0026quot;文件路径\u0026quot;,打开方式);\n写数据ofs \u0026lt;\u0026lt; \u0026quot;写入的数据\u0026quot;;\n关闭文件ofs.close();\n读文件的操作步骤如下\n包含头文件 #include \u0026lt;fstream\u0026gt;\n创建流对象 ifstream ifs;\n打开文件并判断文件是否打开成功 ifs.open(\u0026ldquo;文件路径\u0026rdquo;,打开方式);\n读数据 四种方式读取\n关闭文件 ifs.close();\n处理二进制文件 二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream\u0026amp; write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n打开方式要指定为 ios::binary；\n二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream\u0026amp; read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n预编译头 首先介绍的是如何防止在重复的include\u0026lt;head.h\u0026gt;的时候,不会导致重复的定义和include的方式，以及其中的区别\n#pragma once：自定义包含了这种情况的时候，依赖于不会将同一个文件多次编译，这个方式没办法保证内容相同的不同名文件被重复的编译，针对的是文件。\n#ifndef ：依赖于宏名称不能冲突，这个能保证内容相同的不同文件不小心被同时包含，实际上是一个预编译的条件语句\n首先介绍一下写法：\n1 2 3 4 5 基本的逻辑也就是当我们第一次执行的时候，就会预先定义到这一块，这样到时候就不会导致相应部分的代码被重复的执行或者定义 #ifndef _code_block #define _code_block // code here #endif 在自己编写的时候需要注意不能重复使用宏名（_code_block），不然可能会出现以外的其他地方的代码没有被执行。\n多线程 mutex互斥锁\n内存分区模型 主要将内存分为四个区域:\n代码区：存放函数的二进制代码，由操作系统进行管理\n程序运行前进行分配\n存放CPU执行的机器指令，具体而言代码区是共享的和只读的\n全局区：存放全局变量、静态变量和常量\n这部分空间应该是在预编译的时候事先分配的\n该部分的数据再程序结束后由操作系统释放\n栈区：由编译器制动分配和释放，存放函数的参数值，局部变量等\n堆区：由程序员分配和释放，如果程序员不释放，程序结束后由操作系统回收；\n（类内的存储特点）：\n在c++中，类内的成员变量和成员函数分开存储，只有非静态的成员变量才属于类的对象上的存储。（函数也是不占对象空间的，所有的函数共享一个函数实例）\n（static）静态成员函数在编译阶段分配内存，类内声明类外初始化，所有的对象共享同一份数据；\n类： THIS指针 指向的是，当前调用的这个 对象；\n友元friend： 通过friend关键词告诉编译器其他的可以访问类中私有内容的东西；\n友元可以是：\n函数 类 其他类别的成员函数 继承 构造函数顺序\n继承的时候首先调用父类的构造函数，在构造子类的构造函数，析构是反向的。\n几种继承方式\n注意区分继承方式面临的主体，也就是说：\n派生类能访问的元素实际上都是除了私有类都能访问 区别在于我们是否能通过派生类的实例对基类的变量进行访问，这里的继承方式就代表着这些变量在被继承之后的状态，是私有的保护的，还是公共的 父子的成员同名\n无论是不是静态，都是：\n访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 多态 多态是C++面向对象三大特性之一\n多态分为两类\n静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别：\n静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n3. 拥有纯虚析构函数的类也属于抽象类\r常用STL函数 for_each：遍历容器 transform：搬运容器中的数据到另一个容器中 accumulate：计算容器的元素综合 fill：向容器中添加元素 replace_if find_if set_union：求两个容器的并集 set_intersection：求两个容器的交集 通用部分： 深拷贝和浅拷贝的概念： 浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n同步与异步 ","permalink":"https://hugotest-phi.vercel.app/posts/intview_%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/","summary":"\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"aikenhong_blog\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003cp\u003e\u003ca href=\"https://blog.csdn.net/cppjava_/article/details/68921869\" target=\"_blank\" rel=\"noopener\"\u003eLINK1\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"深度学习部分\"\u003e深度学习部分\u003c/h2\u003e\n\u003ch3 id=\"densenet\"\u003eDenseNet\u003c/h3\u003e\n\u003cp\u003e任意的两层之间都存在直接的链接，每一层的输入都是前面的所有层的输出的并集，而该层学习的特征图也会是后面所有层的输入，DenseBlock中需要Feature_map保持一致；\u003c/p\u003e\n\u003cp\u003eBlock与Block之间的降采样则使用transition layer，使用BN，1*1的 conv，Pooling来降维\u003c/p\u003e\n\u003cp\u003e优缺点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e省参数，省计算\u003c/li\u003e\n\u003cli\u003e抗过拟合，泛化能力强\u003c/li\u003e\n\u003cli\u003e需要保存Feature占显存\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- more --\u003e\r\n\u003ch3 id=\"efficientnet\"\u003eEfficientNet\u003c/h3\u003e\n\u003cp\u003e针对卷积神经网络的模型拓展，可以通过：1\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e增加网络规模可以、 增加\u003cstrong\u003e模型宽度\u003c/strong\u003e，增加\u003cstrong\u003e模型深度\u003c/strong\u003e，增加\u003cstrong\u003e输入图像的分辨率\u003c/strong\u003e，但是如何去人工调整这个比例和参数，比较麻烦，\u003c/li\u003e\n\u003cli\u003e实验发现ConvNet缩放过程中平衡网络宽度、深度、和分辨率的维度是很重要的\u003c/li\u003e\n\u003cli\u003eEfficientNet就是对这些的合理组合，复合型的模型扩展技术集合神经结构搜索技术获得\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-fcbff6e21eb9e7f9cce94c3bd935b84a_720w2.jpg\"\u003e\r\n    \u003cimg alt=\"img\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-fcbff6e21eb9e7f9cce94c3bd935b84a_720w2.jpg\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-fcbff6e21eb9e7f9cce94c3bd935b84a_720w2.jpg\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"img\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e关键技术\u003c/strong\u003e复合扩张技术\u003c/p\u003e\n\u003cp\u003e所以本文提出了\u003cstrong\u003e复合扩张方法\u003c/strong\u003e，这也是文章核心的地方，\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \\alpha,\\beta,\\gamma $$\r\n\u003c/div\u003e\r\n 是我们需要求解的一组参数，如下图公式，带约束的最优参数求解。 \r\n\u003cdiv\u003e\r\n$$ \\alpha,\\beta,\\gamma $$\r\n\u003c/div\u003e\r\n 分别衡量着depth, width和 resolution的比重，其中 \r\n\u003cdiv\u003e\r\n$$ \\beta,\\gamma $$\r\n\u003c/div\u003e\r\n 在约束上会有平方，是因为如果增加宽度或分辨率两倍，其计算量是增加四倍，但是增加深度两倍，其计算量只会增加两倍。\r\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-d158f21d6bae78f05fbcf40fd81255d3_720w.jpg\"\u003e\r\n    \u003cimg alt=\"img\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-d158f21d6bae78f05fbcf40fd81255d3_720w.jpg\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-d158f21d6bae78f05fbcf40fd81255d3_720w.jpg\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"img\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"经典深度学习与机器学习算法"},{"content":"@Aiken 2021-4-8\nAriticle ；Paper ；:star:Code； ZHIHU Intro 引子 提出了一种新的神经网络算子（operator或op）称为involution，它比convolution更轻量更高效，形式上比self-attention更加简洁，可以用在各种视觉任务的模型上取得精度和效率的双重提升。\n通过involution的结构设计，我们能够以统一的视角来理解经典的卷积操作和近来流行的自注意力操作。\n基本思想 将传统Convolution Kernel 的两个基本特性：\n**空间不变性：**在同个通道的HW上共享3*3的卷积系数，参数共享； **通道特异性：**在每个通道上有特异的卷积核，最终使用1*1 like的方式来进行通道间的整合 反对称的修改成：\n空间特异性： 对每个Feature有对应size $H·W·K·K·G | G\u0026laquo;C$ 的kernel，特异性的对不同图像的不同部分进行处理 G表示Involution操作的分组数，如果需要下采样，就需要接步长为2的平均池化层，最终可以得到，实际上是一个分组卷积的方式，也就是说，我们K个一组的共享一个Kernel。用G去切分C，最终组合起来 **通道不变性：**对每个通道之间共享这样的kernel，然后做简单的线性整合，对每个不同的channel有相同的处理方式。 传统的卷积基于邻域相关性的思想，同时旨在同一个channel中用单一的角度去分析特征，所以有空间不变性核通道特异性的这两个特征。\n而Involution实际上更像是Self-Attention这种思路，通过Whole-Size的Kernel，执行一个特异性处理？\n要点分析 这一部分主要介绍一些实现上的技术/理论要点：\n生成FeatureMap对应Size的Kernel 通用的公式如下，我们可以自定义对应的Kernel生成Function，这是算法的开放性和潜力所在。\n$$ \\mathbf{H}_{i,j} = \\phi(\\mathbf{X}_{\\Psi_{i,j}}) \\\\\r\\Psi_{i,j} 是邻域的一个index集合，\\mathbf{X}_{\\Psi_{i,j}}是包含i,j的邻域的一个patch\r$$\r其中可能会包含一些线性变换和通道缩减之类的变换，一种简单的实例化可以由下图来理解。\n对某个index，首先转化生成对应的 $K^2$ ，对应的Value，然后通过加权整合得到最终的OutputValue， Channel 数的放射就又我们的对应生成的Kernel数去控制。\n有点NIN那味了，反正就是嵌套，架构，用MLP得到Kernel，用Kernel进行降维和信息交互。\nThe Author Says:👇\n无论是convolution，self-attention还是新的involution都是message passing和feature aggregation的组合形式，尽管外表各异，本质上没有必要割裂开来看。\n与Self-Attention的联系 将Self-Attention的QKV展开成WX的形式，可以发现实际上Involution是Self-Attention的一个General的表达形式，\nself-attention中不同的head对应到involution中不同的group（在channel维度split） self-attention中每个pixel的attention map $QK^T$ 对应到involution中每个pixel的kernel 同时两者在操作后都会加一个线性变换和残差链接，这和Involution中的对应BottleNet也存在一致\nPosition encoding\nself-attention中的计算是loacation-agnostic的所以需要进行position-encoding，但是involution，生成的元素本身就是按照location排列的，所以不需要进行位置编码。\n此外，Involution保留了CNN中locally的优先特性。：\n因此，我们重新思考self-attention在backbone网络结构中有效的本质可能就是捕捉long-range and self-adaptive interactions，通俗点说是使用一个large and dynamic kernel，而这个kernel用query-key relation来构建则并不是必要的。另一方面，因为我们的involution kernel是单个pixel生成的，这个kernel不太适合扩展到全图来应用，但在一个相对较大的邻域内应用还是可行的），这同时也说明了CNN设计中的locallity依然是宝藏，因为即使用global self-attention，网络的浅层也很难真的利用到复杂的全局信息。\n所以我们所采用的involution去除了self-attention中很多复杂的东西，比如我们仅使用单个pixel的特征向量生成involution kernel（而不是依靠pixel-to-pixel correspondence生成attention map），在生成kernel时隐式地编码了pixel的位置信息（丢弃了显式的position encoding），从而构建了一个非常干净高效的op。\nMathematical 画一下计算图来看看实际上是怎么运行的，这里最后的size变换还没弄清楚计算的规则\n","permalink":"https://hugotest-phi.vercel.app/posts/involution/","summary":"\u003cp\u003e@Aiken 2021-4-8\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s/UmumqhZW7Aqk6s8X1Aj7aA\" target=\"_blank\" rel=\"noopener\"\u003eAriticle \u003c/a\u003e\n；\u003ca href=\"https://arxiv.org/abs/2103.06255\" target=\"_blank\" rel=\"noopener\"\u003ePaper\u003c/a\u003e\n；\u003ca href=\"https://github.com/d-li14/involution\" target=\"_blank\" rel=\"noopener\"\u003e:star:Code；\u003c/a\u003e\n \u003ca href=\"https://zhuanlan.zhihu.com/p/357408252\" target=\"_blank\" rel=\"noopener\"\u003eZHIHU\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"intro-引子\"\u003eIntro 引子\u003c/h2\u003e\n\u003cp\u003e提出了一种新的神经网络算子（operator或op）称为involution，它比convolution更轻量更高效，形式上比self-attention更加简洁，可以用在各种视觉任务的模型上取得精度和效率的双重提升。\u003c/p\u003e\n\u003cp\u003e通过involution的结构设计，我们能够以统一的视角来理解经典的卷积操作和近来流行的自注意力操作。\u003c/p\u003e\n\u003ch2 id=\"基本思想\"\u003e基本思想\u003c/h2\u003e\n\u003cp\u003e将传统Convolution Kernel 的两个基本特性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e**空间不变性：**在同个通道的HW上共享3*3的卷积系数，参数共享；\u003c/li\u003e\n\u003cli\u003e**通道特异性：**在每个通道上有特异的卷积核，最终使用1*1 like的方式来进行通道间的整合\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e反对称的修改成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e空间特异性：\u003c/strong\u003e 对每个Feature有对应size  $H·W·K·K·G | G\u0026laquo;C$  的kernel，特异性的对不同图像的不同部分进行处理\n\u003cul\u003e\n\u003cli\u003eG表示Involution操作的分组数，如果需要下采样，就需要接步长为2的平均池化层，最终可以得到，实际上是一个分组卷积的方式，也就是说，我们K个一组的共享一个Kernel。用G去切分C，最终组合起来\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e**通道不变性：**对每个通道之间共享这样的kernel，然后做简单的线性整合，对每个不同的channel有相同的处理方式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e传统的卷积基于邻域相关性的思想，同时旨在同一个channel中用单一的角度去分析特征，所以有空间不变性核通道特异性的这两个特征。\u003c/p\u003e\n\u003cp\u003e而Involution实际上更像是Self-Attention这种思路，通过Whole-Size的Kernel，执行一个特异性处理？\u003c/p\u003e\n\u003ch2 id=\"要点分析\"\u003e要点分析\u003c/h2\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e这一部分主要介绍一些实现上的技术/理论要点：\u003c/p\u003e\n\u003ch3 id=\"生成featuremap对应size的kernel\"\u003e\u003cstrong\u003e生成FeatureMap对应Size的Kernel\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e通用的公式如下，我们可以自定义对应的Kernel生成Function，这是算法的开放性和潜力所在。\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\n\\mathbf{H}_{i,j} = \\phi(\\mathbf{X}_{\\Psi_{i,j}}) \\\\\r\n\\Psi_{i,j} 是邻域的一个index集合，\\mathbf{X}_{\\Psi_{i,j}}是包含i,j的邻域的一个patch\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e其中可能会包含一些线性变换和通道缩减之类的变换，一种简单的实例化可以由下图来理解。\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210409110945686.png\"\u003e\r\n    \u003cimg alt=\"image-20210409110945686\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210409110945686.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210409110945686.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210409110945686\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Involution"},{"content":"Knowledge Evolution in Neural Networks @Aiken 2021.4.7\nArticle：只能当成OverView，技术细节写的很差 ；Mendeley；\nCode_PyTorch Intro引子 Problem：如何在较小的数据集上训练神经网络，这到底是个小样本的方法还是个类别增量的方法？\nMotivation： 考虑生物“基因”进化的方式，有一部分是“祖传”，另一部分是“适应”，通过对“祖传”的假设的不断学习进化，得到一个新的模型。\n基因编码了从祖先到后代的遗传信息（知识），而基因传递将遗传信息从父母传递至其后代。虽然祖先并不一定具有更好的知识，但是遗传信息（知识）在几代人之间的发展将会促进后代更好的学习曲线。\nHypothesis：\n拟合假设 $H^{origin}$ ： 重置假设： $H^{later}$ TOBEUPDATE：将神经网络拆分成两个假设(子网络)：通过重新训练多代网络来进化 $H^{origin}$ 中的知识，每一代都会扰乱 $H^{later}$ 的内部权重来鼓励 $H^{origin}$ 学习独立的表达形式。\n将深度神经网络的知识封装在一个名为拟合假设的子网络H中，将拟合假设的知识从父母网络传递至其后代，即下一代神经网络。并反复重复此过程，在后代网络中证明了其性能的显著提升：\nContribution：\n提出了KELS（内核级卷积感知拆分），为CNN量身定做。虽然增加了训练时间，但是大大降低了推理成本，也减轻了较小数据集中的过拟合问题。\n提出了KE，提升网络在较小数据集上的性能 KELS，训练时自动学习slim网络，支持CNN，降低推理成本 Related Work\n与两种不同的训练方法作比较\nDSD：在网络结构上与这种dense-sparse-dense\n理论与实现细节 上图展示的是\n普通Fliter：3in 4out\n修正后在ResNet中的Fliter：拆分成两部分假设，深蓝色的是拟合假设，浅灰色的是重置假设。\nThe Knowledge Evolution Training Approach L：layers_num；N：network；F：Fliter（Convolution Kernal）\nZ：Batch Norm；W（FC）：weight；B（FC）：bias；M：0-1 mask（binary）\n首先从概念上将网络划分成两个子网的部分， $H^f$ 、 $H^r$ ，对网络进行随机初始化，然后再e个epoch之后得到generation 1的Network（N1），也就能提取出对应的H.\n:star:Iteration（迭代到下一代）\n基因的贡献直到对下一代网络进行初始化，后续的操作就是“适者生存的部分了”\n#LOOP\n使用 $H^f$ 重新初始化N：使用 $H^f$ 中的F和W去初始化N2，剩下的部分（ $H^r$ ）中的参数进行随机的初始化，初始化的形式可以表达成如下的公式，（随机的部分使用指定好的分布去随机） 重新e个epochs训练进化成N2。 $$ F_l = M_lF_l + (1-M_l)F_l^r\r$$\r#END LOOP\nSplit-Networks 这个框架在实现的时候涉及到Fliter的拆分，所以这部分实际上是文章的核心技术难点。\n使用两种分裂技术来支持KE：\n这种玩意你不看代码谁知道在写什么\nweight-level splitting：按照split-rate，使用0-1mask对每一层的参数进行随机的split。 kernel-level convolutional-aware splitting：代替了对每个单独的权重进行mask，我们直接对kernels做mask，如下图所示 Knowledge Evolution Intuition KE的结构和ResNet和Dropout进行对比，之间的异同，一些直观或者直觉上的理解。\nCode细节\u0026amp;使用情景 这个方法实际上是针对的小样本？相对少样本？的使用情景，通过不断的部分继承和迭代，用DNA的方式传播到后续的网络结构中，感觉这个的使用场景还挺blur的，TOBECONTIUNE.\n这种评估和消融实验的测试方式的选择！\n","permalink":"https://hugotest-phi.vercel.app/posts/knowledgeevolution/","summary":"\u003ch1 id=\"knowledge-evolution-in-neural-networks\"\u003eKnowledge Evolution in Neural Networks\u003c/h1\u003e\n\u003cp\u003e@Aiken 2021.4.7\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s/ZdHhdTrHmdcBF4DYf1HXPQ\" target=\"_blank\" rel=\"noopener\"\u003eArticle：只能当成OverView，技术细节写的很差\u003c/a\u003e\n；Mendeley；\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/ahmdtaha/knowledge_evolution\" target=\"_blank\" rel=\"noopener\"\u003eCode_PyTorch\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"intro引子\"\u003e\u003cstrong\u003eIntro引子\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eProblem\u003c/strong\u003e：如何在较小的数据集上训练神经网络，这到底是个小样本的方法还是个类别增量的方法？\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMotivation：\u003c/strong\u003e 考虑生物“基因”进化的方式，有一部分是“祖传”，另一部分是“适应”，通过对“祖传”的假设的不断学习进化，得到一个新的模型。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e基因编码了从祖先到后代的遗传信息（知识），而基因传递将遗传信息从父母传递至其后代。虽然祖先并不一定具有更好的知识，但是遗传信息（知识）在几代人之间的发展将会促进后代更好的学习曲线。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003eHypothesis：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e拟合假设 $H^{origin}$ ：\u003c/li\u003e\n\u003cli\u003e重置假设： $H^{later}$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTOBEUPDATE：将神经网络拆分成两个假设(子网络)：通过重新训练多代网络来进化 $H^{origin}$ 中的知识，每一代都会扰乱 $H^{later}$ 的内部权重来鼓励 $H^{origin}$ 学习独立的表达形式。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e将深度神经网络的知识封装在一个名为拟合假设的子网络H中，将拟合假设的知识从\u003cstrong\u003e父母网络\u003c/strong\u003e传递至其后代，即下一代神经网络。并反复重复此过程，在后代网络中证明了其性能的显著提升：\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/640\" alt=\"图片\" style=\"zoom:67%;\" /\u003e\r\n\u003cp\u003e\u003cstrong\u003eContribution\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e提出了KELS（内核级卷积感知拆分），为CNN量身定做。虽然增加了训练时间，但是大大降低了推理成本，也减轻了较小数据集中的过拟合问题。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cul\u003e\n\u003cli\u003e提出了KE，提升网络在较小数据集上的性能\u003c/li\u003e\n\u003cli\u003eKELS，训练时自动学习slim网络，支持CNN，降低推理成本\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eRelated Work\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e与两种不同的训练方法作比较\u003c/p\u003e\n\u003cp\u003eDSD：在网络结构上与这种dense-sparse-dense\u003c/p\u003e\n\u003ch2 id=\"理论与实现细节\"\u003e理论与实现细节\u003c/h2\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210408113607935.png\"\u003e\r\n    \u003cimg alt=\"image-20210408113607935\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210408113607935.png\"class=\"responsive-image\" src=\"https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210408113607935.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210408113607935\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"Knowledge Evolution"},{"content":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r@Aiken 2021;\n汇总LeetCode刷题以及刷《剑指offer》过程中遇到的一些不会做的题或者启发性很强的题目等等；内容主要以以下几个方面为主：\n题目-题解-相关注释； 相关难点分析； 相关知识点索引 同时copy到数据结构或者c++的文档中） 《Fuck Algorithm》 针对各个专题指向性的去刷一些Leetcode中的题目，通过对这些题目进行分析整合来对巩固各个知识点，这一部分的代码整合到/leecode文件夹中，但是主要可能整合在md中；\n这里可以顺便把git的内容整理一下，本地的git操作流程 最近先把数据结构刷了，变刷变看后面的搜索等等的内容，一部分一部分的往后看 第一课中回溯和其他规划的题还没看，后续再看看 思考C++中多返回值的设计 数据结构的存储方式 数据结构的存储方式 （物理层面的存储方式）：数组（顺序存储）和链表（链式存储）。 最底层的存储架构上基本上只有这两种实现的方式，更高维的才是：栈、队列、堆、树、图这些高层结构；\n而这些实现的高层实现上，分别使用量中架构有啥优缺点：\n综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下：\n数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。\n链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。\n二分查找专题 由于我经常写错二分查找的边界判断条件，所以这里进行一个整理操作：\n二分查找总结专题 后续整理的时候在进行阅读一下，加深一下理解\n其中需要注意的是：\n我们使用 left+(right-left) /2 来代替 (l+r)/2 ,因为这样的话可以防止right和left太大溢出的操作； mid +- 1 以及最终的返回条件 \u0026lt;= 还是小于 我们分情况来讨论：\n求的是特定值，求的是左右的边界值的时候，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 int binary_search(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if(nums[mid] == target) { // 直接返回 return mid; } } // 直接返回 return -1; } int left_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定左侧边界 right = mid - 1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定右侧边界 left = mid + 1; } } // 最后要检查 right 越界的情况 if (right \u0026lt; 0 || nums[right] != target) return -1; return right; } 数据结构的基本操作 所有数据结构的基本操作一般都局限在 遍历+访问，更具体一点就是：增删改查；\n数据结构存在的目的就在于尽可能快的增删改查：\n遍历的基本操作一般来说也就两种形式：线性和非线性情况，基本的遍历框架可以总结为\n线性遍历： 线性就是 for/while 迭代为代表，经典的就是数组遍历框架；\n1 2 3 4 void traverse(cosnt int[]\u0026amp; arr){ for(int i=0;i\u0026lt;arr.length;i++) // visit(); } 非线性遍历： 链表遍历框架，兼具迭代和递归框架；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 基本的单链表节点 */ class ListNode { int val; ListNode next; } void traverse(ListNode head) { for (ListNode p = head; p != null; p = p.next) { // 迭代访问 p.val：迭代需要写出我们每个的具体操作 } } // 两种不同的遍历写法👆 👇，具体思路上的区别 void traverse(ListNode head) { // 递归访问 head.val // 递归是基于我们的n-1假设，只需要实现n-1 到n的转变就行 traverse(head.next); } 二叉树的情况的话，实际上就是链表的递归情况，然后要针对两侧进行递归就可以了，在多几个分支也是一样的；而也可以拓展成图的遍历，针对图可能出现环的情况就使用flag标记一下就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* 基本的二叉树节点 */ class TreeNode { int val; TreeNode left, right; } void traverse(TreeNode root) { // oprtator 前序遍历 traverse(root.left); // oprtator 中序遍历 traverse(root.right); // oprtator 后序遍历 } 更好的理解数据类型的作用 设计twitter 335 从题目需求出发，更好的理解各种数据结构的使用情景：\n不需要时序，需要快速搜索的关注列表：Hashset，set，\u0026hellip;\n需要发表的时序，同时需要多个用户推文发表的时间顺序，也涉及到顺序的整合：有序链表\n同时考虑一个全局的时间戳来进行比对。（合并k个有序链表）\n合并k个有序链表：借助优先级队列，设定好优先级队列的优先关系（timestamp），它能够实现自动排序，然后我们讲k个链表插进去，就行。\n面向对象设计，针对每个对象的需求来定制需要的数据类型和方法；当然也要考虑基类和子类之间的关系，还有private 和 static的关系。\n具体的代码实现后面还是要看一下的，这种比较复杂的类型设计题目。\n单调栈模板 实际上就是栈，利用了一些巧妙的规则，使得新元素入栈后，栈内的元素都保持有序（单增或者单减）。Purpose：如何设计这样一个数据结构，同时如何利用这样的数据结构来解题。\n496 下一个更大的元素 反向写更好，不要执着了，学起来就完事了\n这题我对题意的理解是错误的，下一个更大的元素，不是按照大小排列的，而是按照原本在数组中的顺序排列的，所以我们实际上可以用一个hash映射来做这样的题目，官方题解中队单调栈的讲解更清晰一点，\n这个是网址中写的，这样的方法是倒着完成的，基本的概念是差不多的，也就是遍历的顺序和判定的条件稍微变换了一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector\u0026lt;int\u0026gt; nextGreaterElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; res(nums.size()); // 存放答案的数组 stack\u0026lt;int\u0026gt; s; // 倒着往栈里放 for (int i = nums.size() - 1; i \u0026gt;= 0; i--) { // 判定个子高矮 while (!s.empty() \u0026amp;\u0026amp; s.top() \u0026lt;= nums[i]) { // 矮个起开，反正也被挡着了。。。 s.pop(); } // nums[i] 身后的 next great number res[i] = s.empty() ? -1 : s.top(); // s.push(nums[i]); } return res; } 下面这个是我写的，我是正向执行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElement(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n = nums2.size(); unordered_map\u0026lt;int,int\u0026gt;orderh; // 这个没有长度初始化这种说法的 stack\u0026lt;int\u0026gt; temps; vector\u0026lt;int\u0026gt; res; // 只初始化长度的话，会初始化为0； temps.push(nums2[0]); // 当遇到比原本的大的时候，我们就直接弹出，直到里面的都比他大 for(int i =1; i\u0026lt;n; i++){ while(!temps.empty() \u0026amp;\u0026amp; nums2[i]\u0026gt;temps.top()){ orderh[temps.top()] = nums2[i]; temps.pop(); } temps.push(nums2[i]); } // 对于剩下来的哪些元素，就赋值为-1 while(!temps.empty()){ orderh[temps.top()] = -1; temps.pop(); } // 添加进最终的结果。 for(int num: nums1){ res.push_back(orderh[num]); } return res; } }; 问题变形，1118等待多少天 这一题，求间隔，我们就讲放入stack的值变成相应的index，然后根据index去索引值来对比，然后通过，相似的操作去求解，但是我们当然也可以反向的进行操作，因为我们现在的num1和num2是相等的，我们就没必要建立hash去索引求解，只需要直接输出答案即可。\n可以像上一题我的写法一样，只需要修改存入stack的值就可以； 也可以反向进行，如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; T) { vector\u0026lt;int\u0026gt; res(T.size()); // 这里放元素索引，而不是元素 stack\u0026lt;int\u0026gt; s; /* 单调栈模板 */ for (int i = T.size() - 1; i \u0026gt;= 0; i--) { while (!s.empty() \u0026amp;\u0026amp; T[s.top()] \u0026lt;= T[i]) { s.pop(); } // 得到索引间距 res[i] = s.empty() ? 0 : (s.top() - i); // 将索引入栈，而不是元素 s.push(i); } return res; } 反正基本思想都是让stack里存放的值从大到小，如果违反了就pop到符合位置。\n503 下一个更大的元素2 如何处理环形数组：也就是他能绕一圈的，进行操作的。\n使用取余来得到相应的环形特性，但是我们其中已经存在的答案怎么fix呢？\n也可以使用双倍长度的解法,构建或者不构建新数组。\n一般的通过取余获得环形特效的代码模板：\n1 2 3 4 5 6 int[] arr = {1,2,3,4,5}; int n = arr.length, index = 0; while (true) { print(arr[index % n]); index++; } 具体实现：通过取余来模拟双倍长度，但是这样的作法，实际上还是进行了重复的计算吧？正向的写也没问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElements(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; res(n); stack\u0026lt;int\u0026gt; s; // 假装这个数组长度翻倍了 for (int i = 2 * n - 1; i \u0026gt;= 0; i--) { // 索引要求模，其他的和模板一样 while (!s.empty() \u0026amp;\u0026amp; s.top() \u0026lt;= nums[i % n]) s.pop(); res[i % n] = s.empty() ? -1 : s.top(); s.push(nums[i % n]); } return res; } }; 删除数组中的重复元素316 1081 这一题实际上还是用单调栈的思路，让里面的顺序尽量是按照从小到大排，就是增加了约束，也就是：\n里面已经有的我们就直接过； 后面没有再出现的情况我们也直接过； 如果是比里面的大就直接加进去，如果是比里面的小，我们就pop到直接过的时候再加 需要两个辅助的存放判断的辅助情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: string removeDuplicateLetters(string s) { if(s.empty()) return {}; // 初始化需要的存储数据结构 vector\u0026lt;int\u0026gt; countAl(256,0); vector\u0026lt;bool\u0026gt; countSt(256,false); stack\u0026lt;int\u0026gt; store; // 初始化count数组 for(auto t: s){ countAl[t]++; } for(char c: s){ countAl[c]--; if(countSt[c]) continue; while(!store.empty() \u0026amp;\u0026amp; store.top()\u0026gt;c){ // 如果top后面没有了 if(countAl[store.top()]==0) break; // 如果还有就pop countSt[store.top()] = false; store.pop(); } store.push(c); countSt[c] = true; } // 对stack中的字符进行反转然后输出 string res; stack\u0026lt;char\u0026gt; temp; while(!store.empty()){ temp.push(store.top()); store.pop(); } while(!temp.empty()){ res.push_back(temp.top()); temp.pop(); } return res; } }; 单调队列 存进index，然后根据index取值来做判断\n实际上就是和上面一样的思路，剑指offer的队列中的最大值，用一个deque双向队列实现，刚好是剑指offer59题。维护一个头部是最大值的队列，后续的加入的时候，将前边比他小的都pop出去，再push，然后每次移动要把头pop出去。\nFA讲解的，结合offer理解更妙 二叉堆实现优先队列 实际上就是用数组维护的一个类似的二叉树，然后要保有最大堆或者最小堆的性质，数组的子节点可以很容易的通过*2来获取： 然后为了维护最大堆或者最小堆的操作，我们需要有一个上浮``下沉两个操作来维护最大堆的性质，实际上也比较简单。就是\n上浮：当父节点小于当前节点的时候就不断向上换 下沉：下面更大的哪个和父节点换。 通过这两个操作来实现删除和添加的维护：\ninsert：添加到底部不断上浮即可 delete：将堆顶元素和堆底元素互换，（1，N）然后将堆顶的元素不断的下沉到正确的地方即可 这些操作都是二分的时间复杂度。\nhash和数组实现O(1)插入删除和随机数 通常理解的情况下我们需要依靠hash来实现O(1)的搜索和插入删除，但是，这样的话，我们没法等概率的取出随机数，我们认为需要借助index，产生一个随机的数字来索引，但是这样，我们就需要借助vector，那如何通过底层的vector来进行删除？\n使用hash来存储index，然后通过swap和pop来O(1)的删除，然后调用rand()和%来产生随机数即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class RandomizedSet { public: // 存储元素的值 vector\u0026lt;int\u0026gt; nums; // 记录每个元素对应在 nums 中的索引 unordered_map\u0026lt;int,int\u0026gt; valToIndex; bool insert(int val) { // 若 val 已存在，不用再插入 if (valToIndex.count(val)) { return false; } // 若 val 不存在，插入到 nums 尾部， // 并记录 val 对应的索引值 valToIndex[val] = nums.size(); nums.push_back(val); return true; } bool remove(int val) { // 若 val 不存在，不用再删除 if (!valToIndex.count(val)) { return false; } // 先拿到 val 的索引 int index = valToIndex[val]; // 将最后一个元素对应的索引修改为 index valToIndex[nums.back()] = index; // 交换 val 和最后一个元素 swap(nums[index], nums.back()); // 在数组中删除元素 val nums.pop_back(); // 删除元素 val 对应的索引 valToIndex.erase(val); return true; } int getRandom() { // 随机获取 nums 中的一个元素 return nums[rand() % nums.size()]; } }; 进阶问题\n排除黑名单数字来产生随机数，这样我们只需要将黑名单里的数字移动到数组的末尾再产生随机数就可以了，但是有两个需要注意的地方：\n黑名单里的数字本来就在末尾 交换的时候黑名单的数字和黑名单里的数字交换了，（实际上他通过限定次数的交换是没有问题的，按顺序还过去就好） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 跳过尾部的黑名单缩影的问题 int last = N - 1; for (int b : blacklist) { // 如果 b 已经在区间 [sz, N) // 可以直接忽略 if (b \u0026gt;= sz) { continue; } while (mapping.count(last)) { last--; } mapping[b] = last; last--; } 链表刷题 主要还是和二叉树一样，熟悉一个递归实现的问题；\n一些总结：双边约束的情况下好像使用迭代写起来比递归好写多了；\n反转链表（206）：\n:stadium:迭代的分析思路：基于n-1的假设，我们可以将n-1已完成的情况，当前在n的情况画出来，或者想象出来来分析怎么解题。\n注意对head非空的判断要在head next的前面 不要临时临时变量，先把题做出来在做简化，（双指针指示法，一个指向前一个一个指向当前一个） 进阶一点的问题：\n递归反转链表的一部分（92） 铺垫任务：反转链表的前N个节点\n具体的区别：\n1 base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。\n刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上\n注意这里tail的设置，理解透\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ListNode successor = null; // 后驱节点 // 反转以 head 为起点的 n 个节点，返回新的头结点 ListNode reverseN(ListNode head, int n) { if (n == 1) { // 记录第 n + 1 个节点 successor = head.next; return head; // 这里也很重要！只有一个的时候return啥。 } // 以 head.next 为起点，需要反转前 n - 1 个节点 ListNode last = reverseN(head.next, n - 1); head.next.next = head; // 让反转之后的 head 节点和后面的节点连起来 head.next = successor; return last; } 最终实现部分：\n:question: 但是这样的方法最终的实现效率并不高有时间的话可以去看看题解中的其他的迭代思想方式；时不时回来刷一刷这两三道题，来加强一下对于递归思想的理解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 */ class Solution { private: ListNode* last = nullptr; public: ListNode* reverseBetween(ListNode* head, int m, int n) { if (m == 1) { return reverseN(head, n); } head-\u0026gt;next = reverseBetween(head-\u0026gt;next, m - 1, n - 1); // 这里，return head和递归之间的关系要掌握好，从变换的阈值开始分析，比较传入值和return值就知道了 return head; } ListNode* reverseN(ListNode* head, int n) { if (n == 1) { last = head-\u0026gt;next; return head; } ListNode* tail = reverseN(head-\u0026gt;next, n - 1); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = last; return tail; } }; 如何k个一组反转链表（25） 使用迭代+递归的方式编写，迭代进行反转，递归进行组合排序（外层架构）,这种双边约束的好像使用迭代的方式比递归更好写一些，而且这样的时间复杂度好像甚至更低把。和上面的对比一下就知道了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode* start, *end; start = end = head; for (int i = 0; i\u0026lt;k;i++) { if(end == nullptr) return head; end = end-\u0026gt;next; } ListNode* newH = reversek(start,end); start-\u0026gt;next = reverseKGroup(end,k); return newH; } ListNode* reversek(ListNode* start, ListNode* end) { ListNode* curr = start; ListNode* prev = nullptr; //最后的赋值再下一行，哪个start.net while(curr!=end) { ListNode* temp = curr; curr = curr-\u0026gt;next; temp-\u0026gt;next= prev; // curr.next= temp; 多做了一部，我们只做到当前curr指向的点就行 prev = temp; } return prev; } }; 判断回文链表（234） 判断是不是回文数的话，首先需要考虑两种基本情况：\n数值的回文数考虑奇数偶数长度的问题（中心节点不统一）；\nstring类型的回文数的情况，考虑的是正着读和反着读是一样的，不考虑中心节点好像；（使用双指针技巧，正向和反向遍历，这实际上也算是一种reverse的问题把）\n不考虑中心节点实际上是从两侧同时逼近的话，只要在left\u0026lt;right的时候执行判断就可以了，这样的话，无论中心是一个数字还是两个数字都会被考虑进去，所以这种中心逼近的思想应该还更好一点\n寻找回文数的基本中心思想是：从中心向两端拓展（反过来就是递归思想）\n而对于链表问题：链表是一个单向索引的数据结构，这种情况下怎么使用双指针的办法？\n遍历的同时存储一个反转副本，然后判断两个链表是否相同？\n使用二叉树的后序遍历的思想，也能倒序的遍历链表，来进行回文数判断\n实际上就是基本的递归思想把；同时我们知道树结构其实也就是依托于LISTNode的高层实现，每个树的节点都是链表的节点来着。但是这样的方法目前来看算法的效率不是特别的高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 时间和空间复杂度都是O（n） 后续需要对这个方法进行优化 使用后续遍历的迭代思想进行的例子; 实现上的核心问题：我们虽然可以通过后序遍历来首先取到链表的tail; 但是我们如何让最底层的取到的也是最前面的head呢？（需要另一一个共有head）; class Solution { public: ListNode* head; bool isPalindrome(ListNode* head) { this-\u0026gt;head = head; return reverseJ(head); } bool reverseJ(ListNode* tail){ // 我们虽然可以通过后序遍历来首先取到链表的tail // 但是我们如何让最底层的取到的也是最前面的head呢？（需要另一一个共有head） if (tail == nullptr) return true; bool ans = reverseJ(tail-\u0026gt;next); ans = ans \u0026amp;\u0026amp; (this-\u0026gt;head-\u0026gt;val == tail-\u0026gt;val); this-\u0026gt;head = this-\u0026gt;head-\u0026gt;next; return ans; } }; 如何优化上面的这个算法，减少这个不必要的入栈的空间复杂度，这就涉及到了如何用两个指针来模拟反向遍历的问题：这是一个特别的算法，我们放到下面一个小专题中来详细讲：\n快慢指针技巧优化空间复杂度 双指针技巧1：快慢指针找到链表的中点，原理如图所示，\n这个方法的时间复杂度是O（n），空间复杂度是O（1）；\nKeypoint-\u0026gt;找到链表的中点。\n1 2 3 4 5 6 7 8 9 ListNode* slow, *fast; slow = fast = head; while (fast != nullptr \u0026amp;\u0026amp; fast-\u0026gt;next != nullptr) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } if (fast != nullptr) slow = slow-\u0026gt;next; // slow 指针现在指向链表中点 如果fast不是nullptr，说明链表的长度为奇数，slow还需要往后进行一步，现在是卡在中间的地方\n1 2 if(fast != nullptr) slow = slow-\u0026gt;next; 接下来就不需要多说了把，直接递归进行后续的链表反转，然后正向运行JUDGE就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while (curr) { ListNode* temp = curr; curr = curr-\u0026gt;next; temp-\u0026gt;next = prev; prev = temp; } return prev; } }; JUDGE:\n1 2 3 4 5 6 7 8 9 10 ListNode* left = head; ListNode* right = reverse(slow); while (right != nullptr) { if (left-\u0026gt;val != right-\u0026gt;val) return false; left = left-\u0026gt;next; right = right-\u0026gt;next; } return true; 二叉树刷题 很多二叉树的问题实际上就是上述总结的二叉树遍历的问题，可以套用以上的框架解决。\n而且二叉树实际上和很多重要的算法都有关系：比如说快速排序就是二叉树的前序遍历；归并排序就是二叉树的后续遍历。\n二叉树中的最大路径和（142） 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径 至少包含一个 节点，且不一定经过根节点。\n路径和 是路径中各节点值的总和。\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n解题的思路：\n注意区分return和最终结果值的区别 由于考虑到节点为negative的情况，这种情况下就需要设定两个值： 一个是经过当前节点的话，最多能得到多少（动态规划，从后往前） 用max来考虑当前节点接不接如（用0来代替） 另一个是最终的最大值 对于每个节点 return：这个节点，后面能取得得最大值； ans：结合这个节点的左右child，能取得的最大值？，为什么一定要加入当前节点的值？因为不加入当前节点的值的话，就是看哪个子节点最大了（子节点已经考虑了0的情况，也就是用max做了处理。） 这实际上还是递归遍历的框架，最重要的在于问题归纳，怎么对左右节点进行处理和怎么对中间节点进行是否引入的判断； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //* Definition for a binary tree node. class Solution { private: int ans = INT_MIN; public: int maxPathSum(TreeNode* root) { helpSum(root); return ans; } int helpSum(TreeNode* root) { if (root == nullptr) return 0; // 考虑negative的情况；用0来判断是否要输入 int rightG = max(helpSum(root-\u0026gt;right), 0); int leftG = max(helpSum(root-\u0026gt;left), 0); // 不经过该节点的情况已经在子节点的地方输出了，不需要我自己画蛇添足的在这里进行政府的判断； // 从最低层节点开始分析你就知道了，已经包含在ans中了 int temp = root-\u0026gt;val + rightG + leftG; ans = max(temp,ans); // 最终都是复数的情况？可能还要考虑temp和val哪个更小的问题 return max(rightG,leftG) + root-\u0026gt;val; } }; 基于前序和中序重建二叉树（105） 和剑指的题目冲突了，06，看书即可；后续和前序的应该关系差不多\n基于前序找到中间切分点，然后根据中间接分店找到左子树和右子树的数目，从前序和中序中抠出子树来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { // int tempre[preorder.size()]; // 函数，返回一个迭代器 return helpbuild(preorder.begin(),preorder.end(),inorder.begin(),inorder.end()); } // 学，给老子学，怎么在c++中实现动态数组的划分传入，如果是python可太爽了； TreeNode* helpbuild(vector\u0026lt;int\u0026gt;::iterator preb, vector\u0026lt;int\u0026gt;:: prend, \\ vector\u0026lt;int\u0026gt;::iterator inob, vector\u0026lt;int\u0026gt;::iterator inoe) { if(inob == inoe) return nullptr; TreeNode* cur = new TreeNode(*preb); // 记住这个函数find，返回的是一个迭代器，迭代器本身就是一个指针，指针的+1会随着类型的不同而变化 auto root = std::find(inob,inoe,*preb); cur-\u0026gt;left = helpbuild(preb+1,preb+(root-inob)+1,inob,root); cur-\u0026gt;right = helpbuild(preb+(root-inob)+1,prend,root+1,inoe); return cur; } }; 基于FA中的算法复原一下？等下思想好像是一样的就是一个前序遍历的过程。\n基于中序和后序重建二叉树（106） 和上一题基本的实现思想采用了一样的思路，但是这样的方法的空间复杂度好像和网友们查了很多我也不知道具体是为啥，看看fA中间的解法把，以下先post我的思路；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; inorder, vector\u0026lt;int\u0026gt;\u0026amp; postorder) { return helpbuild(inorder.begin(),inorder.end(),postorder.begin(),postorder.end()); } TreeNode* helpbuild(vector\u0026lt;int\u0026gt;::iterator ins,vector\u0026lt;int\u0026gt;::iterator ine, vector\u0026lt;int\u0026gt;::iterator pos, vector\u0026lt;int\u0026gt;::iterator poe) { if(poe == pos) return nullptr; // 这里要注意的是end是有值的下一项 // iterator 之间的加减和index之间的加减的关系的转化也要清楚到底是怎么回事 poe--; TreeNode* cur = new TreeNode(*poe); auto root = find(ins,ine,*poe); cur-\u0026gt;left = helpbuild(ins,root,pos,poe-(ine-root-1)); cur-\u0026gt;right = helpbuild(root+1,ine,poe-(ine-root-1),poe); return cur; } }; 下面是FA的实现思路 ：(need to change cpp version)实际上没什么区别，但是就是在++\u0026ndash;这块好像确实直接用下标索引会好一点，在找找把。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 TreeNode build(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) { if (inStart \u0026gt; inEnd) { return null; } // root 节点对应的值就是后序遍历数组的最后一个元素 int rootVal = postorder[postEnd]; // rootVal 在中序遍历数组中的索引 int index = 0; for (int i = inStart; i \u0026lt;= inEnd; i++) { if (inorder[i] == rootVal) { index = i; break; } } // 左子树的节点个数 int leftSize = index - inStart; TreeNode root = new TreeNode(rootVal); // 递归构造左右子树 root.left = build(inorder, inStart, index - 1, postorder, postStart, postStart + leftSize - 1); root.right = build(inorder, index + 1, inEnd, postorder, postStart + leftSize, postEnd - 1); return root; } 翻转二叉树（226） 这题白送的，都不需要再多说什么。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root == nullptr) return nullptr; TreeNode* Temp = root-\u0026gt;right; root-\u0026gt;right = root-\u0026gt; left; root-\u0026gt;left = Temp; invertTree(root-\u0026gt;right); invertTree(root-\u0026gt;left); return root; } }; 填充二叉树节点的右侧指针（116） 这一题也是比较考虑迭代和递归思想的，同时也考研完全二叉树节点的构造特点知识（从左到右建立起来，全满的）\n我的解决方法：每次从最左侧节点开始，给下一层赋予连接，然后通过这样的设定迭代的完成这样的任务。\n需要注意的地方：几个设置为空的判断，包括对于left为空的判断是需要的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: Node* connect(Node* root) { if(!root) return nullptr; else { Node* temptr = root; while(root != nullptr){ // 这一步特别重要也容易忽略 if(!root-\u0026gt;left) return temptr; root-\u0026gt;left-\u0026gt;next = root-\u0026gt;right; root-\u0026gt;right-\u0026gt;next = root-\u0026gt;next?root-\u0026gt;next-\u0026gt;left:nullptr; root = root-\u0026gt;next; } connect(temptr-\u0026gt;left); return temptr; } } }; FA写的方法：没有我写的快，但是其实更好理解一点，他是通过辅助函数把传入的两个节点串起来。但是这样调用的消耗也太大了。\n模拟的就是第一个节点的情况，把分开的分开处理，然后跨树的节点相连。\n这样其实理解起来还难一点，但是主要是一个无死角覆盖的问题，和一个跨树的处理的问题，全部归化成第二到第三层的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: // 主函数 Node* connect(Node* root) { if (root == nullptr) return nullptr; connectTwoNode(root-\u0026gt;left, root-\u0026gt;right); return root; } // 辅助函数 void connectTwoNode(Node* node1, Node* node2) { if (node1 == nullptr || node2 == nullptr) { return; } /**** 前序遍历位置 ****/ // 将传入的两个节点连接 node1-\u0026gt;next = node2; // 连接相同父节点的两个子节点 connectTwoNode(node1-\u0026gt;left, node1-\u0026gt;right); connectTwoNode(node2-\u0026gt;left, node2-\u0026gt;right); // 连接跨越父节点的两个子节点 connectTwoNode(node1-\u0026gt;right, node2-\u0026gt;left); } }; 二叉树展开为链表（114） 我自己的解法beat 100 99\n要注意的是要全部收敛到右侧，解题思路写在下面的代码中，拜读一下自己。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: void flatten(TreeNode* root) { helpflat(root); } TreeNode* helpflat(TreeNode* root){ // 递归的终点以及空值判断 if(!root) return nullptr; //n-1假设：flaten后续的节点并变到左侧，同时由于后续的接入需求，我们需要return最后一个有值的节点 TreeNode* lefte = helpflat(root-\u0026gt;left); TreeNode* righte = helpflat(root-\u0026gt;right); //加入最后左右都是0的话，我们就return当前节点而不是下一个节点（因为我们需要最后一个元素的索引），这其实也是终值判断 if(!lefte \u0026amp;\u0026amp; !righte) return root; // 如果只有右边无序处理，算是已经摊开好了 else if(righte \u0026amp;\u0026amp; !lefte) { } //两边都有或者只有左边的情况下，就是把左边的最后一个的下一个接到当前节点的右侧那一路，然后将改节点转移到右侧，最后将左节点清空。返回尾巴，无论是左边还是右边。 else { lefte-\u0026gt;right = root-\u0026gt;right; root-\u0026gt;right = root-\u0026gt;left; } root-\u0026gt;left = nullptr; // 返回尾巴，如果有右侧尾巴的话，他就在最后，否则就是左侧尾巴是最后 return righte?righte:lefte; } }; FA的解法和思想：(实际上基本是差不多的)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 定义：将以 root 为根的树拉平为链表 void flatten(TreeNode root) { // base case if (root == null) return; flatten(root.left); flatten(root.right); /**** 后序遍历位置 ****/ // 1、左右子树已经被拉平成一条链表 TreeNode left = root.left; TreeNode right = root.right; // 2、将左子树作为右子树 root.left = null; root.right = left; // 3、将原先的右子树接到当前右子树的末端 TreeNode p = root; while (p.right != null) { p = p.right; } p.right = right; } 构建最大二叉树（654） 这里理解上没啥问题，但是实现上有一些奇怪的问题需要分析，后续解决把\n一个就是最后那个+1，没有弄的话会导致溢出等很严重的问题 第二是lvalue的问题还有一个就是为什么使用iterator在这里不太行，后续修改一下试试。 还有一个要注意的就是记得用new关键词来构造新的节点，不然return的那个东西最后本身都不存在了还return个几把。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // FIXME:为什么在这里使用迭代器的方法会出现很多问题，无法进行实现，正确的写法应该是怎么杨的？ // lvalue来初始化一个node我知道不行，但是为什么会是左值呢。 // class Solution { // public: // TreeNode* constructMaximumBinaryTree(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // TreeNode* root = helpbuild(nums.begin(),nums.end()); // return root; // } // TreeNode* helpbuild(vector){ // int max= *begin; // for(vector\u0026lt;int\u0026gt;::iterator it=begin; it!=end; it++){ // if(*it\u0026gt;max) // max = *it; // } // cout\u0026lt;\u0026lt;max\u0026lt;\u0026lt;endl; // TreeNode* inner; // inner-\u0026gt;val = max; // auto next = find(begin,end,max); // inner-\u0026gt;left = helpbuild(begin,next); // inner-\u0026gt;right = helpbuild(next+1,end); // return inner; // } // }; class Solution{ public: TreeNode* constructMaximumBinaryTree(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return helpbuild(nums,0,nums.size()); } TreeNode* helpbuild(vector\u0026lt;int\u0026gt;\u0026amp; nums, int begin, int end){ if(nums.empty() || begin==end) return nullptr; int maxindex = -1, maxval = INT_MIN; for(int i=begin;i\u0026lt;end;i++){ if (nums[i]\u0026gt;=maxval) { maxindex = i; maxval = nums[i]; } } // inner的生存周期问题 TreeNode* inner = new TreeNode(maxval); inner-\u0026gt;left = helpbuild(nums,begin,maxindex); // 下面这里没有+1的画，会导致一个机器严重的问题，但是我不知道为啥，是溢出了把，永远无法到达终点？ inner-\u0026gt;right = helpbuild(nums,maxindex+1,end); return inner; } }; :star: 寻找重复的子树（652） LINK FA参考链接，\n这一题的解题思路还是比较有意思的，解题过程中也出现了比较多的问题，还有一些有待解决的问题需要分析。\n用后序遍历的序列来表征子树:可以观察特点，就知道只有后续遍历保留了子树的结构，其他的方式都有一部分是Top-Down的，就不符合子树的要求 String的方式来寻找重复子树 int变量如何转换到string，为啥出现了很多问题，还有网友的解决方法对比 现在的时空复杂度结果都不太好到网上找一下更好的解决思路和解决的方案； 下面给出一个基本的解法，后续需要进行优化和补充。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // TODO:这题可以讨论一下python的解法，应该会更简单一点。 // FIXME：这题目前这样的结果十分的差，后序看看其他方法的改进，但是这题的解题思路还是很不错 #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; class Solution { public: unordered_map\u0026lt;string,int\u0026gt; memo; vector\u0026lt;TreeNode*\u0026gt; res; vector\u0026lt;TreeNode*\u0026gt; findDuplicateSubtrees(TreeNode* root) { if(!root) return {}; // 这个返回值要记得 traverse(root); return res; } string traverse(TreeNode* root){ if(!root) return \u0026#34;#\u0026#34;; string left = traverse(root-\u0026gt;left); string right = traverse(root-\u0026gt;right); // 得到一个后序遍历的序列，（但是基于这样的序列怎么判断子树一致呢？） // FIXME int到string的转换到底怎么做，好疑惑啊。 char temp = root-\u0026gt;val +\u0026#39;0\u0026#39;; string resstr = left + \u0026#34;,\u0026#34; + right+\u0026#34;,\u0026#34; + temp; // 压入hashmap，通过数值判断重复的root；通过数值判断就知道有没有重复了 if(memo.count(resstr)) memo[resstr]++; if (memo[resstr]==1) res.push_back(root); return resstr; } }; :question: :star: 二叉树的序列化和反序列化（297） 这题 在解题过程中出现了很多问题和值得探讨的点，后续一定要进行归纳总结以及二刷。\n二刷TODO:\n层级遍历的思路设计总结 各种遍历方式的可行性分析(实现) 遍历与数据结构的相对应分析 问题归纳：\n需要总结一下各种数据类型的空值return方式（也就是空值的表达）\nstring : \u0026quot;\u0026quot; {}\n相关的各种常见类型之间的转化；\nstring to int : stoi()\nint to string : to_string() (需要include)\n各个类别中的迭代器实现和类别;\n连续append的实现: (.append().append());\n切分字符串split方法的实现(思路),以及为什么这里在前序遍历的时候需要选用Queue;\n什么类别,什么情况下需要先调用new再执行后续的复制操作(为啥定义的时候不需要,但是这里要new)\n有时候append不行但是push_back可以,这是为什么?这个区别是string特有的还是通用的?\n编程的format实现,要全部写在类里还是类外.(分析易读性)\n前序遍历的代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Codec { public: // 实际上该问题还是突出一个三种遍历方式的问题； // Encodes a tree to a single string. string serialize(TreeNode* root) { string BTString; string SEP = \u0026#34;,\u0026#34;; string ENDS = \u0026#34;#\u0026#34;; if(!root){ BTString.append(ENDS).append(SEP); return BTString; } // 前序遍历位置 // TODO：连续append的表示形式 BTString.append(to_string(root-\u0026gt;val)).append(SEP); BTString.append(serialize(root-\u0026gt;left)); BTString.append(serialize(root-\u0026gt;right)); return BTString; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { // 切分字符串方法 find \u0026amp; substr? // 我们在这里需要的是一个先进先出的情况，所以实际上是一个Quene的类别 // 但是好像实际上for循环也能满足这个问题，但是如果我试图使用递归的话，那我应该还是要用队列 // 长度不固定的问题 // FIXME:String的空值的情况 if(data==\u0026#34;\u0026#34;) return nullptr; // NOTE: 通过循环将布不恒等的数值压入队列 queue\u0026lt;string\u0026gt; q; string Tmpstr; for(int i = 0; i\u0026lt;data.length();i++){ if(data[i]==\u0026#39;,\u0026#39;){ q.push(Tmpstr); Tmpstr.clear(); } else{ // FIXME：append就不行但是push_back就可以，为什么？ Tmpstr.push_back(data[i]); } } return helprebuild(q); } TreeNode* helprebuild(queue\u0026lt;string\u0026gt;\u0026amp; que); }; TreeNode* Codec::helprebuild(queue\u0026lt;string\u0026gt;\u0026amp; que) { TreeNode* root; // if (que.empty()) // return nullptr; string str = que.front(); if(str == \u0026#34;#\u0026#34;) { que.pop(); return nullptr; } // FIXME：还没有给这个类别建立一个存储空间 root = new TreeNode(); root-\u0026gt;val = stoi(str); que.pop(); root-\u0026gt;left = helprebuild(que); root-\u0026gt;right = helprebuild(que); return root; } 完全二叉树的节点计算 完全二叉树和满二叉树有很多不同的定义方式，本文中针对的完全二叉树计算是如下的这种情况：\n每一层都是紧凑靠左排列的\n首先这种节点情况进行计算的话，最优的时间复杂度应该是 $O(logN * logN)$ ?\n首先普通二叉树的话直接就是O（N）遍历就完事了；\n如果是全部填满的满完全二叉树架构的话，就直接 $O(logN)$ 指数计算就好了。\n那么完全二叉树的话，应该是前两者结合，也就是当左右的深度相同的话，就不需要计算，只需要在左右深度不同的情况下进行遍历的操作就可以了，但是这个思想的实现，对于计算复杂度的实现是相当巧妙的，好好分析一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public int countNodes(TreeNode root) { TreeNode l = root, r = root; // 记录左、右子树的高度 int hl = 0, hr = 0; while (l != null) { l = l.left; hl++; } while (r != null) { r = r.right; hr++; } // 如果左右子树的高度相同，则是一棵满二叉树 if (hl == hr) { return (int)Math.pow(2, hl) - 1; } // 如果左右高度不同，则按照普通二叉树的逻辑计算 // 这里两边都是null的情况就会回归1，不需要额外的判断 return 1 + countNodes(root.left) + countNodes(root.right); } 复杂度分析\n一棵完全二叉树的两棵子树，至少有一棵是满二叉树：所以不断切分迭代的话，我们就知道每次的while是 $O(logN)$ 需要迭代 $O(logN)$ 的深度，所以就是上面分析的复杂度。\n:star: 二叉树的最近公共祖先（236）二刷 这个设计思路 还挺有意思 ，虽然代码不长但是思路还比较复杂；可以参考一下这个代码的设计思路，实际上还是逃不脱二叉树的几种框架：\n根据我们需要首先访问的值来决定我们的遍历框架。\n这题首先需要我们找到最底部的值（后序遍历），然后一层一层的往外找，然后找到最底层的哪个公共root（再往上肯定就都是公共的了）；\n如果只有其中一个值就返回那个值的指针，如果root的两侧包含了两个，就返回root。 由于如果Node1的左右包含了p，q；那么Node的父节点的左右肯定另一侧是无效值，可以用这个来设计内层覆盖外层返回值的逻辑。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { // 用来判断是否两个点都存在在以如今的root所在的树中，如果存在的话就返回True // 设计的主要原则： // 1. 出现在了后面节点的左边和右边的话，就不可能出现在父节点的左边和右边 // 2. 再叶节点找到相应的两个指，需要从后面遍历起来，先找到两个节点的位置，然后一级一级的并上来。 if(!root) return nullptr; if(root == q || root == p) return root; TreeNode* left = lowestCommonAncestor(root-\u0026gt;left,p,q); TreeNode* right = lowestCommonAncestor(root-\u0026gt;right,p,q); if (left \u0026amp;\u0026amp; right) return root; if (!left \u0026amp;\u0026amp; !right) return nullptr; return left?left:right; } // bool comexit(TreeNode* root, TreeNode* p, TreeNode* q); }; 扁平化嵌套列表迭代器（341） 这一题主要要好好的看提示和题目，\n这题的关键在于辅助空间的建立和相应的（迭代和循环的）嵌套，还有就是理解题目，但是这种简单的实现方式，实际上并不能达到一个比较好的时间和空间复杂度。\n**我的解法（初始）：**我的方法也可以改成用栈来实现，原理是一样的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class NestedIterator { private: int lens; int index; vector\u0026lt;int\u0026gt; NestIt; // 关键点在于额外辅助数组的构建，但是是否能够预先建立一个比较长的数组 // FIXME：通过初始化函数，建立一个比较合适的数组长度，从而减少需要额外分配内存的时间代价。 // Vector的重新初始化方式。 public: // TODO:迭代器的表示形式应该怎么写 // NOTE：这种题目的阅读逻辑应该怎么分析 NestedIterator(vector\u0026lt;NestedInteger\u0026gt; \u0026amp;nestedList):index(0) { helpBuildVec(nestedList); } void helpBuildVec(vector\u0026lt;NestedInteger\u0026gt; \u0026amp; nestedList){ for(int i =0;i\u0026lt;nestedList.size();i++) { if(nestedList[i].isInteger()) NestIt.push_back(nestedList[i].getInteger()); // 记得要调用取值的函数 else helpBuildVec(nestedList[i].getList()); } lens = NestIt.size(); } int next() { return NestIt[index++]; } bool hasNext() { return index \u0026lt; lens; } }; 实际上迭代器应该根据需要来进行数值的导入，没有必要一开始就将全部的数据读取出来，这样的效率在一些特殊的情况下可能是不好的\n改进1：惰性存放\nVector反向迭代 rbegin rend 利用栈，其实用队列然后正向迭代也是可以的 初步就是先把外层存进去，在实际调用的时候再解包的方法。 实际上需要关注的地方就是hasnext用来解包的过程。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class NestedIterator { private: stack\u0026lt;NestedInteger\u0026gt; st; public: NestedIterator(vector\u0026lt;NestedInteger\u0026gt; \u0026amp;nestedList) { for (auto iter = nestedList.rbegin(); iter != nestedList.rend(); iter++) { st.push(*iter); } } int next() { auto t = st.top(); st.pop(); return t.getInteger(); } bool hasNext() { while (!st.empty()) { auto cur = st.top(); if (cur.isInteger()) return true; st.pop(); auto curList = cur.getList(); for (auto iter = curList.rbegin(); iter != curList.rend(); iter++) { st.push(*iter); } } return false; } }; 二叉搜索树 BST中的搜索（700） 利用大小的特性进行遍历就好了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if(!root) return nullptr; if(root-\u0026gt;val == val) return root; if(val \u0026gt; root-\u0026gt;val) return searchBST(root-\u0026gt;right,val); if(val \u0026lt; root-\u0026gt;val) return searchBST(root-\u0026gt;left,val); return nullptr; } }; BST第k小的元素（230） “从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）”。\n上面这个是最关键的一点，同时我们也很容易理解这点，根据BST本身的性质来说，所以这道题实际上很简单，我们只需要进行一个中序遍历就可以完成这样的问题了，然后在后续的位置进行累计。\n还有就是熟悉迭代到底会从头开始输出还是从尾开始输出，这点逻辑要搞清楚，好像除了前序遍历的话，其他的都是会从尾巴开始的把。 文中提到的优化思路，其实是如何将算法优化到（logn），那就需要知道k和一个数是第几的这个关系，这样的话，实际上是需要树本身存放额外信息的（以自己为root的树有多少节点，这样就能分析出来自己顺位，从而和k对比）。 红黑树这种改良的自平衡BST，增删查改都是O（logN）的复杂度。（后续掌握） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { private: int count = 0; int res = INT_MIN; public: int kthSmallest(TreeNode* root, int k) { traverr(root,k); return res; } void traverr(TreeNode* root, int k){ if (!root) return; traverr(root-\u0026gt;left,k); count++; if(count==k) res = root-\u0026gt;val; traverr(root-\u0026gt;right,k); } }; BST转化为累加树（538，1038） 分析题目，实际上也是一个遍历的问题，由于找的是比自己大的所有数\n:star: 所以累加的方向：是从大数累计到小数，而同时BST的中序遍历是有序的，所以我们改变中序遍历的方式，进行一个从大到小的遍历，用一个默认值来进行累计值的统计。\n:question: 为什么NULL的方法会失效 由于Int的上限的问题，需要使用long不然会出问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // FIXME:为什么使用NULL的方法会失效。 // LONG的使用情景， // 试着用迭代的方式去写（中序遍历） class Solution { public: bool isValidBST(TreeNode* root) { return helpJudge(root,LONG_MAX,LONG_MIN); } bool helpJudge(TreeNode* root, long int max,long int min){ if(!root) return true; // 这个大于等于等于号不能丢掉。 if(root-\u0026gt;val \u0026gt;= max) return false; if(root-\u0026gt;val \u0026lt;= min) return false; // 根据节点往下迭代的情况，更新最小值和最大值，因为右侧的最小值是不断增长的 // 而左侧的最大值是在不断的变小的。这一点是这个问题最关键的地方 return helpJudge(root-\u0026gt;right,max,root-\u0026gt;val) \u0026amp;\u0026amp; helpJudge(root-\u0026gt;left,root-\u0026gt;val,min); } }; BST的节点有效性（98） 也就是左侧的子树都要小于中间然后小于右侧的子树，这点，如果简单的对于所有的节点对左右判断的话，没办法维持子树全体的大小关系的特性，所以需要额外的记录一个值来保持这个特性：\nroot的值是左边的最大值，是右边的最小值； 或者从有序规则来统计一个最大最小值来进行判断，（swap==0） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 boolean isValidBST(TreeNode root) { return isValidBST(root, null, null); } /* 限定以 root 为根的子树节点必须满足 max.val \u0026gt; root.val \u0026gt; min.val */ boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) { // base case if (root == null) return true; // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST if (min != null \u0026amp;\u0026amp; root.val \u0026lt;= min.val) return false; if (max != null \u0026amp;\u0026amp; root.val \u0026gt;= max.val) return false; // 限定左子树的最大值是 root.val，右子树的最小值是 root.val return isValidBST(root.left, min, root) \u0026amp;\u0026amp; isValidBST(root.right, root, max); } BST插入数值（701） 对比判断左右就行了，就是加入了判断的遍历。下面是FA给出的框架\n1 2 3 4 5 6 7 8 9 10 11 TreeNode insertIntoBST(TreeNode root, int val) { // 找到空位置插入新节点 if (root == null) return new TreeNode(val); // if (root.val == val) // BST 中一般不会插入已存在元素 if (root.val \u0026lt; val) root.right = insertIntoBST(root.right, val); if (root.val \u0026gt; val) root.left = insertIntoBST(root.left, val); return root; } 我的解题方法：实际上就是基于遍历的思想，然后在需要的地方执行完操作再往后继续遍历就好了。实际上实现的效果非常的好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(!root){ TreeNode* curr = new TreeNode(val); return curr; } if (val \u0026gt; root-\u0026gt;val) { if (!root-\u0026gt;right) { TreeNode* curr = new TreeNode(val); root-\u0026gt;right = curr; return root; } insertIntoBST(root-\u0026gt;right,val); } else { if(!root-\u0026gt;left) { TreeNode* curr = new TreeNode(val); root-\u0026gt;left = curr; return root; } insertIntoBST(root-\u0026gt;left,val); } return root; } }; :star: BST删除（450） 下面这个的思路其实和我们想的是一样的，但是这种书写的方式留意一下，用delete来做就好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if(root == nullptr) return root;//第一种情况：没找到删除的节点，遍历到空节点直接返回 if(root-\u0026gt;val == key) { //第二种情况：左右孩子都为空（叶子节点），直接删除节点，返回NULL为根节点 //第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点 if(root-\u0026gt;left == nullptr) return root-\u0026gt;right; //第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 else if(root-\u0026gt;right == nullptr) return root-\u0026gt;left; //第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置 //并返回删除节点右孩子为新的根节点 else{ TreeNode* cur = root-\u0026gt;right;//找右子树最左面的节点 while(cur-\u0026gt;left != NULL) { cur = cur-\u0026gt;left; } cur-\u0026gt;left = root-\u0026gt;left;//把要删除的节点左子树放在cur的左孩子的位置 TreeNode* tmp = root; //把root节点保存一下，下面来删除 root = root-\u0026gt;right; //返回旧root的右孩子作为新root delete tmp; //释放节点内存 return root; } } if(root-\u0026gt;val \u0026gt; key) root-\u0026gt;left = deleteNode(root-\u0026gt;left, key); if(root-\u0026gt;val \u0026lt; key) root-\u0026gt;right = deleteNode(root-\u0026gt;right, key); return root; } }; 先找到，**然后改，**主要是不能破坏BST的数值结构.先写出基本的框架\n1 2 3 4 5 6 7 8 9 10 11 12 TreeNode deleteNode(TreeNode root, int key) { if (root.val == key) { // 找到啦，进行删除 } else if (root.val \u0026gt; key) { // 去左子树找 root.left = deleteNode(root.left, key); } else if (root.val \u0026lt; key) { // 去右子树找 root.right = deleteNode(root.right, key); } return root; } 情况 1：A恰好是末端节点，两个子节点都为空，那么它可以当场去世了。\n1 2 if (root.left == null \u0026amp;\u0026amp; root.right == null) return null; 情况 2：A只有一个非空子节点，那么它要让这个孩子接替自己的位置。\n1 2 3 // 排除了情况 1 之后 if (root.left == null) return root.right; if (root.right == null) return root.left; 情况 3：A有两个子节点，麻烦了，为了不破坏 BST 的性质，A**必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。**我们以第二种方式讲解。\n1 2 3 4 5 6 7 8 if (root.left != null \u0026amp;\u0026amp; root.right != null) { // 找到右子树的最小节点 TreeNode minNode = getMin(root.right); // 把 root 改成 minNode root.val = minNode.val; // 转而去删除 minNode root.right = deleteNode(root.right, minNode.val); } 综上所述：但是我们通常不会通过val交换值来交换节点，而是通过链表操作来处理，暂时把框架和思路描写成这样，后续进行修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 TreeNode deleteNode(TreeNode root, int key) { if (root == null) return null; if (root.val == key) { // 这两个 if 把情况 1 和 2 都正确处理了 if (root.left == null) return root.right; if (root.right == null) return root.left; // 处理情况 3 TreeNode minNode = getMin(root.right); root.val = minNode.val; root.right = deleteNode(root.right, minNode.val); } else if (root.val \u0026gt; key) { root.left = deleteNode(root.left, key); } else if (root.val \u0026lt; key) { root.right = deleteNode(root.right, key); } return root; } TreeNode getMin(TreeNode node) { // BST 最左边的就是最小的 while (node.left != null) node = node.left; return node; } 我的解题过程\n遇到的问题：\n删除的话不是之前的链表那种用nullptr替代，好像是直接用delete去做的逻辑，这样的话，编写的难度其实就不太一样了，我们可以找一个替代指针来进行删除。 分析清楚总共有几种情况，一些特殊的情况下直接进行一个值的替换可以吗。（不行） 这里有好几种解题思路，主要用的是一个替换的思想，这里后面要重新看看多捋捋。（这些算法实际上都涉及到内存泄露把，就很离谱） 但是还有一个典型的就是只要我们最后return的ptr的树，是我们的目标树来着。这里给出的方法实际上是直接整个把左子树接到右子树的后面去了，如果删除的是中间节点的话，学习一下。 动态规划方法 首先是动态规划的基本思路（适用条件）（剑指有提到讲的还挺好）：本质上是一种穷举的搜索方法\n求解的是最值问题 最优解可以依赖于子序列的最优解（最优子结构） 大问题可以分解为小问题，小问题还有重叠的更小的子问题； 从上到下分析问题，从下到上的求解问题（避免重复计算）（需要额外的存储空间） 最关键的点在于正确的状态转移方程。（实际上也就是二叉树中多种遍历之间要执行的那个操作）：\n明确[状态] -\u0026gt; 定义dp动态规划表中的数组或者函数的含义（子最优状态）-》明确选择-》明确base case就是起始状态\n可以看一下其中的硬币问题 实际上很多情况下可以使用这样的解题策略：\nBottom-up （Vector，或者用hashtab之类的D-P table 存储） 双指针Bottom-up 其中设计迭代的一些准则：\n遍历的过程中需要的状态必须是已经算出来的 遍历的重点是我们要存储结果的那个位置。 存储表和DP-TABLE不是一个意思\n动态规划的状态压缩方法 主要用于我们需要有二维的存储空间的时候，怎么压缩成一维的这种情况。\n理解如下 ：\n初始状态直接向下压成1维度，去掉i维度\n通过内外层循环的不同更新特性，来逐渐的覆盖之前的值。\n用一个pre和temp来保留上一层的i 和上一层的j\n然后基于先后的更新顺序取更新问题。\n实际上就是利用更新的延后性去压缩空间，实际上只要保留一个temp和一个pre就可以了、\nTODO：\n二刷的时候考虑更新之前的动态规划算法 在做后续题目的时候也考虑执行压缩的策略。 :question:正则表达式问题： 永远的苦主，事实上我应该意识到，这样移动序列的问题，完全可以转化成，递归或者说是动态规划的问题来做，通过一个设想的匹配函数和一个相应的状态转移方程来进行，由于其中的*号带来的多种重复可能性，所以可能需要像动态规划那样建立一个索引表来防止重复计算，这个我们也要重新进行分析一下看看。（我觉得好像是不用的把。）\n实我还没get为什么这一个问题属于正则表达式的问题。研究一下FA中的说法把，\n通过剑指offer中的递归的思想，倒是能够解决这道题，但是问题就在于，这样的话，虽然空间复杂度好了，但是时间复杂度拉跨的不行，这就说明是存在着重复运算的动态规划的情况把，所以我们使用FA中的思路建立一个memo表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: bool isMatch(string\u0026amp; s, string\u0026amp; p) { // 空值测试 if(p.empty()) return s.empty(); return findMatch(s,p,0,0); } bool findMatch(const string\u0026amp; s , const string\u0026amp; p,int si, int pi); }; bool Solution::findMatch(const string\u0026amp; s, const string\u0026amp; p, int si, int pi) { // if(p.empty()) return s.empty(); int s_ize = s.size(), p_size = p.size(); if (pi\u0026gt;=p_size \u0026amp;\u0026amp; si\u0026lt;s_ize) return false; if (pi\u0026gt;=p_size \u0026amp;\u0026amp; si\u0026gt;=s_ize) return true; // 第二种，匹配到了*号的情况 // 由于关键的*的个数，实际上是一种不确定的情况，而只要有一种情况符合就只要当True即可 // 所以用递归的方法去做还是挺合适的 if(p[pi+1]==\u0026#39;*\u0026#39;) { if(p[pi]==s[si] || (p[pi] == \u0026#39;.\u0026#39;\u0026amp;\u0026amp;si\u0026lt;s_ize)) { //实际上三者其中一个的最优就对了 return findMatch(s,p,si+1,pi+2) || findMatch(s,p,si+1,pi) || findMatch(s,p,si,pi+2); } else { return findMatch(s,p,si,pi+2); } } // 三种可能性，首先先判断最简单的清康 .或者相等的情况 if(s[si]==p[pi] || p[pi]==\u0026#39;.\u0026#39; \u0026amp;\u0026amp; si\u0026lt;s_ize) { return findMatch(s,p,si+1,pi+1); } return false; } 建立递归表的方式，这里是参考的官方的减法，但是这里的加和减，和上面的区别就是，\n这里建表的假设是前面的几项是否相同（True or False），以及我们是往后面迭代，他是从前面开始迭代，我们跌打到后边界，他迭代到前边界。所以实际上还是和我们的方法一样的，然后就是通过dp的框架就行。\n这个思路我还是写不好，DP表建立的不好，改天找一天耍一天动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool isMatch(string s, string p) { int m = s.size() + 1, n = p.size() + 1; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(m, vector\u0026lt;bool\u0026gt;(n, false)); dp[0][0] = true; for(int j = 2; j \u0026lt; n; j += 2) dp[0][j] = dp[0][j - 2] \u0026amp;\u0026amp; p[j - 1] == \u0026#39;*\u0026#39;; for(int i = 1; i \u0026lt; m; i++) { for(int j = 1; j \u0026lt; n; j++) { dp[i][j] = p[j - 1] == \u0026#39;*\u0026#39; ? dp[i][j - 1] || dp[i][j - 2] || dp[i - 1][j] \u0026amp;\u0026amp; (s[i - 1] == p[j - 2] || p[j - 2] == \u0026#39;.\u0026#39;): dp[i - 1][j - 1] \u0026amp;\u0026amp; (p[j - 1] == \u0026#39;.\u0026#39; || s[i - 1] == p[j - 1]); } } return dp[m - 1][n - 1]; } }; :star: 编辑距离（着重用于思路理解） 解决两个字符串的动态规划问题，一般都是用两个指针i,j分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模\n这一题的关键在于，如何将这样的问题抽象成状态转移方程，如何抽象成一个动态的规划问题。Fuck Algorithm解析 。\n后续通过第一串代码和最后的正确代码进行分析，但是这样的方法实际上效率也还不够高 我们也可以用new生成普通数组的方式去做，此外，如果我们要存储具体的操作，我们可以定义一个简单的NODE structure去实现这个功能，存放val和opp； TODO：空间效率优化：将二维空间压缩成一维的情况分析。 结合之前的硬币问题，我们可以把三种操作当成三种状态转移操作。然后将两个字符串的长度，看成矩阵的两个维度，然后通过状态转移操作进行坐标上的变换，由于我们需要的是最短距离；我们就假设我们的函数是从A-\u0026gt;B的最短距离的转移函数；\n分析问题的时候给定两个确定的case去分析：1.起始状态 2.状态转移；\n此外：我们不要去分析最优应该是什么样的，遍历求最值，就是能做的操作都做，使用动态规划的方式降维而已。\n基本的实现思路如下（需要集成存储思路）\n✔：动态规划的方法实际上还是Bottom-up更好，无论是从空间还是时间上来说 (但是实际上实现效率还是没有提高，为什么呢？)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: int minDistance(string word1, string word2) { // 实现将word1 变成 word2 // auto w1_it = word1.rbegin(); // auto w2_it = word2.rbegin(); // 首先使用递归的方式实现一下这个问题，然后再用迭代的方式做 int w2_idx = word2.size(); int w1_idx = word1.size(); // 存储表实现：vector 长度初始化学起来(主要需要存储一个空值所以记得后面的index要加1) vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; memo(w1_idx+1,vector\u0026lt;int\u0026gt;(w2_idx+1,0)); // 初始状态初始化 for(int i =0; i\u0026lt;memo.size();i++) memo[i][0] = i; for(int j =0; j\u0026lt;memo[0].size();j++) memo[0][j] = j; // 正向迭代 bottom-up // 实际上从A-》B的变换和从b——》A的变换是对称的，不用太纠结方向的问题 for(int i =1;i\u0026lt;memo.size();i++) { for(int j=1;j\u0026lt;memo[0].size();j++) { // FIXME：操作是存在象征意义的，所以不是都在最后才+1的 // memo[i][j] = min(memo[i][j-1],memo[i-1][j]); // memo[i][j] = min(memo[i][j],memo[i][j-1]); int minv = 500; if(word1[i-1] == word2[j-1]) { minv = memo[i-1][j-1]; // memo[i][j] = memo[i-1][j-1]; } // TODO:减少对数组的操作实际上运行时间会减少。 minv = min(minv,memo[i-1][j-1]+1); minv = min(minv,memo[i-1][j]+1); memo[i][j] = min(minv,memo[i][j-1]+1); // memo[i][j] = min(memo[i][j],memo[i-1][j]+1); // memo[i][j] = min(memo[i][j],memo[i-1][j-1]+1); // memo[i][j] = min(memo[i][j],memo[i][j-1]+1); } } return memo[w1_idx][w2_idx]; } }; 子序列问题 关键的解题思想：\n一维的DP数组：这种子序列问题（子序列不同于子串），需要的一般都是以i为结尾的情况下，取得的最值，这样才符合我们需要归纳 的条件。\n1 2 3 4 5 6 7 8 9 // 基础的算法模板如下 int n = array.length; int[] dp = new int[n]; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { dp[i] = 最值(dp[i], dp[j] + ...) } } 在子数组array[0..i]中，以**array[i]**结尾的目标子序列（最长递增子序列）的长度是dp[i]。\n二维的DP数组:这种思路其实用的更多，尤其是涉及到数组，两个字符串这样的问题的情况下，这种思路实际上涵盖了，包含一个字符串和两个字符串的情况\n1 2 3 4 5 6 7 8 9 10 11 int n = arr.length; int[][] dp = new dp[n][n]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; n; j++) { if (arr[i] == arr[j]) dp[i][j] = dp[i][j] + ... else dp[i][j] = 最值(...) } } 涉及两个字符串/数组时（比如最长公共子序列），dp 数组的含义如下：\n在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为dp[i][j]。\n可以参考的是编辑距离和最长公共子序列两个文章\n只涉及一个字符串/数组时（比如本文要讲的最长回文子序列），dp 数组的含义如下：\n在子数组array[i..j]中，我们要求的子序列（最长回文子序列）的长度为dp[i][j]。\n最长递增子序列（300） 我的思路（排雷）：\n首先找到长长度为一的所有子序列，然后从这个子序列的尾巴出发，找到后续的长度+1的子序列\n覆盖，清楚，（O(2N)的空间） （O（n^3））太差了，正常动态规划应该怎么去做。\n实际上正确的修改能得到二分查找N*logN的最佳时间复杂度的方法。\n为什么不能用以每个结尾的子串中的最长子序列来做动态规划\n因为最大值不可控，而且主要是这个玩意没办法重复利用。还是需要从重复寻找子序列。\n:star: N*logN的改进二分查找加贪心算法 修改前面的假设的方法：我们要以当前值作为前面那个最长子序列的结尾（不是一次搜索完，而是只搜索到当前元素），然后维护一个长度的结尾值最小的算法。官方解答 这里要学习一下二分查找的思路理念\n这题实际上不就是单调栈模板的二分优化嘛，这种情况\n通过一个-1来错开同时并减少多余计算。 用二分查找来找到第一个大于的值的位置（的思想）分析这种情况，从最后的区间开始分析。（我们要找的是第一个比他小的数，所以最后要加一） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 基于二分查找和贪心的算法 vector\u0026lt;int\u0026gt;DpT(nums.size()+1,0); // 这里好像没考虑到负数的情况吧,便于比较和加入所以+1 int lens = 1; DpT[lens] = nums[0]; for(int i=1;i\u0026lt;nums.size();i++) { if(nums[i]\u0026gt;DpT[lens]){ DpT[++lens] = nums[i]; } else{ // 二分查找大型现场。 int left = 1, cur=0, right = lens; while(left \u0026lt;= right){ int mid =(left+right)\u0026gt;\u0026gt;1; if(nums[i]\u0026gt;DpT[mid]){ // 这里为什么要+1，避免重复搜索同时做种错开吗？ left = mid+1; cur = mid; } else{ right = mid-1; } } DpT[cur+1] = nums[i]; } } return lens; } }; 动态规划 dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度\n在迭代搜索的过程中，只需要找比当前值更小的前序子序列+1取最大值就行，最终返回值是dp中的最大值，复杂度O(n^2).\n空间复杂度还行，时间复杂度依旧拉跨。如何将算法的复杂度降低到O(n*long(n))\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 建立dptable，每个存放以当前值为结尾的最长子序列长度 // 在迭代搜索的过程中，只需要找比当前值更小的前序子序列+1取最大值就行 // 最终返回值是dp中的最大值，复杂度O(n^2) vector\u0026lt;int\u0026gt; DPtable(nums.size(),1); // bottom-up 循环 for (int i=1;i\u0026lt;nums.size();i++) { for(int j =0; j\u0026lt;i;j++) { if(nums[i]\u0026gt;nums[j]) DPtable[i] = max(DPtable[i],DPtable[j]+1); } } // 找到最大值返回 int res =1; for(int\u0026amp; v_dp: DPtable) { if(v_dp\u0026gt;res) res = v_dp; } return res; } }; 这里降低到n*logn的方法还比较猎奇。通过新建立堆的方法来实现，但是这种方法为什么的\n俄罗斯套娃信封问题(354) 这个问题是个很有意思的问题，实际上关键在于通过合理的排序操作来给问题降维\n同个宽度的信封无法互相嵌套，那么如何在通过最长递增子序列的搜寻来排除掉同个高度的多个选择呢？（高度之间逆序排列，那么其中的两个无论如何都无法是递增的这样就能达到我们的唯一性和递增的目的了） 一个维度升序一个维度降序，然后进行最终的最长子序列的搜索即可。 **通过排序（一正一逆来给问题降维成一个最长递增子序列的问题）**主要的实现难点应该就在快速排序和嵌套排序中。（这里肯定要使用快速排序把，这也是时间复杂度的重要标准来着。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 二分查找的change位置放错了，找了半天 /* * @lc app=leetcode.cn id=354 lang=cpp * * [354] 俄罗斯套娃信封问题 */ // @lc code=start #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; class Solution { public: int maxEnvelopes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; envelopes) { if(envelopes.empty()) return 0; // 使用匿名函数编写排序算法，sort采用的是快排的基本方法 sort(envelopes.begin(), envelopes.end(), [](const vector\u0026lt;int\u0026gt; \u0026amp; A , const vector\u0026lt;int\u0026gt; \u0026amp; B){ return A[0]\u0026lt;B[0] || (A[0]==B[0] \u0026amp;\u0026amp; A[1]\u0026gt;B[1]); }); // 接着使用二分查找结合动态规划来搜索最长递增子序列 vector\u0026lt;int\u0026gt; dpt (envelopes.size()+1, 0); // HYPER int len = 1; dpt[len] = envelopes[0][1]; for (int i = 1;i\u0026lt;envelopes.size();i++) { // 如果比原本的大，就直接放到后面去，如果没比前面的大，就放到第一个比他大的下面，修改他的值 // 但是如果比第一个值还小的话，就会被放到最前面（第一个好像这样是搜不到0的）去，最后多长的话，是不是就说不准了？ if(envelopes[i][1]\u0026gt;dpt[len]){ len = len + 1; dpt[len] = envelopes[i][1]; } else{ //TODO:lower_boundry的使用 // FIXME:不知道这个二分查找的问题在哪，非常疑惑 change的位置放错了 int l = 1, r = len, cur = 0; while(l\u0026lt;=r){ int mid = (l+r)\u0026gt;\u0026gt;1; if (envelopes[i][1]\u0026gt;dpt[mid]){ l = mid+1; cur = mid; // 最终就会是小于的最后一个 } else{ r = mid ; } } dpt[cur+1] = envelopes[i][1]; } } return len; } }; // @lc code=end 最长回文子序列（516） 这一题的分析里面主要可以通过上面的假设和绘2维图来辅助分析，考虑到常规情况下的回文判断是对两侧的拓展实现的，如果不是两侧相同的画，两边不可能同时对子串发生回文增益；这句话中就隐含了一个操作和两个状态变换。\n代码实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int longestPalindromeSubseq(string s) { // 画那种二维图能够帮助分析是真的， // 考虑到我们常规情况下的回文判断是通过两侧拓展实现的 // 我们在这里也执行增加的两侧相等时进行判断，其他时候借助于状态转移 // if (s.size()==0) return 0; int n = s.size(); int res = 1; // 初始化DP Table 显然子序列的长度应该是大于0的，至少得有一个，所以 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; DpTable(n,vector\u0026lt;int\u0026gt;(n,0)); for (int i=0;i\u0026lt;n;i++) { DpTable[i][i] =1; } // NOTE：这里为了确保下面和旁边都有值，需要更改一下迭代的方向 for(int i=n-2;i\u0026gt;=0;i--) { for (int j=i+1;j\u0026lt;n;j++) { // 由于我们给越界值添加了0，所以不用考虑越界的情况 if(s[i]==s[j]) DpTable[i][j]=DpTable[i+1][j-1] + 2; else DpTable[i][j] = max(DpTable[i+1][j],DpTable[i][j-1]); } } return DpTable[0][n-1]; } }; // 将很多词调用的size用n表示，同时初始化操作用在构造函数中，此外尽量的减少不必要的操作，还有循环方向不要搞错了。 最大子数组和（53） 实际上也是动态规划的问题，每个表存储着以当前节点为结尾的最大子数组和，这个思路其实很简单，因为需要是连续的，所以只有两种选择，要么时自身开始，要么和前面合并；那就做一个max就性了，这样的画实际上只需要3个值来做中间变量就可以了。\n这可能就是压缩的思路，后需要好好看看怎么压缩的，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = nums[0]; int pre = nums[0]; int cur = nums[0]; for (int i = 1; i \u0026lt; nums.size(); i++) { // 当之前的综合\u0026gt;0 无脑加上 if (pre \u0026gt; 0) cur = pre + nums[i]; else cur = nums[i]; // 修改到上个数字为止的总和 pre = cur; // 验证一下最大值 res = max(res, cur); } return res; } }; 最长公共子序列（1143） 这题实际上和编辑距离的思考逻辑有点像，从上面的框架出发，我们很容易考虑到，实际上就是存放到，ij的最最长公共子序列。\n那么我在思考的时候出现了一定的盲区（实际上画图很容易考虑到），在这里分析一下：\n因为如果他们不等，他们是没办法共同产生增益的，也就是一个在末尾的话，另一个就不能在末尾了。所以实际上也是两种转移状态中的max情况。那么就可以开始写了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class Solution { public: int longestCommonSubsequence(string text1, string text2) { // 分析一下basecase // bottom-up 等下写一下递归的框架 int m = text1.size(), n = text2.size(); // 我们分析可以知道，我们按照3个方向进行搜索的话，一开始会存在溢出，所以 // 我们不妨牺牲一点点空间来换取每一步都需要判断的 不必要的运算时间 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dpTable (m+1,vector\u0026lt;int\u0026gt;(n+1,0)); // TODO: 存储空间压缩 for (int i = 1;i\u0026lt;=m;i++){ for(int j = 1;j\u0026lt;=n;j++){ if(text1[i-1]==text2[j-1]) dpTable[i][j] = 1+ dpTable[i-1][j-1]; else dpTable[i][j] = max(dpTable[i-1][j], dpTable[i][j-1]); } } return dpTable[m][n]; } }; // 状态压缩后的结果 class Solution { public: int longestCommonSubsequence(string text1, string text2) { if (text1.empty() || text2.empty()) return {}; int m = text1.size(); int n = text2.size(); // 建立dp，basecases vector\u0026lt;int\u0026gt; dp(n + 1, 0); // dp和text的index 对应关系有1的offset记得 for (int i = 1; i \u0026lt;= m; i++) { int pre = 0; // 最关键的状态压缩在这，我们需要找到每一个j开始的时候这个值是什么 for (int j = 1; j \u0026lt;= n; j++) { int temp = dp[j]; // 状态压缩的值，在更新当前值之前的保存，然后在下一次使用的时候就可以了。 if (text1[i - 1] == text2[j - 1]) { dp[j] = pre + 1; } else { dp[j] = max(dp[j], dp[j - 1]); } pre = temp; // 然后再这里给每个状态进行一次更新， } } return dp[n]; } }; // 需要做的还有矩阵压缩没有考虑。写一下递归的框架（时间效益太差了，但是没错） class Solution { public: int longestCommonSubsequence(string text1, string text2) { int m = text1.size(), n = text2.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dpTable (m,vector\u0026lt;int\u0026gt;(n,-1)); return dp(text1,m-1,text2,n-1,dpTable); } int dp(string s1, int i, string s2, int j, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; dpTable ){ if (i == -1 ||j == -1) { return 0; } if(dpTable[i][j] != -1) return dpTable[i][j]; if(s1[i] == s2[j]) dpTable[i][j] = dp(s1,i-1,s2,j-1,dpTable) +1; else dpTable[i][j] = max(dp(s1,i,s2,j-1,dpTable),dp(s1,i-1,s2,j,dpTable)); return dpTable[i][j]; } }; 实际上 **两个字符串的删除操作（583）**也是公共子序列的问题，稍微修改一下就好了\n1 return -2*dpTable[m][n] + m + n ; 实际上**两个字符串的最小ASCII删除和（712）**也是公共子序列的问题，也是稍微修改一下：\nchar直接赋值给int就是ASCII 把中间存储的是相等的（个数）改成 Ascii和；（毕竟求的是最小的ASCII）,求得最大的重叠ascii码就行了、 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int minimumDeleteSum(string s1, string s2) { int m = s1.length(), n = s2.length(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dpTable (m+1, vector\u0026lt;int\u0026gt;(n+1, 0)); for (int i =1;i\u0026lt;=m;i++) { for (int j = 1; j\u0026lt;=n;j++) { if(s1[i-1] == s2[j-1]) dpTable[i][j] = dpTable[i-1][j-1] + (char)s1[i-1]; else dpTable[i][j] = max(dpTable[i-1][j], dpTable[i][j-1]); } } int sum = 0; for (char\u0026amp; ch: s1) sum += ch; for (char\u0026amp; ch: s2) sum += ch; return -2*dpTable[m][n] + sum ; } }; :star:背包问题 首先阐述一下《0-1背包问题》的题目：\n给你一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？\n类似动态规划问题的实现框架：\n1 2 3 4 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 择优(选择1，选择2...) 题目具体分析：\n我们很容易基于动态规划的思想画出一个简单的转移图（VAL=价值），但是问题在于转移图中的两个索引我们打算如何去定义他。实际上最根本的一个想法就是重量和次序，但是这样就有几种设计的情况了，重量：1. 剩余空间，2，已装入的空间；次序：1. 已装入的文件个数 2. 可选择的物品个数（也就是逐步的遍历所有物品）（第二中实际上我不太想得到，和我的思路不太一样，但是我们需要学习这种思考的的方式。）\n那么如何选择呢？\n首先重量的话，我觉得应该是都可以实现的，最后也不会用剩余重量来进行索引，那我们如果这样的话，我们如果用已经装入文件的个数来进行索引的话，我们没办法去选择出一个最后的状态，但是如果我们使用可选的物品个数，对其选择装入与否的话，就是一个最终的状态了。\n其实换句话来理解的话：\n重量是State，价值是Vale，而每一步是一个0-1选择的问题：很显然这样做的话，我们每步的传递判断，状态转移判断，都会有一个比较底的遍历选择范围，同时最终也有一个清晰的结尾。而且，最关键的是：已装入的个数，实际上很难作为一个指导的状态，因为我们不知道后面的选择范围到底会变成什么样子的。\n1 2 3 4 5 6 7 8 9 10 11 12 最终的框架就会是： int dp[N+1][W+1] dp[0][..] = 0 dp[..][0] = 0 for i in [1..N]: for w in [1..W]: dp[i][w] = max( 把物品 i 装进背包, 不把物品 i 装进背包 ) return dp[N][W] 而如果实现的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int knapsack(int W, int N, vector\u0026lt;int\u0026gt;\u0026amp; wt, vector\u0026lt;int\u0026gt;\u0026amp; val) { // vector 全填入 0，base case 已初始化 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(N + 1, vector\u0026lt;int\u0026gt;(W + 1, 0)); for (int i = 1; i \u0026lt;= N; i++) { for (int w = 1; w \u0026lt;= W; w++) { if (w - wt[i-1] \u0026lt; 0) { // 当前背包容量装不下，只能选择不装入背包 dp[i][w] = dp[i - 1][w]; } else { // 装入或者不装入背包，择优 dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], dp[i - 1][w]); } } } return dp[N][W]; } 分割等和子集（416） 通过求和将问题转化为背包问题，基本思想完全不变，j为当前的总状态，i为考虑的第i-1g个物品，然后也是求最大的值和，这样的话，最后判断值和是否能传递到最后（是否相等即可）\n但是我们还是需要灵活一点，这题实际上可以转化为bool类型去做，实际上状态的传递，用与或非即可实现，bool的转移 同时这里涉及到2维度模型的压缩，基于上面的思路，我们可以通过循环的参数去优化，（最好还是从概念上理解这个优化，这样写起来才能一步到位。） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: // 首先进行求和，然后将sum/2作为背包的容量，那么实际上就是一个背包问题 // 只要对最终的情况进行判断是否为相等就行。 // FIXME：但是这一题的最终重要的问题在于模型压缩，我们如何实现状态转移中的压缩。 bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 求和 int sum = 0; for (int\u0026amp; num: nums) sum += num; // 背包问题求解 if(sum%2 != 0) return false; sum = sum/2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; bapack (nums.size()+1,vector\u0026lt;int\u0026gt;(sum+1,0)); // i 对第i个物体进行判断 j 当前已装入的重量总数；好好分析 for (int i = 1;i\u0026lt;= nums.size();i++){ for(int j = 1;j\u0026lt;=sum;j++){ if (j\u0026lt;nums[i-1]) bapack[i][j]= bapack[i-1][j]; else{ // 这个else 不能省略 bapack[i][j] = max(bapack[i-1][j], bapack[i-1][j-nums[i-1]]+nums[i-1]); } } } return bapack[nums.size()][sum] == sum; } }; 基于bool方式的改进\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 求和 int sum = 0; for (int\u0026amp; num: nums) sum += num; // 背包问题求解 if(sum%2 != 0) return false; sum = sum/2; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; bapack (nums.size()+1,vector\u0026lt;bool\u0026gt;(sum+1,false)); for(int i =0;i\u0026lt;bapack.size();i++) bapack[i][0] = true; // i 对第i个物体进行判断 j 当前已装入的重量总数；好好分析 for (int i = 1;i\u0026lt;= nums.size();i++){ for(int j = 1;j\u0026lt;=sum;j++){ if (j\u0026lt;nums[i-1]) bapack[i][j] = bapack[i-1][j]; else{ // 这个else 不能省略 // 只要其中有一个是true就是true，很直接的说法 bapack[i][j] = bapack[i-1][j] || bapack[i-1][j-nums[i-1]]; } } } return bapack[nums.size()][sum]; } 将算法压缩到一维的情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: // 首先进行求和，然后将sum/2作为背包的容量，那么实际上就是一个背包问题 // 只要对最终的情况进行判断是否为相等就行。 // FIXME：但是这一题的最终重要的问题在于模型压缩，我们如何实现状态转移中的压缩。 // 还有运算时间的优化，这题可以换成bool来做。思考一下。 // 用bool的方式去做实际上就是一个状态的集成，所有的j=0都是true。,然后逐步进行状态的转移和传递即可 bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 求和 int sum = 0; for (int\u0026amp; num: nums) sum += num; // 背包问题求解 if(sum%2 != 0) return false; sum = sum/2; vector\u0026lt;bool\u0026gt; bapack (sum+1,false); bapack[0] = true; // i 对第i个物体进行判断 j 当前已装入的重量总数；好好分析 for (int i = 1;i\u0026lt;= nums.size();i++){ for(int j = sum;j\u0026gt;=0;j--){ // 很明显需要保存的就是上一轮的结果 i-1的情况，别的没啥好说的了 if (j\u0026lt;nums[i-1]); else{ // 这个else 不能省略 // 只要其中有一个是true就是true，很直接的说法 bapack[j] = bapack[j] || bapack[j-nums[i-1]]; // TODO:需要注意这里不要覆盖了更新，所以，要反着来 } } } return bapack[sum]; } }; :star:完全背包问题 基于零钱兑换问题解决一下所完全背包的问题，找一下有没有别的完全背包问题需要做。基本的思路看零钱兑换问题上的实现。\n零钱兑换Ⅱ（518） 这一题的主要思路在于状态转移的情况，我们怎么样排除重复，同时针对这种对于排列不重要只看重组合的情况下（每个items有无数种的完全背包问题，我们应该如何去做）\n实际上基本的思路应该是对所有的items作为一个维度来考量，这个items用没用到作为一个维度来把握，这样的话，然后用一个状态转移值取代替这样的解答。\n注意该算法在压缩时候的特殊性 i的区别(未压缩的已经注释掉了 ) 时间复杂度为啥高也没搞清楚，看看更快的方法把，但实际上这个顶多也就N*amount感觉不高了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: // 完全背包问题，看看官方的解说，对于单题来说解决的挺好的，但是我们要分析这样分析的原因 // 这题是真的狗，到底怎么去构建这个动态增长的最优过程，也就是状态和状态转移，是最难的地方 // 最难的思考点在于到底是怎么排除掉重复计算可能性的情况？ // FIXME：主要在于第二个分支，他一定用到了新增进来的这个值，所以和上面的情况不可能出现重复 // 而基于假设就是所有的情况这种情况，就能将所有的列举额出来，给老子细细品味这个 int change(int amount, vector\u0026lt;int\u0026gt;\u0026amp; coins) { if(!amount) return 1; int n = coins.size(); // 初始化 // vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; DP (n+1, vector\u0026lt;int\u0026gt;(amount+1,0)); // for (int i = 0;i\u0026lt;=n;i++) DP[0][i] = 0; // for (int i = 0;i\u0026lt;=n;i++) DP[i][0] = 1; vector\u0026lt;int\u0026gt; DP (amount+1,0); DP[0] =1; // 进行迭代操作（后续进行压缩简化） for (int i = 1; i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=amount;j++){ // if(j\u0026lt;coins[i-1]) DP[i][j] = DP[i-1][j]; if(j\u0026gt;=coins[i-1]) DP[j] = DP[j] + DP[j-coins[i-1]]; //if(j\u0026lt;coins[i-1]) DP[j] = DP[j]; //else // DP[j] = DP[j] + DP[j-coins[i-1]]; // 核心点所在，但是这种情况为什么会遍历到所有的情况要自己搞明白。 // 实际上还是递归的n-1的假设，假设n-1的情况能够被完全的数出来。 } } return DP[amount]; } }; :star:高楼扔鸡蛋问题 这一题就连看懂题目都很折磨了，他要的是我们求出最优方案最少需要几步能解决这样的问题，他没有一个实际的解，要求的是这样一种，最坏情况下的最优。\n后续可以参考FA-\u0026gt;官方题解，学习进阶的思想和思路， 基本假设：Value：K（State）和楼层N（state）得到的最少次数\n怎么定义这种情况下的状态转移方程\n这个理解起来比较容易，但是我们要知道，实现的时候，由于表是不断递归减小的，也就是上线N，所以实际上是一个三重循环，我卡牛角尖卡在这里。\n怎么定义最坏情况。\n由于没给出实际的结果，所以我们并不知道到底鸡蛋在哪一层碎掉，所以这个鸡蛋碎不碎的状态转移条件就通过MAX函数来模拟这个最差的情况。\n然后用最内层MIN循环得到最好的解。 切分块\n但是时间复杂度肉眼可见的高，所以我们最好分析一下，最坏情况下的最好是什么情况，我们可以知道二分法能解决这样的问题。\n知道是三重循环的话，就能写出Bottom-Up的写法了。\n基本状态转移方程思路\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int superEggDrop(int K, int N) { if(!K || !N) return 0; if(K==1) return N; if(N==1) return 1; int minstep = N+1; // 这个思想我是理解了，如果不使用dp tabble的思路的话，还是很清晰的，但是时间复杂度无法减小。 // 主要就是，他的那个外层在不断的变小，也就是那个表的上界N在不断的迭代，如果我们bottom-up的话， for (int i =0;i\u0026lt;=N;i++) minstep = min(minstep,max(superEggDrop(K-1,N-1), superEggDrop(K,N-i))+1); // mindrop[K][N] = minstep; return minstep; } }; 使用DP-TABLE和BOTTOM-UP的方法进行求解\n实现三重循环进行迭代。但是还是存在runtime error的问题，超出了时间的限制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { private: // bool isdefined = false; // vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mindrop; public: int superEggDrop(int K, int N) { if(!N) return 1; if(K==1) return N; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; DP (K, vector\u0026lt;int\u0026gt; (N+1,N+1)); // 要记住鸡蛋的个数要和序号有-1的关系 // 状态初始化，如果只有一个鸡蛋的话，就需要从头到尾遍历 for(int i =0;i\u0026lt;N+1;i++) DP[0][i] = i; // 刚刚这里写错了 for(int i =0;i\u0026lt;K;i++) DP[i][0] = 0; for(int i =0;i\u0026lt;K;i++) DP[i][1] = 1; // 进入状态转移的循环阶段，Bottom-UP for(int i =1;i\u0026lt;K;i++) { for(int j=1;j\u0026lt;N+1;j++) { // runtime limit， so we must optimal it . for(int iner=1; iner\u0026lt;=j;iner++) { // 最内层循环进行最优先的迭代，也就是模拟上限变化的过程 // max是计算出最差情况下的状态转移方程 min是指最优选择 DP[i][j] = min(DP[i][j], 1+max(DP[i-1][iner-1],DP[i][j-iner])); } } } return DP[K-1][N]; } }; 基于二分假设进行进一步的优化\n我们很容易知道随着楼层的递增，需要的步数一定是增加的，这点毫无疑问，根据这样的特性，我们怎么找出最坏情况下的最好呢？实际上可以转化成上述代码中的\n内层循环中MAX的最小值\n可以发现其中的索引是反向的关系，那么就能给出如下图所示的搜索策略结论\n这样就可以简单的基于二分法来求解这样的优化过程，需要注意的是：\n递增递减，但是不是线性的递增递减，所以不能直接找中间序号要用二分查找傻逼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { private: // bool isdefined = false; // vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mindrop; public: int superEggDrop(int K, int N) { if(!N) return 1; if(K==1) return N; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; DP (K, vector\u0026lt;int\u0026gt; (N+1,N+1)); // 要记住鸡蛋的个数要和序号有-1的关系 // 状态初始化，如果只有一个鸡蛋的话，就需要从头到尾遍历 for(int i =0;i\u0026lt;N+1;i++) DP[0][i] = i; // 刚刚这里写错了 for(int i =0;i\u0026lt;K;i++) DP[i][0] = 0; for(int i =0;i\u0026lt;K;i++) DP[i][1] = 1; // 进入状态转移的循环阶段，Bottom-UP for(int i =1;i\u0026lt;K;i++) { for(int j=1;j\u0026lt;N+1;j++) { // 进行二分法优化。 // // runtime limit， so we must optimal it . // for(int iner=1; iner\u0026lt;=j;iner++) // { // // 最内层循环进行最优先的迭代，也就是模拟上限变化的过程 // // max是计算出最差情况下的状态转移方程 min是指最优选择 // DP[i][j] = min(DP[i][j], 1+max(DP[i-1][iner-1],DP[i][j-iner])); // } int l=1, r=j; int iner; while(l\u0026lt;=r) { iner = (l+r)\u0026gt;\u0026gt;1; if (DP[i-1][iner-1]\u0026lt;= DP[i][j-iner]) { l = iner+1; }else{ r = iner-1; } } iner = r; DP[i][j] = min(DP[i][j], 1+max(DP[i-1][iner-1],DP[i][j-iner])); } } return DP[K-1][N]; } }; 戳气球问题（312） 也是个动态规划的问题，遍历所有情况选取最优，但是我觉得其实还能有别的解法，也就是从小到大选数，但是边界值还是要特殊处理，后续看看这种想法能不能写吧。动态规划的方法在我的GoodNote中写了，时间效率一般，看看别人的解答\n首先给出动态规划情况下的思路和解答\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int maxCoins(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.empty()) return 0; // 首尾不包含 nums.insert(nums.begin(),1); nums.push_back(1); int n = nums.size(); // 加了两个之后的size vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; DP(n,vector\u0026lt;int\u0026gt;(n,0)); // 从下往上遍历，从左往右遍历 for(int i = n-2; i\u0026gt;=0;i--) { for(int j =i+1; j\u0026lt;n; j++) { for(int k =i+1;k\u0026lt;j;k++) { DP[i][j] = max(DP[i][j], nums[k]*nums[i]*nums[j]+DP[i][k]+DP[k][j]); } } } return DP[0][n-1]; } }; 博奕问题 **博弈类问题的套路都差不多，下文举例讲解，其核心思路是在二维 dp 的基础上使用元组分别存储两个人的博弈结果。**下面引入一个例题\nPAIR\n将石头问题改的根据被一般性：\n石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 piles = [1,100,3]，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。\n假设两人都很聪明，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。\n实际上还是和上面的一样，没什么区别，就是，要用元组**（Pair）in CPP**，然后选取单步最优吧，后面的最优交给后面的去搜索得到。动态规划吗唔。实际上就还是遍历所有的解法。所以我们不用考虑搜索的策略。\n四键键盘问题 第二种思路很有参考意义，第一种方法比较常规但是实际上反而没那么容易想到，效果也比较拉跨，不推荐学习。 :star:股票问题 根据FA中的讲解，这一部分我们对股票问题的分析分为两步，第一步是实现基本的动态规划解题框架；第二步是学习一下针对这类问题进阶的状态机解法的问题；\n首先LeetCode中的第一题股票问题就很简单，没什么好多说的，实际上分析问题是一个单次遍历求解最优值的过程；（问题分析能大大的减少复杂度）；\n然后我们可以从第二题引出我们的动态规划解法的框架：\n第二题实际上也给出了我们对于动态规划应用情景的更好理解: 也就是那种分段式的结构，只是把i,j从i到j修改成了买入和卖出而已。这就是股票问题的一个框架把。\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n框架的具体实现（伪代码）：\n1 2 3 4 5 6 def maxProfit(prices): res = 0; for buy in range(len(prices)): for sell in range(buy+1, len(prices)): res = max(res, maxprofit(prices[sell+1:])+prices[sell]-prices[buy]) return res 第二题算法问题具体实现（第一题在代码中）\n这题使用这样递归的动态规划方法的话，确实是很简单，但是如果想要Bottom-Up去写好像还是比较麻烦的，也可能是这个定义不够好。\n初始的动态规划的思路，一维数组，存储的是从今天开始的买入卖出的最优解，但是这样的话，状态转移方程实际上是不好列的;（我们无法确定状态转移房方程）（可能还要多加一层循环把。）\n同样如果我们设置为是从今天开始买入的最优解，这样我写的状态转移方程会导致一个问题，就是后续的sell和buy绑定了，就会没有遍历到所有情况。（:x:）（可能还要多加一层循环才能实现）\n:star:官方的具体解法(考虑到现在手上是否持有股票)这应该就是C++情况下最合理的动态框架了\n考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。然后根据有没有股票来进行四种状态转移。\n定义状态 表示第 ii 天交易完后手里没有股票的最大利润， 表示第 ii 天交易完后手里持有一支股票的最大利润（ii 从 00 开始）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); int dp[n][2]; dp[0][0] = 0, dp[0][1] = -prices[0]; for (int i = 1; i \u0026lt; n; ++i) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } }; 可以将其中的空间复杂度优化为如下形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); int dp0 = 0, dp1 = -prices[0]; for (int i = 1; i \u0026lt; n; ++i) { int newDp0 = max(dp0, dp1 + prices[i]); int newDp1 = max(dp1, dp0 - prices[i]); dp0 = newDp0; dp1 = newDp1; } return dp0; } }; 还有一种解法就是下面的贪心算法，只要是正数我们就加的办法，下一个比上一个大，我们就卖，很简单。\n1 2 3 4 5 6 int res = 0; for(int i =0; i\u0026lt;prices.size()-1; i++) { if(prices[i+1]\u0026gt;prices[i]) res += (prices[i+1]- prices[i]); } return res; 问题的变体： 第三题，和第四题，都是限定了交易次数：如果使用的是递归的框架的话，就直接添加一个次数约束就可以了。上面的动态规划解法的话，给Dp添加一个次数的约束，然后在进行传递就可以了，后面自己修改一下写上来。\n第五题，资金要冻结一天，也就是要加一天才开始交易，稍微改一下就行了；\n第六题，每次卖出需要手续费，我们只需要在+price的时候把手续费扣除就可以了。\n:small_red_triangle: 状态机解法： 状态机解法实际上就是基于官方解法的一种写法，也就是通过这个题目中的状态的转移来列DP方程把。然后基于这种分析方式的话，对于这道题来说，是一个通用的列方程的思路把。\n实际上总结一下这些状态转移就是\n1 2 3 4 5 6 base case: dp[-1][k][0] = dp[i][0][0] = 0; dp[-1][k][1] = dp[i][0][1] = -INT_MAX; Transfer: dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]); dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); 按照这个框架去进行遍历就完事了，6题都可以按照这个框架去写，真的就是通用解，但是时间效率好像也不是特别高，但是需要注意的是，当k是无穷我们就不用特别的去约束，但是当k是有限值的时候，我们就记得要对k进行遍历，内层循环。\n还有更为关键的点是（唯一的Hard，买卖的最佳时期的第三题）也就是只有两种k的时候，我们实际上可以重新分析这个状态转移，也就是，重新构筑这个状态表，改变一下原本的迭代形式。 另一点就是，我实在是不想用new，怎么用vector来建立这样一个3元组呢？到时候看看有没有示例代码；（pair？tuple？or something else？）官方直接用两个向量来表示了 由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种： 1.未进行过任何操作； 2.只进行过一次买操作； 3.进行了一次买操作和一次卖操作，即完成了一笔交易； 4.在完成了一笔交易的前提下，进行了第二次买操作； 5.完成了全部两笔交易。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if(prices.empty()) return 0; int n = prices.size(); int s1 = -prices[0]; int s2 = 0; //我可以不买，所以一定是0不是int——min int s3 = INT_MIN; int s4 = 0; for(int i =1;i\u0026lt;n;i++){ s1 = max(s1, -prices[i]); //第一次买入可以任何时候 s2 = max(s2, s1+prices[i]); // 在此刻第一次卖出 s3 = max(s3, s2-prices[i]); // 第二次 买入 s4 = max(s4, s3+prices[i]); } return s4; } }; 限制了K次的情况,这里实现的时候有很多的细节，但是我觉得基于k的哪个东西有点不合理，所以我们试着用FA中的思路后面重写一下这个框架，其实要改的地方也不是特别多，稍微改几个象征值就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int maxProfit(int k, vector\u0026lt;int\u0026gt;\u0026amp; prices) { if(prices.empty()) return 0; int n = prices.size(); // BUY 表示已经持有股票的情况 // SELL 表示手上啥都没有的情况 k = min(k,n/2); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; DPBuy(n,vector\u0026lt;int\u0026gt;(k+1)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; DPSell(n,vector\u0026lt;int\u0026gt;(k+1,0)); // basecase; DPBuy[0][0] = -prices[0]; for(int i = 1;i\u0026lt;=k;i++){ DPBuy[0][i] = DPSell[0][i] = INT_MIN/2; // 由于我们还要减去一些值，所以这里小但是也不要小的太过分 } // ++ i 和i++ 在for循环里面是一样的，但是性能上在大量使用的时候++更好一些。 for(int i = 1;i\u0026lt;n;i++) { // 为什么这个时候要用作-price[I] DPBuy[i][0] = max(DPBuy[i-1][0],-prices[i]); for(int j = 1;j\u0026lt;=k;j++) { // 只在购买添加操作数，不在卖出添加炒作书 DPBuy[i][j] = max(DPBuy[i-1][j], DPSell[i-1][j]-prices[i]); DPSell[i][j] = max(DPSell[i-1][j],DPBuy[i-1][j-1]+prices[i]); } } return *max_element(DPSell[n-1].begin(),DPSell[n-1].end()); } }; 加税的方法的话，就是要记得如果是在buy的时候扣税，记得在初始化的那次也要扣。在购买的时候扣就不用了。\n打家劫舍问题 实际上是动态规划的问题，以及一些约束情况下的变体，我们要掌握到其中的精髓，进行分析；\n首先对动态规划的问题进行分析的时候我们都要好好的想一下到底是要用一维的表还是用二维的表；（不要使用冗余的操作） 然后还是一样的进行存储空间的压缩就行； 打家劫舍1（198）\n这一题的分析很容易可以知道是这样的情况：（我们可以反向分析，这样的话，就不需要修改Loop的方向了）\n具体的代码实现和相应的空间优化后的结果如下：（100 98）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.empty()) return 0; // 两个相邻的房屋无法取到实际上就是一个简单的状态转移的问题； int n = nums.size(); // vector\u0026lt;int\u0026gt; DP(n+1,0); // 实际上就是一个单项的偷盗图 // BaseCases // DP[0] = 0; // DP[1] =nums[0]; // for(int i=2;i\u0026lt;=n;i++){ // DP[i] = max(nums[i-1]+ DP[i-2], DP[i-1]); // } // return DP[n]; // 基于参数的特性进行存储空间优化 int d0 = 0; int d1 = nums[0]; for(int i =1;i\u0026lt;n;i++){ int temp = d1; d1 = max(d0 + nums[i], d1); d0 = temp; } return d1; } 打家劫舍Ⅱ 第二题和第一题的区别就在于，这个房子是围成一圈的，所以就是，首尾相连的序列，（这应该会使得边界条件更加的复杂，或者引入新的约束）\n问题分析：这题仔细分析以后实际上可以发现就是要么是不包含头，要么是不包含尾（为0），两个取最大值就好了。稍微修改\n打家劫舍Ⅲ 这一题的特点在于房屋的分布是二叉树，最基本的思想还是这样就是，不买就跳下一级，买就跳两级，DP存储就行；\n但是这一题还有一个更加精妙的解法，就是像股票那样，存储该节点购买和不购买的两种情况，通过这种情况进行转移函数就行，这题的话参考官方解法的写法更清楚，而且还有后续优化的结果。\n常规解法（my）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { private: unordered_map\u0026lt;TreeNode*, int\u0026gt; DP; public: int rob(TreeNode* root) { if(!root) return 0; if(DP.find(root)!= DP.end()) return DP[root]; // if(DP.contains(root)) return DP[root]; int robres = rob(root-\u0026gt;left)+ rob(root-\u0026gt;right); int unrobres = root-\u0026gt;val; unrobres += !root-\u0026gt;left? 0: (rob(root-\u0026gt;left-\u0026gt;left) +rob(root-\u0026gt;left-\u0026gt;right)); unrobres += !root-\u0026gt;right? 0: (rob(root-\u0026gt;right-\u0026gt;left) + rob(root-\u0026gt;right-\u0026gt;right)); int res = max(robres, unrobres); DP[root] = res; return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 1. 结合了后续遍历框架：因为我们要知道后续的值才能对前序的值进行处理，所以我们需要先遍历后面的 我们可以用 f(o) 表示选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；g(o) 表示不选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；l 和 r 代表 o 的左右孩子。 class Solution { public: unordered_map \u0026lt;TreeNode*, int\u0026gt; f, g; void dfs(TreeNode* node) { if (!node) { return; } dfs(node-\u0026gt;left); dfs(node-\u0026gt;right); f[node] = node-\u0026gt;val + g[node-\u0026gt;left] + g[node-\u0026gt;right]; g[node] = max(f[node-\u0026gt;left], g[node-\u0026gt;left]) + max(f[node-\u0026gt;right], g[node-\u0026gt;right]); } int rob(TreeNode* root) { dfs(root); return max(f[root], g[root]); } }; 这题的优化写法十分的值得参考，我们如何利用我们自己创造的数据结构,实际上和股票的是一样的也就是传输之前的买和没买的问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct SubtreeStatus { int selected; int notSelected; }; class Solution { public: SubtreeStatus dfs(TreeNode* node) { if (!node) { return {0, 0}; } auto l = dfs(node-\u0026gt;left); auto r = dfs(node-\u0026gt;right); int selected = node-\u0026gt;val + l.notSelected + r.notSelected; int notSelected = max(l.selected, l.notSelected) + max(r.selected, r.notSelected); return {selected, notSelected}; } int rob(TreeNode* root) { auto rootStatus = dfs(root); return max(rootStatus.selected, rootStatus.notSelected); } }; 回文问题终结版：最小代价构造回文串（1312） 是一个非常典型的动态规划的问题，这种子串的问题通常就是基于二维的DP Table去做，那么实现上就是，存储的就是从i,j的字符，构造成回文串的最少次数。\n但是这一题有个陷阱，通常来说，我们分析回文串的问题都是从中间向两端拓展的，但是如果我们每次拓展都直接判断两端的拓展是否相等的话，（+2）这样对于数组完全相等，只需要加1的情况就缺乏了考虑。\n解决的方式 我们只需要一边一边的加就可以了 状态转移方程 = max 左或右 +1；\n基本的解决方法(可以在算法的基础上进行空间压缩，只需要一个向量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int minInsertions(string s) { if(s.empty()) return 0; int n = s.size(); // 建立存储表和初始化参数（单个或者是边界都是0） vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; DP(n,vector\u0026lt;int\u0026gt;(n,0)); // 遍历方向，从从下到上，从左到右 for(int i=n-2; i\u0026gt;=0; i--){ for(int j=i+1; j\u0026lt;n; j++){ // 搜先判断延拓的情况是是否是相等的 if(s[i] == s[j]) DP[i][j] = DP[i+1][j-1]; else DP[i][j] = min(DP[i+1][j], DP[i][j-1]) +1; } } return DP[0][n-1]; } }; 数据压缩后的结果，这个压缩方案实际上比较常见，用代码取解读的话也比较好解读\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 if(s.empty()) return 0; int n = s.size(); vector\u0026lt;int\u0026gt; DP(n,0); for(int i=n-2; i\u0026gt;=0; i--){ int pre = 0; for(int j=i+1; j\u0026lt;n; j++){ // 搜先判断延拓的情况是是否是相等的 int temp = DP[j]; // 到下一轮编程i+1 j-1的值 ，在本轮是i+1，j的值（未更新） if(s[i] == s[j]) DP[j] = pre; else DP[j] = min(DP[j], DP[j-1])+1; pre = temp; // 经典压缩策略 } } return DP[n-1]; 贪心算法：动态规划的特例 FA中对贪心算法的简单讲解 贪心算法实际上是动态规划中每一步都取最优结果的特例，实际上满足这种条件的问题并不是太多，但是这种情况下的效率是更高的。但是想博弈问题这种就不能使用贪心算法。\n举个例子，典型的贪心算法：\n本文解决一个很经典的贪心算法问题 Interval Scheduling（区间调度问题）。给你很多形如[start,end]的闭区间，请你设计一个算法，算出这些区间中最多有几个互不相交的区间。\n也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。\n或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。\n正确的思路（怎么去贪）其实很简单，可以分为以下三步：\n从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。 把所有与 x 区间相交的区间从区间集合 intvs 中删除。 重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。 1 2 3 // 代码的具体实现大致如下： sort (array1, [](const int\u0026amp; A, const int\u0026amp; B){return B[1]\u0026gt;A[1];}); //然后遍历通过尾巴来选就行了。 无重叠区间（435） 实际上和上面的分析是一模一样的情况，就是return的计数值不一样而已。 无需多言\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int eraseOverlapIntervals(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { if(intervals.empty()) return 0; sort(intervals.begin(),intervals.end(),\\ [](const auto\u0026amp; A,const auto\u0026amp; B){return A[1]\u0026lt;B[1];}); int eol = intervals[0][1]; int count = 1; for(auto\u0026amp; list : intervals){ if(list[0]\u0026gt;=eol){ eol = list[1]; count++; } } return intervals.size() - count; } }; 用最少数量的箭社保气球（452） 实际上和上一题一摸一样，就是题目描述不一样罢了，同时边界擦伤的条件也不一样，改个下小于等于就行了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int findMinArrowShots(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points) { if(points.empty()) return 0; sort(points.begin(),points.end(),\\ [](const auto\u0026amp; A,const auto\u0026amp; B){return A[1]\u0026lt;B[1];}); int eol = points[0][1]; int count = 1; for(auto\u0026amp; list : points){ if(list[0]\u0026gt;eol){ eol = list[1]; count++; } } return count; } }; JUMP GAME(55) 很简单的动态规划的思路，需要注意的只要那个break不能直接return，考虑[0]的情况。\n1.这题主要需要我们脑子清醒，很明晰那，《最远距离的就是我们的所有可达点（就算有0也会被绕过。）， 2.除非我们可达点无法再前进了（我们能走到的地方《=当前战力的位置），我们才false，不然我们就能一直前进到终点\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool canJump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int farthest = 0; for (int i=0;i\u0026lt;n;i++) { farthest = max(farthest,i+nums[i]); if (farthest\u0026lt;=i) break; } return farthest\u0026gt;=(n-1); } }; 这实际上还是动态规划，实际的贪心算法在后面的进阶版。\nJUMP GAME2（45） 这一题如果用基本的动态规划思想的话，自底向上和自顶向下都比较好些，就是存储，到当前格子需要的最少步数就可以了。\n我的自底向上的思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 后续可以尝试一下自顶向下的写法，这种写法比较傻逼，但是也可以尝试掌握 // 这题不用贪心算法的话，后面有个很恶心的东西不让做 // 下面这是基本的自底向上的方法， vector\u0026lt;int\u0026gt; DP (nums.size(),INT_MAX); DP[0]=0; // DP 存储到到这里需要多少步 for(int i =0; i\u0026lt;nums.size();i++){ int step = nums[i]; for (int j =1;j\u0026lt;= step;j++){ if(i+j\u0026lt;nums.size()) DP[i+j] = min(DP[i+j],DP[i]+1); } } // for(int\u0026amp;data : DP) // cout\u0026lt;\u0026lt;data\u0026lt;\u0026lt;endl; return DP[nums.size()-1]; // 测试一下自顶向下 } }; 自顶向下的思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 从尾到头，走到尾巴需要多少步。深度有限遍历把，实际上是一种递归的解法、传统的递归分析方法，回顾一下递归的思路。 class Solution { public: vector\u0026lt;int\u0026gt; memo; int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); // 备忘录都初始化为 n，相当于 INT_MAX // 因为从 0 调到 n - 1 最多 n - 1 步 memo = vector\u0026lt;int\u0026gt;(n, n); return dp(nums, 0); } int dp(vector\u0026lt;int\u0026gt;\u0026amp; nums, int p) { int n = nums.size(); // base case if (p \u0026gt;= n - 1) { return 0; } // 子问题已经计算过 if (memo[p] != n) { return memo[p]; } int steps = nums[p]; // 你可以选择跳 1 步，2 步... for (int i = 1; i \u0026lt;= steps; i++) { // 穷举每一个选择 // 计算每一个子问题的结果 int subProblem = dp(nums, p + i); // 取其中最小的作为最终结果 memo[p] = min(memo[p], subProblem + 1); } return memo[p]; } }; 上面两种方法虽然都可以事项，但是时间复杂度上出了问题，没办法再有效的时间内解决这个，往往会超出时间闲置。所以实际上是需要贪心算法的。\n怎么实现贪心的思路呢？\n但是，真的需要「递归地」计算出每一个子问题的结果，然后求最值吗？直观地想一想，似乎不需要递归，只需要判断哪一个选择最具有「潜力」即可：\n我们完全可以跳过那些被包含的情况，所以YOU KNOW\n具体实现：（学）\n这里主要是我们怎么去递增那个end可以学一下，其他的没啥，很容易想到这个贪心的思路\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 后续可以尝试一下自顶向下的写法，这种写法比较傻逼，但是也可以尝试掌握 // 这题不用贪心算法的话，后面有个很恶心的东西不让做 // 下面这是基本的自底向上的方法， int n = nums.size(); int end = 0, farthest = 0; int jumps = 0; for (int i = 0; i \u0026lt; n - 1; i++) { //提前更新一次，达到几次这种最远点，就+几次， farthest = max(nums[i] + i, farthest); if (end == i) { jumps++; end = farthest; } } return jumps; } }; KMP算法：动态规划下属 著名的字符串匹配算法 效率很高，但是确实比较复杂 ；\n先在开头约定，本文用pat表示模式串，长度为M，txt表示文本串，长度为N。KMP 算法是在txt中查找子串pat，如果存在，返回这个子串的起始索引，否则返回 -1。\n这个题目时要匹配完全一致的，也就是顺序不能打乱或者跳过的那种子串\n遍历的解法如下所示：（伪代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int search(String pat, String txt) { int M = pat.length; int N = txt.length; for (int i = 0; i \u0026lt;= N - M; i++) { int j; for (j = 0; j \u0026lt; M; j++) { if (pat[j] != txt[i+j]) break; } // pat 全都匹配了 if (j == M) return i; } // txt 中不存在 pat 子串 return -1; } 但是这样就有很多完全不需要考虑的不可能的情况的计算无法跳过了，所以我们希望使用一些存储空间来辅助算法的进行。\nKMP特点永不回退指针i，不走回头路，也就是不会对txt进行重复的多次扫描，会利用DP数组中的信息将pat移到正确的位置来继续匹配。\n那么这个数组如何构建呢？（确定有限状态自动机）\n这个DP只与pat相关，与Txt没有任何关系\n实际上就是构建状态转移图，然后根据状态转移图来跳转：（这里省略了到0）\n这个DP数组的定义方式：\n1 2 3 4 5 6 7 8 9 10 11 12 dp[j][c] = next 0 \u0026lt;= j \u0026lt; M，代表当前的状态 0 \u0026lt;= c \u0026lt; 256，代表遇到的字符（ASCII 码） 0 \u0026lt;= next \u0026lt;= M，代表下一个状态 dp[4][\u0026#39;A\u0026#39;] = 3 表示： 当前是状态 4，如果遇到字符 A， pat 应该转移到状态 3 dp[1][\u0026#39;B\u0026#39;] = 2 表示： 当前是状态 1，如果遇到字符 B， pat 应该转移到状态 2 根据上面的数组可以构建出这样的状态转移过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int search(String txt) { int M = pat.length(); int N = txt.length(); // pat 的初始态为 0 int j = 0; for (int i = 0; i \u0026lt; N; i++) { // 当前是状态 j，遇到字符 txt[i]， // pat 应该转移到哪个状态？ j = dp[j][txt.charAt(i)]; // 如果达到终止态，返回匹配开头的索引 if (j == M) return i - M + 1; } // 没到达终止态，匹配失败 return -1; } 所以整个DP数组的构建状态：\n1 2 3 for 0 \u0026lt;= j \u0026lt; M: # 状态 for 0 \u0026lt;= c \u0026lt; 256: # 字符 dp[j][c] = next; 实际上就是一种匹配和另一种回退的状态变迁，但是这种状态回退该怎么设置，影子状态的思想：\n和当前的状态具有相同的前缀的状态就是影子状态（类似双指针算法用来辅助）那么具体怎么实现呢？前缀的长度？\n就可以改进上面的代码如下：\n1 2 3 4 5 6 7 8 9 10 int X # 影子状态 for 0 \u0026lt;= j \u0026lt; M: for 0 \u0026lt;= c \u0026lt; 256: if c == pat[j]: # 状态推进 dp[j][c] = j + 1; else: # 状态重启 # 委托 X 计算重启位置 dp[j][c] = dp[X][c]; 完整的最终代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class KMP { private int[][] dp; private String pat; public KMP(String pat) { this.pat = pat; int M = pat.length(); // dp[状态][字符] = 下个状态 dp = new int[M][256]; // base case，也就是遇到了第一个字符才能转移到1 dp[0][pat.charAt(0)] = 1; // 影子状态 X 初始为 0 int X = 0; // 当前状态 j 从 1 开始 for (int j = 1; j \u0026lt; M; j++) { for (int c = 0; c \u0026lt; 256; c++) { if (pat.charAt(j) == c) dp[j][c] = j + 1; else dp[j][c] = dp[X][c]; } // 更新影子状态 影子状态的更新，是随着j的更新而更新的 X = dp[X][pat.charAt(j)]; } } public int search(String txt) {...} } 这里解释一下影子的更新具体是如何做到，这里从文章中抄一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 这里的状态如下： int X = 0; for (int j = 1; j \u0026lt; M; j++) { ... // 更新影子状态 // 当前是状态 X，遇到字符 pat[j]， // pat 应该转移到哪个状态？ X = dp[X][pat.charAt(j)]; } 而搜索过程中： int j = 0; for (int i = 0; i \u0026lt; N; i++) { // 当前是状态 j，遇到字符 txt[i]， // pat 应该转移到哪个状态？ j = dp[j][txt.charAt(i)]; ... } 其中的原理非常微妙，注意代码中 for 循环的变量初始值，可以这样理解：后者是在txt中匹配pat，前者是在pat中匹配pat[1:]，状态X总是落后状态j一个状态，与j具有最长的相同前缀。所以我把X比喻为影子状态，似乎也有一点贴切。\n另外，构建 dp 数组是根据 base casedp[0][..]向后推演。这就是我认为 KMP 算法就是一种动态规划算法的原因。\n:star: 下面来看一下状态转移图的完整构造过程，你就能理解状态X作用之精妙了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class KMP { private int[][] dp; private String pat; public KMP(String pat) { this.pat = pat; int M = pat.length(); // dp[状态][字符] = 下个状态 dp = new int[M][256]; // base case dp[0][pat.charAt(0)] = 1; // 影子状态 X 初始为 0 int X = 0; // 构建状态转移图（稍改的更紧凑了） for (int j = 1; j \u0026lt; M; j++) { for (int c = 0; c \u0026lt; 256; c++) dp[j][c] = dp[X][c]; dp[j][pat.charAt(j)] = j + 1; // 更新影子状态,因为一开始落后一步，然后后面是完全一样的更新，所以只有当 // 又到达重复状态的时候，才会需要进行X的更新。 X = dp[X][pat.charAt(j)]; } } public int search(String txt) { int M = pat.length(); int N = txt.length(); // pat 的初始态为 0 int j = 0; for (int i = 0; i \u0026lt; N; i++) { // 计算 pat 的下一个状态 j = dp[j][txt.charAt(i)]; // 到达终止态，返回结果 if (j == M) return i - M + 1; } // 没到达终止态，匹配失败 return -1; } } 回溯算法详解 我们的目标是“没有蛀牙 ”，框架化回溯算法：实际上我好像也做了很多和回溯相关的题目了，和这里的思路对照一下；\n解决一个回溯问题，实际上就是一个决策树的遍历过程。只需要考虑三个问题\n1、路径：也就是已经做出的选择。\n2、选择列表：也就是你当前可以做的选择。\n3、结束条件：也就是到达决策树底层，无法再做选择的条件。\n具体代码框架：其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」 我觉得这里应该就是存储一个中间结果来做把。通过具体的代码来看看\n1 2 3 4 5 6 7 8 9 10 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 全排列问题： 我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。（实际上这种通常和DFS并在一起用，先遍历了某个选择下的所有可能，然后回到之前的这个节点）\n但是vector没有find之类的函数，所以我们可以通过index 和 swap操作区是实现这样的假装删除，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: void backtrack(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; res, vector\u0026lt;int\u0026gt;\u0026amp; output, int first, int len){ // 所有数都填完了 if (first == len) { res.emplace_back(output); return; } for (int i = first; i \u0026lt; len; ++i) { // 动态维护数组 swap(output[i], output[first]); // 继续递归填下一个数 backtrack(res, output, first + 1, len); // 撤销操作 swap(output[i], output[first]); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; res; backtrack(res, nums, 0, (int)nums.size()); return res; } }; N皇后问题： 实际上是一种特殊的全排列问题，我采取的方式是从上到下进行构建，这样的话判断valid以及遍历过程会清晰一些，同时我们每次只需要做一个单行的loop就行了，实际上就是一个典型的回溯问题，其中有一些需要注意的点\n数据类型的使用，边界条件的约束，还有就是，数据变量的生存周期；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Solution { private: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { // 实际上就是全排列啊，不满足再取消就行了。 // 问题在于怎么设置判断和返回条件。 // 棋盘初始化，我们一列一列的开始遍历。 vector\u0026lt;string\u0026gt;board(n, string(n,\u0026#39;.\u0026#39;)); backtrack(board,0); return res; } void backtrack(vector\u0026lt;string\u0026gt;\u0026amp; board, int row){ int n = board.size(); if(row\u0026gt;=n) return; for(int j=0;j\u0026lt;n;j++){ // 假如某行的每一个都不合法，那就说明之前的摆法已经没救了。 if(!isValid(board, row, j)) { // cout\u0026lt;\u0026lt;row\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; continue; } // cout\u0026lt;\u0026lt;row\u0026lt;\u0026lt;\u0026#34;\u0026amp;\u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;=\u0026#34;\u0026lt;\u0026lt;\u0026#34;Q\u0026#34;; board[row][j] = \u0026#39;Q\u0026#39;; if(row == n-1) { res.emplace_back(board); // cout\u0026lt;\u0026lt;endl; // 这里进行复原很容易忘记，这里需要注意一下，同时这个可以编程n，然后放到最前面去，效率可能会更高? board[row][j] = \u0026#39;.\u0026#39;; continue; } backtrack(board, row+1); board[row][j] = \u0026#39;.\u0026#39;; } return; } bool isValid(vector\u0026lt;string\u0026gt;\u0026amp; board, int row, int col){ /* 对三种情况进行判断，上方，左前方和右前方 由于我们是从上往下添加的，所以下方的情况暂时不用考虑 */ int n = board.size(); // situation1 for(int i = row; i\u0026gt;=0; i--){ if(board[i][col] == \u0026#39;Q\u0026#39;) return false; } // situation2 左上角 int offset = 0; for(int i = row; i\u0026gt;=0; i--){ if(col-offset\u0026lt;0) break; if(board[i][col-offset] == \u0026#39;Q\u0026#39;) return false; offset++; } // situation3 右上角 offset = 0; for(int i = row; i\u0026gt;=0; i--){ if(col+offset\u0026gt;=n) break; if(board[i][col+offset] == \u0026#39;Q\u0026#39;) return false; offset++; } return true; } }; 子集问题 通过回溯或者迭代的方式来搜索子集，是一个典型但是实际上难度不是特别大的题目，可以用作基本的思路回顾。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { /* 实际上这题可以使用2.5种不同的思路去解决 1. 递归法：由于重叠子问题的存在和特殊性，（子问题的每一项加上新加入的一项） 2. 回溯法：前序，也就是不断后移动start，然后逐个加入 后续，使用pop出来的值来用（不是特别贴切）还是前一种好*/ // 递归法 // if(nums.empty()) return {{}}; // int n = nums.back(); // nums.pop_back(); // vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res = subsets(nums); // int size = res.size(); // for(int i = 0; i \u0026lt;size; i++) // { // res.emplace_back(res[i]); // res.back().push_back(n); // } // return res; // 回溯法 vector\u0026lt;int\u0026gt; tempv; int start = 0; backtrack(nums,tempv,0); return res; } void backtrack(vector\u0026lt;int\u0026gt;\u0026amp; nums,vector\u0026lt;int\u0026gt;\u0026amp; tempv, int start){ res.push_back(tempv); int n = nums.size(); for(int i=start; i\u0026lt;n; ++i){ tempv.push_back(nums[i]); backtrack(nums,tempv,i+1); tempv.pop_back(); } return ; } }; 组合问题 实际上也就是典型的回溯框架，由于我们的[1,2]和[2,1]算是重复的两种情况，所以我们和上面一样用start来进行约束就可以了。就能避免重复组合的情况发生，还是在上面的框架上稍微改改.\n这题实际上和上面的排列问题是一对，可以对照着看，看看两个方法编写上的不同之处和相同之处，实际上就是同个框架下的不同写法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;vector\u0026gt; using namespace std; class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combine(int n, int k) { if (k\u0026lt;=0 || n\u0026lt;=0) return res; vector\u0026lt;int\u0026gt; tempv; backtrack(n,k,0 ,tempv); return res; } void backtrack(int n, int k, int start,vector\u0026lt;int\u0026gt; tempv){ if(tempv.size() == k) { res.emplace_back(tempv); return; } for(int i =start; i\u0026lt;n;i++){ tempv.push_back(i+1); backtrack(n,k,i+1,tempv); tempv.pop_back(); } } }; 解数独： 整体上，我非常的不同意这个作者写的代码，因为我觉得她的两个循环实际上是多余的，他的状态转移是有问题的。\n由于一开始有是否有值的判断，所以那个for循环勉强还是可以的把，但是我觉得我的写法更好一些，这一题的主要问题在于。\n如何终止搜索过程！，如何在找到一个解后就安然离去！！仔细思考。 还有那个else为什么很重要！！，没有这个else我们可能会讲原值给改了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;vector\u0026gt; using namespace std; class Solution { public: void solveSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { backtrack(board,0,0); } bool backtrack(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, int r, int c){ // 这里的这个逻辑我有点没搞清楚，为什么要全进行m-n的遍历，我觉得是多余的 // 首先继续宁测试，如果不对再说 if(r==9) return true; // 判断下一个位置： int nextr = r, nextc =c; nextc++; if(nextc\u0026gt;=9) { nextr++; nextc=0;} // 判断返回值 if(board[r][c]!=\u0026#39;.\u0026#39;) { // if(backtrack(board,nextr,nextc)) return true; else return false; } for(char ch = \u0026#39;1\u0026#39;; ch\u0026lt;=\u0026#39;9\u0026#39;; ch++){ if(!isValid(board, r, c, ch)) continue; board[r][c] = ch; if(backtrack(board,nextr,nextc)) return true; // 问题应该是出在，找到了解以后没有返回的问题 board[r][c] = \u0026#39;.\u0026#39;; } return false; } bool isValid(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, int r, int c, char ch){ // 从上到下填，但是我们还是需要搜索整张棋盘， for (int i = 0; i\u0026lt;9; i++) { if(board[r][i] == ch) return false; if(board[i][c] == ch) return false; if(board[(r/3)*3+i/3][(c/3)*3 +i%3]==ch) return false; } return true; } }; 合法括号生成：（22）回溯算法最佳实践 实际上的关键还是在于问题分析的部分：\n1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个显而易见。\n2、对于一个「合法」的括号字符串组合p，必然对于任何0 \u0026lt;= i \u0026lt; len(p)都有：子串p[0..i]中左括号的数量都大于或等于右括号的数量。\n然后就可以使用 回溯的基本框架来完成代码了。\n结束的技巧和之前稍微有点不同可以学一下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: vector\u0026lt;string\u0026gt; generateParenthesis(int n) { if (n == 0) return {}; // 记录所有合法的括号组合 vector\u0026lt;string\u0026gt; res; // 回溯过程中的路径 string track; // 可用的左括号和右括号数量初始化为 n backtrack(n, n, track, res); return res; } // 可用的左括号数量为 left 个，可用的右括号数量为 rgiht 个 void backtrack(int left, int right, string\u0026amp; track, vector\u0026lt;string\u0026gt;\u0026amp; res) { // 若左括号剩下的多，说明不合法 if (right \u0026lt; left) return; // 数量小于 0 肯定是不合法的 if (left \u0026lt; 0 || right \u0026lt; 0) return; // 当所有括号都恰好用完时，得到一个合法的括号组合 if (left == 0 \u0026amp;\u0026amp; right == 0) { res.push_back(track); return; } // 尝试放一个左括号 track.push_back(\u0026#39;(\u0026#39;); // 选择 backtrack(left - 1, right, track, res); track.pop_back(); // 撤消选择 // 尝试放一个右括号 track.push_back(\u0026#39;)\u0026#39;); // 选择 backtrack(left, right - 1, track, res); track.pop_back(); // 撤消选择 } }; BFS算法详解 BFS和DFS框架，实际上DFS在回溯算法中写了很多了，这实际上就是一回事，NOW我们来学习一下BFS。\nBFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。\n**BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多。\n问题的本质（广义描述）是：\n在一幅「图」中找到从起点start到终点target的最近距离，这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事儿。\n比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？\n再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？\n再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？\n实现框架伪代码\n这个框架后面我们后面需要修正一下，便于贴切现在的版本，用我们自己的形式重新总结一下体系架构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 计算从起点 start 到终点 target 的最近距离 int BFS(Node start, Node target) { Queue\u0026lt;Node\u0026gt; q; // 核心数据结构 Set\u0026lt;Node\u0026gt; visited; // 避免走回头路 q.offer(start); // 将起点加入队列 visited.add(start); int step = 0; // 记录扩散的步数 while (q not empty) { int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ for (int i = 0; i \u0026lt; sz; i++) { Node cur = q.poll(); // 访问队列中的当前节点 /* 划重点：这里判断是否到达终点 */ if (cur is target) return step; /* 将 cur 的相邻节点加入队列 */ for (Node x : cur.adj()) if (x not in visited) { q.offer(x); visited.add(x); } } /* 划重点：更新步数在这里 */ step++; } } 其中adj：相邻节点；visited：不会走回头路，比如说二叉树之类的，就不需要这种结构。\n二叉树的最小高度（111） 首先这题实际上使用二叉树的普通遍历框架就已经能解决了，我们先给出一个常规解法的答案在这,然后我们便开始正经探讨到底要怎么解决这个问题，使用BFS的框架，我们现在使用的实际上仍然是DFS。\n用这题来对DFS和BFS两种框架的解题思路进行比对和分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { private: int res = INT_MAX; public: int minDepth(TreeNode* root) { if(!root) return 0; helpFind(root,0); return res; } void helpFind(TreeNode* root, int step){ // 是没有子节点的节点，也就是左右节点都没有要注意区分 if(!root){return;} step++; if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right) { if(step\u0026lt;res) res = step; return; } helpFind(root-\u0026gt;right,step); helpFind(root-\u0026gt;left,step); } }; BFS解题框架\n深度优先搜索，就是我之前希望的搜索思路，这样能够更快的结束这样的搜索过程，就能取得更高的时间和空间效率，在这里我们也对原本的解题框架，进行了一个修正。\n利用patr 来取代depth的设置。 原本框架中的循环好像是么必要的把。（必要的情况分析：如果需要一层一层的做的话，也就是深度+1在层次之外？）oh 不，就是利用pair就能解决这个问题，不需要这样一个循环了，也就是我们要明确深度+1的过程在哪里执行，当然他那样好像会更节省空间吧， 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { private: // int res = INT_MAX; public: int minDepth(TreeNode* root) { if(!root) return 0; queue\u0026lt;pair\u0026lt;TreeNode *, int\u0026gt;\u0026gt; q; // 初始化队列起点 q.emplace(root,1); while(!q.empty()){ // int sz = q.size(); // for(int i=0;i\u0026lt;sz;i++){ TreeNode *temp = q.front().first; int depth = q.front().second; if(!temp-\u0026gt;right \u0026amp;\u0026amp; !temp-\u0026gt;left) return depth; if(temp-\u0026gt;left != nullptr) q.emplace(temp-\u0026gt;left, depth+1); if(temp-\u0026gt;right != nullptr) q.emplace(temp-\u0026gt;right,depth+1); q.pop(); // } } return 0; } }; 打开转盘锁（752） 这一题我觉得是可以使用回溯算法来做，但是好像标准的解法就是使用BFS的方法去做，这样做的话，我按照原本的框架写出了如下的代码，但是这样的代码的时间复杂度超过了题目要求的水准，所以是算法的优化还能提升还是说是其他写法的BFS问题呢？\n可以优化：通过Unorder_set 来优化搜索的过程。具体的改进已经写进代码里了。\n实际上就是看成一张图，然后同个时刻能做出的选择有8个，4个转盘分别从两边转，然后我们就看成是图传播，在解决一下重复和deadends就行了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Solution { public: int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) { // 使用回溯法遍历所有的可能性,同时做出特殊的终结判断 // 同时维护一个最小值,然后最终返回. // 正确理解题目的意思(每次只能转动单个转盘,而且只能移动一格) // 为什么使用BFS,最短路径,找到了就提前终止,同时是路径问题 if (target.empty()) return -1; // 非法情况约束 //初始化搜索队列 // FIXME: 不走回头路这点怎么实现。hash_set? queue\u0026lt;pair\u0026lt;string, int\u0026gt;\u0026gt; que; unordered_set\u0026lt;string\u0026gt; visited; unordered_set\u0026lt;string\u0026gt; dead(deadends.begin(),deadends.end()); que.emplace(\u0026#34;0000\u0026#34;, 0); // visited.insert(\u0026#34;0000\u0026#34;); while (!que.empty()) { //基于多个方向搜索。 // FIXME: deadends 还没有建立排除的机制。 string temp = que.front().first; int depth = que.front().second; if (temp == target) return depth; que.pop(); if (visited.find(temp) != visited.end()) continue; //if (containsDeadend(temp, deadends)) continue; if(dead.find(temp) != dead.end()) continue; visited.insert(temp); for (int i = -4; i \u0026lt; 0; i++) { auto next = moveLock(temp, i); que.emplace(next,depth+1); } for (int i = 1; i \u0026lt; 5; i++) { auto next = moveLock(temp, i); que.emplace(next,depth+1); } } return -1; } string moveLock(string s1, int posandPN) { //由于实际上是涉及到生存周期的问题，但是实际上好像empalce不用考虑这个 if (posandPN \u0026gt; 0 \u0026amp;\u0026amp; posandPN \u0026lt;= 4) { if (s1[posandPN-1] == \u0026#39;9\u0026#39;) s1[posandPN-1] = \u0026#39;0\u0026#39;; else s1[posandPN-1] += 1; } else if (posandPN \u0026lt; 0 \u0026amp;\u0026amp; posandPN \u0026gt;= -4) { if (s1[-posandPN-1] == \u0026#39;0\u0026#39;) s1[-posandPN-1] = \u0026#39;9\u0026#39;; else s1[-posandPN-1] -= 1; } return s1; } // bool containsDeadend(const string\u0026amp; s1, vector\u0026lt;string\u0026gt;\u0026amp; deadends) { // for (string temp : deadends) { // if (s1 == temp) return true; // } // return false; // } }; 双向BFS优化 当我们知道target所在的位置(基本的前提)的时候，我们可以使用双向的BFS策略，也就是target搜索begin，begin搜索starget同时进行，这样的方式在时间效率上会快的，原因如下：\n传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。\n综上所述，这样的算法只能在打开转盘锁的时候使用，因为我们知道终点在哪里，但是这样就设计到一个问题，就是我们好像不能再使用队列了，我们需要用set来判断我们是否产生了交集？\n使用unorder_set结构 交替更新，但是这里的方法没有delete，我感觉还是多少有泄露的可能性，感觉还是要修改后再使用，但是基本思路还是比较清楚的。应该把new改成clear，然后再换把。 基本的框架如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 int openLock(String[] deadends, String target) { Set\u0026lt;String\u0026gt; deads = new HashSet\u0026lt;\u0026gt;(); for (String s : deadends) deads.add(s); // 用集合不用队列，可以快速判断元素是否存在 Set\u0026lt;String\u0026gt; q1 = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; q2 = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); int step = 0; q1.add(\u0026#34;0000\u0026#34;); q2.add(target); while (!q1.isEmpty() \u0026amp;\u0026amp; !q2.isEmpty()) { // 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果 Set\u0026lt;String\u0026gt; temp = new HashSet\u0026lt;\u0026gt;(); /* 将 q1 中的所有节点向周围扩散 */ for (String cur : q1) { /* 判断是否到达终点 */ if (deads.contains(cur)) continue; if (q2.contains(cur)) return step; visited.add(cur); // 实际上原节点都可以不用加，第一次重叠一定是在扩散之后的值和另一个集有重叠的时候把。 /* 将一个节点的未遍历相邻节点加入集合 */ for (int j = 0; j \u0026lt; 4; j++) { String up = plusOne(cur, j); if (!visited.contains(up)) temp.add(up); String down = minusOne(cur, j); if (!visited.contains(down)) temp.add(down); } } /* 在这里增加步数 */ step++; // temp 相当于 q1 // 这里交换 q1 q2，下一轮 while 就是扩散 q2 q1 = q2; q2 = temp; } return -1; } 对于双向的BFS，还有一个优化是，我们下一次的扩散方向是根据现在集合比较小的那个来扩散的。\n滑动谜题 利用BFS来进行暴力穷举，我们只需要每次找到0的位置，然后和上面一样，列出0能做的所有单步决策就行了，然后用队列和防止重复的方法来解决他，但是其中有一些小技巧值得我们学习：\n直接列出所有情况下可选择的邻居来加快算法的速度 将2维降维到1维，用string或者其他的一维向量去做会更方便一点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 int slidingPuzzle(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; board) { int m = 2, n = 3; string start = \u0026#34;\u0026#34;; string target = \u0026#34;123450\u0026#34;; // 将 2x3 的数组转化成字符串 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { start.push_back(board[i][j] + \u0026#39;0\u0026#39;); } } // 记录一维字符串的相邻索引 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; neighbor = { { 1, 3 }, { 0, 4, 2 }, { 1, 5 }, { 0, 4 }, { 3, 1, 5 }, { 4, 2 } }; /******* BFS 算法框架开始 *******/ queue\u0026lt;string\u0026gt; q; unordered_set\u0026lt;string\u0026gt; visited; q.push(start); visited.insert(start); int step = 0; while (!q.empty()) { int sz = q.size(); for (int i = 0; i \u0026lt; sz; i++) { string cur = q.front(); q.pop(); // 判断是否达到目标局面 if (target == cur) { return step; } // 找到数字 0 的索引 int idx = 0; for (; cur[idx] != \u0026#39;0\u0026#39;; idx++); // 将数字 0 和相邻的数字交换位置 for (int adj : neighbor[idx]) { string new_board = cur; // 使用一个新的表也是一个比较重要的策略 swap(new_board[adj], new_board[idx]); // 防止走回头路 if (!visited.count(new_board)) { q.push(new_board); visited.insert(new_board); } } } step++; } return -1; /******* BFS 算法框架结束 *******/ } 双指针使用技巧总结 双指针技巧使用汇总帖 快慢指针的用法和用途： 是否有环：相遇可以判定有环； 找到环的起始点：相遇后，把一个调到头，同速前进，再次相遇即是起始点。（或者先停下一个，然后让另一个从头开始走） 链表的中点：快慢指针，快指针到达终点。 延申问题：对链表进行归并排序，通过快慢指针实现二分的操作，合并两个有序链表。 起始点偏差：先让一个指针走k步，另一个指针再出发，寻找链表的倒数第k个元素 快慢指针的常用算法： 二分查找算法，没啥好说的 子数组之和：只要数组有序，就要想到双指针技巧。通过调节left和right来调整sum的大小。找到对应的区间 反转数组：从前或从后出发，然后直接互换。 下面讲的滑动窗口 双指针技巧例题： 26 \u0026amp; 83有序数组链表去重\n使用快慢指针，遇到不一样的时候往下一个赋值就可以了，链表的话就是修改一下赋值操作，没什么太大的区别。\n27 移除元素\n使用双指针技巧，从两端向内，找到不是val的和val交换即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { if(nums.empty()) return {}; int n = nums.size(); int be = 0, en =n-1; // 使用双指针法解决这个问题，也就是不一样的时候进行交换 while(be\u0026lt;=en){ if(nums[be]!=val){ ++be; } else if(nums[en]==val){ --en; } else{ swap(nums[be],nums[en]); } } return en+1; } }; 移动0：283\n这题要注意是进行删除，然后再后面添加0，和之前的交换不一样，交换会破坏顺序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.empty()) return ; int n = nums.size(); int slow=0, fast =0; // 使用双指针法解决这个问题，也就是不一样的时候进行交换 while(fast\u0026lt;n){ if(nums[fast]!=0){ nums[slow] = nums[fast]; if(slow != fast) nums[fast] =0; ++slow; } fast++; } } }; 滑动窗口算法 思路总结 链表子串数组题 ：就直接考虑双指针的方法去做，双指针基本可以总结成以下的3中类型。\n快慢指针：链表操作，归并排序找中点，链表成环搞判定； 左右指针：反转数组，二分搜索 滑动窗口：字串问题，左右指针滑动，前后并进 滑动窗口的基本框架 ***1、***我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」。\n***2、***我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。\n***3、***此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。\n***4、***重复第 2 和第 3 步，直到right到达字符串S的尽头。\n理解向：思想很简单，但是主要是逻辑上容易出现一些bug和问题：1. 如何添加缩小，2.在哪更新结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 int left = 0, right = 0; while (right \u0026lt; s.size()) { // 增大窗口 window.add(s[right]); right++; while (window needs shrink) { // 缩小窗口 window.remove(s[left]); left++; } } 实现向：具体实现的框架，考虑了边界问题的方法，实际上也没什么说嘛，就是更具体一点，输入操作的位置肯定是这样啊，没什么好说的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* 滑动窗口算法框架 */ void slidingWindow(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; // 初始化状态，便于搜索 int left = 0, right = 0; int valid = 0; // 统计满足情况的数有多少，和需要的匹配时更新答案 while (right \u0026lt; s.size()) { // c 是将移入窗口的字符 char c = s[right]; // 右移窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(\u0026#34;window: [%d, %d)\\n\u0026#34;, left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) { // d 是将移出窗口的字符 char d = s[left]; // 左移窗口 left++; // 进行窗口内数据的一系列更新 ... } } } 典型例题1：76 最小覆盖子串问题，思路分析：\n不断的右移扩大窗口，当满足条件以后左指针右移，优化结果，直到第一次不满足，每次移动左指针都更新答案。 直到右指针超出边缘以后结束。 实现上由于是第一题，给出代码，但是后面的题就到相应的代码文件中去找吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: string minWindow(string s, string t) { if(s.empty() || s.size()\u0026lt;t.size()) return {}; unordered_map\u0026lt;char,int\u0026gt; need,windows; for(char temp: t) need[temp]++; //存储所有需要的字符 // 初始化双指针和判断指针 int right=0, left=0; int valid =0; int n = need.size(); // 存放结果 int len = INT_MAX; int s_index = 0; while(right\u0026lt;s.size()){ char c = s[right]; right++; if(need.count(c)){ windows[c]++; // 考虑到重复数值的出现 if(windows[c] == need[c]) valid++; } while(valid == need.size()){ if(right-left\u0026lt;len){ s_index = left; len = right-left; } char d = s[left]; left++; if(need.count(d)){ // 考虑到有多个对应元素，而我们pop的时候只有当临界值需要修改状态 if(windows[d]== need[d]) valid--; windows[d]--; } } } return len==INT_MAX?\u0026#34;\u0026#34;:s.substr(s_index,len); } }; 典型例题：567字符串排列 这题和上面一题的区别就在于“只包含需要的所有元素” ，并且计数一致（因为是存在排列，所以中间不能有其他的元素）\n这题我的思路是直接不断移动right，然后当right遍历到不同的元素的时候，或者需要元素的count不同的时候，直接\u0026ndash;，但是这样实际上还是有一定的问题的，比如对于windows中的元素\u0026ndash;实际上并不好操作。但是这个思路的计算和遍历思路实际上比框架的快，也不一定，因为要遍历\u0026ndash;；\nFA：右侧递进实际上还是一样的，但是左侧应该是当size不同的时候，要一直遍历到相等。因为是排列，所以长度要想等\n因为这里用的是小于等于的时候都要进入循环，所以第一次发生判断的时候只可能是长度相等的时候。\n典型例题：438所有的字母yiweici排列 和上一题一样，只是要存储所有的start，所以判断的热res修改一下就好了。\n典型例题：3 最小不重复子串 实际上就是终止条件（left），每个字符的count都只有1，不然就left一直++；\n然后更新就行maxlen就行。\n分治算法详解 FA的作者认为可以将回溯，分治和动态规划放到一起，实际上都是一种特殊的递归。\n回溯算法就一种简单粗暴的算法技巧，说白了就是一个暴力穷举算法，比如让你 用回溯算法求子集、全排列、组合 ，你就穷举呗，就考你会不会漏掉或者多算某些情况。\n动态规划是一类算法问题，肯定是让你求最值的。因为动态规划问题拥有 最优子结构 ，可以通过状态转移方程从小规模的子问题最优解推导出大规模问题的最优解。\n分治算法呢，可以认为是一种算法思想，通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。这里有点类似动态规划，所以说运用分治算法也需要满足一些条件，你的原问题结果应该可以通过合并子问题结果来计算。\n最经典的分支框架，归并排序：\n1 2 3 4 5 6 7 8 9 10 void sort(int[] nums, int lo, int hi) { int mid = (lo + hi) / 2; /****** 分 ******/ // 对数组的两部分分别排序 sort(nums, lo, mid); sort(nums, mid + 1, hi); /****** 治 ******/ // 合并两个排好序的子数组 merge(nums, lo, mid, hi); } 为运算表达式设计优先级241 实际上就是考虑所有可能的添加括号的方式，还要考虑括号的合法性和计算的优先级问题；\n实际上没有我们考虑的那么复杂，当我们只加一个括号的时候，我们只需要针对单一的运算符号进行分割就好了，其他的情况都是可以被归化的，\n实际上也没什么特殊的操作，就是通过分和治两部分进行，用分划分成子问题，然后对当前的问题进行解决，这实际上也就是递归做的事情啊，感觉没什么区别，对于特殊的问题实际上也可以使用备忘录来简化操作。\n下面这个我写的代码，值得品一品好吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: vector\u0026lt;int\u0026gt; diffWaysToCompute(string input) { vector\u0026lt;int\u0026gt; res; int n = input.size(); vector\u0026lt;int\u0026gt;a; vector\u0026lt;int\u0026gt;b; for(int i = 0; i\u0026lt;n;i++){ char c = input[i]; if(c==\u0026#39;*\u0026#39; || c==\u0026#39;+\u0026#39; || c==\u0026#39;-\u0026#39;){ a = diffWaysToCompute(input.substr(0,i)); b = diffWaysToCompute(input.substr(i+1,n-i-1)); // 由于我们已经有了c所以我们通过这个定义一个运算 for(int nums1:a){ for(int nums2:b){ int temp = calculate(nums1,nums2,c); res.emplace_back(temp); } } } } // basecase!!! 当我们发现里面没有运算符的时候，就说明这是一个单纯的数字 if(res.empty()){ res.emplace_back(stoi(input)); } return res; } int calculate(const int\u0026amp; num1, const int\u0026amp; num2, char\u0026amp; op){ if(op==\u0026#39;+\u0026#39;){ return num1+num2; }else if(op==\u0026#39;-\u0026#39;){ return num1-num2; }else if(op==\u0026#39;*\u0026#39;){ return num1*num2; } return {}; } }; 区间问题 所谓区间问题也就是线段问题，合并所有的线段，找出线段的交集等等。主要有两个技巧\n排序：常见的有，按照起点升序排序，若起点相同，则按照终点降序排序。 画图：不要偷懒。 典型例题 1288 删除被覆盖区间 这题有个问题我比较疑惑，就是区间竟然还能合并的嘛，fine。解决思路就是，通过起点升序，末端降序，然后首先排除覆盖，遇到区间合并的情况，就更新边界点（left，right），遇到完全不相交的情况，就重新（left，right）；\n实际上有类似的问题涉及到贪心的算法选择。\n下面这个是我的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int removeCoveredIntervals(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { if (intervals.empty()) return 0; // 按照第一维度的升序和第二个维度的降序来排列 sort(intervals.begin(), intervals.end(), [](vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b) { if (a[0] != b[0]) return a[0] \u0026lt; b[0]; else return a[1] \u0026gt; b[1]; }); int res = 1; // 指定当前的边界 vector\u0026lt;int\u0026gt; cur = intervals[0]; for (int i = 1; i \u0026lt; intervals.size(); i++) { // 当第二个维度比当前大的时候就更新 if (intervals[i][1] \u0026gt; cur[1]) { res++; cur = intervals[i]; } } return res; } }; FA中的傻逼写法？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 int removeCoveredIntervals(int[][] intvs) { // 按照起点升序排列，起点相同时降序排列 Arrays.sort(intvs, (a, b) -\u0026gt; { if (a[0] == b[0]) { return b[1] - a[1]; } return a[0] - b[0]; }); // 记录合并区间的起点和终点 int left = intvs[0][0]; int right = intvs[0][1]; int res = 0; for (int i = 1; i \u0026lt; intvs.length; i++) { int[] intv = intvs[i]; // 情况一，找到覆盖区间 if (left \u0026lt;= intv[0] \u0026amp;\u0026amp; right \u0026gt;= intv[1]) { res++; } // 情况二，找到相交区间，合并 if (right \u0026gt;= intv[0] \u0026amp;\u0026amp; right \u0026lt;= intv[1]) { right = intv[1]; } // 情况三，完全不相交，更新起点和终点 if (right \u0026lt; intv[0]) { left = intv[0]; right = intv[1]; } } return intvs.length - res; } 典型题 56 区间合并 和上一题是一样的\n实际上也是按照开始的节点升序排列，后面其实升序降序都可以，按照start和现有的end的关系，看到底是要修改end还是push_back。即可。\n我写的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { if (intervals.empty()) return {}; // 按照第一维度的升序和第二个维度的降序来排列 sort(intervals.begin(), intervals.end(), [](vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b) { if (a[0] != b[0]) return a[0] \u0026lt; b[0]; else return a[1] \u0026gt; b[1]; }); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; temp = intervals[0]; // 考虑需要合并的情况分三种情况，覆盖（无需合并） 重叠 ， 更新 for (auto interval:intervals) { //覆盖的可以直接掠过，通过尾部来进行重叠或者更新的判断； if (interval[1] \u0026gt; temp[1]) { // 判断是重叠的情况还是 更新的情况 if (interval[0] \u0026gt; temp[1]) { res.emplace_back(temp); temp = interval; } else { temp[1] = interval[1]; } } } // 还剩下最后一个没有加入更新 res.emplace_back(temp); return res; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # intervals 形如 [[1,3],[2,6]...] def merge(intervals): if not intervals: return [] # 按区间的 start 升序排列 intervals.sort(key=lambda intv: intv[0]) res = [] res.append(intervals[0]) for i in range(1, len(intervals)): curr = intervals[i] # res 中最后一个元素的引用 last = res[-1] if curr[0] \u0026lt;= last[1]: # 找到最大的 end last[1] = max(last[1], curr[1]) else: # 处理下一个待合并区间 res.append(curr) return res 典型题 986 区间交集问题 实际上画图很容易找到解决的方案，交集就是max （left） min（right），然后哪个的right小，哪个的index就++，没有别的了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A, B 形如 [[0,2],[5,10]...] def intervalIntersection(A, B): i, j = 0, 0 # 双指针 res = [] while i \u0026lt; len(A) and j \u0026lt; len(B): a1, a2 = A[i][0], A[i][1] b1, b2 = B[j][0], B[j][1] # 两个区间存在交集 if b2 \u0026gt;= a1 and a2 \u0026gt;= b1: # 计算出交集，加入 res res.append([max(a1, b1), min(a2, b2)]) # 指针前进 if b2 \u0026lt; a2: j += 1 else: i += 1 return res 排序算法 排序算法最少最少也要nlogn （平均和最差）\n最终要对各个 排序算法都要写一下，不管是基本框架还是具体实现，找找对应的题，没有的话再说。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 boolean isValidBST(TreeNode root) { return isValidBST(root, null, null); } /* 限定以 root 为根的子树节点必须满足 max.val \u0026gt; root.val \u0026gt; min.val */ boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) { // base case if (root == null) return true; // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST if (min != null \u0026amp;\u0026amp; root.val \u0026lt;= min.val) return false; if (max != null \u0026amp;\u0026amp; root.val \u0026gt;= max.val) return false; // 限定左子树的最大值是 root.val，右子树的最小值是 root.val return isValidBST(root.left, min, root) \u0026amp;\u0026amp; isValidBST(root.right, root, max); } 复杂度分析汇总 排序算法一般在最差情况的下时间复杂度为Ω（n log n）;\n书上P151页的表到时候重新扫描一下；\n前三种Θ（n^2）的算法：这种算法的瓶颈就在于只比较相邻的元素，因此比较和移动只能一步步进行。交换相邻记录称为一次交换\n排序算法 时间复杂度 空间复杂度 插入排序 冒泡排序 选择排序 插入排序：\n一个一个输入后面的空位，然后逐步和前面的已经输入的n-1比，“冒泡”合适的位置，逐个进行比较和swap。\n冒泡排序：\n内层将该轮的最值冒出去，最外层就是冒泡n次就是了。\n选择排序：\n实际上就是冒泡排序的从最小值开始，但是不是每次都交换，而是固定每个内循环只交换一次，就是先找值后交换而已。\n一些好一点的算法：\nShell 排序：缩小增量排序 选择适当的增量序列可以使得Shell排序比其他的排序都更有效率；但是选择这个序列是很难的，一般来说选择（1，4，13..）增量每次÷3。Shell不加证明的认为Θ（n^1.5），确实比前面的三种都要快，当n中等规模的时候，也和下面的那些有的比。\n基本思想：利用插入排序的最佳时间代价的特性，试图将待排序序列变成近似有序的，然后再利用插入排序来最后排序；\n实现逻辑：把序列分成多个子序列，然后分别对子序列进行排序，最后把子序列组合起来。\n快速排序：实际上就是二叉树的前序遍历 快速排序的逻辑是，若要对 nums[lo..hi] 进行排序，我们先找一个分界点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]，然后递归地去 nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。\n执行关键在于partiton划分过程，算法效率在于怎么找到划分节点，最差n^2，平均和最佳都是nlogn\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 代码框架，（不是具体实现） /* 快速排序主函数 */ void sort(int[] nums) { // 一般要在这用洗牌算法将 nums 数组打乱， // 以保证较高的效率，我们暂时省略这个细节 sort(nums, 0, nums.length - 1); } /* 快速排序核心逻辑 */ void sort(int[] nums, int lo, int hi) { /****** 前序遍历位置 ******/ // 通过交换元素构建分界点 p int p = partition(nums, lo, hi); /************************/ sort(nums, lo, p - 1); sort(nums, p + 1, hi); } 先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？ int partition(int[] nums, int lo, int hi) { if (lo == hi) return lo; // 将 nums[lo] 作为默认分界点 pivot int pivot = nums[lo]; // j = hi + 1 因为 while 中会先执行 -- int i = lo, j = hi + 1; while (true) { // 保证 nums[lo..i] 都小于 pivot while (nums[++i] \u0026lt; pivot) { if (i == hi) break; } // 保证 nums[j..hi] 都大于 pivot while (nums[--j] \u0026gt; pivot) { if (j == lo) break; } if (i \u0026gt;= j) break; // 如果走到这里，一定有： // nums[i] \u0026gt; pivot \u0026amp;\u0026amp; nums[j] \u0026lt; pivot // 所以需要交换 nums[i] 和 nums[j]， // 保证 nums[lo..i] \u0026lt; pivot \u0026lt; nums[j..hi] swap(nums, i, j); } // 将 pivot 值交换到正确的位置 swap(nums, j, lo); // 现在 nums[lo..j-1] \u0026lt; nums[j] \u0026lt; nums[j+1..hi] return j; } // 交换数组中的两个元素 void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } 归并排序：实际上就是二叉树的后序遍历 再说说归并排序的逻辑，若要对 nums[lo..hi] 进行排序，我们先对 nums[lo..mid] 排序，再对 nums[mid+1..hi] 排序，最后把这两个有序的子数组合并，整个数组就排好序了。\n归并排序的代码框架如下：\n1 2 3 4 5 6 7 8 9 10 11 void sort(int[] nums, int lo, int hi) { int mid = (lo + hi) / 2; sort(nums, lo, mid); sort(nums, mid + 1, hi); /****** 后序遍历位置 ******/ // 合并两个排好序的子数组 // 逐渐的比较两个sort的最小值就行了，应该算是O（n）把，遍历一遍就好 merge(nums, lo, mid, hi); /************************/ } 先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。\n堆排序： 所有情况都是nlogn.\n实现的思想：建堆取中心节点，直至堆空；主要就在于建堆和removefirst；\n分配排序和基数排序 看书，上网找描述，书上能理解但是描述不清楚。\n题型：数组 用二分查找来解决数组题目 实际上二分查找法的关键就在这一个查找，针对查找问题的这些情况，我们都可以用二分法去做，有一些题目虽然会写的比较隐晦，但是我们看到类似如下的暴力搜索框架的时候，就可以考虑使用二分查找法来优化\n1 2 3 for (int i = 0; i \u0026lt; n; i++) if (isOK(i)) return answer; 例题：koko吃香蕉；货物运输\n我对于二分查找的框架的写法实际上还是没有太清楚，到底是应该+1-1还是怎么去约束，我还是要想清楚再写，看看FA的二分查找框架。\nTwo Sum 到N Sum问题 two sum实际上就是教我们使用hash-table之类的数据结构去解决这样的需要穷举的问题，或者排序后再使用双指针的问题。我们当然也可以在自定义数据结构，每次添加数字，旧纪录当前所有可能的和，然后再O1进行索引就行了。\n简单的TWO-SUM就不再多说了，这里提一下如何实现到NSUM的泛化\nN Sum拓展： 首先基于思路还是用sort首先排完序后再用双指针法去做的，实际上更偏向于其中的滑动窗口算法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # two sum的基本情况 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; twoSumTarget(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { // nums 数组必须有序 sort(nums.begin(), nums.end()); int lo = 0, hi = nums.size() - 1; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; while (lo \u0026lt; hi) { int sum = nums[lo] + nums[hi]; int left = nums[lo], right = nums[hi]; if (sum \u0026lt; target) { while (lo \u0026lt; hi \u0026amp;\u0026amp; nums[lo] == left) lo++; } else if (sum \u0026gt; target) { while (lo \u0026lt; hi \u0026amp;\u0026amp; nums[hi] == right) hi--; } else { res.push_back({left, right}); while (lo \u0026lt; hi \u0026amp;\u0026amp; nums[lo] == left) lo++; while (lo \u0026lt; hi \u0026amp;\u0026amp; nums[hi] == right) hi--; } } return res; } 直接 3sum-4sum问题： 简单的思路：穷举，然后判断即可；结合的思路，遍历所有的第一个，然后就转化为2Sum的问题了，为了使得结果不重复，我们需要由于我们的2 sum算法中有避免重复，所以我们就只要保证第一个遍历的数字不要重复即可。\n但是这样加入让我们求100 sum的话，我们可以根据上面的方式，总结出一个通用的方程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* 注意：调用这个函数之前一定要先给 nums 排序 */ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; nSumTarget( vector\u0026lt;int\u0026gt;\u0026amp; nums, int n, int start, int target) { int sz = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; // 至少是 2Sum，且数组大小不应该小于 n if (n \u0026lt; 2 || sz \u0026lt; n) return res; // 2Sum 是 base case if (n == 2) { // 双指针那一套操作 int lo = start, hi = sz - 1; while (lo \u0026lt; hi) { int sum = nums[lo] + nums[hi]; int left = nums[lo], right = nums[hi]; if (sum \u0026lt; target) { while (lo \u0026lt; hi \u0026amp;\u0026amp; nums[lo] == left) lo++; } else if (sum \u0026gt; target) { while (lo \u0026lt; hi \u0026amp;\u0026amp; nums[hi] == right) hi--; } else { res.push_back({left, right}); while (lo \u0026lt; hi \u0026amp;\u0026amp; nums[lo] == left) lo++; while (lo \u0026lt; hi \u0026amp;\u0026amp; nums[hi] == right) hi--; } } } else { // n \u0026gt; 2 时，递归计算 (n-1)Sum 的结果 for (int i = start; i \u0026lt; sz; i++) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]); for (vector\u0026lt;int\u0026gt;\u0026amp; arr : sub) { // (n-1)Sum 加上 nums[i] 就是 nSum arr.push_back(nums[i]); res.push_back(arr); } while (i \u0026lt; sz - 1 \u0026amp;\u0026amp; nums[i] == nums[i + 1]) i++; } } return res; } Union-Find并查算法 理论基础 解决的是图论中的动态连通性问题，也就是逐渐建立图的连通关系（自反性，传递性，对称性）的时候，以下几种API的实现（参考后面提到的数据结构）。\n联通性判断：父节点是否相同。（parent （x）== x） 建立连接：将其中任意一个节点的根节点指向另一个节点的根节点上； 连通分量统计：每次建立连通性的时候\u0026ndash; 使用的数据结构类型：森林（若干树）（每个节点指向其父节点，根节点指向自己）\n通过父节点是否一致来进行判断，是否联通，如果根据这个原理的话，那么树的平衡，也就是深度就比较重要了。合理的设计能够降低树的深度，也就能降低搜索父节点的时间消耗：从而减少无论是建立联通还是连通性判断两个部分。\n平衡性优化：如何避免Union中树的不平衡现象产生？每次将小树接到大树后面，而不是反过来。\n那么我们在每个树种存储相应的size，也就是结点数目，这样在进行Union的时候进行判断就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class UF { // 连通分量个数 private int count; // 存储一棵树 private int[] parent; // 记录树的“重量” private int[] size; public UF(int n) { this.count = n; parent = new int[n]; size = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; size[i] = 1; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // 小树接到大树下面，较平衡 if (size[rootP] \u0026gt; size[rootQ]) { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } else { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } count--; } public boolean connected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } private int find(int x) { while (parent[x] != x) { // 进行路径压缩 parent[x] = parent[parent[x]]; x = parent[x]; } return x; } } 常数级别路径压缩：\n对find函数进行改进 ，每次在进行find的时候同时进行压缩，添加一行代码即可。所有的树高不会超过3，（union的时候树高可能达到3） :question:在这种情况下平衡判断还重要吗，毕竟find压缩的复杂度已经是O(1)了。\n可以不要，基本确实是O(1)但是确实能略微提高运算的效率就是了。 ​\n1 2 3 4 5 6 7 8 private int find(int x) { while (parent[x] != x) { // 进行路径压缩 parent[x] = parent[parent[x]]; x = parent[x]; } return x; } 实际应用： 考虑到把原问题转化成图的动态连通性的关系，同时有一些小技巧：\n将二维数组映射到一维数组；\n1 uf.union(x * n + y, i * n + j); 使用方向代码d来简化代码量！\n1 2 3 int[][] d = new int[][]{ {1,0}, {0,1}, {0,-1}, {-1,0} }; 很多复杂的DFS都可以使用Union-Find来进行解决\n应用1：130被围绕的区域 不那么贴切，也就是130题，围棋问题，完全被围住才能换成x所以边界上是安全的，所以，我们就首先找到和边界上的O联通的所有点，然后把其他的不与这种情况联通的O全部换成X即可。\n传统方法，遍历边界，然后从这些O DFS出去。标记为#，然后将其余的O换成X，然后再将#换回来即可。\n应用2：判定合法算式 这题实际上就是典型的联通问题，根据等式去建立联通关系，然后根据字符翻译成是否联通即可。具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 boolean equationsPossible(String[] equations) { // 26 个英文字母 UF uf = new UF(26); // 先让相等的字母形成连通分量 for (String eq : equations) { if (eq.charAt(1) == \u0026#39;=\u0026#39;) { char x = eq.charAt(0); char y = eq.charAt(3); uf.union(x - \u0026#39;a\u0026#39;, y - \u0026#39;a\u0026#39;); } } // 检查不等关系是否打破相等关系的连通性 for (String eq : equations) { if (eq.charAt(1) == \u0026#39;!\u0026#39;) { char x = eq.charAt(0); char y = eq.charAt(3); // 如果相等关系成立，就是逻辑冲突 if (uf.connected(x - \u0026#39;a\u0026#39;, y - \u0026#39;a\u0026#39;)) return false; } } return true; } 从LRU到LFU LRU：Least recently used 最近使用的就是有用的；\nLFU：Least frequently used 最频繁使用的是有用的；\nLRU设计 我的思路如下：\n怎么去设计这样一个数据结构，实际上是优先队列把？用一定的规则来设计这样的queue，但是为了要能在O(1) push 和get，我们可以使用hashmap，\u0026amp;存放使用的时序和val，以及一个step指向当前的操作数字，但是push中hashmap的删除涉及到find的操作，需要O（n）。**所以不行 **\n正确使用的数据结构应该是：Hash（支持快速索引链表的位置）+双向链表（支持快速的插入和删除）在CPP中使用unordered_map和自定义双向链表来实现双向哈希链表。\nPush 需要判断是否超出了边界。\n具体代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 这里的关键就在于带有额外头尾节点的双向链表，将删除，移动和乱七八糟的全部分离出来 struct Dlist{ int val, key; Dlist* prev; Dlist* next; Dlist():key(0),val(0),prev(nullptr),next(nullptr){} Dlist(int k, int v):key(k),val(v),prev(nullptr),next(nullptr){} }; class LRUCache { private: int cap,size; unordered_map\u0026lt;int,Dlist*\u0026gt; loc; // 双向链表，存个头尾不过分吧 Dlist* head; Dlist* tail; // 指向最后一个的后一个 public: LRUCache(int capacity):cap(capacity),size(0) { head = new Dlist(); tail = new Dlist(); head-\u0026gt;next = tail; tail-\u0026gt;prev = head; } int get(int key) { if(!loc.count(key)) return -1; // 最近使用，移到头部，删除原位 Dlist* root = loc[key]; movetohead(root); return root-\u0026gt;val; } void put(int key, int value) { // 这里需要一个add和一个remove // 当cap不满的时候我们就直接加到List和Hash中，原值不存在 if(!loc.count(key)){ // 先创建新节点，然后判断cap Dlist* root = new Dlist(key,value); // 容易忘记在hash表中添加 loc[key] = root; addHead(root); size++; if(size \u0026gt; cap){ Dlist* temp = removeTail(); loc.erase(temp-\u0026gt;key); // 防止内存泄露 delete temp; --size; } }else{ Dlist* root = loc[key]; root-\u0026gt;val = value; movetohead(root); } } void movetohead(Dlist* root){ // 实际上是删除炒作：上一个的下一个和下一个的上一个 // 实际上也是put操作：然后接在头后面 deleteNode(root); addHead(root); } // 在写移动算法的时候附加的操作 void deleteNode(Dlist* root){ root-\u0026gt;prev-\u0026gt;next = root-\u0026gt;next; root-\u0026gt;next-\u0026gt;prev = root-\u0026gt;prev; } // 在写移动算法的时候会归纳出来的操作 void addHead(Dlist* root){ root-\u0026gt;next = head-\u0026gt;next; root-\u0026gt;prev = head; root-\u0026gt;next-\u0026gt;prev = root; head-\u0026gt;next = root; } Dlist* removeTail(){ // 由于tail指向的是最后一个的后一个，实际上我们只要调用delete就行了 Dlist* temp = tail-\u0026gt;prev; deleteNode(temp); // return是为了delete方便删除 return temp; } }; LFU设计 LFU相比于LRU来说设计上还是要复杂不少的，首先就是LFU除了维护一个优先队列以外，优先的判断和存储是比较难得，我们怎么样去存放一个决定优先级的freq的数据，然后能够很快的找到需要弹出的freq。这个freq还要能够很快的进行更新就是了。\n维护一个freq的优先级，同时freq中也有时序的关系，最新最旧。 其他的和LRU还是挺像的。 这一题还是看看官方的题解把：这题的的两种解法一种set，考虑双哈希的解法；\n画张图还是很容易理解的，也就是通过每个freq的一个双向链表，以及hash指向特定key的双结构去做，根据插入到尾部，就能维护到尾部。\n两种方法都很有参考价值 一些其他的算法技巧 接雨水 我的思路：记录变化点，然后减掉区域内的面积，就是雨水的面积，用两个flag可以实现，一个记录变化，一个记录是否成area。\nFA解法\n暴力解法：对于每个i找到left的最高点，right的最高点，然后选低的哪个，减掉当前坐标即可。 用备忘录优化：需要两个，从左到右的最大，和从右到左的最大，然后按图索骥就可以了 双指针解法：实际上是上一个方法的改进，我们只要知道，无论距离多远，只要一段比较高，就能把低的那边的水给锁住，那么我们只需要一直移动比较低的那一侧就好了，写写看。 判断完美矩形 原来不用自己组合，那有什么难的，面积加端点判断就好了，试着写一下：\n断电判断：一个小矩形的端点，如果只有奇数个矩形接触，那就是一个额外的顶点，这样的顶点超过4个就不行 面积就是很简单了。 翻转煎饼 和我想的没什么区别，找到最大的，翻到顶上，然后翻到底下，然后递归；\n:star:考官调度885： 但凡遇到在动态过程中取最值的要求，肯定要使用有序数据结构，我们常用的数据结构就是二叉堆和平衡二叉搜索树了。\n如果将每两个相邻的考生看做线段的两端点，新安排考生就是找最长的线段，然后让该考生在中间把这个线段「二分」，中点就是给他分配的座位。leave(p)其实就是去除端点p，使得相邻两个线段合并为一个。\n也就是使用set来做\n这是这题的思路，但是我们还是看看官方解答把\n实现一个计算器： 通过stack实现加减乘除（遇到符号将前面的数字入栈），遇到左括号进入递归，遇到右括号跳出递归，遇到空格进行处理。\n参考链接 反直觉概率： 生男生女都一样 男女这个我持保留态度，性别不应该用年龄来划分空间，这种歧义\n生日问题 应该转化为计算每个人的生日都不同。就可以大概计算出来。\n三门问题 应该转化为概率浓缩来理解，换门相当于选择了后面两扇门的概率。\n随机算法：水塘抽样算法 如何在不知道总数的时候产生均匀的随机数？\n这篇文章的启发性很好，实际上就是我们通过将1/n 换成1/i ，然后再获取到下一个index的时候，做一个保留还是变换的决定.\n可以证明，保留的概率为1/i，变换的概率是(i-1)/i;\n同理，如果要随机选择k个数，只要在第i个元素处以k/i的概率选择该元素，以1 - k/i的概率保持原有选择即可。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 返回链表中一个随机节点的值 */ int getRandom(ListNode head) { Random r = new Random(); int i = 0, res = 0; ListNode p = head; // while 循环遍历链表 while (p != null) { // 生成一个 [0, i) 之间的整数 // 这个整数等于 0 的概率就是 1/i if (r.nextInt(++i) == 0) { res = p.val; } p = p.next; } return res; } 拓展延伸：\n以上的抽样算法时间复杂度是 O(n)，但不是最优的方法，更优化的算法基于几何分布（geometric distribution），时间复杂度为 O(k + klog(n/k))。由于涉及的数学知识比较多，这里就不列出了，有兴趣的读者可以自行搜索一下。\n还有一种思路是基于 Fisher–Yates 洗牌算法 的。随机抽取k个元素，等价于对所有元素洗牌，然后选取前k个。只不过，洗牌算法需要对元素的随机访问，所以只能对数组这类支持随机存储的数据结构有效。\n另外有一种思路也比较有启发意义：给每一个元素关联一个随机数，然后把每个元素插入一个容量为k的二叉堆（优先级队列）按照配对的随机数进行排序，最后剩下的k个元素也是随机的。\n差分数组、前缀和 1109航班预定统计 首先分别介绍一下前缀和和差分数组的定义和作用：\n前缀和\n简单来说定义为如下形式：便于计算区间内的累加和之类的操作 差分数组\n主要使用于对区间内的一定元素进行统一的加减运算； 差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。\n这样构造差分数组diff，就可以快速进行区间增减的操作，如果你想对区间nums[i..j]的元素全部加 3，那么只需要让diff[i] += 3，然后再让diff[j+1] -= 3即可：\n最后再又差分数组反推出最终的值就可以了。\n具体应用：机票预定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 vector\u0026lt;int\u0026gt; corpFlightBookings(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bookings, int n) { // 初始化结果数组 vector\u0026lt;int\u0026gt; res(n,0); if(bookings.empty()) return res; // 构建差分数组,初始就全是0，没问题的 vector\u0026lt;int\u0026gt; diff(n,0); // 差分求解 for(auto book: bookings){ int i = book[0]-1; int j = book[1]-1; int val = book[2]; diff[i]+= val; if(j+1\u0026lt;n) diff[j+1]-=val; } // 数组还原 res[0] = diff[0]; for(int i =1;i\u0026lt;n;i++){ // cout\u0026lt;\u0026lt;diff[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; res[i] = diff[i]+res[i-1]; } return res; } 快排亲兄弟：快速选择算法215 经典问题数组中第k个最大元素\n使用二叉堆（优先队列）的解法：显然就是一个针对这种数据结构的问题，我们甚至可以自己写一下这种结构，但是确实是比较麻烦来着。、 使用快速排序的解法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 优先队列的方法 class Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // 使用优先队列的方法进行问题的求解 if(nums.empty() || nums.size()\u0026lt;k) return {}; priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; pq; for(auto num:nums){ pq.push(num); if(pq.size()\u0026gt;k) pq.pop(); } return pq.top(); } }; 快速排序的方法和思路 实际上就是不完全的快速排序，使用二分的策略叠在快速排序上，当我们排序到K的时候，就直接return就行，但是为了使得算法不是每次都取到极端情况，我们每次首先将数组进行一次随机的打乱策略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { if(nums.empty()||nums.size()\u0026lt;k) return {}; // 首先打乱数组避免极端情况产生 random_shuffle(nums.begin(),nums.end()); // 使用二分查找的方法来找到真实的坐标 int n = nums.size(); int lo = 0; int hi = n-1; int resindex = n-k; while(lo\u0026lt;=hi){ int p = partition(nums,lo, hi); if(p\u0026gt;resindex){ hi = p-1; }else if(p\u0026lt;resindex){ lo = p+1; }else{ return nums[p]; } } return -1; } int partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int lo, int hi){ // 快排的划分,初始化为lo if(lo==hi) return lo; int i = lo; int j = hi+1; int privot = nums[lo]; while(true){ while(nums[++i]\u0026lt;privot){ if(i\u0026gt;=hi) break; } while(nums[--j]\u0026gt;privot){ if(j\u0026lt;=lo) break; } if(i\u0026gt;=j) break; swap(nums[i],nums[j]); } swap(nums[lo],nums[j]); return j; } }; 快速计算素数的个数 通过是否是素数的一个个判断的效率没有我们从下网上填充false快，同时填充的时候注意内层循环和外层循环都能通过sqrt进行优化，外层是因为只需要到sqrt就可以了，内层是平方前面的都是重复的。\n直接看写好的代码文件。 super pow 模幂运算 实际上计算的关键就是如下的公式：(用AK+B)之类的假设很容易证明\n$$ （a*b)\\% k = (a\\%k)(b\\%k)\\%k;\r$$\r然后再根据幂运算的乘积性质就很容易了，然后用递归的去做，（分奇偶）\n$$ a^{M+N} = a^M * a^N \\\\\rA^{MN} = A^{M^N}\r$$\r再进一步的优化得到快速幂算法,证明还是基于上面的假设\n$$ a^b \\%c == (a\\%c)^b\r$$\r这里给出两种，一种是每次去最尾巴那一位，一个是快速幂算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 快速幂算法 int base = 1337; int mypow(int a, int k) { if (k == 0) return 1; a %= base; // 这里和直观的理解上是有所偏差的， // 我如果将这里注释掉，转移到下面的两个a中，还是正确的，但是效率差了点 if (k % 2 == 1) { // k 是奇数 return (a * mypow(a, k - 1)) % base; } else { // k 是偶数 int sub = mypow(a, k / 2); return (sub * sub) % base; } } 每次取基底，和其余数组的10次方相乘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int base = 1337; // 计算 a 的 k 次方然后与 base 求模的结果 int mypow(int a, int k) { // 对因子求模 a %= base; int res = 1; for (int _ = 0; _ \u0026lt; k; _++) { // 这里有乘法，是潜在的溢出点 res *= a; // 对乘法结果求模 res %= base; } return res; } int superPow(int a, vector\u0026lt;int\u0026gt;\u0026amp; b) { if (b.empty()) return 1; int last = b.back(); b.pop_back(); int part1 = mypow(a, last); int part2 = mypow(superPow(a, b), 10); // 每次乘法都要求模 return (part1 * part2) % base; } 寻找缺失元素： 排序 × hash × 按index异或 等差数列求和-当前和：防止溢出边加边减 寻找缺失和重复元素（同时出现） 对于这种数组问题，关键点在于元素和索引是成对儿出现的，常用的方法是排序、异或、映射。\n这里介绍的是映射的方法，\nval-\u0026gt; index -\u0026gt; nums[index] = -nums[index]; 这样当我们发现其中的有个数是正数的时候，对应的index就是缺失元素，发现有个数要变换的时候已经是负数的时候就是重复元素。\n字符串乘法： 由于字符串做乘法，就很直观的就是大数相乘的问题，所以就是不能直接转成整形去做，我们直接模仿手乘画图就行，这里的关键在于将我们的乘法拆解的更加的底层\n图不好放，看网站上的，写的特别清楚 主要的问题在一个坐标的转换，但是仔细观察的话问题也不大\n判断括号的合法性： 单种括号，我们只需要（++ ）\u0026ndash;进行判断就可以了，最终==0\n多种括号，需要增加存储的信息：使用STACK，遇到左括号就入栈，右括号就出栈，出栈的时候进行匹配。\n如果带通配符的：双向进行查找，左到右的时候把*当成++ 右到左的时候也把*当成++,在遍历过程中只要小于0了就直接失效 这题实际上也可以使用DP，但是怎么做呢\n状态转移：\n算法： 如果且仅当间隔 s[i], s[i+1], \u0026hellip;, s[j] 能组成有效的括号时，dp[i][j]为 true。只有在下列情况下，dp[i][j] 才为 true：\ns[i] 是 \u0026lsquo;*\u0026rsquo; 号, 且在 s[i+1], s[i+2], \u0026hellip;, s[j] 这个范围能够组成有效的括号 或者，s[i] 为 \u0026lsquo;(\u0026rsquo;，并且在 [i+1，j] 中有一些 k，使得 s[k] 为 \u0026lsquo;)\u0026rsquo;，且(s[i+1:k] 和 s[k+1:j+1])截断的两个间隔可以构成有效的括号；\n判定子序列 很简单的解法：利用双指针直接求解：\n1 2 3 4 5 6 7 8 bool isSubsequence(string s, string t) { int i = 0, j = 0; while (i \u0026lt; s.size() \u0026amp;\u0026amp; j \u0026lt; t.size()) { if (s[i] == t[j]) i++; j++; } return i == s.size(); } 如果有一系列字符串s1,s2,s\u0026hellip;.和t做匹配的时候怎么做呢？\n可以按照现在的方法加入for 循环，但是如果使用二分法，可O(N)减低到O(M)(N),但是实际上我们也不追求这个，\n统计t中每一个字符出现的位置，创建这样一个数组 然后遍历再每个字母的数组中进行二分搜索就行了。 《剑指offer》 在这一部分里面实际上书上和具体实现是存在一定版本上的差异的，我们可以从书上得到解题的那种基本思路，但是实际上并不一定适用于现在的情况，所以我们其实可以基于现在的实现来结合书上的笔记进行整理。在这个文档中主要集中于现今情况下的解题分析；\n基本知识点 重要知识点 书上记录一些比较重要的知识点，后续多次复习或者是重新整理；\n树的3重遍历（*2 循环+递归）= 6种实现；\n红黑树\nSIZEOF Sizeof(Empty Class) = 1 ; 加入构造和析构函数 =1；将析构函数标记为virtual， = 4（32位的机器） =8（64位的机器） （会生成虚函数表，并为该类型的所有实例中添加一个指向虚函数表的指针。）\n也就是说指针在32位上是4字节 在64位上是8字节。\nSingleton 分析书上的C#代码中的代码和我们笔记中的C++情况的异同，然后根据C#中提出的哪些要求来进一步改进C++中的这个单例的实现方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // final version of C++ singleton // 不会产生复制构造函数，只会声明一次实例的生成，同时也简化了调用的步骤 public: Random(const Random\u0026amp;) = delete; static Random\u0026amp; Get() { static Random instance; return instance; } static float Float() {return Get().IFloat();} private: float IFloat() {return m_RandomGenerator;} Random(){} float m_RandomGenerator = o.5f 数据结构 重建二叉树 还是一个基于n-1假设完成的递归思想：递归记得要有初始状态，前序/后序 \u0026amp;\u0026amp; 中序，实际上前序和后序的变换没有什么差别，只是顺序颠倒了一下，这里需要注意的就是怎么样推导出这样的一个重建过程是比较重要的。\n算法和数据操作 对重要的算法理念进行整理和分析，便于后续对这些方法进行复习的时候有个脉络。\n递归和循环的思想 查找和排序的思想（这里需要对排序的算法进行进一步的整理） 回溯法 动态规划与贪婪算法 位运算 递归和循环：斐波那契数列 相关的分析还有一些重要的点：\n迭代由于大量的重复项，所以回导致算法的时间和计算复杂度急剧上升（这个问题应该在各类递归过程中分析，是否会导致递归爆炸栈溢出的问题） 第二个问题在于，int等各个类型的取值范围，需要注意最大能取到哪个数字，从而进行规划 取余的操作应该在哪一步执行，在计算加和的中间就需要执行取余，实际上就是一个移位操作把，把溢出值移位移掉。（是否能够使用移位的手法来进行处理。） 青蛙跳台阶要记得初始情况是不同的记得分析一下就可以了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int fib(int n) { // type 1 stupid answer : 大量重复计算问题的发生 int prea = 0; int preb = 1; if (n \u0026lt; 2) return n \u0026gt; 0 ? n : 0; for (int i = 0; i \u0026lt; n - 1; i++) { int temp = preb; preb += prea; // FIXME：需要注意的事情在于这个取余是要在中间执行的。 preb = preb % (int)(1e9 + 7); prea = temp; } return preb; } }; 查找和排序：旋转数组的最小数字（11） 解题思路：遍历到第一个比前数小的数，就直接break，有一个想法就是对第一个数进行特殊的判断，但是对于这种大部分都是旋转的情况，这个判断带来的收益远小于负面影响，所以还是不做额外判断。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 100% 99.81% class Solution { public: int minArray(vector\u0026lt;int\u0026gt;\u0026amp; numbers) { if(numbers[0]\u0026lt;numbers[numbers.size()-1]) return numbers[0]; for (int i=1; i\u0026lt;numbers.size();i++) { if(numbers[i]\u0026lt;numbers[i-1]) return numbers[i]; } return numbers[0]; } }; 回溯法：矩阵中的路径（12） 这一题我的解题思路实际上还是基于递归的解法，虽然需要四个方向，但是通常情况下，由于false就会退出，实际上复杂度并不会增加太多，但是这个解法的效率还是太低了。具体的解决思路如下。但是这题好像代表的一种新的算法，后续要看一下。\n越界的两种情况的判断顺序 \u0026rsquo;\\0\u0026rsquo;的情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 34 42 class Solution { public: bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { // 实现的问题：判断的就是相应的邻格中有没有相应的元素 // 怎么判断是否重复，切换成一个无表示的值？NULL行不行？ // 总结一下：第一步find，第二部search（4 blocks），第三步替换成NULL，第四步移动格子。 // find start (但是这样有个问题就是起始节点不是单一的，有可能有重复的起始节点。) int s_index = 0, s_jndex = 0; bool res = false; for(int i=0;i\u0026lt;board.size();i++){ for (int j=0;j\u0026lt;board[i].size();j++){ if (board[i][j] == word[0]){ s_index = i; s_jndex=j; res = helpsearch(board, word, i,j,0); if(res) return true; // board[i][j] = NULL; //只能临时控制，不然会导致后续出问题 } } } return false; } bool helpsearch(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board,string word, int idex, int jdex, int kdex){ // 前面的方法遍历所有可能的起始点，但是这样的话，修改重复数组就完蛋了（用迭代的方法来实现临时的赋值） // 迭代搜索 // 这个顺序要在下面的越界判断之前。 if(kdex == word.size()) return true; if(idex\u0026lt;0 || idex\u0026gt;=board.size() || jdex\u0026lt;0 || jdex \u0026gt;=board[0].size()) return false; bool res = false; if (board[idex][jdex] == word[kdex]){ // board[idex][jdex] = \u0026#39;\\0\u0026#39;; // 四种情况这里要体现一下，但是如果用递归的方式写入四个节点的话，好像复杂度有点问题 bool temp = helpsearch(board, word, idex+1, jdex, kdex+1) || helpsearch(board, word, idex-1, jdex, kdex+1)\\ || helpsearch(board, word, idex, jdex-1, kdex+1) || helpsearch(board, word, idex, jdex+1, kdex+1); res = true \u0026amp;\u0026amp; temp; board[idex][jdex] = word[kdex]; } return res; } }; 网站里有个一样的思路，时间和空间复杂度差不多，但是可以看一下是怎么简化代码的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { rows = board.size(); cols = board[0].size(); for(int i = 0; i \u0026lt; rows; i++) { for(int j = 0; j \u0026lt; cols; j++) { if(dfs(board, word, i, j, 0)) return true; } } return false; } private: int rows, cols; bool dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word, int i, int j, int k) { if(i \u0026gt;= rows || i \u0026lt; 0 || j \u0026gt;= cols || j \u0026lt; 0 || board[i][j] != word[k]) return false; if(k == word.size() - 1) return true; board[i][j] = \u0026#39;\\0\u0026#39;; bool res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1); board[i][j] = word[k]; return res; } }; 《回溯法》这个方法的思想比较重要，这边上图，实际上效果时间：87 61是目前最好的但是我觉得还是不太行。\n深度每增加一层，即说明匹配到了一个新的字符。使用迭代器指向word.begin()，深度每增加一层，令迭代器向前移动一个位置。如果该层找不到可行的路径，回溯到父节点，深度减小，迭代器也要后退一个位置，如果在搜索的过程中迭代器指向了word.end()，说明找到了可行路径，返回true，搜索结束。如果搜索了整个解空间树也没有找到可行路径，说明没有可行路径，返回false，搜索结束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public: bool findpath(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, const string\u0026amp; word, vector\u0026lt;bool\u0026gt;\u0026amp; visited, int row, int column, string::iterator\u0026amp; itr) { if (itr == word.end()) //到达字符末尾，匹配成功 return true; if (row \u0026lt; 0 || row \u0026gt;= board.size() || column \u0026lt; 0 || column \u0026gt;= board[0].size()) //如果坐标不在矩阵范围内 return false; //返回false bool haspath = false; //标记子节点是否含有下一个字符 int columns = board[0].size(); //矩阵的列数 //cout \u0026lt;\u0026lt; row \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; column \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; *itr \u0026lt;\u0026lt; endl;\t//大家可以使用cout来查看每一步访问节点的位置，便于理解 if (!visited[row * columns + column] \u0026amp;\u0026amp; board[row][column] == *itr) //当前位置未被访问，且当前位置可以和字符串匹配上 { ++itr; //迭代器后移一个字符 visited[row * columns + column] = true; //标记为以访问，防止该节点的子节点再将该节点加入其子节点 haspath = findpath(board, word, visited, row, column - 1, itr) //左边是否有路径 || findpath(board, word, visited, row, column + 1, itr) //右边是否有路径 || findpath(board, word, visited, row - 1, column, itr) //上边是否有路径 || findpath(board, word, visited, row + 1, column, itr); //下边是否有路径 if (!haspath) //如果子节点没有路径，则说明从当前节点不可能找到路径，回溯 { --itr; //迭代器回退 visited[row * columns + column] = false; //将该节点标记为未访问，方便其他节点再进行访问 } } return haspath; //返回结果 } bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string\u0026amp; word) { if (!word.size()) //所给的word为空 return true; //获得矩阵的行列数 unsigned int rows = board.size(), columns = board[0].size(); for (int i = 0; i \u0026lt; rows; ++i) for (int j = 0; j \u0026lt; columns; ++j) { if (board[i][j] == word[0]) //找到可行节点位置 { auto itr = word.begin(); vector\u0026lt;bool\u0026gt; visited(rows * columns, false); //标记节点是否被访问 if (findpath(board, word, visited, i, j, itr)) //从该节点出发寻找到了路径 return true; } } return false; //所有可能的路径都找了也没到找，返回false } }; 回溯法：机器人的行走路线（13） 问题：这题首先特别重要的一定要理解正确题目的意思，我首先就把题目搞错了，K指的并不是行走的步数，实际上只是一个相应的约束条件，理论上是制定了k但是机器人可以走无数步这样的情况。\nDFS、BFS 师兄说的循环数组我得想一下是为什么是，或者看下书。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { private: int subsum(int x) { // NOTE:这个写法要注意对for循环有一个好的理解，知道到底是象征什么意思。还有第一项空置的含义 int res = 0; for (; x; x /= 10) { res += x % 10; } return res; } public: int movingCount(int m, int n, int k) { // 整理思路重新出发 //NOTE:定义vector的初始化长度，防止vector队内存的动态再分配来影响运行时间 // (length, value) if (!k) return 1; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(m, vector\u0026lt;bool\u0026gt;(n, 0)); // 起始点初始化 int ans = 1; visited[0][0] = 1; // 循环递推,中间需要嵌入是否满足条件的判断。 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { // NOTE:排除边界和不可访问点。当已经访问过的时候直接,但是实际上能不能用跳出的处理呢 if (i == 0 \u0026amp;\u0026amp; j == 0 || subsum(i) + subsum(j) \u0026gt; k) continue; // 排除不可达的情况，由于我们是前向遍历，我们只需要考虑他的前一个或者上一个能到达，才行。 // 这个理论可以好好的分析一下。这样的话，实际上还是有切断的处理的把。（前一个和上一个都就直接换行之类的？） if (i - 1 \u0026gt;= 0 \u0026amp;\u0026amp; visited[i - 1][j]) { visited[i][j] = true; ans += 1; } else if (j - 1 \u0026gt;= 0 \u0026amp;\u0026amp; visited[i][j - 1]) { visited[i][j] = true; ans += 1; } else continue; } } return ans; } }; 动态规划与贪婪算法：剪绳子v1.v2(14/15) 动态规划的基本解法：将问题归化成更小的存在最优情况的子问题。\n在解答问题的时候我们会发现一些重要的点：\n初始的启动量怎么界定？（因为不是每一步都要迭代到底的，所以会出现一些特殊的情况）\n将问题归化到最底层，我们会发现有一些长度如果切分了，相应对乘积的贡献会小于不切分本身的贡献，这种值就是初始的启动量，他们不切分是最好的，在这道题中的体现就是0,1,2,3,4(特殊分界点，切分与否是一致的，)\n初始的特殊情况直接输出\n时间空间复杂度分析：从算法中很容易知道是n^2/2\n我的算法实现（存在问题已解答）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int cuttingRope(int n) { // 这里是特殊的一些情况， if(n\u0026lt;2) return 0; else if(n == 2) return 1; else if (n==3) return 2; // 每一段的长度都需要是整数。 // 初始化结果矩阵:要记得index和绳子的长度有加一的关系,先修改成直接对应的关系好了 // FIXME: 有一点重要的在于，我们不是每一步都要迭代到底，切割本身就是一种分别情况。 // TODO：这个初始值设置怎么界定？ vector\u0026lt;int\u0026gt; maxarray(n+1, 0); maxarray[0] = 0; maxarray[1] = 1; maxarray[2] = 2; maxarray[3] = 3; // bottom-up的循环 for (int i = 4; i \u0026lt;= n; i++) { int maxres = 1; // 每个数值的全部情况,由于是bottom-up的动态规划，不用担心下面迭代上来的情况没有值 for (int j = 1; j \u0026lt;= i / 2; j++) { int tmp = maxarray[j]*maxarray[i=j]; if(tmp \u0026gt;maxarray[i]){ maxarray[i] = tmp; } } } return maxarray[n]; } 使用贪婪的解法来解决这个问题\n从上面的分析我们知道，我们最好是将每一段都切分到2、3，4的情况，这样的话，能节省计算量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 但是我们发现这样的算法的时间效率并没有变高，这是因为这个多重判断的时间复杂度的问题吗，不应该啊。 int cuttingRope(int n) { if(n \u0026lt;= 3) return n-1; int times; if (n%3==1) { times = n/3 -1; return pow(3,times)*4; } else if(n%3==2) { times = n/3; return pow(3,times)*2; } times = n/3; return pow(3,times); } 而通过循环减的方法，我们发现时间复杂度突然小了很多，这是为啥，这是因为在普遍size的情况下，执行了过多的判断吗？ 所以最终选用的方法还是下面这种把？ int cuttingRope(int n) { if(n \u0026lt;= 3) return n-1; int res = 1; while(n \u0026gt; 4) { n = n - 3; //尽可能地多剪长度为3的绳子 res = res * 3; } return res * n; } 改进判断过多的情况： int cuttingRope(int n) { if(n \u0026lt;= 3) return n-1; int times = n/3; int remain = n-3*times; if(remain == 1) return pow(3,times-1)*4; return pow(3,times)* remain?pow(3,times)*remain:pow(3,times); } 位运算：二进制中的1的个数 在这里需要掌握所有二进制运算的基本概念，与或非以及移位操作，还有异或操作；\n知道要掌握啥就可以了具体的接替思想的话后续看书就可以，实现代码如下。算法的时间效率貌似和网友还有一定的差距后续再慢慢看吧，我觉得这样已经差不多了，主要在于思想上的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int hammingWeight(uint32_t n){ // 三种写法，实际上1-2是一类，所以写两种就好了。 // uint32_t i = 1; // int count = 0; // while(i){ // if (n\u0026amp;i) // count++; // i = i\u0026lt;\u0026lt;1; // 别忘了这个赋值 // } // return count; // method 3 unsigned int count = 0; while(n){ n = n \u0026amp; (n-1); ++count; } return count; } 高质量的代码 代码的完整性：数值的整数次方 这一题有一些特别需要注意的点：\n当指数小于1的情况，（在这种情况下底数为0的情况） 使用指数的方法（2分）实现快速的指数计算 -INTMIN的问题，因为0占了一位，所以int下界无法直接去abs，需要进行一个类型转换再进行取负 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: double myPow(double x, int n) { // FIXME：当指数小于等于0的时候 // FIXME：当上述情况的时候底数为0的情况 if(!x) return 0; else if(!n || x==1.0) return 1; else if (n\u0026lt;0){ // 转化为正指数来做 double tmpx = 1.0/x; // FIXME: INT_MIN 因为有个占位，所以取个反可能会越界，所以这里一定要是比int长的变量，而且不能在这里直接取反 // 需要等到变换类型以后再取反 unsigned int absExp = (unsigned int)(n); return normalPow(tmpx,-absExp); } else{ return normalPow(x,n); } } double normalPow(double x, unsigned int n) { // 这是最简单的写法，但是实际上我们可以利用乘方的性质； // TODO: 可以通过指数型的来缩减计算量。（看看有没有必要把） // 有的，不考虑的话时间限制太离谱了。 if(n == 1) return x; if(n == 0) return 0; double res = normalPow(x,n\u0026gt;\u0026gt;2); res *= res; if (1\u0026amp;n) res = res * x; return res; } }; 拓展一个网友的写法，虽然效果没有我的好，但是还是权当作一个参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: double myPow(double x, int n) { if(x == 1 || n == 0) return 1; double ans = 1; long num = n; if(n \u0026lt; 0){ num = -num; x = 1/x; } while(num){ // 主要是这里的解题思路有点那什么意思 if(num \u0026amp; 1) ans *= x; x *= x; num \u0026gt;\u0026gt;= 1; } return ans; } }; 解决面试题的思路 offer29 顺时针读取列表 这题主要看怎么分析问题的吧，我再这题里面的height 和width写反了，有心情的时候改一下，具体的思路如图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { vector\u0026lt;int\u0026gt; res; if(matrix.empty()) return res; // 初始参数设置 bool ishori = false; // 先执行水平的 height才是水平 int offset_x=0,offset_y=0,xi=0,yi=-1; int width=matrix.size(), height=matrix[0].size(); // 水平和垂直写反了， while(width-offset_x \u0026amp;\u0026amp; height-offset_y){ int step = 0; if(ishori){ while(step\u0026lt;width-offset_x){ xi = offset_x%2!=0? xi+1: xi-1; // 基于就奇偶判断给xi上偏移量 res.push_back(matrix[xi][yi]); step++; } ishori = false; offset_y++; // 基于就奇偶判断给yi上偏移量 // yi = offset_x%2==0? yi+1:yi-1; }else{ while(step\u0026lt;height-offset_y){ yi = offset_y%2==0? yi+1: yi-1; // 基于就奇偶判断给yi上偏移量 res.push_back(matrix[xi][yi]); step++; } ishori = true; offset_x++; // xi = offset_y%2!=0? xi-1:xi+1; // 基于就奇偶判断给xi上偏移量 } } return res; } }; 排序搜索统计算法（时间效率那一节） offer 48滑动窗口算法解决，contain和index都需求的问题。 看看网友的解答，已经整理到代码文件中了。\n《LeetCode》 刷题锻炼手感和了解题目设置和题库；\n经典类型题（后续归纳） 最长回文子串（了解一下马拉车）（5） 关键点都在代码块里 cankao 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: string longestPalindrome(string s) { // 这题实际上也能用动态规划来解答，但是这题的动态规划效果一般 // TODO：我们也可以用马拉车算法解决学习一下 // 我们python中写的是什么玩意，我有点没看懂，后面再看看是怎么做的,我觉得可以不用看，思路太傻逼了。但是可以分析测试样例。 //使用简单的递归思想用双指针的方式来解决奇偶不同的情况 string res; for(int i=0;i\u0026lt;s.size();i++) { string S1 = findPalindrome(s,i,i); string S2 = findPalindrome(s,i,i+1); res = res.size()\u0026gt;S1.size()?res:S1; res = res.size()\u0026gt;S2.size()?res:S2; } return res; } string findPalindrome(const string\u0026amp; s, int l, int r) { while(l\u0026gt;=0 \u0026amp;\u0026amp; r\u0026lt;s.size() \u0026amp;\u0026amp; s[l]==s[r]) { l--;r++; } // substr 参数是起始点和长度 return s.substr(l+1,r-1-l); } }; 打印从1到n的最大的n位数（17） 这一题实际上的亮点在于考虑大数问题，显然n位数，这个就是一个很容易溢出的条件，n稍微大点就超出了int的边界范围。\n首先不考虑的话（找工作的时候千万不要这么写）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; printNumbers(int n) { // 书上的方法我已经完全掌握了，但是问题在于这一题要返回整数列表，这就不太对进把， if (n \u0026lt;= 0) return vector\u0026lt;int\u0026gt;(0); int nums = 1; for (int i = 0; i \u0026lt; n; i++) { nums *= 10; } vector\u0026lt;int\u0026gt;res(nums-1, 0); for (int i = 0; i \u0026lt; nums-1; i++) { res[i] = i + 1; } return res; } }; 大数问题后面复习的时候来进行联手\n实际上有两种解法，基本就是看书去实现一下，这里后面再来写就行了。\nLEETCODE 用字符串模拟数组（+，-，输出问题）其中的print我觉得用stoi可能就可以轻松解决了，可能不需要重新编写 全排列问题 表示数值的字符串（20） 这一题简直恶心人，除了书上提到的那些东西，还有一些其他的恶心人的情况。比如\n\u0026quot; 0 \u0026quot; \u0026ldquo;3.\u0026rdquo; \u0026ldquo;3. \u0026quot; \u0026ldquo;46.e3\u0026rdquo; \u0026ldquo;.e1\u0026rdquo;\n最终的实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class Solution { public: bool isNumber(string s) { // 实际上要考虑的特殊value只有 + - E e . // 经过 + - E的以后，还是能接受一样的类型，但是没办法进行同样的符号判断了，就是不能重复出现 // FIXME：可以使用递进的方法，也就是将前面的数字一个个吞掉，这样就不用考虑到重复判断的问题了，只需要进行函数的调用 // 但是经过.后，就什么符号都不能出现了，只能是纯整数。 if(s.empty()) return false; int index = 0; bool cures; // 前面是\u0026#39; \u0026#39;的情况 while(index\u0026lt;s.size()){ if(s[index]==\u0026#39; \u0026#39;) index++; else break; } cures = isInteger(s,index); if(s[index] == \u0026#39;.\u0026#39;) { // 以.开头的到底算不算呢？ // 那以.结尾的呢？ // .e 也算，那我tmd 不是白写了，我觉得这题有病。 index++; if (index != s.size()){ //\u0026#34;. \u0026#34;的情况 if(s[index] == \u0026#39; \u0026#39;){ while(index\u0026lt;s.size()){ if(s[index]==\u0026#39; \u0026#39;) index++; else return false; } } // .e（的情况） else if(s[index] == \u0026#39;e\u0026#39; || s[index]== \u0026#39;E\u0026#39;) cures = cures \u0026amp;\u0026amp; isInteger(s,++index); // \u0026#39;.的普通情况\u0026#39; else cures = isUnsignedInteger(s,index); } // ’.直接结束的情况‘ else return cures; } if(s[index] == \u0026#39;e\u0026#39; || s[index] == \u0026#39;E\u0026#39;) { index ++; cures = cures \u0026amp;\u0026amp; isInteger(s, index); } // 遍历完了才算完事儿 // 后面是’ ‘的 while(index\u0026lt;s.size()){ if(s[index]==\u0026#39; \u0026#39;) index++; else break; } return cures \u0026amp;\u0026amp; index == s.size(); } bool isUnsignedInteger(string\u0026amp; s, int\u0026amp; index){ // 判断是不是纯整数，用于.后的情况 // 通过数值的ascii码，转化为数字的大小来进行比较,而且\\0不会包含在string的size里面 int begin = index; for (;index\u0026lt;s.size();index++){ if(s[index]\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[index]\u0026lt;=\u0026#39;9\u0026#39;){} else break; // 这里直接return好不好呢，因为后续的话还要加入额外的判断。 } return index\u0026gt;begin; } bool isInteger(string\u0026amp; s, int\u0026amp; index){ // 考虑包含 + - 符号 if (s[index] == \u0026#39;+\u0026#39; || s[index] == \u0026#39;-\u0026#39;) index++; return isUnsignedInteger(s,index); } }; 拓展：char和int的转化关系 实际上我们可以通过 i+'0'将int之类的类型转换为char的数字，因为这实际上是对应的ASCII的加减，然后会执行隐式的类型变换，将其变换为char类型的值把。\n总结：链表删除的形式 通常情况下内容覆盖这种操作应该是不被允许的把，但是it depends,比如18题就是这样去实现的 到底是把原指针delete掉来作为删除的凭据，还是直接指向nullptr，在原本的一开始的题目中，好像都是指向了nullptr，但是又有遇到一些是需要delete的。后续总结一下 顺带GIT知识扩充（后续迁移） 基本的workflow 使用的一些KeyPoint 用rebased 代替merge： 其实就是merge对分支的处理比较不友好，可能需要我们进行手动的删除，而rebased就是直接进行重构，具体的操作如下：\n首先，找到这两条分支的最近公共祖先LCA，然后从master节点开始，重演LCA到dev几个commit的修改，如果这些修改和LCA到master的commit有冲突，就会提示你手动解决冲突，最后的结果就是把dev的分支完全接到master上面。\n","permalink":"https://hugotest-phi.vercel.app/posts/intview_%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","summary":"\u003chead\u003e\r\n    \r\n    \u003cscript src=\"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\r\n\r\n\r\n\r\n\r\n\u003cdiv class=\"hugo-encryptor-container\"\u003e\r\n  \u003cdiv class=\"hugo-encryptor-prompt\"\u003e\r\n    \r\n      \u003cp\u003e文章的部分内容被密码保护：\u003c/p\u003e\r\n    \r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"hugo-encryptor-form\"\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-input\"\r\n      placeholder='请输入密码'\r\n    /\u003e\r\n    \u003cinput\r\n      class=\"hugo-encryptor-button\"\r\n      type=\"button\"\r\n      value='CLICK'\r\n      onclick=\"_click_handler(this)\"\r\n    /\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\r\n    class=\"hugo-encryptor-cipher-text\"\r\n    data-password=\"aikenhong_blog\"\r\n    style=\"display: none;\"\r\n  \u003e\r\n    \u003cspan style=\"display: none;\"\u003e--- DON'T MODIFY THIS LINE ---\u003c/span\u003e\r\n    \u003cp\u003e@Aiken 2021;\u003c/p\u003e\n\u003cp\u003e汇总LeetCode刷题以及刷《剑指offer》过程中遇到的一些不会做的题或者启发性很强的题目等等；内容主要以以下几个方面为主：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e题目-题解-相关注释；\n\u003cul\u003e\n\u003cli\u003e相关难点分析；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e相关知识点索引\n同时copy到数据结构或者c++的文档中）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"fuck-algorithm\"\u003e《Fuck Algorithm》\u003c/h2\u003e\n\u003cp\u003e针对各个专题指向性的去刷一些Leetcode中的题目，通过对这些题目进行分析整合来对巩固各个知识点，这一部分的代码整合到/leecode文件夹中，但是主要可能整合在md中；\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e这里可以顺便把git的内容整理一下，本地的git操作流程\u003c/li\u003e\n\u003cli\u003e最近先把数据结构刷了，变刷变看后面的搜索等等的内容，一部分一部分的往后看\u003c/li\u003e\n\u003cli\u003e第一课中回溯和其他规划的题还没看，后续再看看\u003c/li\u003e\n\u003cli\u003e思考C++中多返回值的设计\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"数据结构的存储方式\"\u003e数据结构的存储方式\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://labuladong.github.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95.html\" target=\"_blank\" rel=\"noopener\"\u003e\u003cstrong\u003e数据结构的存储方式\u003c/strong\u003e\u003c/a\u003e\n（物理层面的存储方式）：数组（顺序存储）和链表（链式存储）。\n最底层的存储架构上基本上只有这两种实现的方式，更高维的才是：栈、队列、堆、树、图这些高层结构；\u003c/p\u003e\n\u003cp\u003e而这些实现的高层实现上，分别使用量中架构有啥优缺点：\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cblockquote\u003e\n\u003cp\u003e综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，\u003cstrong\u003e二者的优缺点如下\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e数组\u003c/strong\u003e由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e链表\u003c/strong\u003e因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"二分查找专题\"\u003e二分查找专题\u003c/h3\u003e\n\u003cp\u003e由于我经常写错二分查找的边界判断条件，所以这里进行一个整理操作：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==\u0026amp;mid=2247485044\u0026amp;idx=1\u0026amp;sn=e6b95782141c17abe206bfe2323a4226\u0026amp;chksm=9bd7f87caca0716aa5add0ddddce0bfe06f1f878aafb35113644ebf0cf0bfe51659da1c1b733\u0026amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\"\u003e二分查找总结专题\u003c/a\u003e\n  后续整理的时候在进行阅读一下，加深一下理解\u003c/p\u003e\n\u003cp\u003e其中需要注意的是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我们使用 left+(right-left) /2 来代替 (l+r)/2 ,因为这样的话可以防止right和left太大溢出的操作；\u003c/li\u003e\n\u003cli\u003emid +- 1 以及最终的返回条件 \u0026lt;= 还是小于\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们分情况来讨论：\u003c/p\u003e\n\u003cp\u003e求的是特定值，求的是左右的边界值的时候，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e55\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ebinary_search\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elength\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e// 直接返回\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 直接返回\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eleft_bound\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elength\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e// 别返回，锁定左侧边界\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 最后要检查 left 越界的情况\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elength\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eright_bound\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elength\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e// 别返回，锁定右侧边界\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 最后要检查 right 越界的情况\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"数据结构的基本操作\"\u003e数据结构的基本操作\u003c/h3\u003e\n\u003cp\u003e所有数据结构的基本操作一般都局限在 \u003cstrong\u003e遍历+访问\u003c/strong\u003e，更具体一点就是：\u003cstrong\u003e增删改查\u003c/strong\u003e；\u003c/p\u003e","title":"Leetcode 刷题笔记"},{"content":"主要介绍ssh服务在以下的几个方面（windows，linux）的使用情况：远程服务器连接（22），git\u0026amp;github（gitee），vscode免密登录。\nssh-key GITHUB关于SSH的教程 👈可以直接切换成中文模式的\n查看是否已存在\n1 ls -al ~/.ssh **初始化 / 生成 ssh key **\n1 2 3 4 5 6 # github 推荐，优先度从上到下递减 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # if not support ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; # tradition ssh-keygen -t rsa -C \u0026#34;chenlangl@outlook.com\u0026#34; 将ssh添加到github的个人权限界面中\n免密登录\n在github的教程中也有另一种方式来实现免密登录，好像是ssh-agent的方式安全的保存密码。\nLinux 开放ssh远程权限 参考资料：设置sshd配置文件 | 允许passwd登录root 在开放远程权限之前，首先检查 ssh 服务是否已经启动/安装：\n1 2 # Ps检查相关进程是否启动 ps aux | grep ssh 如果没有启动相关进程，可以检查一下是否存在相关服务：\n1 2 3 # 重启ssh服务，下面是两种不同linux的写法 service ssh restart systemctl restart sshd.service 如果也没有相关服务，需要在设备上先安装相关服务：\n1 2 # 如果安装失败，可以尝试先更新apt， sudo apt-get update sudo apt-get install openssh-server 服务安装完成后，需要修改一下默认配置，默认配置中可能会关闭允许密码登录等相关项：\n1 2 3 4 # 按照如下入境编辑相关配置文件（非重新生成） vim /etc/ssh/sshd_config # 也有可能是下面这个文件名 vim /etc/ssh/ssh_config 检查以下几项（取消注释，NO 改为 YES，添加项）是否符合预期：\nPasswordAuthentication yes # 新建或注释，启用密码登录\rPermitRootLogin prohibit-password # 若存在则注释掉该行\rPermitRootLogin yes # 新建/取消注释\rPubkeyAuthentication yes # [option]启用秘钥登录，用于免密认证 确保配置无误后，重启 SSH 服务，应该就可以通过 SSH 访问相关设备（ssh 的默认端口号为 22）\n1 2 3 # 重启ssh服务，下面是两种不同linux的写法 service ssh restart systemctl restart sshd.service 设置 ssh 服务开机自启（这里介绍 docker 版本的开机自启，）\nvim /root/.bashrc 在.Bashrc 的末尾添加以下代码\n1 service ssh start 重启测试。\n如果是宿主机上直接设置开机自启可使用\n1 sudo systemctl enable ssh 还有一种方式是使用开机自动挂载 一文中的办法，手动编写启动脚本实现。\nGit\u0026amp;Github 官方文档介绍的一些权限错误的地址：https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey\n初始化git的用户配置，可以按照电脑id来进行命名其实区分起来还是好弄一些。\n1 2 3 git config --global user.name \u0026#34;YOURNAME\u0026#34; git config --global user.email YOUEMAILADRESS git config --list 将本机的ssh公钥(public)放到GITHUB账户下的ssh管理地址，执行测试\n1 ssh -T git@github.com 没有问题的话就可以直接进行clone，之类的git操作了\n1 2 // 小trick，不拉取历史的commit git clone --depth=1 REPO_ADRESS ssh 免密认证 windows(Local) - Linux(Services) :Link1 Pro 实际上不光是VsCode，可以在本机上通过ssh服务免密登录服务器了，这一块好像可以通过公钥和私钥两种方式来做，在这里我们首先使用公钥来测试成功。\n具体的操作如下：\n1 2 3 4 5 6 7 8 9 cd ~/.ssh # 创建authorized_kes 在其中填入我们需要远程登录的服务器的ssh pub key，在这里就是windows本机的。 touch authorized_kes # 修改权限 sudo chmod 600 authorized_kes sudo chmod 700 ~/.ssh/ 然后检查密钥登录的功能是否开启\n1 2 # 改相应的ssh配置文件 vim ./etc/ssh/sshd_config 查看其中以下的配置项是否打开：\n#RSAAuthentication yes\r#PubkeyAuthentication yes 可以禁用密码登录，但是这样的方式可能会导致后面挂了以后直接GG，所以慎重。\n重启服务\n1 2 3 service ssh restart # or systemctl restart sshd.service ","permalink":"https://hugotest-phi.vercel.app/posts/ssh/","summary":"\u003cp\u003e主要介绍ssh服务在以下的几个方面（windows，linux）的使用情况：远程服务器连接（22），git\u0026amp;github（gitee），vscode免密登录。\u003c/p\u003e\n\u003ch2 id=\"ssh-key\"\u003essh-key\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://docs.github.com/en/github/authenticating-to-github/checking-for-existing-ssh-keys\" target=\"_blank\" rel=\"noopener\"\u003eGITHUB关于SSH的教程\u003c/a\u003e\n 👈可以直接切换成中文模式的\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e查看是否已存在\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003els -al ~/.ssh\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e**初始化 / 生成 ssh key **\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# github 推荐，优先度从上到下递减\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -t ed25519 -C \u003cspan class=\"s2\"\u003e\u0026#34;your_email@example.com\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# if not support \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -t rsa -b \u003cspan class=\"m\"\u003e4096\u003c/span\u003e -C \u003cspan class=\"s2\"\u003e\u0026#34;your_email@example.com\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# tradition\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -t rsa -C \u003cspan class=\"s2\"\u003e\u0026#34;chenlangl@outlook.com\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e将ssh添加到github的个人权限界面中\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e免密登录\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在github的教程中也有另一种方式来实现免密登录，好像是ssh-agent的方式安全的保存密码。\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"linux-开放ssh远程权限\"\u003eLinux 开放ssh远程权限\u003c/h2\u003e\n\u003cp\u003e参考资料：\u003ca href=\"http://frantic1048.logdown.com/posts/291498-resolve-the-ssh-password-is-correct-but-was-refused-connection\" target=\"_blank\" rel=\"noopener\"\u003e设置sshd配置文件\u003c/a\u003e\n | \u003ca href=\"https://www.cnblogs.com/zqifa/p/linux-ssh-2.html\" target=\"_blank\" rel=\"noopener\"\u003e允许passwd登录root\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e在开放远程权限之前，首先检查 ssh 服务是否已经启动/安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Ps检查相关进程是否启动\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eps aux \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep ssh\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果没有启动相关进程，可以检查一下是否存在相关服务：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 重启ssh服务，下面是两种不同linux的写法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eservice ssh restart\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemctl restart sshd.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果也没有相关服务，需要在设备上先安装相关服务：\u003c/p\u003e","title":"SSH 常用场景和操作"},{"content":"疑似 M. Suwa, N. Sugie and K. Fujimora, \u0026ldquo;A Preliminary Note on Pattern Recognition of Human Emotional Expression\u0026rdquo;, Proc. Int\u0026rsquo;l Joint Conf. Pattern Recognition, pp. 408-410, 1978.\nK. Scherer and P. Ekman, Handbook of Methods in Nonverbal Behavior Research., 1982.\nJ.M. Carroll and J. Russell, \u0026ldquo;Facial Expression in Hollywood\u0026rsquo;s Portrayal of Emotion\u0026rdquo;, J. Personality and Social Psychology, vol. 72, pp. 164-176, 1997.\nStandardization and Assessment of College Students\u0026rsquo; Facial Expression of Emotion.\n好像是评估表情标注的，\nUniversals and cultural differences in the judgments of facial expressions of emotion 不同文化下的表情对应情感的认知\nClassifying Emotion based on Facial Expression Analysis using Gabor Filter: A Basis for Adaptive Effective Teaching Strategy\n确信 Facial Expression Analysis 这篇的introduction里面有好几篇\nEkman P. Facial expression and emotion[J]. American psychologist, 1993, 48(4): 384.\nKeltner D, Ekman P, Gonzaga G C, et al. Facial expression of emotion[J]. 2003.\n上面这两篇的引用里应该能找到特别多\nXu R, Chen J, Han J, et al. Towards emotion-sensitive learning cognitive state analysis of big data in education: deep learning-based facial expression analysis using ordinal information[J]. Computing, 2019: 1-16.\n估计是类似的研究，看标题感觉就是类似的\n","permalink":"https://hugotest-phi.vercel.app/posts/facial_expression_and_emotion/","summary":"\u003ch2 id=\"疑似\"\u003e疑似\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eM. Suwa, N. Sugie and K. Fujimora, \u0026ldquo;A Preliminary Note on Pattern Recognition of Human Emotional Expression\u0026rdquo;, \u003cem\u003eProc. Int\u0026rsquo;l Joint Conf. Pattern Recognition\u003c/em\u003e, pp. 408-410, 1978.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eK. Scherer and P. Ekman, \u003cem\u003eHandbook of Methods in Nonverbal Behavior Research.\u003c/em\u003e, 1982.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eJ.M. Carroll and J. Russell, \u0026ldquo;Facial Expression in Hollywood\u0026rsquo;s Portrayal of Emotion\u0026rdquo;, \u003cem\u003eJ. Personality and Social Psychology\u003c/em\u003e, vol. 72, pp. 164-176, 1997.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eStandardization and Assessment of College Students\u0026rsquo; Facial Expression of Emotion.\u003c/p\u003e","title":"Related Word of Emotion"},{"content":"fGAN 对GAN理论的深度理解 @Aiken 2021 onenote部分的拓展编写，到时候拷过去，整合在一起。\nfGAN: 不只是JS-Div散度，我们可以将所有的散度都应用到GANs的框架中。该部分的阅读是对GAN的基本理论最重要的文章之一。\n基本理论体系和推演 首先给出fGAN中提出的基本理论：可以将所有的Div放入GANs的框架中，来做那个核心的关键演化判别指标：\n$$ D_{f}(P||Q) = \\int_xq(x)f(\\frac{p(x)}{q(x)}dx)\r$$\r上述公式将衡量P和Q两个分布之间的差距，公式中的 $f$ 可以是很多不同的版本，但是要求满足如下的两个条件：\n是一个凸函数； $f(\\frac{(x1+x2)}{2})\\leq \\frac{[f(x1)+f(x2)]}{2}$ ，需要注意国内外的凹凸相反 $f(1)=0$ 。 而我们知道 $q(x)$ 是概率密度分布函数，实际上可以看成凸函数性质的推广，所以我们可以证得：\n$$ D_{f}(P||Q) = \\int_xq(x)f(\\frac{p(x)}{q(x)}dx) \\geq\rf(\\int q(x) \\frac{p(x)}{q(x)} dx) = f(1) = 0\r$$\r显然当我们取得合适的f，KL（ $f(x) = xlog(x)$ ）; ReverseKL( $-log(x)$ )；chi square ( $f(x) = (x-1)^2$ )；\nFenchel Conjugate共轭 补充Fenchel共轭的知识来对后续的fGAN推导进行补充，定理内容如下：\n每个凸函数都有一个对应的共轭函数读作 $f^*(x)$\n$$ f^*(x) = \\max \\limits_{x\\in dom(f)} xt - f(x)\r$$\rt是给定的，对于所有的变量t， $xt-f(x)$ 对应了无数条直线：\n举个例子 $f(x)=xlog(x)$ 时，我们可以将对应的 $f^*(x)$ 画出来。\n实际上就是对给定的t，求 $g(x)$ 共轭方程的最大值的过程，求个导，然后就可解得 $x-\u0026gt;t$ 然后带回就能得到共轭方程。\n介绍共轭方程主要是为了和 $f(x)$ 进行转化\n$$ f^{*}(t)=\\sup _{x \\in \\operatorname{dom}(f)}\\{x t-f(x)\\} \\quad \\Leftrightarrow \\quad f(x)=\\max _{t \\in \\operatorname{dom}\\left(f^{*}\\right)}\\left\\{x t-f^{*}(t)\\right\\}\r$$\rF-Div GAN推导 将转化方程带入，利用简单的不等式转化，我们就能将之前的F-Div转换为一个类似GAN的式子：\n$$ \\begin{aligned}\rD_{f}(P \\| Q) \u0026=\\int_{x} q(x) f\\left(\\frac{p(x)}{q(x)}\\right) d x \\\\\r\u0026=\\int_{x} q(x)\\left(\\max _{t \\in \\operatorname{dom}\\left(f^{*}\\right)}\\left\\{\\frac{p(x)}{q(x)} t-f^{*}(t)\\right\\}\\right) d x \\\\\r\u0026 \\geqslant \\int_{x} q(x)\\left(\\frac{p(x)}{q(x)} D(x)-f^{*}(D(x))\\right) d x \\\\\r\u0026=\\int_{x} p(x) D(x) d x-\\int_{x} q(x) f^{*}(D(x)) d x \\\\\r\u0026 \\approx \\max _{D} \\int_{x} p(x) D(x) d x-\\int_{x} q(x) f^{*}(D(x)) d x\r\\end{aligned}\r$$\r解释一下：第三行就是由于t是随便取值的；最后一行就是我们要求一个D使得式子最大，上界实际上就是第二行的式子。\n这样我们就能推导出F-Div的变体：\n$$ \\begin{aligned}\rD_{f}(P \\| Q) \u0026 \\approx \\max _{D} \\int_{x} p(x) D(x) d x-\\int_{x} q(x) f^{*}(D(x)) d x \\\\\r\u0026=\\max _{D}\\left\\{E_{x \\sim P}[D(x)]-E_{x \\sim Q}\\left[f^{*}(D(x))\\right]\\right\\}\r\\end{aligned}\r$$\r对于生成器来说，我们就是要找到一个PG使得：\n$$ \\begin{aligned}\rG^{*} \u0026=\\arg \\min _{G} D_{f}\\left(P_{\\text {data }} \\| P_{G}\\right) \\\\\r\u0026=\\arg \\min _{G} \\max _{D}\\left\\{E_{x \\sim P_{\\text {data }}}[D(x)]-E_{x \\sim P_{G}}\\left[f^{*}(D(x))\\right]\\right\\} \\\\\r\u0026=\\arg \\min _{G} \\max _{D} V(G, D)\r\\end{aligned}\r$$\r这样我们的推导过程就结束了，然后我们也可以使用更多的Div Function，使用不同的Div距离直接选择对应的函数就可以了。\nJS Div不是最佳的Div 由于分布的数据之间是没有重合的，使用JS Div的时候就很难衡量出他的距离，Equally Bad\n为什么如果两个分布完全没有重合的话，那么这两个分布的 JS Div 会是一样的?\n前面有提到，JS Div 是通过判别器计算出来的，而判别器的本质是二分类器，只要 $P_G$ 与 $P_{data}$ 完全没有重合，判别器就能 100%地鉴别出 $P_G(x)$ 与 $P_{data}(x)$ 的差异，因此二者的 JS Div 就是一样的。\nLSGAN最小二乘 解决的就是没有重合的问题，解决思路如下：让判别器始终都不能100%的鉴别出差异，这样就能保证在没有重合的时候也能分辨出差异程度。\n当我们的D太好的时候（能将数据完全分开）这种时候生成器就优化不了了，也是Equal Bad带来的最大问题。那么如果我们将最终的激活从sigmoid换成linear激活层，这样训练出来的D就会是一个线性的直线，\n这样只有当完全重合的时候D才会是一个没有梯度的直线，但是这个也并没有真正的解决这个问题，而只是绕开了这个问题。\n真正解决了这个核心问题的是下面的WGAN\nWasserstein-GAN 核心思想：用Wasserstrin距离（EM距离）取代JS距离\n","permalink":"https://hugotest-phi.vercel.app/posts/gans/","summary":"\u003ch1 id=\"fgan-对gan理论的深度理解\"\u003efGAN 对GAN理论的深度理解\u003c/h1\u003e\n\u003cp\u003e@Aiken 2021 onenote部分的拓展编写，到时候拷过去，整合在一起。\u003c/p\u003e\n\u003cp\u003efGAN: 不只是JS-Div散度，我们可以\u003cstrong\u003e将所有的散度都应用到GANs的框架\u003c/strong\u003e中。该部分的阅读是对GAN的基本理论最重要的文章之一。\u003c/p\u003e\n\u003ch2 id=\"基本理论体系和推演\"\u003e基本理论体系和推演\u003c/h2\u003e\n\u003cp\u003e首先给出fGAN中提出的基本理论：可以将所有的Div放入GANs的框架中，来做那个核心的关键演化判别指标：\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\nD_{f}(P||Q) = \\int_xq(x)f(\\frac{p(x)}{q(x)}dx)\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e上述公式将衡量P和Q两个分布之间的差距，公式中的 $f$ 可以是很多不同的版本，但是要求满足如下的两个条件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e是一个凸函数； $f(\\frac{(x1+x2)}{2})\\leq \\frac{[f(x1)+f(x2)]}{2}$ ，需要注意国内外的凹凸相反\u003c/li\u003e\n\u003cli\u003e$f(1)=0$ 。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e而我们知道 $q(x)$ 是概率密度分布函数，实际上可以看成凸函数性质的推广，所以我们可以证得：\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\nD_{f}(P||Q) = \\int_xq(x)f(\\frac{p(x)}{q(x)}dx) \\geq\r\nf(\\int q(x) \\frac{p(x)}{q(x)} dx) = f(1) = 0\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003e显然当我们取得合适的f，KL（ $f(x) = xlog(x)$ ）; ReverseKL( $-log(x)$ )；chi square ( $f(x) = (x-1)^2$ )；\u003c/p\u003e\n\u003ch3 id=\"fenchel-conjugate共轭\"\u003eFenchel Conjugate共轭\u003c/h3\u003e\n\u003cp\u003e补充Fenchel共轭的知识来对后续的fGAN推导进行补充，定理内容如下：\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e每个凸函数都有一个对应的共轭函数读作 $f^*(x)$\u003c/p\u003e\n\u003cdiv\u003e\r\n$$ \r\nf^*(x) = \\max \\limits_{x\\in dom(f)} xt - f(x)\r\n $$\r\n\u003c/div\u003e\r\n\u003cp\u003et是给定的，对于所有的变量t， $xt-f(x)$ 对应了无数条直线：\u003c/p\u003e","title":"GANs 01"},{"content":"\r👋 Hi there! I'm AikenHong.\r🚀 About Me I am a Machine Learning Engineer and passionate software developer, specializing in AI research, with a strong commitment to exploring the endless possibilities within the IT industry. I hold a master\u0026rsquo;s degree from Xi\u0026rsquo;an Jiaotong University.\nI am currently focused on AI and machine learning projects while diligently working to become a full-stack developer. My enthusiasm for exploring new worlds and concepts is fueled by my love for travel and immersive video games, which inspire my creativity and drive my eagerness to learn and try new things.\n🛠️ Skills \u0026amp; Tools Development Languages:\nMain: Python, C++, Bash Learning: JavaScript (HTML \u0026amp; CSS) Future Plans: Rust \u0026amp; Go Development Tools:\nOperating Systems: Mac, Windows, Linux IDEs: VSCode \u0026amp; Vim (Neovim) Terminal Emulators: Windows Terminal, WezTerm, iTerm 🎮 Fun Fact The strategy and perseverance needed in Souls-like games are traits I carry into my coding and research work. Just like in gaming, patience and creativity are key!\nFeel free to explore my repositories and connect with me for any collaboration. Let\u0026rsquo;s learn and innovate together!\n🔗 Connect with Me Fi. ","permalink":"https://hugotest-phi.vercel.app/about/","summary":"\u003cp align=\"center\"\u003e\r\n  \u003cimg src=\" https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/DSCF4104_%E5%89%AF%E6%9C%AC.JPG\" width=100%\u003e\r\n\u003c/p\u003e\r\n\u003cp align=\"center\"\u003e\r\n  👋 Hi there! I'm AikenHong.\r\n\u003c/p\u003e\r\n\u003ch3 id=\"-about-me\"\u003e🚀 About Me\u003c/h3\u003e\n\u003cp\u003eI am a Machine Learning Engineer and passionate software developer, specializing in AI research, with a strong commitment to exploring the endless possibilities within the IT industry. I hold a master\u0026rsquo;s degree from Xi\u0026rsquo;an Jiaotong University.\u003c/p\u003e\n\u003cp\u003eI am currently focused on AI and machine learning projects while diligently working to become a full-stack developer. My enthusiasm for exploring new worlds and concepts is fueled by my love for travel and immersive video games, which inspire my creativity and drive my eagerness to learn and try new things.\u003c/p\u003e","title":"About Me"},{"content":"@AikenHong 20200726\n基于YOLO v4 掌握一些CV方面训练的Trick，同时针对Typora的使用进行一个熟悉掌握。GITHUB CODE 一些相关的参考资料\n⚡️https://zhuanlan.zhihu.com/p/150127712\n⚡ 机器之心YOLOv4 ⚡️https://www.zhihu.com/question/390191723/answer/1177584901\n本文中一些其他的收获\n• 其他可替代的Object Detection的SOTA算法有哪些\n• BoS，BoF方法\n• 简直是一个Tricks的综述\nAbstract 本文对近期再CNN上的一些Feature方法进行了尝试组合，并实现了新的SOTA，其实就是一些通用的Trick的组合尝试，包括\n• 加权残差连接（WRC）\n• Cross-Stage-Partial-connection，CSP\n• Cross mini-Batch Normalization，CmBN\n• 自对抗训练（Self-adversarial-training，SAT）\n• Mish 激活（Mish-activation）\n• Mosaic 数据增强\n• DropBlock 正则化\n• CIoU 损失\n基于该文章我们可以了解一下这些方法的主要思路和后续的应用价值。YOLOv4 更快，更准确，只需要比较小的计算需求即可\nINTRODUCTION • 更快更强，从速度和准确率，以及训练需求上提升实际运用价值\n​\t这里有一些其他的SOTA可以列一下：EfficientDet、ATSS，ASFT，CenterMask\n• AP：平均准确率 FPS：每秒传输帧率嘛？\n主要贡献可总结如下\n建立了一个高效强大的目标检测模型。它使得每个人都可以使用 1080Ti 或 2080Ti 的 GPU 来训练一个快速准确的目标检测器。\n验证了当前最优 Bag-of-Freebies 和 Bag-of-Specials 目标检测方法在检测器训练过程中的影响。\nBag-of-freebies: 仅仅只增加training cost或者只改变training strategy的方法。典型例子：数据增强 bag-of-specials: 增加少量推理成本，但能提高准确率的**插件模块（****plugin modules）和后处理方法（post-processing method）**被称为BoS。\n修改了 SOTA 方法，使之更加高效，更适合单 GPU 训练。这些方法包括 CBN、PAN、SAM 等。\nPAN: Path aggregation network for instance segmentation\nSAM: CBAM: Convolutional block attention module\nRELATED WORK 基本架构\nobject detector 通常由backbone和head两部分构成，其中backbone是再imagenet上预训练的骨架\nGPU: VGG [68], ResNet [26], ResNeXt [86],or DenseNet [30] CPU: SqueezeNet [31], MobileNet[28, 66, 27, 74], or ShuffleNet [97, 53] head则是用来预测物体类别和边界框的网络架构\nOne-Stage: YOLO [61, 62, 63], SSD [50],and RetinaNet [45] Anchor-free：CenterNet [13], CornerNet [37, 38], FCOS [78], etc. Two-Stage: R-CNN [19] series: fast R-CNN [18], faster R-CNN [64], R-FCN [9],and Libra R-CNN [58] anchor-free: Rep-Points[87] 近年来在backbone和head之间插入neck用以收集不同stage的feature-maps FPN、PAN、BiFPN、NAS-FPN、etc.\nTo sum up, an ordinary object detector is composed of several parts:\nBag-of-freebies:\n仅仅只增加training cost或者只改变training strategy的方法。典型例子：数据增强\n目标检测中的多种数据增强：包括对图像遮挡的处理，随机擦除和基本的数据增强，也有feature map中类似的操作 解决数据存在偏差的问题：例如数据不平衡 BoundingBox回归方法：MSE-》IoU，也就是一些边界回归上的损失函数，CIoU、GIoU、DIoU、MSE等 Bag of specials\n增加少量推理成本，但能提高准确率的**插件模块（plugin modules）和后处理方法（post-processing method）**被称为BoS。\nPlugin modules：例如扩大接受域，引入注意力机制，增强特征集成能力等等，\npost-processing method：筛选预测结果的方法\n扩大接受域：SPP（将SPM集成到CNN中）、ASPP、RFB。\nAttention module：\nChannel-Wise：SE\nPoint-Wise：SAM\nfeature integration：\n将低层的物理特征集成到高层语义特征\nskip connection、hyper-column FPN出现后：SFAM、ASFF、BiFPN activation function： 解决softmax和sigmoid中出现的梯度消失问题：ReLU、LReLU、PReLU、ReLU6、SELU、Swish、hard-Swish、Mish post-process：\n– NMS用于处理预测同一对象的一些BBox，并保留响应速度更快的BBox\n– 还有一些相关变体\n– anchor-free的方法不需要这部分\nArchitecture 找到最优的input network resolution，conv layer number， the parameter number(filter size2 * filters * channel / groups) 以及 **the number of layer outputs(filters)**之间的最有平衡\n挑选能够增加感受域的额外单元（additional block），以及最佳参数聚合方法\nYoloV4 的基本目标是提高生产系统中神经网络的运行速度，同时为并行计算做出优化，而不是针对低计算量理论指标（BFLOP）进行优化。YoloV4 的作者提出了两种实时神经网络：\n（Backbone）\n• 对于 GPU，研究者在卷积层中使用少量组（1-8 组）：CSPResNeXt50 / CSPDarknet53；\n• 对于 VPU，研究者使用了分组卷积（grouped-convolution），但避免使用 Squeeze-and-excitement（SE）块。具体而言，它包括以下模型：EfficientNet-lite / MixNet / GhostNet / MobileNetV3。\n分类器和检测器需求上的区别：\n架构选择part1\nCSPDarknet53\u0026lt;-最终选择的一个较好的模型（backbone）\n在cspdarknet52上添加了spp block，用PANet取代v3中的FPN，yolov3作为head\n架构选择part2：selection of BoF or BoS\nCNN的优化通常有这几个方面：\nActivations: ReLU, leaky-ReLU, parametric-ReLU, ReLU6, SELU, Swish, or Mish Bounding box regression loss: MSE, IoU, GIoU,CIoU, DIoU Data augmentation: CutOut, MixUp, CutMix Regularization method: DropOut, DropPath [36], Spatial DropOut [79], or DropBlock Normalization of the network activations by their mean and variance: Batch Normalization (BN) [32], Cross-GPU Batch Normalization (CGBN or SyncBN) [93], Filter Response Normalization (FRN) [70], or Cross-Iteration Batch Normalization (CBN) [89]\nSkip-connections: Residual connections, Weighted residual connections, Multi-input weighted residual connections, or Cross stage partial connections (CSP) 架构选择Part3 ：额外的改进\n使得架构能够更适合在单个GPU上进行运算，设计了一些改进\n• 新的数据增强方法：mosaic \u0026amp;SAT（self-Adversarial Training）\n• 在遗传算法中使用了最佳的超参数\n• 修改SAM，PAN和CmBN使得设计适合更有效的训练和检测\nMosaic（马赛克）数据增强，把四张图拼成一张图来训练，变相的等价于增大了mini-batch。这是从CutMix混合两张图的基础上改进；\nMosaic数据增强\nSelf-Adversarial Training(自对抗训练)，这是在一张图上，让神经网络反向更新图像，对图像做改变扰动，然后在这个图像上训练。这个方法，是图像风格化的主要方法，让网络反向更新图像来风格化图像（对风格化感兴趣，可以看看我写的一篇介绍谷歌的一个实时任意风格化的文章 ）；对自身实行对抗攻击\n跨最小批的归一化（Cross mini-batch Normal），在CBN的基础上改进；\nBN, CBN，CmBN的对比\n修改的SAM，从SAM的逐空间的attention，到逐点的attention； [image: https://pic4.zhimg.com/50/v2-440bfacec2a426272ef06e94a16837bb_hd.jpg?source=1940ef5c]\nSAM和修改的SAM对比图\n修改的PAN，把通道从相加（add）改变为concat，改变很小； [image: https://pic4.zhimg.com/50/v2-a1f0ccf10cea594c1aebcc98111c6dd5_hd.jpg?source=1940ef5c][image: https://pic4.zhimg.com/80/v2-a1f0ccf10cea594c1aebcc98111c6dd5_720w.jpg?source=1940ef5c]\nPAN和修改的PAN\n最终整体架构表示：\nExperiments 实验中的一些参数设置和具体的表达就从文章中看吧，还有各种trick的表达效果,其实很重要，可以省下很多的研究时间。\n• Influence of different features on Classifier training\n• Influence of different features on Detector training\n• Influence of different backbones and pretrained weightings on Detector training\n• Influence of different minibatch size on Detector training\nFAQ\n• reception field 的理解，以及作用\n","permalink":"https://hugotest-phi.vercel.app/posts/cv-yolov4/","summary":"\u003cp\u003e@AikenHong 20200726\u003c/p\u003e\n\u003cp\u003e基于YOLO v4 掌握一些CV方面训练的\u003cstrong\u003eTrick\u003c/strong\u003e，同时针对Typora的使用进行一个熟悉掌握。\u003ca href=\"https://github.com/AlexeyAB/darknet\" target=\"_blank\" rel=\"noopener\"\u003eGITHUB CODE\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e一些相关的参考资料\u003c/p\u003e\n\u003cp\u003e⚡️https://zhuanlan.zhihu.com/p/150127712\u003c/p\u003e\n\u003cp\u003e⚡ \u003ca href=\"https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==\u0026amp;mid=2650785604\u0026amp;idx=1\u0026amp;sn=46bd186e5291deded9f6ec1ae6a22649\u0026amp;chksm=871a033ab06d8a2cff370a06e9e88f578a6c16a70231778ae2f997a8b30e347c6e746db10759\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=0429kHitmMCPeF2JGN1XCzik\u0026amp;sharer_sharetime=1588144165276\u0026amp;sharer_shareid=484a4a951d2ad320314b6b56ee9a0ba8\u0026amp;key=c53866ae67b2b8c4b46c89671357025dcdb6b895d1ebde603135230e484682a3552d924bf6126ecf72cb98361e1171f0f0381bee5bd456520dd201034c33ec48272d62ae73345cc914c2db9c6e943a10\u0026amp;ascene=1\u0026amp;uin=NTkyNDg4NjQw\u0026amp;devicetype=Windows\u0026#43;10\u0026#43;x64\u0026amp;version=62090070\u0026amp;lang=zh_CN\u0026amp;exportkey=ASfZUAGjes1A%2BJpXS1yNmT0%3D\u0026amp;pass_ticket=GB56ClnZIrs5ENfLSAh4yF9tj54n041FM39bTg38LQuW%2FKDyBPyfqKLD8SDIZgE%2F\" target=\"_blank\" rel=\"noopener\"\u003e机器之心YOLOv4\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e⚡️https://www.zhihu.com/question/390191723/answer/1177584901\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e本文中一些其他的收获\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e•  其他可替代的Object Detection的SOTA算法有哪些\u003c/p\u003e\n\u003cp\u003e•  BoS，BoF方法\u003c/p\u003e\n\u003cp\u003e•  简直是一个Tricks的综述\u003c/p\u003e\n\u003ch2 id=\"abstract\"\u003eAbstract\u003c/h2\u003e\n\u003cp\u003e本文对近期再CNN上的一些Feature方法进行了尝试组合，并实现了新的SOTA，其实就是一些\u003cstrong\u003e通用的\u003cstrong\u003e\u003cstrong\u003eTrick\u003c/strong\u003e\u003c/strong\u003e的组合\u003c/strong\u003e尝试，包括\u003c/p\u003e\n\u003cp\u003e•  加权残差连接（WRC）\u003c/p\u003e\n\u003cp\u003e•  Cross-Stage-Partial-connection，CSP\u003c/p\u003e\n\u003cp\u003e•  Cross mini-Batch Normalization，CmBN\u003c/p\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e•  自对抗训练（Self-adversarial-training，SAT）\u003c/p\u003e\n\u003cp\u003e•  Mish 激活（Mish-activation）\u003c/p\u003e\n\u003cp\u003e•  Mosaic 数据增强\u003c/p\u003e\n\u003cp\u003e•  DropBlock 正则化\u003c/p\u003e\n\u003cp\u003e•  CIoU 损失\u003c/p\u003e\n\u003cp\u003e基于该文章我们可以了解一下这些方法的主要思路和后续的应用价值。YOLOv4 更快，更准确，只需要比较小的计算需求即可\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n  \u003ca data-fancybox=\"gallery\" href=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210930165042.png\"\u003e\r\n    \u003cimg alt=\"image-20210930165040810\" loading=\"lazy\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210930165042.png\"class=\"responsive-image\" src=\"https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210930165042.png\" style=\"display: block; margin: 0 auto;\"\r\n      alt=\"image-20210930165040810\"  /\u003e\r\n  \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\u003cscript\u003e\r\n  document.addEventListener(\"DOMContentLoaded\", function() {\r\n      var images = document.querySelectorAll(\".responsive-image\");\r\n      var maxHeight = window.innerHeight / 2.5;\r\n      images.forEach(function(image) {\r\n          image.style.maxHeight = maxHeight + \"px\";\r\n      });\r\n  });\r\n\u003c/script\u003e\r\n\u003c/p\u003e","title":"YOLOv4 阅读笔记"},{"content":"参考资料：\n一些关于markdown语法的参考资料，但是实际上如果用Typora的话，有很多的语法是不需要记忆的，只需要稍微了解就可以了，更需要学习的其实是Latex的公式编写。\n基本语法：https://www.jianshu.com/p/191d1e21f7ed 进阶语法：https://blog.csdn.net/m0_37925202/article/details/80461714 其他语法：https://blog.csdn.net/cuishizun/article/details/80311673 目录：\nEditor [一些常用操作](#Some daily usage) 希腊字母表 Editor： Obsidian、Nvim、Typora：Notes的主力编写工具 VsCode：Readme文档 Jupyter：代码笔记编写的时候 Some daily usage： 操作名称 Typora VsCode 跳转 [button] (#name)-\u0026gt;# [button] (#name)-\u0026gt; \u0026lt;span id=\u0026ldquo;name\u0026rdquo;\u0026gt; 复选框 - [ ] - [ ] 希腊字母表： 序号 希腊字母 Markdoown 序号 希腊字母 Markdoown 1 α \\alpha 19 β \\beta 2 γ \\gamma 20 δ \\delta 3 Γ \\Gamma 21 Δ \\Delta 4 ε \\varepsilon 22 ϵ \\epsilon 5 ζ \\zeta 23 η \\eta 6 Θ \\Theta 24 ι \\iota 7 θ \\theta 25 κ \\kappa 8 Λ \\Lambda 26 λ \\lambda 9 μ \\mu 27 ν \\nu 10 ξ \\xi 28 ο \\omicron 11 Π \\Pi 29 ρ \\rho 12 π \\pi 30 τ \\tau 13 Σ \\Sigma 31 Φ \\Phi 14 σ \\sigma 32 ϕ \\phi 15 Υ \\Upsilon 33 Ψ \\Psi 16 υ \\upsilon 34 ψ \\psi 17 Ω \\Omega 35 ω \\omega 18 φ \\varphi 36 Ξ \\Xi ","permalink":"https://hugotest-phi.vercel.app/posts/markdown/","summary":"\u003cp\u003e\u003cstrong\u003e参考资料\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e一些关于markdown语法的参考资料，但是实际上如果用Typora的话，有很多的语法是不需要记忆的，只需要稍微了解就可以了，更需要学习的其实是\u003cstrong\u003eLatex的公式\u003c/strong\u003e编写。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e基本语法：https://www.jianshu.com/p/191d1e21f7ed\u003c/li\u003e\n\u003cli\u003e进阶语法：https://blog.csdn.net/m0_37925202/article/details/80461714\u003c/li\u003e\n\u003cli\u003e其他语法：https://blog.csdn.net/cuishizun/article/details/80311673\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e目录：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#Editor\"\u003eEditor\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e[一些常用操作](#Some daily usage)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%e5%b8%8c%e8%85%8a%e5%ad%97%e6%af%8d%e8%a1%a8\"\u003e希腊字母表\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"editor\"\u003eEditor：\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eObsidian、Nvim、Typora：Notes的主力编写工具\u003c/li\u003e\n\u003cli\u003eVsCode：Readme文档\u003c/li\u003e\n\u003cli\u003eJupyter：代码笔记编写的时候\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"some-daily-usage\"\u003eSome daily usage：\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e操作名称\u003c/th\u003e\n          \u003cth\u003eTypora\u003c/th\u003e\n          \u003cth\u003eVsCode\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e跳转\u003c/td\u003e\n          \u003ctd\u003e[button] (#name)-\u0026gt;#\u003c/td\u003e\n          \u003ctd\u003e[button] (#name)-\u0026gt; \u0026lt;span id=\u0026ldquo;name\u0026rdquo;\u0026gt;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e复选框\u003c/td\u003e\n          \u003ctd\u003e- [ ]\u003c/td\u003e\n          \u003ctd\u003e- [ ]\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c!-- more --\u003e\r\n\u003ch2 id=\"希腊字母表\"\u003e希腊字母表：\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e序号\u003c/th\u003e\n          \u003cth\u003e希腊字母\u003c/th\u003e\n          \u003cth\u003eMarkdoown\u003c/th\u003e\n          \u003cth\u003e序号\u003c/th\u003e\n          \u003cth\u003e希腊字母\u003c/th\u003e\n          \u003cth\u003eMarkdoown\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003eα\u003c/td\u003e\n          \u003ctd\u003e\\alpha\u003c/td\u003e\n          \u003ctd\u003e19\u003c/td\u003e\n          \u003ctd\u003eβ\u003c/td\u003e\n          \u003ctd\u003e\\beta\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003eγ\u003c/td\u003e\n          \u003ctd\u003e\\gamma\u003c/td\u003e\n          \u003ctd\u003e20\u003c/td\u003e\n          \u003ctd\u003eδ\u003c/td\u003e\n          \u003ctd\u003e\\delta\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e3\u003c/td\u003e\n          \u003ctd\u003eΓ\u003c/td\u003e\n          \u003ctd\u003e\\Gamma\u003c/td\u003e\n          \u003ctd\u003e21\u003c/td\u003e\n          \u003ctd\u003eΔ\u003c/td\u003e\n          \u003ctd\u003e\\Delta\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e4\u003c/td\u003e\n          \u003ctd\u003eε\u003c/td\u003e\n          \u003ctd\u003e\\varepsilon\u003c/td\u003e\n          \u003ctd\u003e22\u003c/td\u003e\n          \u003ctd\u003eϵ\u003c/td\u003e\n          \u003ctd\u003e\\epsilon\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e5\u003c/td\u003e\n          \u003ctd\u003eζ\u003c/td\u003e\n          \u003ctd\u003e\\zeta\u003c/td\u003e\n          \u003ctd\u003e23\u003c/td\u003e\n          \u003ctd\u003eη\u003c/td\u003e\n          \u003ctd\u003e\\eta\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e6\u003c/td\u003e\n          \u003ctd\u003eΘ\u003c/td\u003e\n          \u003ctd\u003e\\Theta\u003c/td\u003e\n          \u003ctd\u003e24\u003c/td\u003e\n          \u003ctd\u003eι\u003c/td\u003e\n          \u003ctd\u003e\\iota\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e7\u003c/td\u003e\n          \u003ctd\u003eθ\u003c/td\u003e\n          \u003ctd\u003e\\theta\u003c/td\u003e\n          \u003ctd\u003e25\u003c/td\u003e\n          \u003ctd\u003eκ\u003c/td\u003e\n          \u003ctd\u003e\\kappa\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e8\u003c/td\u003e\n          \u003ctd\u003eΛ\u003c/td\u003e\n          \u003ctd\u003e\\Lambda\u003c/td\u003e\n          \u003ctd\u003e26\u003c/td\u003e\n          \u003ctd\u003eλ\u003c/td\u003e\n          \u003ctd\u003e\\lambda\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e9\u003c/td\u003e\n          \u003ctd\u003eμ\u003c/td\u003e\n          \u003ctd\u003e\\mu\u003c/td\u003e\n          \u003ctd\u003e27\u003c/td\u003e\n          \u003ctd\u003eν\u003c/td\u003e\n          \u003ctd\u003e\\nu\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e10\u003c/td\u003e\n          \u003ctd\u003eξ\u003c/td\u003e\n          \u003ctd\u003e\\xi\u003c/td\u003e\n          \u003ctd\u003e28\u003c/td\u003e\n          \u003ctd\u003eο\u003c/td\u003e\n          \u003ctd\u003e\\omicron\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e11\u003c/td\u003e\n          \u003ctd\u003eΠ\u003c/td\u003e\n          \u003ctd\u003e\\Pi\u003c/td\u003e\n          \u003ctd\u003e29\u003c/td\u003e\n          \u003ctd\u003eρ\u003c/td\u003e\n          \u003ctd\u003e\\rho\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e12\u003c/td\u003e\n          \u003ctd\u003eπ\u003c/td\u003e\n          \u003ctd\u003e\\pi\u003c/td\u003e\n          \u003ctd\u003e30\u003c/td\u003e\n          \u003ctd\u003eτ\u003c/td\u003e\n          \u003ctd\u003e\\tau\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e13\u003c/td\u003e\n          \u003ctd\u003eΣ\u003c/td\u003e\n          \u003ctd\u003e\\Sigma\u003c/td\u003e\n          \u003ctd\u003e31\u003c/td\u003e\n          \u003ctd\u003eΦ\u003c/td\u003e\n          \u003ctd\u003e\\Phi\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e14\u003c/td\u003e\n          \u003ctd\u003eσ\u003c/td\u003e\n          \u003ctd\u003e\\sigma\u003c/td\u003e\n          \u003ctd\u003e32\u003c/td\u003e\n          \u003ctd\u003eϕ\u003c/td\u003e\n          \u003ctd\u003e\\phi\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e15\u003c/td\u003e\n          \u003ctd\u003eΥ\u003c/td\u003e\n          \u003ctd\u003e\\Upsilon\u003c/td\u003e\n          \u003ctd\u003e33\u003c/td\u003e\n          \u003ctd\u003eΨ\u003c/td\u003e\n          \u003ctd\u003e\\Psi\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e16\u003c/td\u003e\n          \u003ctd\u003eυ\u003c/td\u003e\n          \u003ctd\u003e\\upsilon\u003c/td\u003e\n          \u003ctd\u003e34\u003c/td\u003e\n          \u003ctd\u003eψ\u003c/td\u003e\n          \u003ctd\u003e\\psi\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e17\u003c/td\u003e\n          \u003ctd\u003eΩ\u003c/td\u003e\n          \u003ctd\u003e\\Omega\u003c/td\u003e\n          \u003ctd\u003e35\u003c/td\u003e\n          \u003ctd\u003eω\u003c/td\u003e\n          \u003ctd\u003e\\omega\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e18\u003c/td\u003e\n          \u003ctd\u003eφ\u003c/td\u003e\n          \u003ctd\u003e\\varphi\u003c/td\u003e\n          \u003ctd\u003e36\u003c/td\u003e\n          \u003ctd\u003eΞ\u003c/td\u003e\n          \u003ctd\u003e\\Xi\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Markdown Handbook"},{"content":"说明：重点针对超分辨率技术\n备注： 超分辨率在人脸识别上的多，但是表情识别上的确实不多，不过很多都会引用一波\n超分辨率在表情识别中的应用 KEY WORDs ：\r1. (\u0026#34;super resolution\u0026#34; OR \u0026#34;image restore\u0026#34;) AND (\u0026#34;facial expression recognition\u0026#34; OR \u0026#34;emotion recognition\u0026#34;) 2. (\u0026#34;super resolution\u0026#34;) AND (\u0026#34;expression recognition\u0026#34;) \u0026lt; Robust Emotion Recognition from Low Quality and Low Bit Rate Video: A Deep Learning Approach \u0026gt; 针对于低带宽传输的分辨率不足和比率低的应用场景 基于facial expression recognition 的 emotion recognition 在解码器进行视频下采样的时候，联合SR和识别 \u0026lt; Effective image super resolution via hierarchical convolutional neural network \u0026gt; 通过层次卷积神经网络(HCNN)来实现有校的SR 在facial expression recognition 中案例研究发现增强后的图像有助于提高识别性能 \u0026lt; Spatio-temporal Pain Recognition in CNN-Based Super-Resolved Facial Images \u0026gt; 有点擦边吧，就是基于超分辨率算法的多分辨率图像，对面部进行识别从而判断疼痛程度 也可能妹啥用，你可以考虑一下 \u0026lt; Low-resolution facial expression recognition: A filter learning perspective \u0026gt; 摘要中没有明确的提到Super-Resolution， 但是感觉低分辨率这个问题前缀，可能和SR有关系来着 \u0026lt; PKU_ICST at TRECVID 2019: Instance Search Task \u0026gt; 好像是什么比赛，过程中有一部分是面部表情检测 在识别之前采取了超分辨率的查询增强 \u0026lt; Facial Expression Restoration Based on Improved Graph Convolutional Networks \u0026gt; 针对分辨率低和部分遮挡的面部表情识别 GAN IGCN RRMB 修复和超分辨率面部表情 图像恢复技术、图像增强技术、人脸增强技术在表情识别中的应用 KEY WORDs：\r1. (\u0026#34;super resolution\u0026#34; OR \u0026#34;image restore\u0026#34;) AND (\u0026#34;facial expression recognition\u0026#34; OR \u0026#34;emotion recognition\u0026#34;) 2. (\u0026#34;image restore\u0026#34;) AND (\u0026#34;expression recognition\u0026#34;) ——NONE\r3. (\u0026#34;Image enhancement\u0026#34;) AND (\u0026#34;facial expression recognition\u0026#34;)\r4. (\u0026#34;face enhancement\u0026#34;) AND (\u0026#34;facial expression recognition\u0026#34;)\r5. (\u0026#34;Image restoration\u0026#34;) AND (\u0026#34;facial expression recognition\u0026#34;) \u0026lt; Efficient facial expression recognition via convolution neural network and infrared imaging technology \u0026gt; 离散小波变换正则化和快速盲恢复模型来重建红外光谱。。。。来帮助面部表情识别 针对光，姿势变化，噪声和遮挡的人脸识别？AND 其他 \u0026lt; Facial appearance and texture feature-based robust facial expression recognition framework for sentiment knowledge discovery \u0026gt; 没有提到超分辨率或是图像重建 但是有提到标题那几个，结合局部和全局特征\u0026hellip; \u0026lt; Improving Facial Emotion Recognition Systems with Crucial Feature Extractors \u0026gt; 是对表情识别的增强但是好像不是图像增强\u0026hellip;.. 基于特征提取的增强把 ","permalink":"https://hugotest-phi.vercel.app/posts/hyper_resolution/","summary":"\u003cp\u003e说明：重点针对\u003cstrong\u003e超分辨率\u003c/strong\u003e技术\u003c/p\u003e\n\u003cp\u003e备注：\n超分辨率在人脸识别上的多，但是表情识别上的确实不多，不过很多都会引用一波\u003cbr\u003e\u003c/p\u003e\n\u003ch2 id=\"超分辨率在表情识别中的应用\"\u003e超分辨率在表情识别中的应用\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eKEY WORDs ：\r\n\r\n1. (\u0026#34;super resolution\u0026#34; OR \u0026#34;image restore\u0026#34;) AND (\u0026#34;facial expression recognition\u0026#34; OR \u0026#34;emotion recognition\u0026#34;)   \r\n2. (\u0026#34;super resolution\u0026#34;) AND  (\u0026#34;expression recognition\u0026#34;)   \n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/pdf/1709.03126.pdf\" target=\"_blank\" rel=\"noopener\"\u003e\u0026lt; Robust Emotion Recognition from Low Quality and Low Bit Rate Video: A Deep Learning Approach \u0026gt;\u003c/a\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e针对于低带宽传输的分辨率不足和比率低的应用场景\u003c/li\u003e\n\u003cli\u003e基于facial expression recognition 的 emotion recognition\u003c/li\u003e\n\u003cli\u003e在解码器进行视频下采样的时候，\u003cstrong\u003e联合SR和识别\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.sciencedirect.com/science/article/abs/pii/S0925231219312974\" target=\"_blank\" rel=\"noopener\"\u003e\u0026lt; Effective image super resolution via hierarchical convolutional neural network \u0026gt;\u003c/a\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e通过层次卷积神经网络(HCNN)来实现有校的SR\u003c/li\u003e\n\u003cli\u003e在facial expression recognition 中案例研究发现增强后的图像有助于提高识别性能\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://link.springer.com/chapter/10.1007/978-3-319-56687-0_13\" target=\"_blank\" rel=\"noopener\"\u003e\u0026lt; Spatio-temporal Pain Recognition in CNN-Based Super-Resolved Facial Images \u0026gt;\u003c/a\u003e\n\u003c/p\u003e","title":"Hyper-Resolution"},{"content":"Goals： 1.数据量要求\n2.标注的标准\n3.标注的手段\nMicrosoft COCO Captions: 使用Amazon的Mechanical Turk(AMT)收集数据，再对数据进行标注。\n“Each of our captions are also generated using human subjects on AMT.”\n一些其他信息：(Caption Evaluation Server): 好像是可以评价caption的生成质量，但是应该是仅仅针对于使用COCO数据进行的，所以这一部分就不分析了。\n文中（section 3）包含了几种不同评价方法的介绍：\nBLEU\nROUGE\nMETEOR\nCIDEr\n在进行Evaluation之前的 Tokenization and preprocessing中：\n使用了工具来添加caption标记：\nStanford PTBTokenizer in Stanford CoreNLP tools (version 3.4.1) 这个工具是模仿的是peen treebank3. 其参考文献和相关链接如下：\n“The Stanford CoreNLP natural language processing toolkit,” in Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, 2014, pp. 55–60. related-link 数据规模： （平均1-5）\n330k image - \u0026gt;1.5m captions;\n训练\u0026amp;验证image : 每张照片的caption 由5个独立的人分别给出;\n对于Testing Image，收集额外的标题用来比较 人类标题的和机器生成的标题的表现。\n(MS COCO c5): 5 referenc captions for every image on MS COCO traning/ validation/ testing dataset.\nT: (82,782-413,915) V: (40,504-202,520) Testing: (40,775-179,189)\n(MS COCO c40): 40 reference sentences for a randomly chosen 5,000 images from the MS COCO testing dataset.\n给出更多对应的句子，许多评估指标可能与人类判断，有更高的相关性。\nT: (82,782-413,915) V: (40,504-202,520) Testing: (40,775-200,060)\n数据集搭建： none\n标注格式： #范例\nDescribtion\n原则：尽量短，只包含准确且重要的现况，不包含任何推理的部分。\nDescribe all the important parts of the scene. Do not start the sentences with “There is. Do not describe unimportant details. Do not describe things that might have happened in the future or past. Do not describe what a person might say. Do not give people proper names. The sentences should contain at least 8 words. (NOT Caption)Microsoft COCO dataset: 一些其他信息： “the creation of our dataset drew upon extensive crowd worker involvement via novel user interfaces for category detection, instance spotting and instance segmentation”\n“认为以往的数据集对于background信息过于忽视，除了主要的object 作为background的object很难识别”\n应该是设计了一个便于标注的用户界面\n标注格式： (Image-对应Question)为一组，按照实例分割对对象进行标记\n对每个对象main.backgroud都留存实例级别的分割掩膜(比bounding box精确的完全分割)\n1.标注存在的类别：\n采用分层方法，先判断大类，这样逐层往下分，比较快\n结果如图a\n2.Instance Spotting：\n第一步的时候，在找到的类别上画个x，这一轮，就找更多的类别，在新类上画新x 结果图图b\n3.分割实例\n修改了Bell等人的软件？用来标注\nOpenSurfaces: A richly annotated catalog of surface appearance. SIGGRAPH 32(4) (2013)\n数据规模： 91 objects， 328k image， 250w instances\n类别少,实例多。避免long tail\nCOCO: 1 image - 7.7 object instance\nimagenet: 3\nSUN: 2.3\n数据集搭建： （COCO）基于Amazon Mechanical Turk收集数据，基于Image2text、SUNdatabase来查询图像对，从而收集。\n分层标记方法：将每个图像标记为特定的对象类别。\n选择类别：只要那些thing（人，椅子，汽车），不要专注于stuff（天空街道草地）（没有精确的边界的）\nnon-iconic \u0026amp; iconic图像： （举个例子，比如证件照和乱拍的生活照？）是否是中心大对象之类的。 都有，但是大部分用non-\n","permalink":"https://hugotest-phi.vercel.app/posts/imagecaptionrequirement/","summary":"\u003ch2 id=\"goals\"\u003eGoals：\u003c/h2\u003e\n\u003cp\u003e1.数据量要求\u003cbr\u003e\n2.标注的标准\u003cbr\u003e\n3.标注的手段\u003c/p\u003e\n\u003ch2 id=\"microsoft-coco-captions\"\u003eMicrosoft COCO Captions:\u003c/h2\u003e\n\u003cp\u003e使用Amazon的Mechanical Turk(AMT)收集数据，再对数据进行标注。\u003cbr\u003e\n“Each of our captions are also generated using human subjects on AMT.”\u003c/p\u003e\n\u003ch3 id=\"一些其他信息caption-evaluation-server\"\u003e一些其他信息：(Caption Evaluation Server):\u003c/h3\u003e\n\u003cp\u003e好像是可以评价caption的生成质量，但是应该是仅仅针对于使用COCO数据进行的，所以这一部分就不分析了。\u003cbr\u003e\n文中（section 3）包含了几种不同评价方法的介绍：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eBLEU\u003cbr\u003e\nROUGE\u003cbr\u003e\nMETEOR\u003cbr\u003e\nCIDEr\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在进行Evaluation之前的 Tokenization and preprocessing中：\u003cbr\u003e\n使用了工具来添加caption标记：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStanford PTBTokenizer in Stanford CoreNLP tools (version 3.4.1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个工具是模仿的是peen treebank3.   其参考文献和相关链接如下：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“The Stanford CoreNLP natural language processing toolkit,” in Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, 2014, pp. 55–60. \u003ca href=\"http://www.aclweb.org/anthology/P/P14/P14-5010\" target=\"_blank\" rel=\"noopener\"\u003erelated-link\u003c/a\u003e\n\u003c/p\u003e","title":"Image Caption Dataset"},{"content":"根据这次需要搜集的表情的数据集，整理一下搜索数据集的网站和思路等\n##PART1 \u0026ldquo;表情数据集\u0026rdquo; 下列是对数据搜集的要求：\n是否开源 图片的大小和数量 图片的采集方式 eg：ck+\n==数据来源及对应的搜索结果如下：==\n谷歌数据集搜索导航 60个人脸识别的数据集汇总 cv方面的好几百个数据集汇总 另一个cv方向的数据集汇总 github-CV汇总帖 EmotioNet 好像是一个什么挑战赛的数据集要博士后或者相应教员才能申请使用申请页面 没有具体的用于表情识别的数据子集的信息（好像数据很多，但是不知道在哪下，除了那个博士后申请的）\nRAF real-world Affective Face\n数据量29672个图像，7种基本情绪，12种复合情绪，（包含种族年龄范围性别属性，5个准确定位和37个自动生成的定位）\n**数据收集方式：**来源网络，大小应该很杂 （由40个人独立标定）\nemail\nonenote中标记的和google 数据集搜索\nFaceTracer Database basic info：（有图片的原始url）（wild）(网上收集的)姿势、环境、照明、质量 等等参差不齐，大小不固定 (针对非商业用途开放) (表情只有笑容) 故而不在详细收集，其他的标注信息，文中有详细讲解。 Tencent ML-Images 可能会有表情吧，是一个很大规模的多标签数据集。。。 ND-2006 Dataset 06年貌似 13450张图片 6种基本情感 888个对象 Google facial expression comparison dataset 没有对数据集的基本信息介绍 百度/CSDN搜索\nhttps://blog.csdn.net/mathlxj/article/details/87920084 https://blog.csdn.net/computerme/article/details/49469767 JAFFE 只有219张，标签为分散离散值。 划分六种情感指标 256*256 中科大的NVIE 其中正面光照103人，左侧光照99人，右侧光照103人。每种光照下，每人有六种表情（喜悦、愤怒、哀 伤、恐惧、厌恶、惊奇）中的三种以上 平静帧、最大帧都已挑出 下载协议然后发给他们，才能下载 AFEW database 数据来源：电影片段的剪辑。情绪类型：“六类基本表情”+中性 SFEW database 数据来源：从AFEW中抽取出来的表情的静态帧。标注都在xml中 LIRIS-ACCEDE database 同样也是基于电影抽取的，有三种数据集，包含离散的情感数据和基于维度的情感数据 BU-3DFE database 3D的人脸表情数据集 **数据来源：**找人来做实验采集，按照要求的情绪做出表情 **数据量：**2500个3d面部模型（来自100个人） 还有同类的一些包含序列的等等的数据集，估计差别不大。 同样需要email获取 Oulu-CASIA database 数据来源：让80个受试者做出相应的表情并用不同相机采集（红外可见光正常光和弱光） 情绪类型：快乐、悲伤、惊讶、愤怒、恐惧、厌恶 email RAFD 数据来源：让67个受试者做出相应的表情在不同注视点和不同角度采集 情绪类型：8种情感类型 email KDEF database 数据来源：柔和、均匀的光线，多角度拍摄表情，使用统一的T恤颜色，在拍摄过程中使用网格将参与者面部居中，以及在扫描过程中将眼睛和嘴巴定位在固定的图像坐标中。 数据量：4900张 (70个人，一个7个情感) 页面底端超链接（没进去成功。。） ExpW 9w张左右，图片差不多8G AffectNet 百万量级数据（Emotion Net好像也是） 获取方式：从互联网获取 7类情感，首页有各种情感的数据量，最少的也有4k张 填写申请表email下载 Multi-PIE Face Database 收钱给数据集 获取方式：记录会话 数据量：75w图片 一些视频数据集(具体的在CSDN站上)（这些我就没有去详细看了）\nHUMAINE Database 应为带表情标签的视频数据集（CSDN用户表示下载后没有标签）(我翻墙也进不去很奇怪) Recola database MMI RU-FACS database-未公开 Belfast naturalistic database -主要是演讲时候的情感识别 VAM corpus 也是演讲的 AVEC系列数据集 ","permalink":"https://hugotest-phi.vercel.app/posts/emotion_dataset/","summary":"\u003cp\u003e根据这次需要搜集的表情的数据集，整理一下搜索数据集的网站和思路等\u003c/p\u003e\n\u003cp\u003e##PART1 \u0026ldquo;表情数据集\u0026rdquo;\n下列是对数据搜集的要求：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e是否开源\u003c/li\u003e\n\u003cli\u003e图片的大小和数量\u003c/li\u003e\n\u003cli\u003e图片的采集方式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eeg：\u003cstrong\u003eck+\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e==数据来源及对应的搜索结果如下：==\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://toolbox.google.com/datasetsearch\" target=\"_blank\" rel=\"noopener\"\u003e谷歌数据集搜索导航\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.kairos.com/blog/60-facial-recognition-databases\" target=\"_blank\" rel=\"noopener\"\u003e60个人脸识别的数据集汇总\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://homepages.inf.ed.ac.uk/rbf/CVonline/Imagedbase.htm\" target=\"_blank\" rel=\"noopener\"\u003ecv方面的好几百个数据集汇总\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"www.cvpapers.com/datasets.html\"\u003e另一个cv方向的数据集汇总\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ChanChiChoi/awesome-Face_Recognition\" target=\"_blank\" rel=\"noopener\"\u003egithub-CV汇总帖\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://cbcsl.ece.ohio-state.edu/EmotionNetChallenge/index.html#overview\" target=\"_blank\" rel=\"noopener\"\u003eEmotioNet\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e好像是一个什么挑战赛的数据集要博士后或者相应教员才能申请使用\u003ca href=\"http://cbcsl.ece.ohio-state.edu/dbform_compound.html\" target=\"_blank\" rel=\"noopener\"\u003e申请页面\u003c/a\u003e\n   \u003cbr\u003e\n没有具体的用于表情识别的数据子集的信息（好像数据很多，但是不知道在哪下，除了那个博士后申请的）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003ca href=\"http://www.whdeng.cn/RAF/model1.html\" target=\"_blank\" rel=\"noopener\"\u003eRAF\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003ereal-world Affective Face\u003cbr\u003e\n\u003cstrong\u003e数据量\u003c/strong\u003e29672个图像，7种基本情绪，12种复合情绪，（包含种族年龄范围性别属性，5个准确定位和37个自动生成的定位）\u003cbr\u003e\n**数据收集方式：**来源网络，大小应该很杂 （由40个人独立标定）\u003cbr\u003e\nemail\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!-- more --\u003e\r\n\u003cp\u003e\u003cstrong\u003eonenote中标记的和google 数据集搜索\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://www.cs.columbia.edu/CAVE/databases/facetracer/\" target=\"_blank\" rel=\"noopener\"\u003eFaceTracer Database\u003c/a\u003e\n\nbasic info：（有图片的原始url）（wild）(网上收集的)姿势、环境、照明、质量 等等参差不齐，\u003cstrong\u003e大小不固定\u003c/strong\u003e\n(针对\u003cstrong\u003e非商业用途开放\u003c/strong\u003e)   (\u003cstrong\u003e表情只有笑容\u003c/strong\u003e)\n故而不在详细收集，其他的标注信息，文中有详细讲解。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Tencent/tencent-ml-images?tdsourcetag=s_pctim_aiomsg#tencent-ml-images\" target=\"_blank\" rel=\"noopener\"\u003eTencent ML-Images\u003c/a\u003e\n\n可能会有表情吧，是一个很大规模的多标签数据集。。。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://cvrl.nd.edu/projects/data/#nd-2006-data-set\" target=\"_blank\" rel=\"noopener\"\u003eND-2006 Dataset\u003c/a\u003e\n 06年貌似\n13450张图片\n6种基本情感\n888个对象\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ai.google/tools/datasets/google-facial-expression/\" target=\"_blank\" rel=\"noopener\"\u003eGoogle facial expression comparison dataset\u003c/a\u003e\n\n没有对数据集的基本信息介绍\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e百度/CSDN搜索\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/mathlxj/article/details/87920084\" target=\"_blank\" rel=\"noopener\"\u003ehttps://blog.csdn.net/mathlxj/article/details/87920084\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/computerme/article/details/49469767\" target=\"_blank\" rel=\"noopener\"\u003ehttps://blog.csdn.net/computerme/article/details/49469767\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://zenodo.org/record/3451524#.XaQ4vm5uKmQ\" target=\"_blank\" rel=\"noopener\"\u003eJAFFE\u003c/a\u003e\n\n只有219张，标签为分散离散值。\n划分六种情感指标  256*256\u003c/li\u003e\n\u003cli\u003e中科大的\u003ca href=\"http://nvie.ustc.edu.cn/\" target=\"_blank\" rel=\"noopener\"\u003eNVIE\u003c/a\u003e\n\n其中\u003cstrong\u003e正面光照103人，左侧光照99人，右侧光照103人\u003c/strong\u003e。每种光照下，每人有六种表情（\u003cstrong\u003e喜悦、愤怒、哀 伤、恐惧、厌恶、惊奇\u003c/strong\u003e）中的三种以上\n平静帧、最大帧都已挑出 \u003ca href=\"http://nvie.ustc.edu.cn/contact.html\" target=\"_blank\" rel=\"noopener\"\u003e下载协议然后发给他们，才能下载\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://sites.google.com/site/emotiwchallenge/\" target=\"_blank\" rel=\"noopener\"\u003eAFEW database\u003c/a\u003e\n\n\u003cstrong\u003e数据来源\u003c/strong\u003e：电影片段的剪辑。\u003cstrong\u003e情绪类型\u003c/strong\u003e：“六类基本表情”+中性\n\u003ca href=\"https://cs.anu.edu.au/few/emotiw2015.html\" target=\"_blank\" rel=\"noopener\"\u003eSFEW database\u003c/a\u003e\n\n\u003cstrong\u003e数据来源\u003c/strong\u003e：从AFEW中抽取出来的表情的静态帧。标注都在xml中\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://liris-accede.ec-lyon.fr/\" target=\"_blank\" rel=\"noopener\"\u003eLIRIS-ACCEDE database\u003c/a\u003e\n\n同样也是基于电影抽取的，有三种数据集，包含离散的情感数据和基于维度的情感数据\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.cs.binghamton.edu/~lijun/Research/3DFE/3DFE_Analysis.html\" target=\"_blank\" rel=\"noopener\"\u003eBU-3DFE database\u003c/a\u003e\n\n3D的人脸表情数据集 **数据来源：**找人来做实验采集，按照要求的情绪做出表情\n**数据量：**2500个3d面部模型（来自100个人）\n还有同类的一些包含序列的等等的数据集，估计差别不大。\n同样需要email获取\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.cse.oulu.fi/CMV/Downloads/Oulu-CASIA\" target=\"_blank\" rel=\"noopener\"\u003eOulu-CASIA database\u003c/a\u003e\n\n\u003cstrong\u003e数据来源\u003c/strong\u003e：让80个受试者做出相应的表情并用不同相机采集（红外可见光正常光和弱光）\n\u003cstrong\u003e情绪类型\u003c/strong\u003e：快乐、悲伤、惊讶、愤怒、恐惧、厌恶\nemail\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.socsci.ru.nl:8180/RaFD2/RaFD\" target=\"_blank\" rel=\"noopener\"\u003eRAFD\u003c/a\u003e\n\n\u003cstrong\u003e数据来源\u003c/strong\u003e：让67个受试者做出相应的表情在不同注视点和不同角度采集\n\u003cstrong\u003e情绪类型\u003c/strong\u003e：8种情感类型\nemail\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.emotionlab.se/kdef/\" target=\"_blank\" rel=\"noopener\"\u003eKDEF database\u003c/a\u003e\n\n\u003cstrong\u003e数据来源\u003c/strong\u003e：柔和、均匀的光线，多角度拍摄表情，使用统一的T恤颜色，在拍摄过程中使用网格将参与者面部居中，以及在扫描过程中将眼睛和嘴巴定位在固定的图像坐标中。\n\u003cstrong\u003e数据量\u003c/strong\u003e：4900张 (70个人，一个7个情感)\n页面底端超链接（没进去成功。。）\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://mmlab.ie.cuhk.edu.hk/projects/socialrelation/index.html\" target=\"_blank\" rel=\"noopener\"\u003eExpW\u003c/a\u003e\n\n9w张左右，图片差不多8G\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://mohammadmahoor.com/affectnet/\" target=\"_blank\" rel=\"noopener\"\u003eAffectNet\u003c/a\u003e\n\n百万量级数据（Emotion Net好像也是）\n\u003cstrong\u003e获取方式\u003c/strong\u003e：从互联网获取\n\u003cstrong\u003e7类情感\u003c/strong\u003e，首页有各种情感的数据量，最少的也有4k张\n填写申请表email下载\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.flintbox.com/public/project/4742/\" target=\"_blank\" rel=\"noopener\"\u003eMulti-PIE Face Database\u003c/a\u003e\n\n收钱给数据集\n\u003cstrong\u003e获取方式\u003c/strong\u003e：记录会话\n\u003cstrong\u003e数据量\u003c/strong\u003e：75w图片\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e一些视频数据集(具体的在CSDN站上)（这些我就没有去详细看了）\u003c/p\u003e","title":"表情数据集"}]