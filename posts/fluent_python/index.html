<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fluent Python 01 数据模型与结构 | aiken's blog</title>
<meta name=keywords content="Python,Langs"><meta name=description content='Chapter 1 数据模型
Se1 magic method
数据模型在这里的定义是对python框架的描述,他规范了python构建模块的接口；这些接口对应解释器中对一些特殊句法(常用句法)的激活和使用.本章节的核心就在于对这些特殊句法的理解和使用.
特殊方法带来的一些主要交互场景:

迭代
属性访问
集合类
函数和方法的调用
对象的创建和销毁
字符串的表示形式和格式化
上下文管理模块(with模块)

这些特殊方法的存在实际上，是为了让python的解释器调用，除非我们有大量的元编程，否则我们一般不调用他，通过内置的len等函数进行调用的话，他们的速度更快
下面我们通过最典型的__getitem__和__len__对其有简单的介绍, 并介绍各个魔术方法的使用场景
Se2 using it and show more
最常用也最典型的magic method 不外乎__getitem__和__len__;

len即对当前对象提供对于通用的len()方法的接口,通常用于查看对象的length or size
getitem除了提供obj[index]的索引方式的同时,

他也会对python内置的那些迭代方法提供支持for i in range(b)
对于依托于这些迭代的方法也能够得以支持from random import choice
切片操作



Se2.1 overwrite operator

这一部分我们主要介绍如下的一些特殊方法,他们将实现+,*,abs,print,bool
对应的特殊方法可以从下面的代码中领会


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


from math import hypot
# hypot will calculate the eud-dis from 0-point(x,y)
# we using vector as an example
class Vector:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __repr__(self):
        # this method -> print
        return "Vertor({},{})".format(self.x, self.y)

    def __abs__(self):
        return hypot(self.x, self.y)

    def __add__(self, other:Vector):
        x = self.x + other.x
        y = self.y + other.y
        return Vector(x,y)

    def __mul__(self, scalar):
        return Vertor(self.x*scalar, self.y*scalar)

    def __bool__(self):
        return bool(self.x or self.y)


在这里需要注意的是,中缀运算符像add,mul的原则都是不改变操作对象,而是生成一个新的对象.'><meta name=author content="aikenhong"><link rel=canonical href=https://hugotest-phi.vercel.app/posts/fluent_python/><link crossorigin=anonymous href=/assets/css/stylesheet.2f85ca17c12c62fa86b1e474b8a51aca4856f0d645debfe4922a4d5ddc6aa978.css integrity="sha256-L4XKF8EsYvqGseR0uKUaykhW8NZF3r/kkipNXdxqqXg=" rel="preload stylesheet" as=style><link rel=icon href=https://hugotest-phi.vercel.app/favicon/ghost.ico><link rel=icon type=image/png sizes=16x16 href=https://hugotest-phi.vercel.app/favicon/ghost-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hugotest-phi.vercel.app/favicon/ghost-32x32.png><link rel=apple-touch-icon href=https://hugotest-phi.vercel.app/favicon/ghost-apple-touch-icon.png><link rel=mask-icon href=https://hugotest-phi.vercel.app/favicon/ghost-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hugotest-phi.vercel.app/posts/fluent_python/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><meta property="og:url" content="https://hugotest-phi.vercel.app/posts/fluent_python/"><meta property="og:site_name" content="aiken's blog"><meta property="og:title" content="Fluent Python 01 数据模型与结构"><meta property="og:description" content='Chapter 1 数据模型 Se1 magic method 数据模型在这里的定义是对python框架的描述,他规范了python构建模块的接口；这些接口对应解释器中对一些特殊句法(常用句法)的激活和使用.本章节的核心就在于对这些特殊句法的理解和使用. 特殊方法带来的一些主要交互场景:
迭代 属性访问 集合类 函数和方法的调用 对象的创建和销毁 字符串的表示形式和格式化 上下文管理模块(with模块) 这些特殊方法的存在实际上，是为了让python的解释器调用，除非我们有大量的元编程，否则我们一般不调用他，通过内置的len等函数进行调用的话，他们的速度更快
下面我们通过最典型的__getitem__和__len__对其有简单的介绍, 并介绍各个魔术方法的使用场景
Se2 using it and show more 最常用也最典型的magic method 不外乎__getitem__和__len__;
len即对当前对象提供对于通用的len()方法的接口,通常用于查看对象的length or size getitem除了提供obj[index]的索引方式的同时, 他也会对python内置的那些迭代方法提供支持for i in range(b) 对于依托于这些迭代的方法也能够得以支持from random import choice 切片操作 Se2.1 overwrite operator 这一部分我们主要介绍如下的一些特殊方法,他们将实现+,*,abs,print,bool 对应的特殊方法可以从下面的代码中领会
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from math import hypot # hypot will calculate the eud-dis from 0-point(x,y) # we using vector as an example class Vector: def __init__(self, x=0, y=0): self.x = x self.y = y def __repr__(self): # this method -> print return "Vertor({},{})".format(self.x, self.y) def __abs__(self): return hypot(self.x, self.y) def __add__(self, other:Vector): x = self.x + other.x y = self.y + other.y return Vector(x,y) def __mul__(self, scalar): return Vertor(self.x*scalar, self.y*scalar) def __bool__(self): return bool(self.x or self.y) 在这里需要注意的是,中缀运算符像add,mul的原则都是不改变操作对象,而是生成一个新的对象.'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-06T12:53:47+00:00"><meta property="article:modified_time" content="2021-11-06T12:53:47+00:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Langs"><meta property="og:image" content="https://hugotest-phi.vercel.app/cover/cover3.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hugotest-phi.vercel.app/cover/cover3.jpeg"><meta name=twitter:title content="Fluent Python 01 数据模型与结构"><meta name=twitter:description content='Chapter 1 数据模型
Se1 magic method
数据模型在这里的定义是对python框架的描述,他规范了python构建模块的接口；这些接口对应解释器中对一些特殊句法(常用句法)的激活和使用.本章节的核心就在于对这些特殊句法的理解和使用.
特殊方法带来的一些主要交互场景:

迭代
属性访问
集合类
函数和方法的调用
对象的创建和销毁
字符串的表示形式和格式化
上下文管理模块(with模块)

这些特殊方法的存在实际上，是为了让python的解释器调用，除非我们有大量的元编程，否则我们一般不调用他，通过内置的len等函数进行调用的话，他们的速度更快
下面我们通过最典型的__getitem__和__len__对其有简单的介绍, 并介绍各个魔术方法的使用场景
Se2 using it and show more
最常用也最典型的magic method 不外乎__getitem__和__len__;

len即对当前对象提供对于通用的len()方法的接口,通常用于查看对象的length or size
getitem除了提供obj[index]的索引方式的同时,

他也会对python内置的那些迭代方法提供支持for i in range(b)
对于依托于这些迭代的方法也能够得以支持from random import choice
切片操作



Se2.1 overwrite operator

这一部分我们主要介绍如下的一些特殊方法,他们将实现+,*,abs,print,bool
对应的特殊方法可以从下面的代码中领会


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


from math import hypot
# hypot will calculate the eud-dis from 0-point(x,y)
# we using vector as an example
class Vector:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __repr__(self):
        # this method -> print
        return "Vertor({},{})".format(self.x, self.y)

    def __abs__(self):
        return hypot(self.x, self.y)

    def __add__(self, other:Vector):
        x = self.x + other.x
        y = self.y + other.y
        return Vector(x,y)

    def __mul__(self, scalar):
        return Vertor(self.x*scalar, self.y*scalar)

    def __bool__(self):
        return bool(self.x or self.y)


在这里需要注意的是,中缀运算符像add,mul的原则都是不改变操作对象,而是生成一个新的对象.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hugotest-phi.vercel.app/posts/"},{"@type":"ListItem","position":2,"name":"Fluent Python 01 数据模型与结构","item":"https://hugotest-phi.vercel.app/posts/fluent_python/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Fluent Python 01 数据模型与结构","name":"Fluent Python 01 数据模型与结构","description":"Chapter 1 数据模型 Se1 magic method 数据模型在这里的定义是对python框架的描述,他规范了python构建模块的接口；这些接口对应解释器中对一些特殊句法(常用句法)的激活和使用.本章节的核心就在于对这些特殊句法的理解和使用. 特殊方法带来的一些主要交互场景:\n迭代 属性访问 集合类 函数和方法的调用 对象的创建和销毁 字符串的表示形式和格式化 上下文管理模块(with模块) 这些特殊方法的存在实际上，是为了让python的解释器调用，除非我们有大量的元编程，否则我们一般不调用他，通过内置的len等函数进行调用的话，他们的速度更快\n下面我们通过最典型的__getitem__和__len__对其有简单的介绍, 并介绍各个魔术方法的使用场景\nSe2 using it and show more 最常用也最典型的magic method 不外乎__getitem__和__len__;\nlen即对当前对象提供对于通用的len()方法的接口,通常用于查看对象的length or size getitem除了提供obj[index]的索引方式的同时, 他也会对python内置的那些迭代方法提供支持for i in range(b) 对于依托于这些迭代的方法也能够得以支持from random import choice 切片操作 Se2.1 overwrite operator 这一部分我们主要介绍如下的一些特殊方法,他们将实现+,*,abs,print,bool 对应的特殊方法可以从下面的代码中领会\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from math import hypot # hypot will calculate the eud-dis from 0-point(x,y) # we using vector as an example class Vector: def __init__(self, x=0, y=0): self.x = x self.y = y def __repr__(self): # this method -\u0026gt; print return \u0026#34;Vertor({},{})\u0026#34;.format(self.x, self.y) def __abs__(self): return hypot(self.x, self.y) def __add__(self, other:Vector): x = self.x + other.x y = self.y + other.y return Vector(x,y) def __mul__(self, scalar): return Vertor(self.x*scalar, self.y*scalar) def __bool__(self): return bool(self.x or self.y) 在这里需要注意的是,中缀运算符像add,mul的原则都是不改变操作对象,而是生成一个新的对象.\n","keywords":["Python","Langs"],"articleBody":"Chapter 1 数据模型 Se1 magic method 数据模型在这里的定义是对python框架的描述,他规范了python构建模块的接口；这些接口对应解释器中对一些特殊句法(常用句法)的激活和使用.本章节的核心就在于对这些特殊句法的理解和使用. 特殊方法带来的一些主要交互场景:\n迭代 属性访问 集合类 函数和方法的调用 对象的创建和销毁 字符串的表示形式和格式化 上下文管理模块(with模块) 这些特殊方法的存在实际上，是为了让python的解释器调用，除非我们有大量的元编程，否则我们一般不调用他，通过内置的len等函数进行调用的话，他们的速度更快\n下面我们通过最典型的__getitem__和__len__对其有简单的介绍, 并介绍各个魔术方法的使用场景\nSe2 using it and show more 最常用也最典型的magic method 不外乎__getitem__和__len__;\nlen即对当前对象提供对于通用的len()方法的接口,通常用于查看对象的length or size getitem除了提供obj[index]的索引方式的同时, 他也会对python内置的那些迭代方法提供支持for i in range(b) 对于依托于这些迭代的方法也能够得以支持from random import choice 切片操作 Se2.1 overwrite operator 这一部分我们主要介绍如下的一些特殊方法,他们将实现+,*,abs,print,bool 对应的特殊方法可以从下面的代码中领会\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from math import hypot # hypot will calculate the eud-dis from 0-point(x,y) # we using vector as an example class Vector: def __init__(self, x=0, y=0): self.x = x self.y = y def __repr__(self): # this method -\u003e print return \"Vertor({},{})\".format(self.x, self.y) def __abs__(self): return hypot(self.x, self.y) def __add__(self, other:Vector): x = self.x + other.x y = self.y + other.y return Vector(x,y) def __mul__(self, scalar): return Vertor(self.x*scalar, self.y*scalar) def __bool__(self): return bool(self.x or self.y) 在这里需要注意的是,中缀运算符像add,mul的原则都是不改变操作对象,而是生成一个新的对象.\nse2.2 show more 这一部分我们会展示更多的一些特殊方法，对这些特殊方法的了解也方便我们对python中方法运行的一些掌握\n这些特殊方法的使用场景很容易从命名中可以得到一个基本的认知，像迭代，调用，集合等等的这些属性可能是相对常用的，要熟练进行掌握\n例如__str__ | __repr__的方法,就可以方便我们进行print和相应的调试输出.\n_iadd_ 对应的是+=的这种原地操作, 这个也是我们需要注意的\nChapter 2 数据结构 python的一个重要特点就在于多种数据结构上的操作通用性, 无论是字符串,列表,字节序列,XML元素,他们都公用一套丰富的操作.\n此外在python的函数中, 当我们对一个对象进行就地改动, 那他就应该返回None, 这样可以让调用者知道传入的参数发生了改变, 并未产生新的对象, 这种约定俗成的定义方法, 实际上是一种好的习惯.\n迭代, 切片, 排序, 拼接\n在这里我们还是要熟悉一下各种类型支持的一些操作, 在python中我们可以通过help(list)查看, 当然最好还是做一个简单的总结熟悉对应的数据结构的一些默认方法.\nse 1 序列构成的数组 se 1.1 类型概念 python标准库用C实现了丰富的序列类型, 列举如下.\n序列类型 具体类型 类型特点 容器序列 list, tuple, collections.deque 存放不同数据的类型 扁平序列 str, bytes, bytearray, memoryview, array.array 只能容纳一种类型 说明 上面是第一种分类情况, 下面会介绍另一种分类.\n具体的特点会在下面介绍 可变序列 list, bytearray, array.array, collections.deque, memoryview 支持增删改 不可变序列 tuple, str, bytes 不支持增删改 通过这些类别中共有和非公有的特性，我们对这些序列的不同概念进行理解。\nse 1.2 列表推导\u0026生成器表达式 生成器表达式和列表推导式的区别 ，\nlist是python中重要的一个可变序列类型，列表推导式是我们构建列表的快捷方式，生成器表达式则是创建其他任何类型的序列。\n列表推导式：\n1 2 3 4 5 6 7 8 9 10 11 # 这种方式实际上相比于循环来说更加易读 symbols = “\u0026*（@￥” unicode = [ord(symbol) for symbol in symbols] clothes = [(color, size) for color in colors for size in sizes] # 双层循环,写在里面的是外层循环 # 列表推导式 with conditions, 条件语句应该放在后面 res = [num(i) for i in range(10) if i \u003e= 2] # filter和map 也能完成列表推导式做得到的事情，当然lambda也可以 # 具体的map和filter的定义在后面详细解读 unicode = list(filter(lambda c : c\u003e127, map(ord, symbols))) 生成器表达式：\n首先理解生成器和推导式的区别，推导式是直接完成整体的构建，而生成器是逐步的餐厨我们需要的元素，需要几个就产生几个，使用yield方法进行创建，而生成器表达式可以在没有该表达式的情况下及时创建简化生成器。\n而在编写的时候和列表推导式的区别是，用()代替[]即可\n1 2 for tshirt in ('{} {}'.format(c,s) for c in colors for s in sizes): print(tshirt) 生成器会逐个产出元素而不会一次性生成，所以实际上这种方法更有内存效率\nse 1. 3 循环的本质 和迭代器有重要的关系，有iter方法都能进行迭代，我们可以用hasattr检查\n1 hasattr(str, '__iter__') 循环的后台会发生如下的流程：\niter()将对象转换为迭代器对象 next()逐渐获取序列的下一个元素 stopiteration没有要调用的元素引发异常 se 1.4 tuple不止不可变 tuple的不可变属性更应该作为一个record这种信息载体来使用，他的这种不可变的特性，让他的position和对应的存储都显得有意义，我们可以通过_占位*解包等操作，来对我们的数据进行读取和管理。\n这里拆包的灵活使用是一个重点，用*ignore来跳过我们不需要的那些元素，也可以通过fmt来灵活的拆出嵌套元素\n1 2 3 4 5 6 7 8 9 10 metro_areas = [ ('Tokyo', 'JP', 36, (x1, x2)), ('Tokyo', 'JP', 36, (x1, x2)), ('Tokyo', 'JP', 36, (x1, x2)) ] # 这种format的编写方式也值得我们学习 fmt = '{:15} | {:9.4f} | {:9.4f}' for name,cc,pop,(lati,longti) in metro_areas: if longtitude\u003c=0: print(fmt.format(name,lati,longti)) 元组本身已经设计得不错, 但是作为记录来用的话, 我们通常需要给字段一个名称, nametuple就为我们解决这个问题:\ncollections.namedtuple用来构建一个带字段名的元组和一个有名字的类,这个有名字的类帮助我们调试.\n1 2 3 4 from collections import namedtuple contact = namedtuple('contact', key1, key2, key3) # first dimension is the typename aiken = contact(v1,v2,v3) 该collections.namedtuple除了元组的属性以外还行增了一些特性, 常用的有如下两个\n_fields 返回包含所有字段的元组\n_asdict() 将具名元组转换为collections.OrderedDict\n_make() 接受可迭代对象来生成类的一个实例, 也就是可以用*解包的方式来生成一个实例, 而这种方法在元组中是不可用的\n1 2 name_data = (v1,v2,v3) name = contact._make(*name_data) se 1 5 切片 这一块切片的设计逻辑讲的很好, 为何从零开始且不包括最后一个, 会为我们带来很多操作上和可读性上的便利, 具体看书.\nslice(start, stop, step)实现切片对象, 或者slice(stop)\n1 2 3 myslice = slice(1,5,2) arr = list(range(10)) print(arr[myslice]) 可以使用切片对象的方式能够将我们的切片规则参数化, 方便我们去设置和约定.\n省略号在python中的表示是..., 这种用来作为多维切片的时候可能会用到\n1 x[i, ...] = x[i, :, :, :] se 1.6 对序列使用+ * 序列使用*n的时候, 通常是建立一个新的对象, 但是如果序列中是对其他可变对象的引用的到时候, 实际上会得到n个引用结果.\n1 2 3 4 # 可以通过如下的代码测试 mylist = [['_']] * 3 mylist[1][2] = 0 # print [['_', '_', 0], ['_', '_', 0], ['_', '_', 0]] python的传值类型大多数情况下都是reference assign, 有时候我们对这种对象进行赋值的时候, 我们需要使用深拷贝来进行值的拷贝.\n+=是否有_iadd_的实现, 有很大的区别, a+b对应的是实现一个新的对象的产生, 我们可以通过id来进行检查. 如果不断没有必要的产生新的对象的话, 会存在比较大的浪费.\nse 1.7 list.sort 和sorted list.sort 就地修改, 返回None sort(list) 新建一个列表作为返回值, 可接受任何形式的可迭代对象, 最终返回的都是列表. 函数有两个关键词reverse, key: 指定排序的标准.\n用bisect来管理已排序的序列: 主要有两个函数bisect和insort, 通过这两个函数使用二分查找法在有序序列中查找或插入元素.\nse 1.8 其他序列数据结构 列表虽然好用，但也不是万能的，再一些特定的情况下，有特定的数据结构能更好的支持对应的操作。\n如果我们要存放大量的数据，这种时候array的效率要高得多（存放的是机器翻译），而吐过我们频繁的进行先进先出的策略deque的速度应该更快； 同样，如果我们需要频繁的检查一个元素是否出现在一个集合中，要考虑使用set（无序）\n数组ARRAY： 如果我们只需要一个包含数字的列表，那么array.array会比list更加高效，同样他也支持所有可变序列相关的操作，pop,insert,extend,也提供共文件读取和存储的更快的操作：.frombytes, .tofild\narray在使用的过程中需要指定存储的类型码(具体使用的时候查阅): floats = array('d', (random() for i in range(10**7)))\n存取大数组到array的二进制文件比存储到文本文件中快60倍, 因为这种操作中避免了float函数的执行, 写入同样的也快7倍, 同时占用的空间更少.\n同样pickle处理浮点数组的方式几乎和array一样快, 且pickle可以处理各种各样的数字类型, 甚至简单的自定义类型, 是一个快速序列化数字类型的方法.\nmemoryview: 内存视图使得用户在不复制内容的情况下操作同一个数组的不同切片. 实际上是Numpy一些功能的简单实现\nnumpy \u0026 scipy: Numpy实现了多维同质数组和矩阵 Scipy是基于Numpy的科学计算库, 为线性代数,数值积分和统计学设计\ncollections.deque 线程安全, 可以从两端添加或者删除元素. 常用来作为最近用到的几个元素 queue同步类Queue, LifoQueue, PriorityQueue multiprocessing设计为了进程之间的通信 heapq当作堆和优先队列来用 Se2 字典和集合 泛映射类型 Chapter 3 把函数视作对象 se 3 函数装饰器和闭包 这一部分不同于之前的\n","wordCount":"563","inLanguage":"en","image":"https://hugotest-phi.vercel.app/cover/cover3.jpeg","datePublished":"2021-11-06T12:53:47Z","dateModified":"2021-11-06T12:53:47Z","author":[{"@type":"Person","name":"aikenhong"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://hugotest-phi.vercel.app/posts/fluent_python/"},"publisher":{"@type":"Organization","name":"aiken's blog","logo":{"@type":"ImageObject","url":"https://hugotest-phi.vercel.app/favicon/ghost.ico"}}}</script></head><body id=top><script type=module src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.esm.js defer></script><script nomodule src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.js defer></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hugotest-phi.vercel.app/ accesskey=h title="aiken's blog (Alt + H)">aiken's blog</a><div class=logo-switches><button id=theme-toggle-nav accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hugotest-phi.vercel.app/ title=home><span>home</span></a></li><li><a href=https://hugotest-phi.vercel.app/archives/ title=archives><span>archives</span></a></li><li><a href=https://hugotest-phi.vercel.app/search title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><div class=sidebar><ul><li class=logo style=--bg:#333><a href=#><div class=logo-icon><img src=/logo/logo.png></div><div class=logo-text>Aiken's Blog</div></a></li><div class=menulist><li style=--bg:#f44336><a href=https://hugotest-phi.vercel.app/ title=home><div class=logo-icon><ion-icon name=home-outline></ion-icon></div><div class=logo-text>home</div></a></li><li style=--bg:#b145e9><a href=https://hugotest-phi.vercel.app/posts/ title=posts><div class=logo-icon><ion-icon name=newspaper-outline></ion-icon></div><div class=logo-text>posts</div></a></li><li style=--bg:#0f93c7><a href=https://hugotest-phi.vercel.app/tags/ title=tags><div class=logo-icon><ion-icon name=pricetags-outline></ion-icon></div><div class=logo-text>tags</div></a></li><li style=--bg:#ffa117><a href=https://hugotest-phi.vercel.app/categories/ title=categories><div class=logo-icon><ion-icon name=grid-outline></ion-icon></div><div class=logo-text>categories</div></a></li><li style=--bg:#0fc70f><a href=https://hugotest-phi.vercel.app/archives/ title=archives><div class=logo-icon><ion-icon name=folder-outline></ion-icon></div><div class=logo-text>archives</div></a></li><li style=--bg:#d16111><a href=https://hugotest-phi.vercel.app/about/ title=about><div class=logo-icon><ion-icon name=person></ion-icon></div><div class=logo-text>about</div></a></li><li style=--bg:#15c095><a href=https://hugotest-phi.vercel.app/search title="search (Alt + /)" accesskey=/><div class=logo-icon><ion-icon name=search></ion-icon></div><div class=logo-text>search</div></a></li></div><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt +T)"><li><div class=logo-icon id=moon><ion-icon name=moon-outline></ion-icon></div><div class=logo-icon id=sun><ion-icon name=sunny-outline></ion-icon></div></li></button></div></ul></div><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hugotest-phi.vercel.app/>Home</a>&nbsp;»&nbsp;<a href=https://hugotest-phi.vercel.app/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Fluent Python 01 数据模型与结构</h1><div class=post-meta><span title='2021-11-06 12:53:47 +0000 UTC'>November 6, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;563 words&nbsp;·&nbsp;aikenhong&nbsp;·&nbsp;<a href=/tags/python> Python</a>&nbsp;·&nbsp;<a href=/tags/langs> Langs</a>&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/fluent_python.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://hugotest-phi.vercel.app/cover/cover3.jpeg alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#chapter-1-%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b aria-label="Chapter 1 数据模型">Chapter 1 数据模型</a><ul class=header-level-2><li><a href=#se1-magic-method aria-label="Se1 magic method">Se1 magic method</a></li><li><a href=#se2-using-it-and-show-more aria-label="Se2 using it and show more">Se2 using it and show more</a><ul class=header-level-3><li><a href=#se21-overwrite-operator aria-label="Se2.1 overwrite operator">Se2.1 overwrite operator</a></li><li><a href=#se22-show-more aria-label="se2.2 show more">se2.2 show more</a></li></ul></li></ul></li><li><a href=#chapter-2-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="Chapter 2 数据结构">Chapter 2 数据结构</a><ul class=header-level-2><li><a href=#se-1-%e5%ba%8f%e5%88%97%e6%9e%84%e6%88%90%e7%9a%84%e6%95%b0%e7%bb%84 aria-label="se 1 序列构成的数组">se 1 序列构成的数组</a><ul class=header-level-3><li><a href=#se-11-%e7%b1%bb%e5%9e%8b%e6%a6%82%e5%bf%b5 aria-label="se 1.1 类型概念">se 1.1 类型概念</a></li><li><a href=#se-12-%e5%88%97%e8%a1%a8%e6%8e%a8%e5%af%bc%e7%94%9f%e6%88%90%e5%99%a8%e8%a1%a8%e8%be%be%e5%bc%8f aria-label="se 1.2 列表推导&生成器表达式">se 1.2 列表推导&生成器表达式</a></li><li><a href=#se-1-3-%e5%be%aa%e7%8e%af%e7%9a%84%e6%9c%ac%e8%b4%a8 aria-label="se 1. 3 循环的本质">se 1. 3 循环的本质</a></li><li><a href=#se-14-tuple%e4%b8%8d%e6%ad%a2%e4%b8%8d%e5%8f%af%e5%8f%98 aria-label="se 1.4 tuple不止不可变">se 1.4 tuple不止不可变</a></li><li><a href=#se-1-5-%e5%88%87%e7%89%87 aria-label="se 1 5 切片">se 1 5 切片</a></li><li><a href=#se-16-%e5%af%b9%e5%ba%8f%e5%88%97%e4%bd%bf%e7%94%a8- aria-label="se 1.6 对序列使用+ *">se 1.6 对序列使用<code>+ *</code></a></li><li><a href=#se-17-listsort-%e5%92%8csorted aria-label="se 1.7 list.sort 和sorted">se 1.7 list.sort 和sorted</a></li><li><a href=#se-18-%e5%85%b6%e4%bb%96%e5%ba%8f%e5%88%97%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="se 1.8 其他序列数据结构">se 1.8 其他序列数据结构</a></li></ul></li><li><a href=#se2-%e5%ad%97%e5%85%b8%e5%92%8c%e9%9b%86%e5%90%88 aria-label="Se2 字典和集合">Se2 字典和集合</a><ul class=header-level-3><li><a href=#%e6%b3%9b%e6%98%a0%e5%b0%84%e7%b1%bb%e5%9e%8b aria-label=泛映射类型>泛映射类型</a></li></ul></li></ul></li><li><a href=#chapter-3-%e6%8a%8a%e5%87%bd%e6%95%b0%e8%a7%86%e4%bd%9c%e5%af%b9%e8%b1%a1 aria-label="Chapter 3 把函数视作对象">Chapter 3 把函数视作对象</a><ul class=header-level-2><li><a href=#se-3-%e5%87%bd%e6%95%b0%e8%a3%85%e9%a5%b0%e5%99%a8%e5%92%8c%e9%97%ad%e5%8c%85 aria-label="se 3 函数装饰器和闭包">se 3 函数装饰器和闭包</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase(),n=document.querySelector(`.inner ul li a[href="#${t}"]`);n.classList.remove("read")}),activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach((t)=>{const o=encodeURI(t.getAttribute("id")).toLowerCase(),s=document.querySelector(`.inner ul li a[href="#${o}"]`);if(t===activeElement){s.classList.add("active");const e=document.querySelector(".toc .inner"),t=s.offsetTop,n=e.clientHeight,o=s.clientHeight,i=t-n/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else getOffsetTop(t)<e&&s.classList.add("read"),s.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return!document.querySelector(".hugo-encryptor-prompt")&&elements.length!=0&&(elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),console.log("Elements re-queried:",elements)),0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=chapter-1-数据模型>Chapter 1 数据模型<a hidden class=anchor aria-hidden=true href=#chapter-1-数据模型>#</a></h2><h3 id=se1-magic-method>Se1 magic method<a hidden class=anchor aria-hidden=true href=#se1-magic-method>#</a></h3><p>数据模型在这里的定义是对python框架的描述,他规范了python构建模块的接口；这些接口对应解释器中对一些特殊句法(常用句法)的激活和使用.本章节的核心就在于对这些特殊句法的理解和使用.
特殊方法带来的一些主要交互场景:</p><ul><li>迭代</li><li>属性访问</li><li>集合类</li><li>函数和方法的调用</li><li>对象的创建和销毁</li><li>字符串的表示形式和格式化</li><li>上下文管理模块(with模块)</li></ul><p>这些特殊方法的存在实际上，是为了让python的解释器调用，除非我们有大量的元编程，否则我们一般不调用他，通过内置的<code>len</code>等函数进行调用的话，他们的速度更快</p><p>下面我们通过最典型的<code>__getitem__</code>和<code>__len__</code>对其有简单的介绍, 并介绍各个魔术方法的使用场景</p><h3 id=se2-using-it-and-show-more>Se2 using it and show more<a hidden class=anchor aria-hidden=true href=#se2-using-it-and-show-more>#</a></h3><p>最常用也最典型的magic method 不外乎<code>__getitem__</code>和<code>__len__</code>;</p><ul><li>len即对当前对象提供对于通用的<code>len()</code>方法的接口,通常用于查看对象的<code>length or size</code></li><li>getitem除了提供<code>obj[index]</code>的索引方式的同时,<ul><li>他也会对python内置的那些迭代方法提供支持<code>for i in range(b)</code></li><li>对于依托于这些迭代的方法也能够得以支持<code>from random import choice</code></li><li>切片操作</li></ul></li></ul><h4 id=se21-overwrite-operator>Se2.1 overwrite operator<a hidden class=anchor aria-hidden=true href=#se21-overwrite-operator>#</a></h4><p>这一部分我们主要介绍如下的一些特殊方法,他们将实现<code>+,*,abs,print,bool</code>
对应的特殊方法可以从下面的代码中领会</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>hypot</span>
</span></span><span class=line><span class=cl><span class=c1># hypot will calculate the eud-dis from 0-point(x,y)</span>
</span></span><span class=line><span class=cl><span class=c1># we using vector as an example</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Vector</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># this method -&gt; print</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;Vertor(</span><span class=si>{}</span><span class=s2>,</span><span class=si>{}</span><span class=s2>)&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__abs__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>hypot</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__add__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>:</span><span class=n>Vector</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>other</span><span class=o>.</span><span class=n>x</span>
</span></span><span class=line><span class=cl>        <span class=n>y</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>other</span><span class=o>.</span><span class=n>y</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Vector</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__mul__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>scalar</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Vertor</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>x</span><span class=o>*</span><span class=n>scalar</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>y</span><span class=o>*</span><span class=n>scalar</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__bool__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>bool</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>x</span> <span class=ow>or</span> <span class=bp>self</span><span class=o>.</span><span class=n>y</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>在这里需要注意的是,中缀运算符像add,mul的原则都是不改变操作对象,而是生成一个新的对象.</p><h4 id=se22-show-more>se2.2 show more<a hidden class=anchor aria-hidden=true href=#se22-show-more>#</a></h4><p>这一部分我们会展示更多的一些特殊方法，对这些特殊方法的了解也方便我们对python中方法运行的一些掌握</p><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211107235441.png><img alt=image-20211107235440843 loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211107235441.png class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211107235441.png style="display:block;margin:0 auto" alt=image-20211107235440843></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>这些特殊方法的使用场景很容易从命名中可以得到一个基本的认知，像迭代，调用，集合等等的这些属性可能是相对常用的，要熟练进行掌握</p><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211107235931.png><img alt=image-20211107235931085 loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211107235931.png class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211107235931.png style="display:block;margin:0 auto" alt=image-20211107235931085></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>例如<code>__str__</code> | <code>__repr__</code>的方法,就可以方便我们进行print和相应的调试输出.</p><p><code>_iadd_</code> 对应的是<code>+=</code>的这种原地操作, 这个也是我们需要注意的</p><h2 id=chapter-2-数据结构>Chapter 2 数据结构<a hidden class=anchor aria-hidden=true href=#chapter-2-数据结构>#</a></h2><p>python的一个重要特点就在于多种数据结构上的操作通用性, 无论是字符串,列表,字节序列,XML元素,他们都公用一套丰富的操作.</p><p>此外在python的函数中, 当我们对一个对象进行就地改动, 那他就应该返回<code>None</code>, 这样可以让调用者知道传入的参数发生了改变, 并未产生新的对象, 这种约定俗成的定义方法, 实际上是一种好的习惯.</p><p><strong>迭代, 切片, 排序, 拼接</strong></p><p>在这里我们还是要熟悉一下各种类型支持的一些操作, 在python中我们可以通过<code>help(list)</code>查看, 当然最好还是做一个简单的总结熟悉对应的数据结构的一些默认方法.</p><h3 id=se-1-序列构成的数组>se 1 序列构成的数组<a hidden class=anchor aria-hidden=true href=#se-1-序列构成的数组>#</a></h3><h4 id=se-11-类型概念>se 1.1 类型概念<a hidden class=anchor aria-hidden=true href=#se-11-类型概念>#</a></h4><p>python标准库用C实现了丰富的序列类型, 列举如下.</p><table><thead><tr><th>序列类型</th><th>具体类型</th><th>类型特点</th></tr></thead><tbody><tr><td>容器序列</td><td>list, tuple, collections.deque</td><td>存放不同数据的类型</td></tr><tr><td>扁平序列</td><td>str, bytes, bytearray, memoryview, array.array</td><td>只能容纳一种类型</td></tr><tr><td>说明</td><td>上面是第一种分类情况, 下面会介绍另一种分类.<br>具体的特点会在下面介绍</td><td></td></tr><tr><td>可变序列</td><td>list, bytearray, array.array, collections.deque, memoryview</td><td>支持增删改</td></tr><tr><td>不可变序列</td><td>tuple, str, bytes</td><td>不支持增删改</td></tr></tbody></table><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211114010701.png><img alt=image-20211114010659279 loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211114010701.png class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211114010701.png style="display:block;margin:0 auto" alt=image-20211114010659279></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>通过这些类别中共有和非公有的特性，我们对这些序列的不同概念进行理解。</p><h4 id=se-12-列表推导生成器表达式>se 1.2 列表推导&生成器表达式<a hidden class=anchor aria-hidden=true href=#se-12-列表推导生成器表达式>#</a></h4><p>生成器表达式和列表推导式的<a href=https://zhuanlan.zhihu.com/p/64252902 target=_blank rel=noopener>区别</a>
，</p><p><code>list</code>是python中重要的一个可变序列类型，列表推导式是我们构建列表的快捷方式，生成器表达式则是创建其他任何类型的序列。</p><p>列表推导式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 这种方式实际上相比于循环来说更加易读</span>
</span></span><span class=line><span class=cl><span class=n>symbols</span> <span class=o>=</span> <span class=err>“</span><span class=o>&amp;*</span><span class=err>（</span><span class=o>@</span><span class=err>￥”</span>
</span></span><span class=line><span class=cl><span class=n>unicode</span> <span class=o>=</span> <span class=p>[</span><span class=nb>ord</span><span class=p>(</span><span class=n>symbol</span><span class=p>)</span> <span class=k>for</span> <span class=n>symbol</span> <span class=ow>in</span> <span class=n>symbols</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>clothes</span> <span class=o>=</span> <span class=p>[(</span><span class=n>color</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span> <span class=k>for</span> <span class=n>color</span> <span class=ow>in</span> <span class=n>colors</span> 
</span></span><span class=line><span class=cl>           				<span class=k>for</span> <span class=n>size</span> <span class=ow>in</span> <span class=n>sizes</span><span class=p>]</span> <span class=c1># 双层循环,写在里面的是外层循环</span>
</span></span><span class=line><span class=cl><span class=c1># 列表推导式 with conditions, 条件语句应该放在后面</span>
</span></span><span class=line><span class=cl><span class=n>res</span> <span class=o>=</span> <span class=p>[</span><span class=n>num</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> <span class=k>if</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># filter和map 也能完成列表推导式做得到的事情，当然lambda也可以</span>
</span></span><span class=line><span class=cl><span class=c1># 具体的map和filter的定义在后面详细解读</span>
</span></span><span class=line><span class=cl><span class=n>unicode</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>filter</span><span class=p>(</span><span class=k>lambda</span> <span class=n>c</span> <span class=p>:</span> <span class=n>c</span><span class=o>&gt;</span><span class=mi>127</span><span class=p>,</span> <span class=nb>map</span><span class=p>(</span><span class=nb>ord</span><span class=p>,</span> <span class=n>symbols</span><span class=p>)))</span>
</span></span></code></pre></td></tr></table></div></div><p>生成器表达式：</p><p>首先理解生成器和推导式的区别，推导式是直接完成整体的构建，而生成器是逐步的餐厨我们需要的元素，需要几个就产生几个，使用<code>yield</code>方法进行创建，而生成器表达式可以在没有该表达式的情况下及时创建简化生成器。</p><p>而在编写的时候和列表推导式的区别是，用<code>()</code>代替<code>[]</code>即可</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>tshirt</span> <span class=ow>in</span> <span class=p>(</span><span class=s1>&#39;</span><span class=si>{}</span><span class=s1> </span><span class=si>{}</span><span class=s1>&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=n>s</span><span class=p>)</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>colors</span> <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>sizes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>tshirt</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>生成器会逐个产出元素而不会一次性生成，所以实际上这种方法更有内存效率</p><h4 id=se-1-3-循环的本质>se 1. 3 循环的本质<a hidden class=anchor aria-hidden=true href=#se-1-3-循环的本质>#</a></h4><p>和迭代器有重要的关系，有<code>iter</code>方法都能进行迭代，我们可以用<code>hasattr</code>检查</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>hasattr</span><span class=p>(</span><span class=nb>str</span><span class=p>,</span> <span class=s1>&#39;__iter__&#39;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>循环的后台会发生如下的流程：</p><ol><li><code>iter()</code>将对象转换为迭代器对象</li><li><code>next()</code>逐渐获取序列的下一个元素</li><li><code>stopiteration</code>没有要调用的元素引发异常</li></ol><h4 id=se-14-tuple不止不可变>se 1.4 tuple不止不可变<a hidden class=anchor aria-hidden=true href=#se-14-tuple不止不可变>#</a></h4><p>tuple的不可变属性更应该作为一个<code>record</code>这种信息载体来使用，他的这种不可变的特性，让他的<code>position</code>和对应的存储都显得有意义，我们可以通过<code>_</code>占位<code>*</code>解包等操作，来对我们的数据进行读取和管理。</p><p>这里拆包的灵活使用是一个重点，用<code>*ignore</code>来跳过我们不需要的那些元素，也可以通过<code>fmt</code>来灵活的拆出嵌套元素</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>metro_areas</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s1>&#39;Tokyo&#39;</span><span class=p>,</span> <span class=s1>&#39;JP&#39;</span><span class=p>,</span> <span class=mi>36</span><span class=p>,</span> <span class=p>(</span><span class=n>x1</span><span class=p>,</span> <span class=n>x2</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s1>&#39;Tokyo&#39;</span><span class=p>,</span> <span class=s1>&#39;JP&#39;</span><span class=p>,</span> <span class=mi>36</span><span class=p>,</span> <span class=p>(</span><span class=n>x1</span><span class=p>,</span> <span class=n>x2</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s1>&#39;Tokyo&#39;</span><span class=p>,</span> <span class=s1>&#39;JP&#39;</span><span class=p>,</span> <span class=mi>36</span><span class=p>,</span> <span class=p>(</span><span class=n>x1</span><span class=p>,</span> <span class=n>x2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1># 这种format的编写方式也值得我们学习</span>
</span></span><span class=line><span class=cl><span class=n>fmt</span> <span class=o>=</span> <span class=s1>&#39;</span><span class=si>{:15}</span><span class=s1> | </span><span class=si>{:9.4f}</span><span class=s1> | </span><span class=si>{:9.4f}</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>name</span><span class=p>,</span><span class=n>cc</span><span class=p>,</span><span class=n>pop</span><span class=p>,(</span><span class=n>lati</span><span class=p>,</span><span class=n>longti</span><span class=p>)</span> <span class=ow>in</span> <span class=n>metro_areas</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>longtitude</span><span class=o>&lt;=</span><span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>fmt</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=n>lati</span><span class=p>,</span><span class=n>longti</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211114120246.png><img alt=image-20211114120244427 loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211114120246.png class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/3070imgs/20211114120246.png style="display:block;margin:0 auto" alt=image-20211114120244427></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>元组本身已经设计得不错, 但是作为记录来用的话, 我们通常需要给字段一个名称, <code>nametuple</code>就为我们解决这个问题:</p><p><code>collections.namedtuple</code>用来构建一个带字段名的元组和一个有名字的类,这个有名字的类帮助我们调试.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>namedtuple</span>
</span></span><span class=line><span class=cl><span class=n>contact</span> <span class=o>=</span> <span class=n>namedtuple</span><span class=p>(</span><span class=s1>&#39;contact&#39;</span><span class=p>,</span> <span class=n>key1</span><span class=p>,</span> <span class=n>key2</span><span class=p>,</span> <span class=n>key3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># first dimension is the typename</span>
</span></span><span class=line><span class=cl><span class=n>aiken</span> <span class=o>=</span> <span class=n>contact</span><span class=p>(</span><span class=n>v1</span><span class=p>,</span><span class=n>v2</span><span class=p>,</span><span class=n>v3</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>该<code>collections.namedtuple</code>除了元组的属性以外还行增了一些特性, 常用的有如下两个</p><ul><li><p><code>_fields</code> 返回包含所有字段的元组</p></li><li><p><code>_asdict()</code> 将具名元组转换为<code>collections.OrderedDict</code></p></li><li><p><code>_make()</code> 接受可迭代对象来生成类的一个实例, 也就是可以用<code>*解包</code>的方式来生成一个实例, 而这种方法在元组中是不可用的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>name_data</span> <span class=o>=</span> <span class=p>(</span><span class=n>v1</span><span class=p>,</span><span class=n>v2</span><span class=p>,</span><span class=n>v3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>name</span> <span class=o>=</span> <span class=n>contact</span><span class=o>.</span><span class=n>_make</span><span class=p>(</span><span class=o>*</span><span class=n>name_data</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=se-1-5-切片>se 1 5 切片<a hidden class=anchor aria-hidden=true href=#se-1-5-切片>#</a></h4><p>这一块切片的设计逻辑讲的很好, 为何从零开始且不包括最后一个, 会为我们带来很多操作上和可读性上的便利, 具体看书.</p><p><code>slice(start, stop, step)</code>实现切片对象, 或者<code>slice(stop)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>myslice</span> <span class=o>=</span> <span class=nb>slice</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>myslice</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>可以使用切片对象的方式能够将我们的切片规则参数化, 方便我们去设置和约定.</p><p>省略号在python中的表示是<code>...</code>, 这种用来作为多维切片的时候可能会用到</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=o>...</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=p>:,</span> <span class=p>:,</span> <span class=p>:]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=se-16-对序列使用->se 1.6 对序列使用<code>+ *</code><a hidden class=anchor aria-hidden=true href=#se-16-对序列使用->#</a></h4><p>序列使用<code>*n</code>的时候, 通常是建立一个新的对象, 但是如果序列中是对其他可变对象的引用的到时候, 实际上会得到n个引用结果.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 可以通过如下的代码测试</span>
</span></span><span class=line><span class=cl><span class=n>mylist</span> <span class=o>=</span> <span class=p>[[</span><span class=s1>&#39;_&#39;</span><span class=p>]]</span> <span class=o>*</span> <span class=mi>3</span> 
</span></span><span class=line><span class=cl><span class=n>mylist</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=c1># print [[&#39;_&#39;, &#39;_&#39;, 0], [&#39;_&#39;, &#39;_&#39;, 0], [&#39;_&#39;, &#39;_&#39;, 0]]</span>
</span></span></code></pre></td></tr></table></div></div><p>python的传值类型大多数情况下都是reference assign, 有时候我们对这种对象进行赋值的时候, 我们需要使用深拷贝来进行值的拷贝.</p><p><code>+=</code>是否有<code>_iadd_</code>的实现, 有很大的区别, <code>a+b</code>对应的是实现一个新的对象的产生, 我们可以通过<code>id</code>来进行检查. 如果不断没有必要的产生新的对象的话, 会存在比较大的浪费.</p><h4 id=se-17-listsort-和sorted>se 1.7 list.sort 和sorted<a hidden class=anchor aria-hidden=true href=#se-17-listsort-和sorted>#</a></h4><ul><li><code>list.sort</code> 就地修改, 返回None</li><li><code>sort(list)</code> 新建一个列表作为返回值, 可接受任何形式的可迭代对象, 最终返回的都是列表.</li></ul><p>函数有两个关键词<code>reverse</code>, <code>key</code>: 指定排序的标准.</p><p>用bisect来管理已排序的序列: 主要有两个函数<code>bisect</code>和<code>insort</code>, 通过这两个函数使用二分查找法在有序序列中查找或插入元素.</p><h4 id=se-18-其他序列数据结构>se 1.8 其他序列数据结构<a hidden class=anchor aria-hidden=true href=#se-18-其他序列数据结构>#</a></h4><p>列表虽然好用，但也不是万能的，再一些特定的情况下，有特定的数据结构能更好的支持对应的操作。</p><p>如果我们要存<strong>放大量的数据</strong>，这种时候array的效率要高得多（存放的是机器翻译），而吐过我们频繁的进行<strong>先进先出</strong>的策略deque的速度应该更快；
同样，如果我们需要频繁的检查一个元素是否出现在一个集合中，要考虑使用set（无序）</p><p><strong>数组ARRAY</strong>：
如果我们只需要一个包含数字的列表，那么array.array会比list更加高效，同样他也支持所有可变序列相关的操作，<code>pop,insert,extend</code>,也提供共文件读取和存储的更快的操作：<code>.frombytes, .tofild</code></p><p>array在使用的过程中需要指定存储的类型码(具体使用的时候查阅):
<code>floats = array('d', (random() for i in range(10**7)))</code></p><p>存取大数组到array的二进制文件比存储到文本文件中快60倍, 因为这种操作中避免了float函数的执行, 写入同样的也快7倍, 同时占用的空间更少.</p><p>同样<code>pickle</code>处理浮点数组的方式几乎和<code>array</code>一样快, 且<code>pickle</code>可以处理各种各样的数字类型, 甚至简单的自定义类型, 是一个快速序列化数字类型的方法.</p><p><strong>memoryview</strong>:
内存视图使得用户在不复制内容的情况下操作同一个数组的不同切片. 实际上是Numpy一些功能的简单实现</p><p><strong>numpy & scipy</strong>:
Numpy实现了多维同质数组和矩阵
Scipy是基于Numpy的科学计算库, 为线性代数,数值积分和统计学设计</p><ul><li><code>collections.deque</code> 线程安全, 可以从两端添加或者删除元素. 常用来作为最近用到的几个元素</li><li><code>queue</code>同步类Queue, LifoQueue, PriorityQueue</li><li><code>multiprocessing</code>设计为了进程之间的通信</li><li><code>heapq</code>当作堆和优先队列来用</li></ul><h3 id=se2-字典和集合>Se2 字典和集合<a hidden class=anchor aria-hidden=true href=#se2-字典和集合>#</a></h3><h4 id=泛映射类型>泛映射类型<a hidden class=anchor aria-hidden=true href=#泛映射类型>#</a></h4><h2 id=chapter-3-把函数视作对象>Chapter 3 把函数视作对象<a hidden class=anchor aria-hidden=true href=#chapter-3-把函数视作对象>#</a></h2><h3 id=se-3-函数装饰器和闭包>se 3 函数装饰器和闭包<a hidden class=anchor aria-hidden=true href=#se-3-函数装饰器和闭包>#</a></h3><p>这一部分不同于之前的</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://hugotest-phi.vercel.app/tags/python/>Python</a></li><li><a href=https://hugotest-phi.vercel.app/tags/langs/>Langs</a></li></ul><nav class=paginav><a class=prev href=https://hugotest-phi.vercel.app/posts/owl-survey/><span class=title>« Prev</span><br><span>OWL-survey</span>
</a><a class=next href=https://hugotest-phi.vercel.app/posts/python/><span class=title>Next »</span><br><span>Python01 数据模型和常用数据结构</span></a></nav></footer><div id=disqus_thread></div><script>function loadDisqus(){var e=document,t=e.createElement("script");t.src="https://aiken-hugo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t),window.disqus_config=function(){this.page.url=window.location.href,this.page.identifier=window.location.href.substring(18)}}var runningOnBrowser=typeof window!="undefined",isBot=runningOnBrowser&&!("onscroll"in window)||typeof navigator!="undefined"&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){if(!isBot&&supportsIntersectionObserver){var e=new IntersectionObserver(function(t){t[0].isIntersecting&&(loadDisqus(),e.disconnect())},{threshold:[0]});e.observe(document.getElementById("disqus_thread"))}else loadDisqus()},1)</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://hugotest-phi.vercel.app/>aiken's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container>Visitors: <span id=busuanzi_value_site_uv></span>
Views: <span id=busuanzi_value_site_pv></span></span></footer><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),o=13863,i=16993;if(!e||!t){console.error("Busuanzi elements not found.");return}const n=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+o;break}}),s=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){s.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+i;break}});n.observe(e,{childList:!0}),s.observe(t,{childList:!0})})</script><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))}),document.getElementById("theme-toggle-nav").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("/js/pangu.js",function(){pangu.spacingPage()})</script></body></html>