<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git 01 入门与常用操作 | aiken's blog</title>
<meta name=keywords content="Git,Github"><meta name=description content='参考文献：稀土掘金
 | ProGit2
GIT 与 SVN 的区别
SVN 是集中式版本控制系统，其所有的版本管理都是集中在某个中央服务器，因此，在干活的时候，首先都需要从中央服务器中获取最新的版本，修改后将版本推送到中央服务器，因此大多数场景下需要进行联网使用。可能会更依托于相应的图形化客户端来进行同步和版本管理，便于管理美术资源等等。
GIT 是分布式版本管理系统，每个人的电脑就是一个完整的版本库，可以进行独立的版本管理，多人协作可能依托于 github 之类的中继节点，将修改同步给对方，解决冲突。
Init 初始化
包含 ssh 的详细指令在 ssh 的文档中，这边只介绍设置完这一系列操作之后的 git 初始化，主要是初始化 ssh，并将私钥放到 github 或者 gitee 的账户中。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


git config --global user.name "YourName"
git config --global user.email "YourEmailAdress"

# 查看相关的配置信息
git config --list

# 设置CRLF和LF的相关转换 第一条在提交的时候自动抓换位LF，迁出转换为CRLF
# 第二条拒绝混合换行符的提交
git config --global core.autocrlf true
git config --global core.safecrlf true 


Github 设置
官方文档介绍的一些权限错误的地址：< https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey>
'><meta name=author content="aikenhong"><link rel=canonical href=https://hugotest-phi.vercel.app/posts/git_manual1/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://hugotest-phi.vercel.app/favicon/ghost.ico><link rel=icon type=image/png sizes=16x16 href=https://hugotest-phi.vercel.app/favicon/ghost-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hugotest-phi.vercel.app/favicon/ghost-32x32.png><link rel=apple-touch-icon href=https://hugotest-phi.vercel.app/favicon/ghost-apple-touch-icon.png><link rel=mask-icon href=https://hugotest-phi.vercel.app/favicon/ghost-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hugotest-phi.vercel.app/posts/git_manual1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><meta property="og:url" content="https://hugotest-phi.vercel.app/posts/git_manual1/"><meta property="og:site_name" content="aiken's blog"><meta property="og:title" content="Git 01 入门与常用操作"><meta property="og:description" content='参考文献：稀土掘金 | ProGit2
GIT 与 SVN 的区别 SVN 是集中式版本控制系统，其所有的版本管理都是集中在某个中央服务器，因此，在干活的时候，首先都需要从中央服务器中获取最新的版本，修改后将版本推送到中央服务器，因此大多数场景下需要进行联网使用。可能会更依托于相应的图形化客户端来进行同步和版本管理，便于管理美术资源等等。
GIT 是分布式版本管理系统，每个人的电脑就是一个完整的版本库，可以进行独立的版本管理，多人协作可能依托于 github 之类的中继节点，将修改同步给对方，解决冲突。
Init 初始化 包含 ssh 的详细指令在 ssh 的文档中，这边只介绍设置完这一系列操作之后的 git 初始化，主要是初始化 ssh，并将私钥放到 github 或者 gitee 的账户中。
1 2 3 4 5 6 7 8 9 10 git config --global user.name "YourName" git config --global user.email "YourEmailAdress" # 查看相关的配置信息 git config --list # 设置CRLF和LF的相关转换 第一条在提交的时候自动抓换位LF，迁出转换为CRLF # 第二条拒绝混合换行符的提交 git config --global core.autocrlf true git config --global core.safecrlf true Github 设置 官方文档介绍的一些权限错误的地址：< https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey> '><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-01T12:19:34+00:00"><meta property="article:modified_time" content="2022-02-01T12:19:34+00:00"><meta property="article:tag" content="Git"><meta property="article:tag" content="Github"><meta property="og:image" content="https://hugotest-phi.vercel.app/cover/cover13.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hugotest-phi.vercel.app/cover/cover13.jpeg"><meta name=twitter:title content="Git 01 入门与常用操作"><meta name=twitter:description content='参考文献：稀土掘金
 | ProGit2
GIT 与 SVN 的区别
SVN 是集中式版本控制系统，其所有的版本管理都是集中在某个中央服务器，因此，在干活的时候，首先都需要从中央服务器中获取最新的版本，修改后将版本推送到中央服务器，因此大多数场景下需要进行联网使用。可能会更依托于相应的图形化客户端来进行同步和版本管理，便于管理美术资源等等。
GIT 是分布式版本管理系统，每个人的电脑就是一个完整的版本库，可以进行独立的版本管理，多人协作可能依托于 github 之类的中继节点，将修改同步给对方，解决冲突。
Init 初始化
包含 ssh 的详细指令在 ssh 的文档中，这边只介绍设置完这一系列操作之后的 git 初始化，主要是初始化 ssh，并将私钥放到 github 或者 gitee 的账户中。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


git config --global user.name "YourName"
git config --global user.email "YourEmailAdress"

# 查看相关的配置信息
git config --list

# 设置CRLF和LF的相关转换 第一条在提交的时候自动抓换位LF，迁出转换为CRLF
# 第二条拒绝混合换行符的提交
git config --global core.autocrlf true
git config --global core.safecrlf true 


Github 设置
官方文档介绍的一些权限错误的地址：< https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey>
'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hugotest-phi.vercel.app/posts/"},{"@type":"ListItem","position":2,"name":"Git 01 入门与常用操作","item":"https://hugotest-phi.vercel.app/posts/git_manual1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git 01 入门与常用操作","name":"Git 01 入门与常用操作","description":"参考文献：稀土掘金 | ProGit2\nGIT 与 SVN 的区别 SVN 是集中式版本控制系统，其所有的版本管理都是集中在某个中央服务器，因此，在干活的时候，首先都需要从中央服务器中获取最新的版本，修改后将版本推送到中央服务器，因此大多数场景下需要进行联网使用。可能会更依托于相应的图形化客户端来进行同步和版本管理，便于管理美术资源等等。\nGIT 是分布式版本管理系统，每个人的电脑就是一个完整的版本库，可以进行独立的版本管理，多人协作可能依托于 github 之类的中继节点，将修改同步给对方，解决冲突。\nInit 初始化 包含 ssh 的详细指令在 ssh 的文档中，这边只介绍设置完这一系列操作之后的 git 初始化，主要是初始化 ssh，并将私钥放到 github 或者 gitee 的账户中。\n1 2 3 4 5 6 7 8 9 10 git config --global user.name \u0026#34;YourName\u0026#34; git config --global user.email \u0026#34;YourEmailAdress\u0026#34; # 查看相关的配置信息 git config --list # 设置CRLF和LF的相关转换 第一条在提交的时候自动抓换位LF，迁出转换为CRLF # 第二条拒绝混合换行符的提交 git config --global core.autocrlf true git config --global core.safecrlf true Github 设置 官方文档介绍的一些权限错误的地址：\u0026lt; https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey\u003e ","keywords":["Git","Github"],"articleBody":"参考文献：稀土掘金 | ProGit2\nGIT 与 SVN 的区别 SVN 是集中式版本控制系统，其所有的版本管理都是集中在某个中央服务器，因此，在干活的时候，首先都需要从中央服务器中获取最新的版本，修改后将版本推送到中央服务器，因此大多数场景下需要进行联网使用。可能会更依托于相应的图形化客户端来进行同步和版本管理，便于管理美术资源等等。\nGIT 是分布式版本管理系统，每个人的电脑就是一个完整的版本库，可以进行独立的版本管理，多人协作可能依托于 github 之类的中继节点，将修改同步给对方，解决冲突。\nInit 初始化 包含 ssh 的详细指令在 ssh 的文档中，这边只介绍设置完这一系列操作之后的 git 初始化，主要是初始化 ssh，并将私钥放到 github 或者 gitee 的账户中。\n1 2 3 4 5 6 7 8 9 10 git config --global user.name \"YourName\" git config --global user.email \"YourEmailAdress\" # 查看相关的配置信息 git config --list # 设置CRLF和LF的相关转换 第一条在提交的时候自动抓换位LF，迁出转换为CRLF # 第二条拒绝混合换行符的提交 git config --global core.autocrlf true git config --global core.safecrlf true Github 设置 官方文档介绍的一些权限错误的地址：\u003c https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey\u003e 将本机的 ssh 公钥(public)放到 GITHUB 账户下的 ssh 管理地址，执行测试\n1 ssh -T git@github.com 没有问题的话就可以直接进行 clone，之类的 git 操作了\n1 2 # 小trick，不拉取历史的commit git clone --depth=1 REPO_ADRESS Gitignore 文件编写 参考文件：【 Git忽略提交规则 】【 gitignore 各语言模版 】\n首先创建对应的 .gitignore 文件，根据自己的需求编写内容，这里也推荐通过 VsCode 的插件或者使用上述仓库中对应语言的模版文件来创建初始化 ignore 文件，会包含一些常用的通常无需上传的本地配置或者本地缓存等内容；\n1 touch .gitignore 在覆盖了这些通用的忽略项后，可以根据项目情况添加特有的路径，通常主要包括以下的几类：\n大文件：如自用的测试数据等 敏感配置文件：包含了敏感信息的配置项等（这里建议考虑使用 env 等，或者上传对应的 default 文件） 日志文件 设置 Git 的代理 设置全局代理使用如下的方式：\n1 2 git config --global http.proxy 127.0.0.1:1080 git config --global https.proxy 127.0.0.1:1080 同理取消全局代理如下\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy 常用指令与架构介绍 Git 整体的使用架构如下图所示 ，一般而言开发者在工作区进行当前修改，将需要同步或者发布的修改内容通过暂存区存储到本地 \u0026 远程仓库中，结合远程仓库的协作特性和分支功能，可以实现同个项目的多人同步分离开发，同时开发多种功能等。\n因此 Git 或者 Svn 等 CLI 的使用技能，在公司中或者在项目参与中是相当重要的，建议每个人程序开发者都能对其有一定的了解。\n下面是一些基本的命令使用，其中许多命令都有一些额外的参数可供使用，如果经常使用 Git 建议可以简单阅读一下 ProGit。\n这里会简单记录一些命令，其中那些在 git 使用中会有所提示的命令就不再赘述，例如 pull 别的分支的时候取消 merge 到当前分支的 git merge –abort 之类就会有所提示。\n普通 command 分支 command 创建本地 repo git init 创建/显示分支 git branch name 工作区状态 git status 切换分支 git checkout [branch] 添加到暂存区 git add /. 切换 git checkout -b name 暂存区到本地 git commit -m ‘mesg’ 合并分支 git merge branch 日志 git log (–oneline) 删除分支 git branch -d 拉取远程库 git pull / git fetch 推送本地分支 git push origin branch 克隆远程库 git clone 撤销 标签 撤销工作区修改 git checkout – file-name 创建标签 git tag tag-name 撤销暂存区修改 git reset HEAD file-name 显示所有标签 git tag 撤销本地库修改 git reset –hard commitID 删除标签 git tag -d tag 远程 储藏 · 同步本地库和 git remote add origin xx@y repo 保存现场 git stash 远程库 git push -u origin master 恢复现场 git stash pop Commit 规范和相关命令 commit 命令实现将\"将暂存区的文件以特定的注释提交到仓库中\"，提交的 Message 建议建立统一的规范，这样可以方便后续使用 log 查阅的时候定位到特定修改的 commit。\nMessage Standard 标准提交内容 本人推荐的 Commit Message 格式如下，该格式并非是一成不变的，可以根据仓库中存放的项目类型来灵活变更 Tag 的数量和内容。\n1 git commit -m \"[tag1(modify scope)] [tag2(modify type)]: excatly modify info\" Tag1 (modify scope): 说明修改的内容，泛一些例如修改代码 code，资源 res，细一些则例如修改的文件夹 tool、util Tag2（modify type）：说明修改的类型，主要有：Feat、Fix、Refactor、Style、Test、Docs、Merge，如果修改的是资源等文件可以忽略。 Modify info：修改的详细信息，说明修改的目的和修改的内容即可 例如以下的几个写法：\n1 2 3 git commit -m \"[res]: add presonal conf file\" git commit -m \"[code-util][Feat]: add function to parser conf file\" git commit -m \"[code \u0026 res][Feat \u0026 Fix]: add function for merge conf, fix bug on parser conf, add my conf resource\" 该部分没有什么硬性要求，只需要自己能够清晰的看懂自己的 commit 且具备一致性即可。\nExtra Operation 撤销、重写、合并 有时候针对已经提交的 Commit 不满意，或者有一些新的更改需要添加到上一次的 Commit 中，可以参考下面的操作。\n撤销 Commit 或者重写 Commit Message\n1 2 git reset --soft HEAD^ # 撤销当前commit git commit --amend # 重写当前commit 合并多次 Commit：通过 rebase 命令来进行 merge，该命令通过整理多次的 Commit 来使得整个提交历史更为整洁有序，但是需要额外的精力去整理就是。具体的操作流程如下：\n首先查看 commit 的 hash 1 git log 找到需要修改的 commit 的前一个 commit 的 ID 1 2 3 4 5 # 找到需要合并的最早commit的上一个的ID git rebase -i # 也可以使用以下命令合并header往前多少n次的commit git rebase -i HEAD~n square：将该次 commit 和上一次 commit 合并 pick：保留该次 commit 通过修改 commit 提交界面的 square 和 pick 即可实现多次 commit 的合并。\nHistory 历史查看 查看当前分支的提交历史只需要通过 git log 即可看到基本的提交信息，这里简要介绍一些参数来帮助更清晰的定位 commit\ngit log -p -{n}: 参数 -p 以 diff 的形式在显示基本提交信息的基础上还显示该提交的具体修改内容，由于内容较多；可以通过 -{n} 仅显示最近 n 次提交的内容 git log --stat ：参数 --stat 显示每次提交的统计信息，包含修改的文件以及对该文件修改的行数的统计信息 git log --graph： 参数 --graph 会使用简单的 ASCII 图像来可视化提交之间的分支关系，也就是 vscode 中 gitgraph 的命令行版本，可以帮助了解提交之间的合并和起始提交等信息 此外还有诸如 --pretty 等参数可以自定义 log 显示的具体格式，需要的话可以参阅 progit 或者官方文档进行了解。\nAdd 一些额外操作 Add 命令主要将修改的内容提交到暂存区，不仅可以作为我们一次次的中间存储节点，也是为后续的提交做缓冲，但是难免会遇到以下的情况：\n提交错文件或者修改了结构需要将一个或者多个文件从暂存区中撤退出来； 清除工作区中不需要提交的临时文件 如果是撤销所有提交的文件：\n1 git reset HEAD . 撤销特定文件的提交\n1 git reset HEAD 以上两个命令不需要记录，只需要使用 git status 查看当前状态的时候会有提示。\n清除工作区中不需要提交的临时文件，可以使用以下的命令\n1 2 git clean -nf # 查看会被清除的未追踪文件 git clean -f # 清除未追踪的文件 如果涉及到文件夹可以添加参数 d\n1 2 git clean -ndf # 查看会被清除的未追踪文件和文件夹 git clean -fd # 实际执行清除指令 其中-n 参数为查看而不实际执行的参数，避免文件的误删。具体可以通过 git help clean 查看。\nCherryPick 挑选 Commit 仅简要介绍其作用，详细使用等后续有使用场景再来补充。\nGit CherryPick 命令实现从别的分支挑选某个 Commit 的修改合并到当前分支中，该命令在一些提交数少的分支中，可以代替 merge，实现一个更为线性整洁的 Master 分支。\n可以结合 Rebase 合并提交使用，由此得到一个更为干净的提交历史。\n暂存区 \u0026 Stash 暂存区指的是 git add. 后存储到的区域，用来作为本地和仓库之间的缓存。\n暂存区处理 清除暂存区某个文件的指令（通常是为了修改.gitignore）的时候执行\n1 git rm -r --cache filename 看暂存区有什么文件\n1 2 git ls-files git status stash 区域使用 是一个特殊的区域，本地的 git 存储区，一般来说使用场景较少，例如以下的场景。\n本地改了代码，但是突然有个人过来问你另一个分支的问题，同时这个时候你在实现某个功能，实现一半，又不想提交到 Git 仓库中，那么你就可以考虑使用 git stash save \"临时存一下\"，这个时候它就会帮你存到这个储存区，你去其他分支做完事情回来，再 git stash pop就好了。\n主要使用的就是以下的几个命令：\ngit stash save \"message\" 将当前的修改暂存 git stash list 查看暂存了哪些修改 git pop 默认使用存储的堆栈中的第一个 stash git stash apply stash@{n} 使用第 n+1 个 stash，n 从 0 开始。 一般建议是不要使用太多的 stash，这样一个 save 和一个 pop 命令就可以 handle 。\n如果 pop 操作导致冲突，希望撤销 git stash pop 行为，可以使用 git reset --hard 回退当前修改，该操作会保留 pop 出来的修改仍然在 stash 中。\n一些 Git 工作流介绍 使用 Git Rebase 保持简洁的 History 参考资料： 优雅且安全的使用 GitRebase 前文已经介绍过了 git rebase 用于合并 merge 的功能，这里主要介绍的是 git rebase 在分支合并中的作用，何时在分支管理中使用 git rebase 取代 git merge 来进行分支合并。\ngit merge 是一种非破坏性的操作，当我们使用 git merge 进行分支合并的时候，会提供一个新的 commit ，其内容为两个分支的合并提交，这也是与 rebase 最大的区别。\nrebase 正如其单词所言，re-base，重构我们的 base，我们可以使用下面的命令将 master 分之合并到我们的 dev 分支中：\n1 2 git checkout dev git rebase master 这会将我们的 dev 分支的新增内容移动到 master 分支之后，相当于重新构建了 dev 分支上的每个 commit，将其在新的 master 之后再合入。\n使用这种方式的话，项目的历史记录会更为线性，会使得分支的提交历史更加整洁，没有不必要的合并提交，考虑到可能在开发过程中我们可能会多次需要更新 master 分支的内容，这样能让我们的更新更加容易追溯和复原。\n此外正如合并多次 commit 的操作，使用 -i 可以开启 rebase 的交互模式，交互模式中我们就可以将多次提交浓缩为单次提交(squash)，或者合并某两个连续的提交(fixup)。\ntips: 如果需要一次性将从 master 分出来的 dev 上的第一个提交到最后一个 dev 上的提交合并，避免用 Head~n 去数，或者手动去找对应的 commitID，也可以用 git merge-base dev master 代替，这里的 master 就是你的切出 dev 的原始分支，不一定是 master。\n但是由于 rebase 操作是一个破坏性的操作，会修改我们之前的每次原始提交，因此在使用的时候需要慎重，遵循 rebase 使用的法则：永远不要再公共分支上使用它，在公共分支使用会导致所有人的原始 master 和远端无法对齐，导致一系列问题。\n但是如果别人同样在远程开发 dev 分支，我们 fetch 后同样可以考虑使用 merge 或者 rebase 更新 dev 分支本身，因为这只影响了我们 local 端的后续提交。BTW，git pull --rebase 可以强制使用 rebase 的方式来集成远程分支。\n最终开发完成后，使用 rebase 更新分支上 master 的内容，再去 master 上 merge，会产生最好的线性历史记录，也确保不会影响他人的开发：\n1 2 3 4 5 git checkout dev git rebase master git checkout master git merge dev git push origin master:master 如果不确定 rebase 的使用是否正确，可以复制一个临时分支来执行 rebase，如果不小心搞乱了，还可以有原始的分支来复原。\n使用 Git Merge –squash 保持简洁 History 除了上述使用 rebase 将分支上的 commit 逐个移动到 master 分支之后，进而维持 master 上的线性提交历史，上述还提到可以使用 rebase 合并多次 commit 后进行提交，但由于 rebase 本身会改变开发分支，所以实际上更推荐仅在 Merge 的时候进行分支上的 commit 合并（例如开发分支上的 commit 较为随意的情况），这种情况下可以在 rebase 的时候使用-i 操作或者使用 git merge --squash {branch} 进行 merge\n远程协作 考虑多用户，多分支的在线场景，如何有效的 Pull \u0026 Push.\n在本地仓库切换默认提交用户 在多用户的终端场景，推送前记得切换相关的用户设置。\n1 2 git config --local user.name \"YourName\" git config --local user.emali \"YourEmail\" 推送、拉取远程分支 1 2 3 # 冒号前本地，冒号后远程， git push origin local_branch:remote_branch git pull origin remote_branch:local_branch 仅 Clone 指定分支 1 git clone -b {branch} {rep} 拉取代码解决冲突 git fetch 实际上 pull = fetch + merge，可以解决完冲突再进行代码提交，相对 pull 更安全，结合 Vscode 中的 Gitgraph 等，用于解决冲突和验证修改方面更为安全简单。\n1 2 3 git fetch git log -p FETCH_HEAD git merge FETCH_HEAD 通过使用 Stash 的方式，同样可以避免再拉取远程代码的时候不覆盖本地的代码，灵活选用吧，一般情况下使用 fetch 已经足够。\n一些工具 一些好用的 CLI（命令行工具）和 VsCode 插件推荐：\nLazygit （命令行工具，带一个比较酷炫的 GUI） Gitlens（VsCode）：在编辑界面显示每行代码的提交者，丰富 github 的 git 拓展选项 Gitgraph（VsCode）：方便查看每次 commit 的修改内容，用对比窗口显示，便于发现冲突解决和修改内容 Beyond Compare（差异对比工具）：类似 diff 命令，非常好用的对比和修改不同版本的文件，文件夹之间的差异。 Win Merge （差异对比工具）： BC 的免费替代品，基本上是足够使用的。 还有一些诸如 tortoise 和 github 客户端等图形界面也可供尝试 Troubleshooting 从 Commit 中删除大文件 避免.git 目录占用过多存储，这一部分写的有点小瑕疵，到时候就看超链接\n郑宇 ；主要是要将大文件排除追踪，在 push 之前都还是比较好解决的，但是如果已经提交上去了就稍微比较麻烦，尝试将其中的大文件删掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 1. 运行gc，生成pack文件`–prune = now` 表示对所有的文件都做修剪 git gc --prune=now # 2. 找出最大的k个文件，以3为例 git verify -pack -v .git/objects/pack/*.idx |sort -k -3 -n |tail -3 # bug: cannot open ///bad .. # 可能是由于地址出错了，修改地址，如下是查看地址的代码 find .git/objects/ -type -f # 3. 查看那些大文件究竟是谁，按照上一步输出的hash value 进行搜索，（不用全长） git rev-list --objects --all |grep # 4. 移除对该文件的追踪引用 git filter-branch --force --index-filter \"git rm --cache --ignore-unmatch ''\" --prune-empty --tag-name-filter cat -- --all # 5. 进行repack git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin git reflog expire --expire=now --all git gc --prune=now # 6. 查看pack的空间使用情况 git count-objects -v # 7. 强制推送重构大文件 git push origin local-b:remote-b --force 连接问题 openssl error 10054 1 git config --global http.postBuffer 524288000 time out port443 just wait for some time，应该是代理的问题，不行就使用国行版 github 把\nserver certificate verification failed. CAfile 使用github.com.cnpmjs.org国内镜像站的时候，可能会出现权限的问题，这种情况下就要对 git 的证书验证命令做调整，有两种策略，执行其中一种：\n1 git config --global http.sshverify false 1 2 # carry out in the export GIT_SSL_NO_VERIFY=1 之后我们就可以正常的使用镜像站对原有的 repo 进行更新和拉取了，比如说 omz update.\nToBeContinue Git Rebase专题：GIt Merge和Git Rebase的区别 Git Reset 和 Git Cherrypick 专题：紧急修复 Git tag 专题开发标签 ","wordCount":"1140","inLanguage":"en","image":"https://hugotest-phi.vercel.app/cover/cover13.jpeg","datePublished":"2022-02-01T12:19:34Z","dateModified":"2022-02-01T12:19:34Z","author":[{"@type":"Person","name":"aikenhong"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://hugotest-phi.vercel.app/posts/git_manual1/"},"publisher":{"@type":"Organization","name":"aiken's blog","logo":{"@type":"ImageObject","url":"https://hugotest-phi.vercel.app/favicon/ghost.ico"}}}</script></head><body id=top><script type=module src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.esm.js defer></script><script nomodule src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.js defer></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hugotest-phi.vercel.app/ accesskey=h title="aiken's blog (Alt + H)">aiken's blog</a><div class=logo-switches><button id=theme-toggle-nav accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hugotest-phi.vercel.app/ title=home><span>home</span></a></li><li><a href=https://hugotest-phi.vercel.app/archives/ title=archives><span>archives</span></a></li><li><a href=https://hugotest-phi.vercel.app/search title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><div class=sidebar><ul><li class=logo style=--bg:#333><a href=#><div class=logo-icon><img src=/logo/logo.png></div><div class=logo-text>Aiken's Blog</div></a></li><div class=menulist><li style=--bg:#f44336><a href=https://hugotest-phi.vercel.app/ title=home><div class=logo-icon><ion-icon name=home-outline></ion-icon></div><div class=logo-text>home</div></a></li><li style=--bg:#b145e9><a href=https://hugotest-phi.vercel.app/posts/ title=posts><div class=logo-icon><ion-icon name=newspaper-outline></ion-icon></div><div class=logo-text>posts</div></a></li><li style=--bg:#0f93c7><a href=https://hugotest-phi.vercel.app/tags/ title=tags><div class=logo-icon><ion-icon name=pricetags-outline></ion-icon></div><div class=logo-text>tags</div></a></li><li style=--bg:#ffa117><a href=https://hugotest-phi.vercel.app/categories/ title=categories><div class=logo-icon><ion-icon name=grid-outline></ion-icon></div><div class=logo-text>categories</div></a></li><li style=--bg:#0fc70f><a href=https://hugotest-phi.vercel.app/archives/ title=archives><div class=logo-icon><ion-icon name=folder-outline></ion-icon></div><div class=logo-text>archives</div></a></li><li style=--bg:#d16111><a href=https://hugotest-phi.vercel.app/about/ title=about><div class=logo-icon><ion-icon name=person></ion-icon></div><div class=logo-text>about</div></a></li><li style=--bg:#15c095><a href=https://hugotest-phi.vercel.app/search title="search (Alt + /)" accesskey=/><div class=logo-icon><ion-icon name=search></ion-icon></div><div class=logo-text>search</div></a></li></div><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt +T)"><li><div class=logo-icon id=moon><ion-icon name=moon-outline></ion-icon></div><div class=logo-icon id=sun><ion-icon name=sunny-outline></ion-icon></div></li></button></div></ul></div><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hugotest-phi.vercel.app/>Home</a>&nbsp;»&nbsp;<a href=https://hugotest-phi.vercel.app/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Git 01 入门与常用操作</h1><div class=post-meta><span title='2022-02-01 12:19:34 +0000 UTC'>February 1, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1140 words&nbsp;·&nbsp;aikenhong&nbsp;·&nbsp;<a href=/tags/git> Git</a>&nbsp;·&nbsp;<a href=/tags/github> Github</a>&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Git_Manual1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://hugotest-phi.vercel.app/cover/cover13.jpeg alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#git-%e4%b8%8e-svn-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="GIT 与 SVN 的区别">GIT 与 SVN 的区别</a></li><li><a href=#init-%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label="Init 初始化">Init 初始化</a><ul class=header-level-2><li><a href=#github-%e8%ae%be%e7%bd%ae aria-label="Github 设置">Github 设置</a></li><li><a href=#gitignore-%e6%96%87%e4%bb%b6%e7%bc%96%e5%86%99 aria-label="Gitignore 文件编写">Gitignore 文件编写</a></li><li><a href=#%e8%ae%be%e7%bd%ae-git-%e7%9a%84%e4%bb%a3%e7%90%86 aria-label="设置 Git 的代理">设置 Git 的代理</a></li></ul></li><li><a href=#%e5%b8%b8%e7%94%a8%e6%8c%87%e4%bb%a4%e4%b8%8e%e6%9e%b6%e6%9e%84%e4%bb%8b%e7%bb%8d aria-label=常用指令与架构介绍>常用指令与架构介绍</a><ul class=header-level-2><li><a href=#commit-%e8%a7%84%e8%8c%83%e5%92%8c%e7%9b%b8%e5%85%b3%e5%91%bd%e4%bb%a4 aria-label="Commit 规范和相关命令">Commit 规范和相关命令</a><ul class=header-level-3><li><a href=#message-standard-%e6%a0%87%e5%87%86%e6%8f%90%e4%ba%a4%e5%86%85%e5%ae%b9 aria-label="Message Standard 标准提交内容">Message Standard 标准提交内容</a></li><li><a href=#extra-operation-%e6%92%a4%e9%94%80%e9%87%8d%e5%86%99%e5%90%88%e5%b9%b6 aria-label="Extra Operation 撤销、重写、合并">Extra Operation 撤销、重写、合并</a></li></ul></li><li><a href=#history-%e5%8e%86%e5%8f%b2%e6%9f%a5%e7%9c%8b aria-label="History 历史查看">History 历史查看</a></li><li><a href=#add-%e4%b8%80%e4%ba%9b%e9%a2%9d%e5%a4%96%e6%93%8d%e4%bd%9c aria-label="Add 一些额外操作">Add 一些额外操作</a></li><li><a href=#cherrypick-%e6%8c%91%e9%80%89-commit aria-label="CherryPick 挑选 Commit">CherryPick 挑选 Commit</a></li></ul></li><li><a href=#%e6%9a%82%e5%ad%98%e5%8c%ba--stash aria-label="暂存区 & Stash">暂存区 & Stash</a><ul class=header-level-2><li><a href=#%e6%9a%82%e5%ad%98%e5%8c%ba%e5%a4%84%e7%90%86 aria-label=暂存区处理>暂存区处理</a></li><li><a href=#stash-%e5%8c%ba%e5%9f%9f%e4%bd%bf%e7%94%a8 aria-label="stash 区域使用">stash 区域使用</a></li></ul></li><li><a href=#%e4%b8%80%e4%ba%9b-git-%e5%b7%a5%e4%bd%9c%e6%b5%81%e4%bb%8b%e7%bb%8d aria-label="一些 Git 工作流介绍">一些 Git 工作流介绍</a><ul class=header-level-2><li><a href=#%e4%bd%bf%e7%94%a8-git-rebase-%e4%bf%9d%e6%8c%81%e7%ae%80%e6%b4%81%e7%9a%84-history aria-label="使用 Git Rebase 保持简洁的 History">使用 Git Rebase 保持简洁的 History</a></li><li><a href=#%e4%bd%bf%e7%94%a8-git-merge---squash-%e4%bf%9d%e6%8c%81%e7%ae%80%e6%b4%81-history aria-label="使用 Git Merge &ndash;squash 保持简洁 History">使用 Git Merge &ndash;squash 保持简洁 History</a></li><li><a href=#%e8%bf%9c%e7%a8%8b%e5%8d%8f%e4%bd%9c aria-label=远程协作>远程协作</a><ul class=header-level-3><li><a href=#%e5%9c%a8%e6%9c%ac%e5%9c%b0%e4%bb%93%e5%ba%93%e5%88%87%e6%8d%a2%e9%bb%98%e8%ae%a4%e6%8f%90%e4%ba%a4%e7%94%a8%e6%88%b7 aria-label=在本地仓库切换默认提交用户>在本地仓库切换默认提交用户</a></li><li><a href=#%e6%8e%a8%e9%80%81%e6%8b%89%e5%8f%96%e8%bf%9c%e7%a8%8b%e5%88%86%e6%94%af aria-label=推送、拉取远程分支>推送、拉取远程分支</a></li><li><a href=#%e4%bb%85-clone-%e6%8c%87%e5%ae%9a%e5%88%86%e6%94%af aria-label="仅 Clone 指定分支">仅 Clone 指定分支</a></li><li><a href=#%e6%8b%89%e5%8f%96%e4%bb%a3%e7%a0%81%e8%a7%a3%e5%86%b3%e5%86%b2%e7%aa%81 aria-label=拉取代码解决冲突>拉取代码解决冲突</a></li></ul></li></ul></li><li><a href=#%e4%b8%80%e4%ba%9b%e5%b7%a5%e5%85%b7 aria-label=一些工具>一些工具</a></li><li><a href=#troubleshooting aria-label=Troubleshooting>Troubleshooting</a><ul class=header-level-2><li><a href=#%e4%bb%8e-commit-%e4%b8%ad%e5%88%a0%e9%99%a4%e5%a4%a7%e6%96%87%e4%bb%b6 aria-label="从 Commit 中删除大文件">从 Commit 中删除大文件</a></li><li><a href=#%e8%bf%9e%e6%8e%a5%e9%97%ae%e9%a2%98 aria-label=连接问题>连接问题</a></li></ul></li><li><a href=#tobecontinue aria-label=ToBeContinue>ToBeContinue</a></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase(),n=document.querySelector(`.inner ul li a[href="#${t}"]`);n.classList.remove("read")}),activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach((t)=>{const o=encodeURI(t.getAttribute("id")).toLowerCase(),s=document.querySelector(`.inner ul li a[href="#${o}"]`);if(t===activeElement){s.classList.add("active");const e=document.querySelector(".toc .inner"),t=s.offsetTop,n=e.clientHeight,o=s.clientHeight,i=t-n/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else getOffsetTop(t)<e&&s.classList.add("read"),s.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return!document.querySelector(".hugo-encryptor-prompt")&&elements.length!=0&&(elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),console.log("Elements re-queried:",elements)),0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>参考文献：<a href=https://juejin.cn/post/7131713973572861966 target=_blank rel=noopener>稀土掘金</a>
| ProGit2</p><h2 id=git-与-svn-的区别>GIT 与 SVN 的区别<a hidden class=anchor aria-hidden=true href=#git-与-svn-的区别>#</a></h2><p>SVN 是集中式版本控制系统，其所有的版本管理都是集中在某个中央服务器，因此，在干活的时候，首先都需要从中央服务器中获取最新的版本，修改后将版本推送到中央服务器，因此大多数场景下需要进行联网使用。可能会更依托于相应的图形化客户端来进行同步和版本管理，便于管理美术资源等等。</p><p>GIT 是分布式版本管理系统，每个人的电脑就是一个完整的版本库，可以进行独立的版本管理，多人协作可能依托于 github 之类的中继节点，将修改同步给对方，解决冲突。</p><h2 id=init-初始化>Init 初始化<a hidden class=anchor aria-hidden=true href=#init-初始化>#</a></h2><p>包含 ssh 的详细指令在 ssh 的文档中，这边只介绍设置完这一系列操作之后的 git 初始化，主要是初始化 ssh，并将私钥放到 github 或者 gitee 的账户中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git config --global user.name <span class=s2>&#34;YourName&#34;</span>
</span></span><span class=line><span class=cl>git config --global user.email <span class=s2>&#34;YourEmailAdress&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看相关的配置信息</span>
</span></span><span class=line><span class=cl>git config --list
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 设置CRLF和LF的相关转换 第一条在提交的时候自动抓换位LF，迁出转换为CRLF</span>
</span></span><span class=line><span class=cl><span class=c1># 第二条拒绝混合换行符的提交</span>
</span></span><span class=line><span class=cl>git config --global core.autocrlf <span class=nb>true</span>
</span></span><span class=line><span class=cl>git config --global core.safecrlf <span class=nb>true</span> 
</span></span></code></pre></td></tr></table></div></div><h3 id=github-设置>Github 设置<a hidden class=anchor aria-hidden=true href=#github-设置>#</a></h3><p>官方文档介绍的一些权限错误的地址：&lt; <a href=https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey%3e target=_blank rel=noopener>https://docs.github.com/en/github/authenticating-to-github/error-permission-denied-publickey></a></p><p>将本机的 ssh 公钥(public)放到 GITHUB 账户下的 ssh 管理地址，执行测试</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ssh -T git@github.com
</span></span></code></pre></td></tr></table></div></div><p>没有问题的话就可以直接进行 clone，之类的 git 操作了</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 小trick，不拉取历史的commit</span>
</span></span><span class=line><span class=cl>git clone --depth<span class=o>=</span><span class=m>1</span> REPO_ADRESS
</span></span></code></pre></td></tr></table></div></div><h3 id=gitignore-文件编写>Gitignore 文件编写<a hidden class=anchor aria-hidden=true href=#gitignore-文件编写>#</a></h3><p>参考文件：【 <a href=https://www.cnblogs.com/kevingrace/p/5690241.html target=_blank rel=noopener>Git忽略提交规则</a>
】【 <a href=https://github.com/github/gitignore target=_blank rel=noopener>gitignore 各语言模版</a>
】</p><p>首先创建对应的 <code>.gitignore</code> 文件，根据自己的需求编写内容，这里也<strong>推荐</strong>通过 VsCode 的插件或者使用上述仓库中<strong>对应语言的模版文件</strong>来创建初始化 ignore 文件，会包含一些常用的通常无需上传的本地配置或者本地缓存等内容；</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>touch .gitignore
</span></span></code></pre></td></tr></table></div></div><p>在覆盖了这些通用的忽略项后，可以根据项目情况添加特有的路径，通常主要包括以下的几类：</p><ul><li><strong>大文件</strong>：如自用的测试数据等</li><li><strong>敏感配置文件</strong>：包含了敏感信息的配置项等（这里建议考虑使用 env 等，或者上传对应的 default 文件）</li><li><strong>日志文件</strong></li></ul><h3 id=设置-git-的代理>设置 Git 的代理<a hidden class=anchor aria-hidden=true href=#设置-git-的代理>#</a></h3><p>设置全局代理使用如下的方式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git config --global http.proxy 127.0.0.1:1080
</span></span><span class=line><span class=cl>git config --global https.proxy 127.0.0.1:1080
</span></span></code></pre></td></tr></table></div></div><p>同理取消全局代理如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git config --global --unset http.proxy  
</span></span><span class=line><span class=cl>git config --global --unset https.proxy
</span></span></code></pre></td></tr></table></div></div><h2 id=常用指令与架构介绍>常用指令与架构介绍<a hidden class=anchor aria-hidden=true href=#常用指令与架构介绍>#</a></h2><p>Git 整体的使用架构如<a href=https://juejin.cn/post/7131713973572861966 target=_blank rel=noopener>下图所示</a>
，一般而言开发者在工作区进行当前修改，将需要同步或者发布的修改内容通过暂存区存储到本地 & 远程仓库中，结合远程仓库的协作特性和分支功能，可以实现同个项目的多人同步分离开发，同时开发多种功能等。</p><p>因此 Git 或者 Svn 等 CLI 的使用技能，在公司中或者在项目参与中是相当重要的，建议每个人程序开发者都能对其有一定的了解。</p><div align=center><img src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20221204135313.png style=zoom:75%></div><p>下面是一些基本的命令使用，其中许多命令都有一些额外的参数可供使用，如果经常使用 Git 建议可以简单阅读一下 <strong>ProGit</strong>。</p><blockquote><p>这里会简单记录一些命令，其中那些在 git 使用中会有所提示的命令就不再赘述，例如 pull 别的分支的时候取消 merge 到当前分支的 git merge &ndash;abort 之类就会有所提示。</p></blockquote><table><thead><tr><th>普通</th><th>command</th><th>分支</th><th>command</th></tr></thead><tbody><tr><td>创建本地 repo</td><td>git init</td><td>创建/显示分支</td><td>git branch name</td></tr><tr><td>工作区状态</td><td>git status</td><td>切换分支</td><td>git checkout [branch]</td></tr><tr><td>添加到暂存区</td><td>git add /.</td><td>切换</td><td>git checkout -b name</td></tr><tr><td>暂存区到本地</td><td>git commit -m ‘mesg’</td><td>合并分支</td><td>git merge branch</td></tr><tr><td>日志</td><td>git log (–oneline)</td><td>删除分支</td><td>git branch -d</td></tr><tr><td>拉取远程库</td><td>git pull / git fetch</td><td>推送本地分支</td><td>git push origin branch</td></tr><tr><td>克隆远程库</td><td>git clone</td><td></td><td></td></tr><tr><td><strong>撤销</strong></td><td></td><td><strong>标签</strong></td><td></td></tr><tr><td>撤销工作区修改</td><td>git checkout – file-name</td><td>创建标签</td><td>git tag tag-name</td></tr><tr><td>撤销暂存区修改</td><td>git reset HEAD file-name</td><td>显示所有标签</td><td>git tag</td></tr><tr><td>撤销本地库修改</td><td>git reset –hard commitID</td><td>删除标签</td><td>git tag -d tag</td></tr><tr><td><strong>远程</strong></td><td></td><td><strong>储藏</strong></td><td>·</td></tr><tr><td>同步本地库和</td><td>git remote add origin xx@y repo</td><td>保存现场</td><td>git stash</td></tr><tr><td>远程库</td><td>git push -u origin master</td><td>恢复现场</td><td>git stash pop</td></tr></tbody></table><h3 id=commit-规范和相关命令>Commit 规范和相关命令<a hidden class=anchor aria-hidden=true href=#commit-规范和相关命令>#</a></h3><p>commit 命令实现将"将暂存区的文件以特定的注释提交到仓库中"，提交的 Message 建议建立统一的规范，这样可以方便后续使用 log 查阅的时候定位到特定修改的 commit。</p><h4 id=message-standard-标准提交内容>Message Standard 标准提交内容<a hidden class=anchor aria-hidden=true href=#message-standard-标准提交内容>#</a></h4><p>本人推荐的 Commit Message 格式如下，该格式并非是一成不变的，可以根据仓库中存放的项目类型来灵活变更 Tag 的数量和内容。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git commit -m <span class=s2>&#34;[tag1(modify scope)] [tag2(modify type)]: excatly modify info&#34;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Tag1 (modify scope): 说明修改的内容，泛一些例如修改代码 code，资源 res，细一些则例如修改的文件夹 tool、util</li><li>Tag2（modify type）：说明修改的类型，主要有：<code>Feat</code>、<code>Fix</code>、<code>Refactor</code>、<code>Style</code>、<code>Test</code>、<code>Docs</code>、<code>Merge</code>，如果修改的是资源等文件可以忽略。</li><li>Modify info：修改的详细信息，说明修改的目的和修改的内容即可</li></ul><p>例如以下的几个写法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git commit -m <span class=s2>&#34;[res]: add presonal conf file&#34;</span>
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;[code-util][Feat]: add function to parser conf file&#34;</span>
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;[code &amp; res][Feat &amp; Fix]: add function for merge conf, fix bug on parser conf, add my conf resource&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>该部分没有什么硬性要求，只需要自己能够清晰的看懂自己的 commit 且具备一致性即可。</p><h4 id=extra-operation-撤销重写合并>Extra Operation 撤销、重写、合并<a hidden class=anchor aria-hidden=true href=#extra-operation-撤销重写合并>#</a></h4><blockquote><p>有时候针对已经提交的 Commit 不满意，或者有一些新的更改需要添加到上一次的 Commit 中，可以参考下面的操作。</p></blockquote><p><strong>撤销</strong> Commit 或者<strong>重写</strong> Commit Message</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git reset --soft HEAD^  <span class=c1># 撤销当前commit</span>
</span></span><span class=line><span class=cl>git commit --amend      <span class=c1># 重写当前commit</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>合并多次 Commit</strong>：通过 rebase 命令来进行 merge，该命令通过整理多次的 Commit 来使得整个提交历史更为整洁有序，但是需要额外的精力去整理就是。具体的操作流程如下：</p><ol><li>首先查看 commit 的 hash</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git log
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>找到需要修改的 commit 的<strong>前一个</strong> commit 的 ID</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 找到需要合并的最早commit的上一个的ID</span>
</span></span><span class=line><span class=cl>git rebase -i &lt;ID&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 也可以使用以下命令合并header往前多少n次的commit</span>
</span></span><span class=line><span class=cl>git rebase -i HEAD~n
</span></span></code></pre></td></tr></table></div></div><ul><li>square：将该次 commit 和上一次 commit 合并</li><li>pick：保留该次 commit</li></ul><p>通过修改 commit 提交界面的 square 和 pick 即可实现多次 commit 的合并。</p><h3 id=history-历史查看>History 历史查看<a hidden class=anchor aria-hidden=true href=#history-历史查看>#</a></h3><p>查看当前分支的提交历史只需要通过 <code>git log</code> 即可看到基本的提交信息，这里简要介绍一些参数来帮助更清晰的定位 commit</p><ul><li><code>git log -p -{n}</code>: 参数 <code>-p</code> 以 diff 的形式在显示基本提交信息的基础上还显示该提交的具体修改内容，由于内容较多；可以通过 <code>-{n}</code> 仅显示最近 n 次提交的内容</li><li><code>git log --stat</code> ：参数 <code>--stat</code> 显示每次提交的统计信息，包含修改的文件以及对该文件修改的行数的统计信息</li><li><code>git log --graph</code>： 参数 <code>--graph</code> 会使用简单的 ASCII 图像来可视化提交之间的分支关系，也就是 vscode 中 gitgraph 的命令行版本，可以帮助了解提交之间的合并和起始提交等信息</li></ul><p>此外还有诸如 <code>--pretty</code> 等参数可以自定义 log 显示的具体格式，需要的话可以参阅 progit 或者官方文档进行了解。</p><h3 id=add-一些额外操作>Add 一些额外操作<a hidden class=anchor aria-hidden=true href=#add-一些额外操作>#</a></h3><p>Add 命令主要将修改的内容提交到暂存区，不仅可以作为我们一次次的中间存储节点，也是为后续的提交做缓冲，但是难免会遇到以下的情况：</p><ul><li>提交错文件或者修改了结构需要将一个或者多个文件从暂存区中撤退出来；</li><li>清除工作区中不需要提交的临时文件</li></ul><p>如果是撤销所有提交的文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git reset HEAD .
</span></span></code></pre></td></tr></table></div></div><p>撤销特定文件的提交</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git reset HEAD &lt;file&gt;
</span></span></code></pre></td></tr></table></div></div><p>以上两个命令不需要记录，只需要使用 <code>git status</code> 查看当前状态的时候会有提示。</p><p>清除工作区中不需要提交的临时文件，可以使用以下的命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git clean -nf <span class=c1># 查看会被清除的未追踪文件</span>
</span></span><span class=line><span class=cl>git clean -f  <span class=c1># 清除未追踪的文件</span>
</span></span></code></pre></td></tr></table></div></div><p>如果涉及到文件夹可以添加参数 d</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git clean -ndf <span class=c1># 查看会被清除的未追踪文件和文件夹</span>
</span></span><span class=line><span class=cl>git clean -fd  <span class=c1># 实际执行清除指令</span>
</span></span></code></pre></td></tr></table></div></div><p>其中-n 参数为查看而不实际执行的参数，避免文件的误删。具体可以通过 <code>git help clean</code> 查看。</p><h3 id=cherrypick-挑选-commit>CherryPick 挑选 Commit<a hidden class=anchor aria-hidden=true href=#cherrypick-挑选-commit>#</a></h3><blockquote><p>仅简要介绍其作用，详细使用等后续有使用场景再来补充。</p></blockquote><p>Git CherryPick 命令实现从别的分支挑<strong>选某个 Commit 的修改合并到当前分支中</strong>，该命令在一些提交数少的分支中，可以代替 merge，实现一个更为线性整洁的 Master 分支。</p><p>可以结合 Rebase 合并提交使用，由此得到一个更为干净的提交历史。</p><h2 id=暂存区--stash>暂存区 & Stash<a hidden class=anchor aria-hidden=true href=#暂存区--stash>#</a></h2><p>暂存区指的是 git add. 后存储到的区域，用来作为本地和仓库之间的缓存。</p><h3 id=暂存区处理>暂存区处理<a hidden class=anchor aria-hidden=true href=#暂存区处理>#</a></h3><p>清除暂存区某个文件的指令（通常是为了修改.gitignore）的时候执行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git rm -r --cache filename
</span></span></code></pre></td></tr></table></div></div><p>看暂存区有什么文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git ls-files
</span></span><span class=line><span class=cl>git status
</span></span></code></pre></td></tr></table></div></div><h3 id=stash-区域使用>stash 区域使用<a hidden class=anchor aria-hidden=true href=#stash-区域使用>#</a></h3><p>是一个特殊的区域，本地的 git 存储区，一般来说使用场景较少，例如以下的场景。</p><blockquote><p>本地改了代码，但是突然有个人过来问你另一个分支的问题，同时这个时候你在实现某个功能，实现一半，又不想提交到 Git 仓库中，那么你就可以考虑使用 <code>git stash save "临时存一下"</code>，这个时候它就会帮你存到这个储存区，你去其他分支做完事情回来，再 <code>git stash pop</code>就好了。</p></blockquote><p>主要使用的就是以下的几个命令：</p><ul><li><code>git stash save "message"</code> 将当前的修改暂存</li><li><code>git stash list</code> 查看暂存了哪些修改</li><li><code>git pop </code>默认使用存储的堆栈中的第一个 stash</li><li><code>git stash apply stash@{n}</code> 使用第 n+1 个 stash，n 从 0 开始。</li></ul><p>一般建议是不要使用太多的 stash，这样一个 save 和一个 pop 命令就可以 handle 。</p><blockquote><p>如果 pop 操作导致冲突，希望撤销 <code>git stash pop</code> 行为，可以使用 <code>git reset --hard</code> 回退当前修改，该操作会保留 pop 出来的修改仍然在 stash 中。</p></blockquote><h2 id=一些-git-工作流介绍>一些 Git 工作流介绍<a hidden class=anchor aria-hidden=true href=#一些-git-工作流介绍>#</a></h2><h3 id=使用-git-rebase-保持简洁的-history>使用 Git Rebase 保持简洁的 History<a hidden class=anchor aria-hidden=true href=#使用-git-rebase-保持简洁的-history>#</a></h3><p>参考资料： <a href=https://www.cnblogs.com/FraserYu/p/11192840.html target=_blank rel=noopener>优雅且安全的使用 GitRebase</a></p><blockquote><p>前文已经介绍过了 git rebase 用于合并 merge 的功能，这里主要介绍的是 git rebase 在分支合并中的作用，何时在分支管理中使用 git rebase 取代 git merge 来进行分支合并。</p></blockquote><p>git merge 是一种非破坏性的操作，当我们使用 git merge 进行分支合并的时候，会提供一个新的 commit ，其内容为两个分支的合并提交，这也是与 rebase 最大的区别。</p><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240804121843.png><img alt=image.png loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240804121843.png class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240804121843.png style="display:block;margin:0 auto" alt=image.png></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>rebase 正如其单词所言，re-base，重构我们的 base，我们可以使用下面的命令将 master 分之合并到我们的 dev 分支中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git checkout dev
</span></span><span class=line><span class=cl>git rebase master
</span></span></code></pre></td></tr></table></div></div><p>这会将我们的 dev 分支的新增内容移动到 master 分支之后，相当于重新构建了 dev 分支上的每个 commit，将其在新的 master 之后再合入。</p><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240804122136.png><img alt=image.png loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240804122136.png class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/mac/20240804122136.png style="display:block;margin:0 auto" alt=image.png></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>使用这种方式的话，项目的历史记录会更为线性，会使得分支的提交历史更加整洁，没有不必要的合并提交，考虑到可能在开发过程中我们可能会多次需要更新 master 分支的内容，这样能让我们的更新更加容易追溯和复原。</p><p>此外正如合并多次 commit 的操作，使用 -i 可以开启 rebase 的交互模式，交互模式中我们就可以将多次提交浓缩为单次提交(squash)，或者合并某两个连续的提交(fixup)。</p><blockquote><p>tips: 如果需要一次性将从 master 分出来的 dev 上的第一个提交到最后一个 dev 上的提交合并，避免用 Head~n 去数，或者手动去找对应的 commitID，也可以用 <code>git merge-base dev master</code> 代替，这里的 master 就是你的切出 dev 的原始分支，不一定是 master。</p></blockquote><p>但是由于 rebase 操作是一个破坏性的操作，会修改我们之前的每次原始提交，因此在使用的时候需要慎重，遵循 rebase 使用的法则：<strong>永远不要再公共分支上使用它</strong>，在公共分支使用会导致所有人的原始 master 和远端无法对齐，导致一系列问题。</p><p>但是如果别人同样在远程开发 dev 分支，我们 fetch 后同样可以考虑使用 merge 或者 rebase 更新 dev 分支本身，因为这只影响了我们 local 端的后续提交。BTW，<code>git pull --rebase</code> 可以强制使用 rebase 的方式来集成远程分支。</p><p>最终开发完成后，使用 rebase 更新分支上 master 的内容，再去 master 上 merge，会产生最好的线性历史记录，也确保不会影响他人的开发：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git checkout dev
</span></span><span class=line><span class=cl>git rebase master
</span></span><span class=line><span class=cl>git checkout master
</span></span><span class=line><span class=cl>git merge dev
</span></span><span class=line><span class=cl>git push origin master:master
</span></span></code></pre></td></tr></table></div></div><p>如果不确定 rebase 的使用是否正确，可以复制一个临时分支来执行 rebase，如果不小心搞乱了，还可以有原始的分支来复原。</p><h3 id=使用-git-merge---squash-保持简洁-history>使用 Git Merge &ndash;squash 保持简洁 History<a hidden class=anchor aria-hidden=true href=#使用-git-merge---squash-保持简洁-history>#</a></h3><p>除了上述使用 rebase 将分支上的 commit 逐个移动到 master 分支之后，进而维持 master 上的线性提交历史，上述还提到可以使用 rebase 合并多次 commit 后进行提交，但由于 rebase 本身会改变开发分支，所以实际上更推荐仅在 Merge 的时候进行分支上的 commit 合并（例如开发分支上的 commit 较为随意的情况），这种情况下可以在 rebase 的时候使用-i 操作或者使用 <code>git merge --squash {branch} </code>进行 merge</p><h3 id=远程协作>远程协作<a hidden class=anchor aria-hidden=true href=#远程协作>#</a></h3><p>考虑多用户，多分支的在线场景，如何有效的 Pull & Push.</p><h4 id=在本地仓库切换默认提交用户>在本地仓库切换默认提交用户<a hidden class=anchor aria-hidden=true href=#在本地仓库切换默认提交用户>#</a></h4><p>在多用户的终端场景，推送前记得切换相关的用户设置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git config --local user.name <span class=s2>&#34;YourName&#34;</span>
</span></span><span class=line><span class=cl>git config --local user.emali <span class=s2>&#34;YourEmail&#34;</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=推送拉取远程分支>推送、拉取远程分支<a hidden class=anchor aria-hidden=true href=#推送拉取远程分支>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 冒号前本地，冒号后远程，</span>
</span></span><span class=line><span class=cl>git push origin local_branch:remote_branch
</span></span><span class=line><span class=cl>git pull origin remote_branch:local_branch
</span></span></code></pre></td></tr></table></div></div><h4 id=仅-clone-指定分支>仅 Clone 指定分支<a hidden class=anchor aria-hidden=true href=#仅-clone-指定分支>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git clone -b <span class=o>{</span>branch<span class=o>}</span> <span class=o>{</span>rep<span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=拉取代码解决冲突>拉取代码解决冲突<a hidden class=anchor aria-hidden=true href=#拉取代码解决冲突>#</a></h4><p>git fetch 实际上 pull = fetch + merge，可以解决完冲突再进行代码提交，相对 pull 更安全，结合 Vscode 中的 Gitgraph 等，用于解决冲突和验证修改方面更为安全简单。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git fetch
</span></span><span class=line><span class=cl>git log -p FETCH_HEAD
</span></span><span class=line><span class=cl>git merge FETCH_HEAD
</span></span></code></pre></td></tr></table></div></div><p>通过使用 Stash 的方式，同样可以避免再拉取远程代码的时候不覆盖本地的代码，灵活选用吧，一般情况下使用 fetch 已经足够。</p><h2 id=一些工具>一些工具<a hidden class=anchor aria-hidden=true href=#一些工具>#</a></h2><p>一些好用的 CLI（命令行工具）和 VsCode 插件推荐：</p><ul><li><a href=https://github.com/jesseduffield/lazygit target=_blank rel=noopener>Lazygit</a>
（命令行工具，带一个比较酷炫的 GUI）</li><li>Gitlens（VsCode）：在编辑界面显示每行代码的提交者，丰富 github 的 git 拓展选项</li><li>Gitgraph（VsCode）：方便查看每次 commit 的修改内容，用对比窗口显示，便于发现冲突解决和修改内容</li><li>Beyond Compare（差异对比工具）：类似 diff 命令，非常好用的对比和修改不同版本的文件，文件夹之间的差异。</li><li>Win Merge （差异对比工具）： BC 的免费替代品，基本上是足够使用的。</li><li>还有一些诸如 tortoise 和 github 客户端等图形界面也可供尝试</li></ul><h2 id=troubleshooting>Troubleshooting<a hidden class=anchor aria-hidden=true href=#troubleshooting>#</a></h2><h3 id=从-commit-中删除大文件>从 Commit 中删除大文件<a hidden class=anchor aria-hidden=true href=#从-commit-中删除大文件>#</a></h3><p>避免.git 目录占用过多存储，这一部分写的有点小瑕疵，到时候就看超链接</p><p><a href=https://www.zhihu.com/question/29769130/answer/315745139 target=_blank rel=noopener>郑宇</a>
；主要是要将大文件排除追踪，在 push 之前都还是比较好解决的，但是如果已经提交上去了就稍微比较麻烦，尝试将其中的大文件删掉。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 1. 运行gc，生成pack文件`–prune = now` 表示对所有的文件都做修剪</span>
</span></span><span class=line><span class=cl>git gc --prune<span class=o>=</span>now
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 找出最大的k个文件，以3为例</span>
</span></span><span class=line><span class=cl>git verify -pack -v .git/objects/pack/*.idx <span class=p>|</span>sort -k -3 -n <span class=p>|</span>tail -3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># bug: cannot open ///bad ..</span>
</span></span><span class=line><span class=cl><span class=c1># 可能是由于地址出错了，修改地址，如下是查看地址的代码</span>
</span></span><span class=line><span class=cl>find .git/objects/ -type -f
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 查看那些大文件究竟是谁，按照上一步输出的hash value 进行搜索，（不用全长）</span>
</span></span><span class=line><span class=cl>git rev-list --objects --all <span class=p>|</span>grep &lt;hashvalue&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4. 移除对该文件的追踪引用</span>
</span></span><span class=line><span class=cl>git filter-branch --force --index-filter <span class=s2>&#34;git rm --cache --ignore-unmatch &#39;&lt;FILENAME HERER&gt;&#39;&#34;</span> --prune-empty --tag-name-filter cat -- --all
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 5. 进行repack</span>
</span></span><span class=line><span class=cl>git <span class=k>for</span>-each-ref --format<span class=o>=</span><span class=s1>&#39;delete %(refname)&#39;</span> refs/original <span class=p>|</span> git update-ref --stdin
</span></span><span class=line><span class=cl>git reflog expire --expire<span class=o>=</span>now --all
</span></span><span class=line><span class=cl>git gc --prune<span class=o>=</span>now
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 6. 查看pack的空间使用情况</span>
</span></span><span class=line><span class=cl>git count-objects -v
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 7. 强制推送重构大文件</span>
</span></span><span class=line><span class=cl>git push origin local-b:remote-b --force
</span></span></code></pre></td></tr></table></div></div><h3 id=连接问题>连接问题<a hidden class=anchor aria-hidden=true href=#连接问题>#</a></h3><ol><li><strong>openssl error 10054</strong></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl> git config --global http.postBuffer <span class=m>524288000</span>
</span></span></code></pre></td></tr></table></div></div><ol start=2><li><strong>time out port443</strong></li></ol><p>just wait for some time，应该是代理的问题，不行就使用国行版 github 把</p><ol start=3><li><strong>server certificate verification failed. CAfile</strong></li></ol><p>使用<code>github.com.cnpmjs.org</code>国内镜像站的时候，可能会出现权限的问题，这种情况下就要对 git 的证书验证命令做调整，有两种策略，执行其中一种：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git config --global http.sshverify <span class=nb>false</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># carry out in the </span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>GIT_SSL_NO_VERIFY</span><span class=o>=</span><span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><p>之后我们就可以正常的使用镜像站对原有的 repo 进行更新和拉取了，比如说 omz update.</p><h2 id=tobecontinue>ToBeContinue<a hidden class=anchor aria-hidden=true href=#tobecontinue>#</a></h2><ul><li>Git Rebase专题：<a href=https://juejin.cn/post/7123826435357147166 target=_blank rel=noopener>GIt Merge和Git Rebase的区别</a></li><li>Git Reset 和 Git Cherrypick 专题：<a href=https://juejin.cn/post/7131713973572861966 target=_blank rel=noopener>紧急修复</a></li><li>Git tag 专题开发标签</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://hugotest-phi.vercel.app/tags/git/>Git</a></li><li><a href=https://hugotest-phi.vercel.app/tags/github/>Github</a></li></ul><nav class=paginav><a class=prev href=https://hugotest-phi.vercel.app/posts/finetune/><span class=title>« Prev</span><br><span>Fine Tuning</span>
</a><a class=next href=https://hugotest-phi.vercel.app/posts/transfer-sync-files/><span class=title>Next »</span><br><span>Linux 文件传输和同步</span></a></nav></footer><div id=disqus_thread></div><script>function loadDisqus(){var e=document,t=e.createElement("script");t.src="https://aiken-hugo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t),window.disqus_config=function(){this.page.url=window.location.href,this.page.identifier=window.location.href.substring(18)}}var runningOnBrowser=typeof window!="undefined",isBot=runningOnBrowser&&!("onscroll"in window)||typeof navigator!="undefined"&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){if(!isBot&&supportsIntersectionObserver){var e=new IntersectionObserver(function(t){t[0].isIntersecting&&(loadDisqus(),e.disconnect())},{threshold:[0]});e.observe(document.getElementById("disqus_thread"))}else loadDisqus()},1)</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://hugotest-phi.vercel.app/>aiken's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container>Visitors: <span id=busuanzi_value_site_uv></span>
Views: <span id=busuanzi_value_site_pv></span></span></footer><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),o=13863,i=16993;if(!e||!t){console.error("Busuanzi elements not found.");return}const n=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+o;break}}),s=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){s.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+i;break}});n.observe(e,{childList:!0}),s.observe(t,{childList:!0})})</script><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))}),document.getElementById("theme-toggle-nav").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("/js/pangu.js",function(){pangu.spacingPage()})</script></body></html>