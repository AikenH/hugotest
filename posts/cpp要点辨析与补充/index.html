<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++的常见数据类型和操作 | aiken's blog</title>
<meta name=keywords content="Cpp,Langs"><meta name=description content="主要介绍一些常用数据类型的一些method，区别还有一些特殊的定义；
priority_queue 默认是大顶堆，great的话是小顶堆，less的话是大顶堆，自定义的话不知道是不是一致的
set默认top是小顶，这个大小我就不知道了，自定义的话，好像和我想得是一致的
所有的动态容器都是存放在heap上的，像是什么Vector，String，unordered_map之类的
指定精度的输出和计算
在腾讯的笔试中出现的需要指定精度和指定的计算精度的分析，在使用常数的时候一定要使用.0去修正一个方法。
Vector 动态数组
Vector中的一些常用的函数，方法，以及一些属性介绍和辨析
emplace_back & push_back（在末尾添加元素）
empalce_back 直接在数组的末尾进行构造，而push_back借助于构造的临时变量再将其加入数组末尾，所以在一些操作中empalce_back对于空间时间的效率是会更高的，但是如果我们有重复构筑的数据的话，可能就需要使用push_back。
要注意实际上vector中并没有append的方法。

初始化方法
主要有几种常用的构造函数，在这里主要介绍的是关于多维度的初始化构造方式。


1
2
3
4
5
6


vector<int> v = {7, 5, 16, 8}; // 最基本的定义
// 通过大括号来设定多级的vector的初始值
vector<vector<char>> value = {
    {'5','3','.','.','7','.','.','.','.'},
    {'6','.','.','1','9','5','.','.','.'}
}; 


常用的长度和常量


1


vector<vector<int>> vec(size1,vector<int>(size2,defaultvalue));


Unordered_map&amp;set哈希结构
CPP中hash table的实现数据类型：
实际上就是无序表，针对不同情况下的基本的定义方式，理念相同，针对不同的应用场景


 unordered_map<typedef,typedef> Hashtable : 实际上是Key-Value的架构


unordered_set<typedef> Hashset ：只包含key的类型


插入的话，可以使用数组的形式，也可以用insert 或者emplace把。
取值方式
除了通过Key取Value这种老生常谈的方式，我们这里探讨的是iterator的情况下如何取到当前的值：

set: *it即可；
map：*it取的应该是value，key的话通过 it->first来取值，value通过it->second

按照迭代器来初始化


1


unordered_set<string> deaded(deadends.begin(),deadends.end());


是否存在键值
使用.count不要再用find和end了，那个估计时间成本特别高了。。。。怎么更慢了。
使用map[key] 可以访问键对应的值，但是如果Key不存在，cpp会自动创建这个key同时赋值为0；
erase
可以直接根据键值进行erase()"><meta name=author content="aikenhong"><link rel=canonical href=https://hugotest-phi.vercel.app/posts/cpp%E8%A6%81%E7%82%B9%E8%BE%A8%E6%9E%90%E4%B8%8E%E8%A1%A5%E5%85%85/><link crossorigin=anonymous href=/assets/css/stylesheet.2f85ca17c12c62fa86b1e474b8a51aca4856f0d645debfe4922a4d5ddc6aa978.css integrity="sha256-L4XKF8EsYvqGseR0uKUaykhW8NZF3r/kkipNXdxqqXg=" rel="preload stylesheet" as=style><link rel=icon href=https://hugotest-phi.vercel.app/favicon/ghost.ico><link rel=icon type=image/png sizes=16x16 href=https://hugotest-phi.vercel.app/favicon/ghost-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hugotest-phi.vercel.app/favicon/ghost-32x32.png><link rel=apple-touch-icon href=https://hugotest-phi.vercel.app/favicon/ghost-apple-touch-icon.png><link rel=mask-icon href=https://hugotest-phi.vercel.app/favicon/ghost-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hugotest-phi.vercel.app/posts/cpp%E8%A6%81%E7%82%B9%E8%BE%A8%E6%9E%90%E4%B8%8E%E8%A1%A5%E5%85%85/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><meta property="og:url" content="https://hugotest-phi.vercel.app/posts/cpp%E8%A6%81%E7%82%B9%E8%BE%A8%E6%9E%90%E4%B8%8E%E8%A1%A5%E5%85%85/"><meta property="og:site_name" content="aiken's blog"><meta property="og:title" content="C++的常见数据类型和操作"><meta property="og:description" content="主要介绍一些常用数据类型的一些method，区别还有一些特殊的定义；
priority_queue 默认是大顶堆，great的话是小顶堆，less的话是大顶堆，自定义的话不知道是不是一致的
set默认top是小顶，这个大小我就不知道了，自定义的话，好像和我想得是一致的
所有的动态容器都是存放在heap上的，像是什么Vector，String，unordered_map之类的
指定精度的输出和计算 在腾讯的笔试中出现的需要指定精度和指定的计算精度的分析，在使用常数的时候一定要使用.0去修正一个方法。
Vector 动态数组 Vector中的一些常用的函数，方法，以及一些属性介绍和辨析
emplace_back & push_back（在末尾添加元素） empalce_back 直接在数组的末尾进行构造，而push_back借助于构造的临时变量再将其加入数组末尾，所以在一些操作中empalce_back对于空间时间的效率是会更高的，但是如果我们有重复构筑的数据的话，可能就需要使用push_back。
要注意实际上vector中并没有append的方法。
初始化方法 主要有几种常用的构造函数，在这里主要介绍的是关于多维度的初始化构造方式。
1 2 3 4 5 6 vector<int> v = {7, 5, 16, 8}; // 最基本的定义 // 通过大括号来设定多级的vector的初始值 vector<vector<char>> value = { {'5','3','.','.','7','.','.','.','.'}, {'6','.','.','1','9','5','.','.','.'} }; 常用的长度和常量
1 vector<vector<int>> vec(size1,vector<int>(size2,defaultvalue)); Unordered_map&amp;set哈希结构 CPP中hash table的实现数据类型： 实际上就是无序表，针对不同情况下的基本的定义方式，理念相同，针对不同的应用场景
unordered_map<typedef,typedef> Hashtable : 实际上是Key-Value的架构
unordered_set<typedef> Hashset ：只包含key的类型
插入的话，可以使用数组的形式，也可以用insert 或者emplace把。
取值方式 除了通过Key取Value这种老生常谈的方式，我们这里探讨的是iterator的情况下如何取到当前的值：
set: *it即可； map：*it取的应该是value，key的话通过 it->first来取值，value通过it->second 按照迭代器来初始化 1 unordered_set<string> deaded(deadends.begin(),deadends.end()); 是否存在键值 使用.count不要再用find和end了，那个估计时间成本特别高了。。。。怎么更慢了。
使用map[key] 可以访问键对应的值，但是如果Key不存在，cpp会自动创建这个key同时赋值为0；
erase 可以直接根据键值进行erase()"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-28T06:24:23+00:00"><meta property="article:modified_time" content="2021-11-28T06:24:23+00:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Langs"><meta property="og:image" content="https://hugotest-phi.vercel.app/cover/cover11.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hugotest-phi.vercel.app/cover/cover11.jpeg"><meta name=twitter:title content="C++的常见数据类型和操作"><meta name=twitter:description content="主要介绍一些常用数据类型的一些method，区别还有一些特殊的定义；
priority_queue 默认是大顶堆，great的话是小顶堆，less的话是大顶堆，自定义的话不知道是不是一致的
set默认top是小顶，这个大小我就不知道了，自定义的话，好像和我想得是一致的
所有的动态容器都是存放在heap上的，像是什么Vector，String，unordered_map之类的
指定精度的输出和计算
在腾讯的笔试中出现的需要指定精度和指定的计算精度的分析，在使用常数的时候一定要使用.0去修正一个方法。
Vector 动态数组
Vector中的一些常用的函数，方法，以及一些属性介绍和辨析
emplace_back & push_back（在末尾添加元素）
empalce_back 直接在数组的末尾进行构造，而push_back借助于构造的临时变量再将其加入数组末尾，所以在一些操作中empalce_back对于空间时间的效率是会更高的，但是如果我们有重复构筑的数据的话，可能就需要使用push_back。
要注意实际上vector中并没有append的方法。

初始化方法
主要有几种常用的构造函数，在这里主要介绍的是关于多维度的初始化构造方式。


1
2
3
4
5
6


vector<int> v = {7, 5, 16, 8}; // 最基本的定义
// 通过大括号来设定多级的vector的初始值
vector<vector<char>> value = {
    {'5','3','.','.','7','.','.','.','.'},
    {'6','.','.','1','9','5','.','.','.'}
}; 


常用的长度和常量


1


vector<vector<int>> vec(size1,vector<int>(size2,defaultvalue));


Unordered_map&amp;set哈希结构
CPP中hash table的实现数据类型：
实际上就是无序表，针对不同情况下的基本的定义方式，理念相同，针对不同的应用场景


 unordered_map<typedef,typedef> Hashtable : 实际上是Key-Value的架构


unordered_set<typedef> Hashset ：只包含key的类型


插入的话，可以使用数组的形式，也可以用insert 或者emplace把。
取值方式
除了通过Key取Value这种老生常谈的方式，我们这里探讨的是iterator的情况下如何取到当前的值：

set: *it即可；
map：*it取的应该是value，key的话通过 it->first来取值，value通过it->second

按照迭代器来初始化


1


unordered_set<string> deaded(deadends.begin(),deadends.end());


是否存在键值
使用.count不要再用find和end了，那个估计时间成本特别高了。。。。怎么更慢了。
使用map[key] 可以访问键对应的值，但是如果Key不存在，cpp会自动创建这个key同时赋值为0；
erase
可以直接根据键值进行erase()"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hugotest-phi.vercel.app/posts/"},{"@type":"ListItem","position":2,"name":"C++的常见数据类型和操作","item":"https://hugotest-phi.vercel.app/posts/cpp%E8%A6%81%E7%82%B9%E8%BE%A8%E6%9E%90%E4%B8%8E%E8%A1%A5%E5%85%85/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++的常见数据类型和操作","name":"C\u002b\u002b的常见数据类型和操作","description":"主要介绍一些常用数据类型的一些method，区别还有一些特殊的定义；\npriority_queue 默认是大顶堆，great的话是小顶堆，less的话是大顶堆，自定义的话不知道是不是一致的\nset默认top是小顶，这个大小我就不知道了，自定义的话，好像和我想得是一致的\n所有的动态容器都是存放在heap上的，像是什么Vector，String，unordered_map之类的\n指定精度的输出和计算 在腾讯的笔试中出现的需要指定精度和指定的计算精度的分析，在使用常数的时候一定要使用.0去修正一个方法。\nVector 动态数组 Vector中的一些常用的函数，方法，以及一些属性介绍和辨析\nemplace_back \u0026amp; push_back（在末尾添加元素） empalce_back 直接在数组的末尾进行构造，而push_back借助于构造的临时变量再将其加入数组末尾，所以在一些操作中empalce_back对于空间时间的效率是会更高的，但是如果我们有重复构筑的数据的话，可能就需要使用push_back。\n要注意实际上vector中并没有append的方法。\n初始化方法 主要有几种常用的构造函数，在这里主要介绍的是关于多维度的初始化构造方式。\n1 2 3 4 5 6 vector\u0026lt;int\u0026gt; v = {7, 5, 16, 8}; // 最基本的定义 // 通过大括号来设定多级的vector的初始值 vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; value = { {\u0026#39;5\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;}, {\u0026#39;6\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;9\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39;} }; 常用的长度和常量\n1 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec(size1,vector\u0026lt;int\u0026gt;(size2,defaultvalue)); Unordered_map\u0026amp;set哈希结构 CPP中hash table的实现数据类型： 实际上就是无序表，针对不同情况下的基本的定义方式，理念相同，针对不同的应用场景\nunordered_map\u0026lt;typedef,typedef\u0026gt; Hashtable : 实际上是Key-Value的架构\nunordered_set\u0026lt;typedef\u0026gt; Hashset ：只包含key的类型\n插入的话，可以使用数组的形式，也可以用insert 或者emplace把。\n取值方式 除了通过Key取Value这种老生常谈的方式，我们这里探讨的是iterator的情况下如何取到当前的值：\nset: *it即可； map：*it取的应该是value，key的话通过 it-\u0026gt;first来取值，value通过it-\u0026gt;second 按照迭代器来初始化 1 unordered_set\u0026lt;string\u0026gt; deaded(deadends.begin(),deadends.end()); 是否存在键值 使用.count不要再用find和end了，那个估计时间成本特别高了。。。。怎么更慢了。\n使用map[key] 可以访问键对应的值，但是如果Key不存在，cpp会自动创建这个key同时赋值为0；\nerase 可以直接根据键值进行erase()\n","keywords":["Cpp","Langs"],"articleBody":"主要介绍一些常用数据类型的一些method，区别还有一些特殊的定义；\npriority_queue 默认是大顶堆，great的话是小顶堆，less的话是大顶堆，自定义的话不知道是不是一致的\nset默认top是小顶，这个大小我就不知道了，自定义的话，好像和我想得是一致的\n所有的动态容器都是存放在heap上的，像是什么Vector，String，unordered_map之类的\n指定精度的输出和计算 在腾讯的笔试中出现的需要指定精度和指定的计算精度的分析，在使用常数的时候一定要使用.0去修正一个方法。\nVector 动态数组 Vector中的一些常用的函数，方法，以及一些属性介绍和辨析\nemplace_back \u0026 push_back（在末尾添加元素） empalce_back 直接在数组的末尾进行构造，而push_back借助于构造的临时变量再将其加入数组末尾，所以在一些操作中empalce_back对于空间时间的效率是会更高的，但是如果我们有重复构筑的数据的话，可能就需要使用push_back。\n要注意实际上vector中并没有append的方法。\n初始化方法 主要有几种常用的构造函数，在这里主要介绍的是关于多维度的初始化构造方式。\n1 2 3 4 5 6 vector\u003cint\u003e v = {7, 5, 16, 8}; // 最基本的定义 // 通过大括号来设定多级的vector的初始值 vector\u003cvector\u003cchar\u003e\u003e value = { {'5','3','.','.','7','.','.','.','.'}, {'6','.','.','1','9','5','.','.','.'} }; 常用的长度和常量\n1 vector\u003cvector\u003cint\u003e\u003e vec(size1,vector\u003cint\u003e(size2,defaultvalue)); Unordered_map\u0026set哈希结构 CPP中hash table的实现数据类型： 实际上就是无序表，针对不同情况下的基本的定义方式，理念相同，针对不同的应用场景\nunordered_map Hashtable : 实际上是Key-Value的架构\nunordered_set Hashset ：只包含key的类型\n插入的话，可以使用数组的形式，也可以用insert 或者emplace把。\n取值方式 除了通过Key取Value这种老生常谈的方式，我们这里探讨的是iterator的情况下如何取到当前的值：\nset: *it即可； map：*it取的应该是value，key的话通过 it-\u003efirst来取值，value通过it-\u003esecond 按照迭代器来初始化 1 unordered_set\u003cstring\u003e deaded(deadends.begin(),deadends.end()); 是否存在键值 使用.count不要再用find和end了，那个估计时间成本特别高了。。。。怎么更慢了。\n使用map[key] 可以访问键对应的值，但是如果Key不存在，cpp会自动创建这个key同时赋值为0；\nerase 可以直接根据键值进行erase()\nList 双向链表like 通常用list 来实现类似双向链表的类型，基本的使用上好像和其他的容器没什么区别，没有index索引，可能需要用iteration来进行遍历操作，\n和双向队列相同，可以在两端添加和删除，pop push emplace也就是有_back和_front的后缀。 自带reverse，可以将元素的顺序反转； unique可以删除连续的重复元素； sort自带排序算法； Pair 二元元组对 二元tuple类型 实际上应该就是python中的二元tuple，也就是包含两个元素的数据结构，都是公开，可以是同样类别或者不同类别的，再STL中。\nUSAGE： 初始化：基本的初始化方式如下\n1 2 3 4 pair\u003ctype1, type2\u003e Data1; // 基本的调用方式如下 Data1.first = {}; Data2.second = {}; 用作新的类型定义的方式\n1 2 typedef pair\u003ctype1, type2\u003e newtypeName; newtypeName Data2; 实际上再DP中也是比较常见的，因为有一些情况下需要额外的信息存储就会使用这个类型。\nString \u0026 char 字符串 一些常用的函数 strcpy：将stringA 的值复制到stringB\nstrcat：直接用+就行了\nqueue队列 实际上就是队列数据结构的CPP实现，基本的特征和队列的要求是一致的，常在BFS中使用到。\n常用的成员函数和操作 front/back：访问首/尾元素; push/emplace/pop: 在末尾插入/构造数据；弹出队首数据； swap：交换内容（还没尝试过使用的方式）; Deque双端队列 有下标顺序的容器，允许在首尾两端快速插入和删除，相比于原本的普通队列，元素访问上没什么区；主要的区别在于\npop、emplace、push都变成了两种形式：pop_back\\ pop_front …etc. Priority_queue优先队列 参考资料 “例如，用 std::greaterT 将导致最小元素作为 top() 出现。”\nUsage 基本使用方式 1 2 priority_queue\u003ctype, container, compare\u003e 存放的数据类型，底层的容器类型，比较方程 基本的使用\n1 2 3 top push、pop、emplace swap Priority_queue与Multiset辨析： 实际上set和map这些数据结构是基于红黑树进行建立的，而优先队列是基于最大堆最小堆来建立的，虽然他们都有序，但是实际上他们的结构还是大不相同的。\n堆本身是一个完全二叉树（除了最后一层以外都是满的，而且空的值都在右侧），同时满足夫节点大于所有子节点\nSet本身是一个自平衡的BST（红黑树）：\n红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍\nset/multiset 堆相关的数据类型 比起说是堆，实际上就是集合的意思，但是这两个数据类型，本质上是基于红黑树等数据结构的基础设计（实现）的，很容易能转化为最大值堆和最小值堆。\n两者之间的基础区别： 两者都包含在中，进入这两个数据结构的数据都是会直接被排序好的（迭代器输出的话是从小到大的顺序排列），支持插入，删除，查找。\nset不允许重复元素的录入，会自动屏蔽重复元素； multiset可以容忍元素的重复，也就是不会做统筹处理； Usage使用方式： 可以通过在初始化的时候自定义compare，来规定排序的方向（来构建最大堆和最小堆），这里就涉及到了一下的两部分内容：\nless、greater的使用和介绍 两者包含在functional中\n是系统定义好的基本bool比较器，前者就是当A小于B的时候会return true；后者应该是反过来的；\n在一些函数或者类型定义的时候会使用到这两者的参数，避免我们的重复定义。\n:question:但是这里目前有一个问题就是他这里介绍的使用方式来建立最大值和最下值堆，和我个人理解的不太一样，我们需要去后面辨析一下到底是怎么样才是对的。\n应该和我理解的是一眼的，less最终就会是升序排列的，greater就会是降序排列的集合，然后只要我们在下面的pop或者push中指定一样的compare function就行。不，和我理解的是相反的\npush_heap pop_heap堆元素的添加和删除 帮助通过最大值堆和最小值堆的数据的添加和删除；此外我们在这里可能需要额外的介绍一下make_heap，应该也是heap的系列套件，不知道是从什么数据类型开始来帮助建立堆，我们后续需要补充一下。\n通过push_heap能够实现堆元素的添加同时并不破坏数据结构，实际上应该也就是实现了shiftup之类的操作。 而通过pop_heap的话，实际上实现的是将要弹出的元素换到了末尾，这样我们从0，n-2的元素就是重构好的最大/小堆。必要的时候我们需要手动调用pop_back()，来对要弹出的元素进行实质上的弹出。 make_heap将一个可迭代容器按照指定的compere建立成堆，默认是最大堆，输入的是begin，end，compa， AVL平衡二叉搜索树 实际上就是在插入元素的时候实现两个操作：\n单旋转：插入的大小关系符合但是失衡的情况 双旋转：插入的大小关系不符合同时发生了失衡的情况 平衡二叉树 B+、B树、红黑树 根节点最少有两个子女，每个中间节点都包含k-1个元素和k个孩子，每个叶子节点都包含k-1个元素，所有的叶子节点都位于同一层。\n重点就在于节省io时间还有中间的节点数量等等\nB树与B+树：https://blog.csdn.net/windflybird/article/details/79875972\n红黑树：https://zhuanlan.zhihu.com/p/31805309\n红黑树和AVL的区分：https://www.jianshu.com/p/37436ed14cc6 ；https://www.it610.com/article/1297797681401372672.htm\nSWAP FUNCTION swap在实际操作的时候经常被用到，很多时候会被拿来代替删除等等的命令。\n他适用的数据结构和数据类型以及传入的方式可以简单总结如下：\n初始定义就是交换两个变量之间的赋值，但是在各个数据类型中都存在swap的特化方程，所以根据该特化执行的情况下，等价于varA.swap(varB)，会交换其中的所有值； 通过基本的定义也能实现vector中两个不同index下的值的交换； Switch操作要常用 代替if else\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int calculate(string s) { vector\u003cint\u003e stk; char preSign = '+'; int num = 0; int n = s.length(); for (int i = 0; i \u003c n; ++i) { if (isdigit(s[i])) { num = num * 10 + int(s[i] - '0'); } if (!isdigit(s[i]) \u0026\u0026 s[i] != ' ' || i == n - 1) { switch (preSign) { case '+': stk.push_back(num); break; case '-': stk.push_back(-num); break; case '*': stk.back() *= num; break; default: stk.back() /= num; } preSign = s[i]; num = 0; } } return accumulate(stk.begin(), stk.end(), 0); } }; 位操作运算 参考资料 ^异或；~取反；|或；\u0026 与。\n位运算符的优先级从高到低，依次为~、\u0026、^、|。\n基本的一些操作Tips 根据剑指offer后面的两道题，我们可以分析一下怎么做到按位来进行操作\nException 异常处理 介绍cpp中的断言等异常处理的语句：assert try catch\nAssert 断言 设置条件断点，当Expression == false 的时候终止程序运行， Just take one arguments （Expression）；\n可以使用 #define NOEDEBUG 预处理符来终止程序中assert的作用。\n1 2 3 // #define NODEBUG // 注释掉的时候assert是有效的 assert(2+2==5); Try_Catch \u0026 Throw 异常捕捉和抛出 Throw就是Try中遇到异常执行的抛出语句，有默认的抛出类类型，我们也可以自定义抛出的值就是了，基本语法框架如下\n1 2 3 try { /* */ } catch (const std::exception\u0026 e) { /* */ } // 具名形参 try { /* */ } catch (const std::exception\u0026) { /* */ } // 不具名形参 try { /* */ } catch (...) { /* */ } // 可被任何异常激活的catch 还有一个比较具体的例子可以表示如下\n1 2 3 4 5 6 7 8 9 10 11 try { f(); } catch (const std::overflow_error\u0026 e) { // 若 f() 抛出 std::overflow_error 则执行之（“相同类型”规则） } catch (const std::runtime_error\u0026 e) { // 若 f() 抛出 std::underflow_error 则执行之（“基类”规则） } catch (const std::exception\u0026 e) { // 若 f() 抛出 std::logic_error 则执行之（“基类”规则） } catch (...) { // 若 f() 抛出 std::string 或 int 或任何其他无关类型则执行之 } 然后介绍一下我们自己调用throw的方式：我们可以抛出任意类型的值，然后通过catch捕获该类型即可，示范如下：\n不知道可不可以直接抛出“…”这种，下次试试。\n1 2 3 4 5 6 try { std::cout \u003c\u003c \"Throwing an integer exception...\\n\"; throw 42; } catch (int i) { std::cout \u003c\u003c \" the integer exception was caught, with value: \" \u003c\u003c i \u003c\u003c '\\n'; } Printf 按照format输出 #inlcude 参考cpp reference进行基本的学习吧，实际上\nAccumulate，isdigit 通过迭代器叠加其中的所有数字\nisdigit：返回的是是否是0~9的字符把\nDefine定义函数 1 #define nRand(n){rand() % n} 指针相关内容 函数指针 用typedef减少输入量的写法，实际应用在之前的cpp笔记中已经有了\n智能指针 unique_prt\u003c\u003e:会自己销毁的指针，管理的是堆对象，但是指针本身是随着栈，来进行管理的\nshared_ptr\u003c\u003e：对于同一个对象会维护一个指向该对象的count，通过这个count，在count清零的时候自动析构该类\nweak_ptr\u003c\u003e: 防止shared_ptr产生两个shard交互引用的情况，这样就永远不会被释放，通过weak指针，他不进行计数，当weak指针被销毁的时候就直接将空间释放，也不会使得技术++\n","wordCount":"545","inLanguage":"en","image":"https://hugotest-phi.vercel.app/cover/cover11.jpeg","datePublished":"2021-11-28T06:24:23Z","dateModified":"2021-11-28T06:24:23Z","author":[{"@type":"Person","name":"aikenhong"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://hugotest-phi.vercel.app/posts/cpp%E8%A6%81%E7%82%B9%E8%BE%A8%E6%9E%90%E4%B8%8E%E8%A1%A5%E5%85%85/"},"publisher":{"@type":"Organization","name":"aiken's blog","logo":{"@type":"ImageObject","url":"https://hugotest-phi.vercel.app/favicon/ghost.ico"}}}</script></head><body id=top><script type=module src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.esm.js defer></script><script nomodule src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.js defer></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hugotest-phi.vercel.app/ accesskey=h title="aiken's blog (Alt + H)">aiken's blog</a><div class=logo-switches><button id=theme-toggle-nav accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hugotest-phi.vercel.app/ title=home><span>home</span></a></li><li><a href=https://hugotest-phi.vercel.app/archives/ title=archives><span>archives</span></a></li><li><a href=https://hugotest-phi.vercel.app/search title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><div class=sidebar><ul><li class=logo style=--bg:#333><a href=#><div class=logo-icon><img src=/logo/logo.png></div><div class=logo-text>Aiken's Blog</div></a></li><div class=menulist><li style=--bg:#f44336><a href=https://hugotest-phi.vercel.app/ title=home><div class=logo-icon><ion-icon name=home-outline></ion-icon></div><div class=logo-text>home</div></a></li><li style=--bg:#b145e9><a href=https://hugotest-phi.vercel.app/posts/ title=posts><div class=logo-icon><ion-icon name=newspaper-outline></ion-icon></div><div class=logo-text>posts</div></a></li><li style=--bg:#0f93c7><a href=https://hugotest-phi.vercel.app/tags/ title=tags><div class=logo-icon><ion-icon name=pricetags-outline></ion-icon></div><div class=logo-text>tags</div></a></li><li style=--bg:#ffa117><a href=https://hugotest-phi.vercel.app/categories/ title=categories><div class=logo-icon><ion-icon name=grid-outline></ion-icon></div><div class=logo-text>categories</div></a></li><li style=--bg:#0fc70f><a href=https://hugotest-phi.vercel.app/archives/ title=archives><div class=logo-icon><ion-icon name=folder-outline></ion-icon></div><div class=logo-text>archives</div></a></li><li style=--bg:#d16111><a href=https://hugotest-phi.vercel.app/about/ title=about><div class=logo-icon><ion-icon name=person></ion-icon></div><div class=logo-text>about</div></a></li><li style=--bg:#15c095><a href=https://hugotest-phi.vercel.app/search title="search (Alt + /)" accesskey=/><div class=logo-icon><ion-icon name=search></ion-icon></div><div class=logo-text>search</div></a></li></div><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt +T)"><li><div class=logo-icon id=moon><ion-icon name=moon-outline></ion-icon></div><div class=logo-icon id=sun><ion-icon name=sunny-outline></ion-icon></div></li></button></div></ul></div><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hugotest-phi.vercel.app/>Home</a>&nbsp;»&nbsp;<a href=https://hugotest-phi.vercel.app/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++的常见数据类型和操作</h1><div class=post-meta><span title='2021-11-28 06:24:23 +0000 UTC'>November 28, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;545 words&nbsp;·&nbsp;aikenhong&nbsp;·&nbsp;<a href=/tags/cpp> Cpp</a>&nbsp;·&nbsp;<a href=/tags/langs> Langs</a>&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/CPP%e8%a6%81%e7%82%b9%e8%be%a8%e6%9e%90%e4%b8%8e%e8%a1%a5%e5%85%85.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://hugotest-phi.vercel.app/cover/cover11.jpeg alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%8c%87%e5%ae%9a%e7%b2%be%e5%ba%a6%e7%9a%84%e8%be%93%e5%87%ba%e5%92%8c%e8%ae%a1%e7%ae%97 aria-label=指定精度的输出和计算>指定精度的输出和计算</a></li><li><a href=#vector-%e5%8a%a8%e6%80%81%e6%95%b0%e7%bb%84 aria-label="Vector 动态数组">Vector 动态数组</a><ul class=header-level-2><li><a href=#emplace_back--push_back%e5%9c%a8%e6%9c%ab%e5%b0%be%e6%b7%bb%e5%8a%a0%e5%85%83%e7%b4%a0 aria-label="emplace_back & push_back（在末尾添加元素）">emplace_back & push_back（在末尾添加元素）</a></li><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96%e6%96%b9%e6%b3%95 aria-label=初始化方法>初始化方法</a></li></ul></li><li><a href=#unordered_mapset%e5%93%88%e5%b8%8c%e7%bb%93%e6%9e%84 aria-label=Unordered_map&amp;set哈希结构>Unordered_map&amp;set哈希结构</a><ul class=header-level-2><li><a href=#cpp%e4%b8%adhash-table%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label="CPP中hash table的实现数据类型：">CPP中hash table的实现数据类型：</a></li><li><a href=#%e5%8f%96%e5%80%bc%e6%96%b9%e5%bc%8f aria-label=取值方式>取值方式</a></li><li><a href=#%e6%8c%89%e7%85%a7%e8%bf%ad%e4%bb%a3%e5%99%a8%e6%9d%a5%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=按照迭代器来初始化>按照迭代器来初始化</a></li><li><a href=#%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8%e9%94%ae%e5%80%bc aria-label=是否存在键值>是否存在键值</a></li><li><a href=#erase aria-label=erase>erase</a></li></ul></li><li><a href=#list-%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8like aria-label="List 双向链表like">List 双向链表like</a></li><li><a href=#pair-%e4%ba%8c%e5%85%83%e5%85%83%e7%bb%84%e5%af%b9 aria-label="Pair 二元元组对">Pair 二元元组对</a><ul class=header-level-2><li><a href=#%e4%ba%8c%e5%85%83tuple%e7%b1%bb%e5%9e%8b aria-label=二元tuple类型>二元tuple类型</a></li><li><a href=#usage aria-label=USAGE：>USAGE：</a></li></ul></li><li><a href=#string--char-%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label="String & char 字符串">String & char 字符串</a><ul class=header-level-2><li><a href=#%e4%b8%80%e4%ba%9b%e5%b8%b8%e7%94%a8%e7%9a%84%e5%87%bd%e6%95%b0 aria-label=一些常用的函数>一些常用的函数</a></li></ul></li><li><a href=#queue%e9%98%9f%e5%88%97 aria-label=queue队列>queue队列</a><ul class=header-level-2><li><a href=#%e5%b8%b8%e7%94%a8%e7%9a%84%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e5%92%8c%e6%93%8d%e4%bd%9c aria-label=常用的成员函数和操作>常用的成员函数和操作</a></li><li><a href=#deque%e5%8f%8c%e7%ab%af%e9%98%9f%e5%88%97 aria-label=Deque双端队列>Deque双端队列</a></li><li><a href=#priority_queue%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97 aria-label=Priority_queue优先队列>Priority_queue优先队列</a><ul class=header-level-3><li><a href=#usage-%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f aria-label="Usage 基本使用方式">Usage 基本使用方式</a></li></ul></li><li><a href=#priority_queue%e4%b8%8emultiset%e8%be%a8%e6%9e%90 aria-label=Priority_queue与Multiset辨析：>Priority_queue与Multiset辨析：</a></li></ul></li><li><a href=#setmultiset-%e5%a0%86%e7%9b%b8%e5%85%b3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label="set/multiset 堆相关的数据类型">set/multiset 堆相关的数据类型</a><ul class=header-level-2><li><a href=#%e4%b8%a4%e8%80%85%e4%b9%8b%e9%97%b4%e7%9a%84%e5%9f%ba%e7%a1%80%e5%8c%ba%e5%88%ab aria-label=两者之间的基础区别：>两者之间的基础区别：</a></li><li><a href=#usage%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f aria-label=Usage使用方式：>Usage使用方式：</a><ul class=header-level-3><li><a href=#lessgreater%e7%9a%84%e4%bd%bf%e7%94%a8%e5%92%8c%e4%bb%8b%e7%bb%8d aria-label=less、greater的使用和介绍>less、greater的使用和介绍</a></li><li><a href=#push_heap--pop_heap%e5%a0%86%e5%85%83%e7%b4%a0%e7%9a%84%e6%b7%bb%e5%8a%a0%e5%92%8c%e5%88%a0%e9%99%a4 aria-label="push_heap  pop_heap堆元素的添加和删除">push_heap pop_heap堆元素的添加和删除</a></li></ul></li></ul></li><li><a href=#avl%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91 aria-label=AVL平衡二叉搜索树>AVL平衡二叉搜索树</a></li><li><a href=#bb%e6%a0%91%e7%ba%a2%e9%bb%91%e6%a0%91 aria-label=B+、B树、红黑树>B+、B树、红黑树</a></li><li><a href=#swap-function aria-label="SWAP FUNCTION">SWAP FUNCTION</a></li><li><a href=#switch%e6%93%8d%e4%bd%9c%e8%a6%81%e5%b8%b8%e7%94%a8 aria-label=Switch操作要常用>Switch操作要常用</a></li><li><a href=#%e4%bd%8d%e6%93%8d%e4%bd%9c%e8%bf%90%e7%ae%97 aria-label=位操作运算>位操作运算</a><ul class=header-level-2><li><a href=#%e5%9f%ba%e6%9c%ac%e7%9a%84%e4%b8%80%e4%ba%9b%e6%93%8d%e4%bd%9ctips aria-label=基本的一些操作Tips>基本的一些操作Tips</a></li></ul></li><li><a href=#exception-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86 aria-label="Exception 异常处理">Exception 异常处理</a><ul class=header-level-2><li><a href=#assert-%e6%96%ad%e8%a8%80 aria-label="Assert 断言">Assert 断言</a></li><li><a href=#try_catch--throw-%e5%bc%82%e5%b8%b8%e6%8d%95%e6%8d%89%e5%92%8c%e6%8a%9b%e5%87%ba aria-label="Try_Catch & Throw 异常捕捉和抛出">Try_Catch & Throw 异常捕捉和抛出</a></li></ul></li><li><a href=#printf-%e6%8c%89%e7%85%a7format%e8%be%93%e5%87%ba aria-label="Printf 按照format输出">Printf 按照format输出</a></li><li><a href=#accumulateisdigit aria-label=Accumulate，isdigit>Accumulate，isdigit</a></li><li><a href=#define%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0 aria-label=Define定义函数>Define定义函数</a></li><li><a href=#%e6%8c%87%e9%92%88%e7%9b%b8%e5%85%b3%e5%86%85%e5%ae%b9 aria-label=指针相关内容>指针相关内容</a><ul class=header-level-2><li><a href=#%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88 aria-label=函数指针>函数指针</a></li><li><a href=#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88 aria-label=智能指针>智能指针</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase(),n=document.querySelector(`.inner ul li a[href="#${t}"]`);n.classList.remove("read")}),activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach((t)=>{const o=encodeURI(t.getAttribute("id")).toLowerCase(),s=document.querySelector(`.inner ul li a[href="#${o}"]`);if(t===activeElement){s.classList.add("active");const e=document.querySelector(".toc .inner"),t=s.offsetTop,n=e.clientHeight,o=s.clientHeight,i=t-n/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else getOffsetTop(t)<e&&s.classList.add("read"),s.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return!document.querySelector(".hugo-encryptor-prompt")&&elements.length!=0&&(elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),console.log("Elements re-queried:",elements)),0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>主要介绍一些常用数据类型的一些method，区别还有一些特殊的定义；</p><p>priority_queue 默认是大顶堆，great的话是小顶堆，less的话是大顶堆，自定义的话不知道是不是一致的</p><p>set默认top是小顶，这个大小我就不知道了，自定义的话，好像和我想得是一致的</p><p><strong>所有的动态容器都是存放在heap上的，像是什么Vector，String，unordered_map之类的</strong></p><h2 id=指定精度的输出和计算>指定精度的输出和计算<a hidden class=anchor aria-hidden=true href=#指定精度的输出和计算>#</a></h2><p>在腾讯的笔试中出现的需要指定精度和指定的计算精度的分析，在使用常数的时候一定要使用.0去修正一个方法。</p><h2 id=vector-动态数组>Vector 动态数组<a hidden class=anchor aria-hidden=true href=#vector-动态数组>#</a></h2><p>Vector中的一些常用的函数，方法，以及一些属性介绍和辨析</p><h3 id=emplace_back--push_back在末尾添加元素>emplace_back & push_back（在末尾添加元素）<a hidden class=anchor aria-hidden=true href=#emplace_back--push_back在末尾添加元素>#</a></h3><p><code>empalce_back </code>直接在数组的末尾进行构造，而<code>push_back</code>借助于构造的临时变量再将其加入数组末尾，所以在一些操作中<code>empalce_back</code>对于空间时间的效率是会更高的，但是如果我们有重复构筑的数据的话，可能就需要使用<code>push_back</code>。</p><p>要注意实际上vector中并<strong>没有</strong>append的方法。</p><h3 id=初始化方法>初始化方法<a hidden class=anchor aria-hidden=true href=#初始化方法>#</a></h3><p>主要有几种常用的构造函数，在这里主要介绍的是关于多维度的初始化构造方式。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=p>{</span><span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>8</span><span class=p>};</span> <span class=c1>// 最基本的定义
</span></span></span><span class=line><span class=cl><span class=c1>// 通过大括号来设定多级的vector的初始值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;&gt;</span> <span class=n>value</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=sc>&#39;5&#39;</span><span class=p>,</span><span class=sc>&#39;3&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>,</span><span class=sc>&#39;7&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=sc>&#39;6&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>,</span><span class=sc>&#39;1&#39;</span><span class=p>,</span><span class=sc>&#39;9&#39;</span><span class=p>,</span><span class=sc>&#39;5&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>,</span><span class=sc>&#39;.&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span> 
</span></span></code></pre></td></tr></table></div></div><p>常用的长度和常量</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>vec</span><span class=p>(</span><span class=n>size1</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>size2</span><span class=p>,</span><span class=n>defaultvalue</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=unordered_mapset哈希结构>Unordered_map&amp;set哈希结构<a hidden class=anchor aria-hidden=true href=#unordered_mapset哈希结构>#</a></h2><h3 id=cpp中hash-table的实现数据类型>CPP中hash table的实现数据类型：<a hidden class=anchor aria-hidden=true href=#cpp中hash-table的实现数据类型>#</a></h3><p>实际上就是无序表，针对不同情况下的基本的定义方式，理念相同，针对不同的应用场景</p><ul><li><p><code>unordered_map&lt;typedef,typedef> Hashtable</code> : 实际上是Key-Value的架构</p></li><li><p><code>unordered_set&lt;typedef> Hashset</code> ：只包含key的类型</p></li></ul><p>插入的话，可以使用数组的形式，也可以用insert 或者emplace把。</p><h3 id=取值方式>取值方式<a hidden class=anchor aria-hidden=true href=#取值方式>#</a></h3><p>除了通过Key取Value这种老生常谈的方式，我们这里探讨的是iterator的情况下如何取到当前的值：</p><ol><li><strong>set</strong>: <code>*it</code>即可；</li><li><strong>map：</strong><code>*it</code>取的应该是value，<strong>key</strong>的话通过 <code>it->first</code>来取值，<strong>value</strong>通过<code>it->second</code></li></ol><h3 id=按照迭代器来初始化>按照迭代器来初始化<a hidden class=anchor aria-hidden=true href=#按照迭代器来初始化>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>deaded</span><span class=p>(</span><span class=n>deadends</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span><span class=n>deadends</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=是否存在键值>是否存在键值<a hidden class=anchor aria-hidden=true href=#是否存在键值>#</a></h3><p>使用<code>.count</code>不要再用find和end了，那个估计时间成本特别高了。。。。怎么更慢了。</p><p>使用map[key] 可以访问键对应的值，但是如果Key不存在，cpp会自动创建这个key同时赋值为0；</p><h3 id=erase>erase<a hidden class=anchor aria-hidden=true href=#erase>#</a></h3><p>可以直接根据键值进行erase()</p><h2 id=list-双向链表like>List 双向链表like<a hidden class=anchor aria-hidden=true href=#list-双向链表like>#</a></h2><p>通常用<a href=https://zh.cppreference.com/w/cpp/container/list target=_blank rel=noopener>list</a>
来实现类似双向链表的类型，基本的使用上好像和其他的容器没什么区别，没有index索引，可能需要用iteration来进行遍历操作，</p><ul><li>和双向队列相同，可以在两端添加和删除，pop push emplace也就是有_back和_front的后缀。</li><li>自带reverse，可以将元素的顺序反转；</li><li>unique可以删除连续的重复元素；</li><li>sort自带排序算法；</li></ul><h2 id=pair-二元元组对>Pair 二元元组对<a hidden class=anchor aria-hidden=true href=#pair-二元元组对>#</a></h2><h3 id=二元tuple类型>二元tuple类型<a hidden class=anchor aria-hidden=true href=#二元tuple类型>#</a></h3><p>实际上应该就是python中的二元tuple，也就是包含两个元素的数据结构，都是公开，可以是同样类别或者不同类别的，再STL中。</p><h3 id=usage>USAGE：<a hidden class=anchor aria-hidden=true href=#usage>#</a></h3><p>初始化：基本的初始化方式如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>pair</span><span class=o>&lt;</span><span class=n>type1</span><span class=p>,</span> <span class=n>type2</span><span class=o>&gt;</span> <span class=n>Data1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 基本的调用方式如下
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Data1</span><span class=p>.</span><span class=n>first</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=n>Data2</span><span class=p>.</span><span class=n>second</span> <span class=o>=</span> <span class=p>{};</span>
</span></span></code></pre></td></tr></table></div></div><p>用作新的类型定义的方式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=n>pair</span><span class=o>&lt;</span><span class=n>type1</span><span class=p>,</span> <span class=n>type2</span><span class=o>&gt;</span> <span class=n>newtypeName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>newtypeName</span> <span class=n>Data2</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>实际上再DP中也是比较常见的，因为有一些情况下需要额外的信息存储就会使用这个类型。</p><h2 id=string--char-字符串>String & char 字符串<a hidden class=anchor aria-hidden=true href=#string--char-字符串>#</a></h2><h3 id=一些常用的函数>一些常用的函数<a hidden class=anchor aria-hidden=true href=#一些常用的函数>#</a></h3><p>strcpy：将stringA 的值复制到stringB</p><p>strcat：直接用+就行了</p><h2 id=queue队列>queue队列<a hidden class=anchor aria-hidden=true href=#queue队列>#</a></h2><p>实际上就是队列数据结构的CPP实现，基本的特征和队列的要求是一致的，常在BFS中使用到。</p><h3 id=常用的成员函数和操作>常用的成员函数和操作<a hidden class=anchor aria-hidden=true href=#常用的成员函数和操作>#</a></h3><ol><li><code>front/back</code>：访问首/尾元素;</li><li><code>push/emplace/pop</code>: 在末尾插入/构造数据；弹出队首数据；</li><li><code>swap</code>：交换内容（还没尝试过使用的方式）;</li></ol><h3 id=deque双端队列>Deque双端队列<a hidden class=anchor aria-hidden=true href=#deque双端队列>#</a></h3><p>有下标顺序的容器，允许在首尾两端快速插入和删除，相比于原本的普通队列，元素访问上没什么区；主要的区别在于</p><ol><li>pop、emplace、push都变成了两种形式：<code>pop_back\ pop_front</code> &mldr;etc.</li></ol><h3 id=priority_queue优先队列>Priority_queue优先队列<a hidden class=anchor aria-hidden=true href=#priority_queue优先队列>#</a></h3><p><a href=https://blog.csdn.net/weixin_36888577/article/details/79937886 target=_blank rel=noopener>参考资料</a>
“例如，用 std::greaterT 将导致最小元素作为 <a href=https://zh.cppreference.com/w/cpp/container/priority_queue/top target=_blank rel=noopener>top()</a>
出现。”</p><h4 id=usage-基本使用方式>Usage 基本使用方式<a hidden class=anchor aria-hidden=true href=#usage-基本使用方式>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>priority_queue</span><span class=o>&lt;</span><span class=n>type</span><span class=p>,</span> <span class=n>container</span><span class=p>,</span> <span class=n>compare</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=err>存放的数据类型，底层的容器类型，比较方程</span>
</span></span></code></pre></td></tr></table></div></div><p>基本的使用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>top</span>
</span></span><span class=line><span class=cl><span class=n>push</span><span class=err>、</span><span class=n>pop</span><span class=err>、</span><span class=n>emplace</span>
</span></span><span class=line><span class=cl><span class=n>swap</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=priority_queue与multiset辨析>Priority_queue与Multiset辨析：<a hidden class=anchor aria-hidden=true href=#priority_queue与multiset辨析>#</a></h3><p>实际上set和map这些数据结构是基于红黑树进行建立的，而优先队列是基于<strong>最大堆最小堆</strong>来建立的，虽然他们都有序，但是实际上他们的结构还是大不相同的。</p><p>堆本身是一个完全二叉树（除了最后一层以外都是满的，而且空的值都在右侧），同时满足夫节点大于所有子节点</p><p>Set本身是一个自平衡的BST（红黑树）：</p><blockquote><p>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</p></blockquote><h2 id=setmultiset-堆相关的数据类型>set/multiset 堆相关的数据类型<a hidden class=anchor aria-hidden=true href=#setmultiset-堆相关的数据类型>#</a></h2><p>比起说是堆，实际上就是集合的意思，但是这两个数据类型，本质上是基于红黑树等数据结构的基础设计（实现）的，很容易能转化为最大值堆和最小值堆。</p><h3 id=两者之间的基础区别>两者之间的基础区别：<a hidden class=anchor aria-hidden=true href=#两者之间的基础区别>#</a></h3><p>两者都包含在<code>&lt;set></code>中，进入这两个数据结构的数据都是会直接被排序好的（迭代器输出的话是从小到大的顺序排列），支持插入，删除，查找。</p><ol><li>set不允许重复元素的录入，会自动屏蔽重复元素；</li><li>multiset可以容忍元素的重复，也就是不会做统筹处理；</li></ol><h3 id=usage使用方式>Usage使用方式：<a hidden class=anchor aria-hidden=true href=#usage使用方式>#</a></h3><p>可以通过在初始化的时候自定义compare，来规定排序的方向（来构建<strong>最大堆</strong>和<strong>最小堆</strong>），这里就涉及到了一下的两部分内容：</p><h4 id=lessgreater的使用和介绍>less、greater的使用和介绍<a hidden class=anchor aria-hidden=true href=#lessgreater的使用和介绍>#</a></h4><p>两者包含在<code>functional</code>中</p><p>是系统定义好的基本bool比较器，前者就是当A小于B的时候会return true；后者应该是反过来的；</p><p>在一些函数或者类型定义的时候会使用到这两者的参数，避免我们的重复定义。</p><p>:question:但是这里目前有一个问题就是他这里介绍的使用方式来建立最大值和最下值堆，和我个人理解的不太一样，我们需要去后面辨析一下到底是怎么样才是对的。</p><p>应该和我理解的是一眼的，less最终就会是升序排列的，greater就会是降序排列的集合，然后只要我们在下面的pop或者push中指定一样的compare function就行。不，和我理解的是相反的</p><h4 id=push_heap--pop_heap堆元素的添加和删除>push_heap pop_heap堆元素的添加和删除<a hidden class=anchor aria-hidden=true href=#push_heap--pop_heap堆元素的添加和删除>#</a></h4><p>帮助通过最大值堆和最小值堆的数据的添加和删除；此外我们在这里可能需要额外的介绍一下<code>make_heap</code>，应该也是heap的系列套件，不知道是从什么数据类型开始来帮助建立堆，我们后续需要补充一下。</p><ol><li>通过<code>push_heap</code>能够实现堆元素的添加同时并不破坏数据结构，实际上应该也就是实现了shiftup之类的操作。</li><li>而通过<code>pop_heap</code>的话，实际上实现的是将要弹出的元素换到了末尾，这样我们从0，n-2的元素就是重构好的最大/小堆。必要的时候我们需要手动调用<code>pop_back()</code>，来对要弹出的元素进行实质上的弹出。</li><li><code>make_heap</code>将一个可迭代容器按照指定的compere建立成堆，默认是最大堆，输入的是begin，end，compa，</li></ol><h2 id=avl平衡二叉搜索树>AVL平衡二叉搜索树<a hidden class=anchor aria-hidden=true href=#avl平衡二叉搜索树>#</a></h2><p>实际上就是在插入元素的时候实现两个操作：</p><ol><li>单旋转：插入的大小关系符合但是失衡的情况</li><li>双旋转：插入的大小关系不符合同时发生了失衡的情况</li></ol><p><a href=https://www.cnblogs.com/vamei/archive/2013/03/21/2964092.html target=_blank rel=noopener>平衡二叉树</a></p><h2 id=bb树红黑树>B+、B树、红黑树<a hidden class=anchor aria-hidden=true href=#bb树红黑树>#</a></h2><p>根节点最少有两个子女，每个中间节点都包含k-1个元素和k个孩子，每个叶子节点都包含k-1个元素，所有的叶子节点都位于同一层。</p><p>重点就在于节省io时间还有中间的节点数量等等</p><p>B树与B+树：https://blog.csdn.net/windflybird/article/details/79875972</p><p>红黑树：https://zhuanlan.zhihu.com/p/31805309</p><p>红黑树和AVL的区分：https://www.jianshu.com/p/37436ed14cc6 ；https://www.it610.com/article/1297797681401372672.htm</p><h2 id=swap-function>SWAP FUNCTION<a hidden class=anchor aria-hidden=true href=#swap-function>#</a></h2><p>swap在实际操作的时候经常被用到，很多时候会被拿来代替删除等等的命令。</p><p>他适用的数据结构和数据类型以及传入的方式可以简单总结如下：</p><ol><li>初始定义就是交换两个变量之间的赋值，但是在各个数据类型中都存在swap的特化方程，所以<strong>根据该特化执行</strong>的情况下，等价于<code>varA.swap(varB)</code>，会交换其中的所有值；</li><li>通过基本的定义也能实现vector中两个不同index下的值的交换；</li></ol><h2 id=switch操作要常用>Switch操作要常用<a hidden class=anchor aria-hidden=true href=#switch操作要常用>#</a></h2><p>代替if else</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>calculate</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>stk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>preSign</span> <span class=o>=</span> <span class=sc>&#39;+&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>length</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>isdigit</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>num</span> <span class=o>=</span> <span class=n>num</span> <span class=o>*</span> <span class=mi>10</span> <span class=o>+</span> <span class=kt>int</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=sc>&#39;0&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>isdigit</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>&amp;&amp;</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39; &#39;</span> <span class=o>||</span> <span class=n>i</span> <span class=o>==</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>switch</span> <span class=p>(</span><span class=n>preSign</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=sc>&#39;+&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>stk</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=sc>&#39;-&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>stk</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=o>-</span><span class=n>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=sc>&#39;*&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>stk</span><span class=p>.</span><span class=n>back</span><span class=p>()</span> <span class=o>*=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>stk</span><span class=p>.</span><span class=n>back</span><span class=p>()</span> <span class=o>/=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>preSign</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>accumulate</span><span class=p>(</span><span class=n>stk</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>stk</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=位操作运算>位操作运算<a hidden class=anchor aria-hidden=true href=#位操作运算>#</a></h2><p><a href=https://blog.csdn.net/cyuyan112233/article/details/40758031 target=_blank rel=noopener>参考资料</a>
<code>^</code>异或；<code>~</code>取反；<code>|</code>或；<code>&</code> 与。</p><p>位运算符的优先级从高到低，依次为~、&、^、|。</p><h3 id=基本的一些操作tips>基本的一些操作Tips<a hidden class=anchor aria-hidden=true href=#基本的一些操作tips>#</a></h3><p>根据剑指offer后面的两道题，我们可以分析一下怎么做到按位来进行操作</p><h2 id=exception-异常处理>Exception 异常处理<a hidden class=anchor aria-hidden=true href=#exception-异常处理>#</a></h2><p>介绍cpp中的断言等异常处理的语句：<code>assert</code> <code>try catch</code></p><h3 id=assert-断言>Assert 断言<a hidden class=anchor aria-hidden=true href=#assert-断言>#</a></h3><p>设置条件断点，当Expression == false 的时候终止程序运行， Just take one arguments （Expression）；</p><p>可以使用 <code>#define NOEDEBUG</code> 预处理符来终止程序中assert的作用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// #define NODEBUG 
</span></span></span><span class=line><span class=cl><span class=c1>// 注释掉的时候assert是有效的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>assert</span><span class=p>(</span><span class=mi>2</span><span class=o>+</span><span class=mi>2</span><span class=o>==</span><span class=mi>5</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=try_catch--throw-异常捕捉和抛出>Try_Catch & Throw 异常捕捉和抛出<a hidden class=anchor aria-hidden=true href=#try_catch--throw-异常捕捉和抛出>#</a></h3><p>Throw就是Try中遇到异常执行的抛出语句，有默认的抛出类类型，我们也可以自定义抛出的值就是了，基本语法框架如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span> <span class=cm>/* */</span> <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* */</span> <span class=p>}</span> <span class=c1>// 具名形参
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>try</span> <span class=p>{</span> <span class=cm>/* */</span> <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=o>&amp;</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* */</span> <span class=p>}</span>  <span class=c1>// 不具名形参
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>try</span> <span class=p>{</span> <span class=cm>/* */</span> <span class=p>}</span> <span class=k>catch</span> <span class=p>(...)</span> <span class=p>{</span> <span class=cm>/* */</span> <span class=p>}</span>  <span class=c1>// 可被任何异常激活的catch
</span></span></span></code></pre></td></tr></table></div></div><p>还有一个比较具体的例子可以表示如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>overflow_error</span><span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 若 f() 抛出 std::overflow_error 则执行之（“相同类型”规则）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 若 f() 抛出 std::underflow_error 则执行之（“基类”规则）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 若 f() 抛出 std::logic_error 则执行之（“基类”规则）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>catch</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 若 f() 抛出 std::string 或 int 或任何其他无关类型则执行之
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>然后介绍一下我们自己调用<code>throw</code>的方式：我们可以抛出任意类型的值，然后通过catch捕获该类型即可，示范如下：</p><p>不知道可不可以直接抛出“&mldr;”这种，下次试试。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Throwing an integer exception...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; the integer exception was caught, with value: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=printf-按照format输出>Printf 按照format输出<a hidden class=anchor aria-hidden=true href=#printf-按照format输出>#</a></h2><pre tabindex=0><code>#inlcude&lt;cstdio&gt;
</code></pre><p>参考cpp reference进行基本的学习吧，实际上</p><h2 id=accumulateisdigit>Accumulate，isdigit<a hidden class=anchor aria-hidden=true href=#accumulateisdigit>#</a></h2><p>通过迭代器叠加其中的所有数字</p><p>isdigit：返回的是是否是0~9的字符把</p><h2 id=define定义函数>Define定义函数<a hidden class=anchor aria-hidden=true href=#define定义函数>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define nRand(n){rand() % n}
</span></span></span></code></pre></td></tr></table></div></div><h2 id=指针相关内容>指针相关内容<a hidden class=anchor aria-hidden=true href=#指针相关内容>#</a></h2><h3 id=函数指针>函数指针<a hidden class=anchor aria-hidden=true href=#函数指针>#</a></h3><p>用typedef减少输入量的写法，实际应用在之前的cpp笔记中已经有了</p><h3 id=智能指针>智能指针<a hidden class=anchor aria-hidden=true href=#智能指针>#</a></h3><p>unique_prt&lt;>:会自己销毁的指针，管理的是堆对象，但是指针本身是随着栈，来进行管理的</p><p>shared_ptr&lt;>：对于同一个对象会维护一个指向该对象的count，通过这个count，在count清零的时候自动析构该类</p><p>weak_ptr&lt;>: 防止shared_ptr产生两个shard交互引用的情况，这样就永远不会被释放，通过weak指针，他不进行计数，当weak指针被销毁的时候就直接将空间释放，也不会使得技术++</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://hugotest-phi.vercel.app/tags/cpp/>Cpp</a></li><li><a href=https://hugotest-phi.vercel.app/tags/langs/>Langs</a></li></ul><nav class=paginav><a class=prev href=https://hugotest-phi.vercel.app/posts/pythontips/><span class=title>« Prev</span><br><span>（转）What the Fuck Python！ 一些python特性</span>
</a><a class=next href=https://hugotest-phi.vercel.app/posts/linux/><span class=title>Next »</span><br><span>Linux 基础操作 01</span></a></nav></footer><div id=disqus_thread></div><script>function loadDisqus(){var e=document,t=e.createElement("script");t.src="https://aiken-hugo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t),window.disqus_config=function(){this.page.url=window.location.href,this.page.identifier=window.location.href.substring(18)}}var runningOnBrowser=typeof window!="undefined",isBot=runningOnBrowser&&!("onscroll"in window)||typeof navigator!="undefined"&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){if(!isBot&&supportsIntersectionObserver){var e=new IntersectionObserver(function(t){t[0].isIntersecting&&(loadDisqus(),e.disconnect())},{threshold:[0]});e.observe(document.getElementById("disqus_thread"))}else loadDisqus()},1)</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://hugotest-phi.vercel.app/>aiken's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container>Visitors: <span id=busuanzi_value_site_uv></span>
Views: <span id=busuanzi_value_site_pv></span></span></footer><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),o=13863,i=16993;if(!e||!t){console.error("Busuanzi elements not found.");return}const n=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+o;break}}),s=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){s.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+i;break}});n.observe(e,{childList:!0}),s.observe(t,{childList:!0})})</script><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))}),document.getElementById("theme-toggle-nav").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("/js/pangu.js",function(){pangu.spacingPage()})</script></body></html>