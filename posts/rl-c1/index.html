<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RL Notebook 01 | aiken's blog</title>
<meta name=keywords content="Reinforcement learning,Machine Learning"><meta name=description content="Created by: Aiken H
Detail: survey
Finished?: No
Tags: Paper
URL1: https://www.cnblogs.com/pinard/category/1254674.html

URL2: https://github.com/ljpzzz/machinelearning

URL3: https://datawhalechina.github.io/easy-rl/#/

Chapter1 模型基础
强化学习（一）模型基础

强化学习是介于监督和无监督学习之间的，强化学习没有输出值，但是有reward： 同时这个reward是事后给出的，而不是及时回馈的。而无监督学习是只有数据特征，同时数据之间是独立的，没有前后依赖的关系。


  
    
  





Theory理论基础



简化模型介绍：
上面的大脑代表我们的算法执行个体，我们可以操作个体来做决策，即选择一个合适的动作（Action）At。下面的地球代表我们要研究的环境,它有自己的状态模型，我们选择了动作At后，环境的状态(State)会变，我们会发现环境状态已经变为St+1,同时我们得到了我们采取动作At的延时奖励(Reward)Rt+1。然后个体可以继续选择下一个合适的动作，然后环境的状态又会变，又有新的奖励值。。。这就是强化学习的思路。


强化学习的模型关键要素：

环境的状态S：t时刻环境的状态 $S_t$ 是它环境状态集中的某一个状态
个体的动作A：个体在某个时刻可能做出的动作集合
环境的奖励R：个体在某个时刻对应状态下做出的动作 $A_t$ 得到的奖励会在t+1时刻得到
个体的策略 $\pi$ ：个体根据当前的环境选择采取动作的策略分布（函数），一般表示为一个条件概率分布的形式，概率大的动作被个体选择的概率显然更高


$$ \pi(a|s)= P(A_t = a | S_t = s) $$


在策略 $\pi$ 和状态s采行动后的价值 $v_\pi(s)$ ：一般是一个期望函数，因为我们不能每次只能选择当前的reward最大的策略，而是需要考虑大局，所以我们要有一个综合的（当前和后续）的延时奖励。


$$ v_\pi(s) = \mathbb{E}(R_{t+1} + \gamma R_{t+2} + \gamma ^2 R_{t+3} + ... |S_t = s) $$


奖励衰减因子 $\gamma$ ：也就是上式的权重，极端值考虑贪婪和一致等同，范围在[0,1]
环境的状态转移模型：也就是环境从s经过a后转化下一个状态的状态机，也可以表示为一个概率模型 $P_{ss^‘}^a$ (s→s&rsquo; , a)
探索率 $\epsilon$ ：主要用于训练迭代中，我们一般选择当前价值最大的动作，但是为了搜索空间的完备，我们会用 $\epsilon$ 的概率去选择非最大价值的动作，来提升训练的鲁棒性

SUMMARY：主要介绍了强化学习模型的workflow以及其中需要考虑的8个主要参数和函数架构。最主要的机制还是Policy和reward设计这一块"><meta name=author content="aikenhong"><link rel=canonical href=https://aikenh.cn/hugotest/posts/rl-c1/><link crossorigin=anonymous href=/hugotest/assets/css/stylesheet.2f85ca17c12c62fa86b1e474b8a51aca4856f0d645debfe4922a4d5ddc6aa978.css integrity="sha256-L4XKF8EsYvqGseR0uKUaykhW8NZF3r/kkipNXdxqqXg=" rel="preload stylesheet" as=style><link rel=icon href=https://aikenh.cn/favicon/ghost.ico><link rel=icon type=image/png sizes=16x16 href=https://aikenh.cn/favicon/ghost-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aikenh.cn/favicon/ghost-32x32.png><link rel=apple-touch-icon href=https://aikenh.cn/favicon/ghost-apple-touch-icon.png><link rel=mask-icon href=https://aikenh.cn/favicon/ghost-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aikenh.cn/hugotest/posts/rl-c1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><meta property="og:url" content="https://aikenh.cn/hugotest/posts/rl-c1/"><meta property="og:site_name" content="aiken's blog"><meta property="og:title" content="RL Notebook 01"><meta property="og:description" content="Created by: Aiken H Detail: survey Finished?: No Tags: Paper URL1: https://www.cnblogs.com/pinard/category/1254674.html URL2: https://github.com/ljpzzz/machinelearning URL3: https://datawhalechina.github.io/easy-rl/#/ Chapter1 模型基础 强化学习（一）模型基础 强化学习是介于监督和无监督学习之间的，强化学习没有输出值，但是有reward： 同时这个reward是事后给出的，而不是及时回馈的。而无监督学习是只有数据特征，同时数据之间是独立的，没有前后依赖的关系。
Theory理论基础 简化模型介绍：
上面的大脑代表我们的算法执行个体，我们可以操作个体来做决策，即选择一个合适的动作（Action）At。下面的地球代表我们要研究的环境,它有自己的状态模型，我们选择了动作At后，环境的状态(State)会变，我们会发现环境状态已经变为St+1,同时我们得到了我们采取动作At的延时奖励(Reward)Rt+1。然后个体可以继续选择下一个合适的动作，然后环境的状态又会变，又有新的奖励值。。。这就是强化学习的思路。
强化学习的模型关键要素：
环境的状态S：t时刻环境的状态 $S_t$ 是它环境状态集中的某一个状态 个体的动作A：个体在某个时刻可能做出的动作集合 环境的奖励R：个体在某个时刻对应状态下做出的动作 $A_t$ 得到的奖励会在t+1时刻得到 个体的策略 $\pi$ ：个体根据当前的环境选择采取动作的策略分布（函数），一般表示为一个条件概率分布的形式，概率大的动作被个体选择的概率显然更高 $$ \pi(a|s)= P(A_t = a | S_t = s) $$在策略 $\pi$ 和状态s采行动后的价值 $v_\pi(s)$ ：一般是一个期望函数，因为我们不能每次只能选择当前的reward最大的策略，而是需要考虑大局，所以我们要有一个综合的（当前和后续）的延时奖励。 $$ v_\pi(s) = \mathbb{E}(R_{t+1} + \gamma R_{t+2} + \gamma ^2 R_{t+3} + ... |S_t = s) $$奖励衰减因子 $\gamma$ ：也就是上式的权重，极端值考虑贪婪和一致等同，范围在[0,1] 环境的状态转移模型：也就是环境从s经过a后转化下一个状态的状态机，也可以表示为一个概率模型 $P_{ss^‘}^a$ (s→s’ , a) 探索率 $\epsilon$ ：主要用于训练迭代中，我们一般选择当前价值最大的动作，但是为了搜索空间的完备，我们会用 $\epsilon$ 的概率去选择非最大价值的动作，来提升训练的鲁棒性 SUMMARY：主要介绍了强化学习模型的workflow以及其中需要考虑的8个主要参数和函数架构。最主要的机制还是Policy和reward设计这一块"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-23T13:50:06+00:00"><meta property="article:modified_time" content="2021-05-23T13:50:06+00:00"><meta property="article:tag" content="Reinforcement Learning"><meta property="article:tag" content="Machine Learning"><meta property="og:image" content="https://aikenh.cn/cover/cover15.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aikenh.cn/cover/cover15.jpeg"><meta name=twitter:title content="RL Notebook 01"><meta name=twitter:description content="Created by: Aiken H
Detail: survey
Finished?: No
Tags: Paper
URL1: https://www.cnblogs.com/pinard/category/1254674.html

URL2: https://github.com/ljpzzz/machinelearning

URL3: https://datawhalechina.github.io/easy-rl/#/

Chapter1 模型基础
强化学习（一）模型基础

强化学习是介于监督和无监督学习之间的，强化学习没有输出值，但是有reward： 同时这个reward是事后给出的，而不是及时回馈的。而无监督学习是只有数据特征，同时数据之间是独立的，没有前后依赖的关系。


  
    
  





Theory理论基础



简化模型介绍：
上面的大脑代表我们的算法执行个体，我们可以操作个体来做决策，即选择一个合适的动作（Action）At。下面的地球代表我们要研究的环境,它有自己的状态模型，我们选择了动作At后，环境的状态(State)会变，我们会发现环境状态已经变为St+1,同时我们得到了我们采取动作At的延时奖励(Reward)Rt+1。然后个体可以继续选择下一个合适的动作，然后环境的状态又会变，又有新的奖励值。。。这就是强化学习的思路。


强化学习的模型关键要素：

环境的状态S：t时刻环境的状态 $S_t$ 是它环境状态集中的某一个状态
个体的动作A：个体在某个时刻可能做出的动作集合
环境的奖励R：个体在某个时刻对应状态下做出的动作 $A_t$ 得到的奖励会在t+1时刻得到
个体的策略 $\pi$ ：个体根据当前的环境选择采取动作的策略分布（函数），一般表示为一个条件概率分布的形式，概率大的动作被个体选择的概率显然更高


$$ \pi(a|s)= P(A_t = a | S_t = s) $$


在策略 $\pi$ 和状态s采行动后的价值 $v_\pi(s)$ ：一般是一个期望函数，因为我们不能每次只能选择当前的reward最大的策略，而是需要考虑大局，所以我们要有一个综合的（当前和后续）的延时奖励。


$$ v_\pi(s) = \mathbb{E}(R_{t+1} + \gamma R_{t+2} + \gamma ^2 R_{t+3} + ... |S_t = s) $$


奖励衰减因子 $\gamma$ ：也就是上式的权重，极端值考虑贪婪和一致等同，范围在[0,1]
环境的状态转移模型：也就是环境从s经过a后转化下一个状态的状态机，也可以表示为一个概率模型 $P_{ss^‘}^a$ (s→s&rsquo; , a)
探索率 $\epsilon$ ：主要用于训练迭代中，我们一般选择当前价值最大的动作，但是为了搜索空间的完备，我们会用 $\epsilon$ 的概率去选择非最大价值的动作，来提升训练的鲁棒性

SUMMARY：主要介绍了强化学习模型的workflow以及其中需要考虑的8个主要参数和函数架构。最主要的机制还是Policy和reward设计这一块"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aikenh.cn/hugotest/posts/"},{"@type":"ListItem","position":2,"name":"RL Notebook 01","item":"https://aikenh.cn/hugotest/posts/rl-c1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RL Notebook 01","name":"RL Notebook 01","description":"Created by: Aiken H Detail: survey Finished?: No Tags: Paper URL1: https://www.cnblogs.com/pinard/category/1254674.html URL2: https://github.com/ljpzzz/machinelearning URL3: https://datawhalechina.github.io/easy-rl/#/ Chapter1 模型基础 强化学习（一）模型基础 强化学习是介于监督和无监督学习之间的，强化学习没有输出值，但是有reward： 同时这个reward是事后给出的，而不是及时回馈的。而无监督学习是只有数据特征，同时数据之间是独立的，没有前后依赖的关系。\nTheory理论基础 简化模型介绍：\n上面的大脑代表我们的算法执行个体，我们可以操作个体来做决策，即选择一个合适的动作（Action）At。下面的地球代表我们要研究的环境,它有自己的状态模型，我们选择了动作At后，环境的状态(State)会变，我们会发现环境状态已经变为St+1,同时我们得到了我们采取动作At的延时奖励(Reward)Rt+1。然后个体可以继续选择下一个合适的动作，然后环境的状态又会变，又有新的奖励值。。。这就是强化学习的思路。\n强化学习的模型关键要素：\n环境的状态S：t时刻环境的状态 $S_t$ 是它环境状态集中的某一个状态 个体的动作A：个体在某个时刻可能做出的动作集合 环境的奖励R：个体在某个时刻对应状态下做出的动作 $A_t$ 得到的奖励会在t+1时刻得到 个体的策略 $\\pi$ ：个体根据当前的环境选择采取动作的策略分布（函数），一般表示为一个条件概率分布的形式，概率大的动作被个体选择的概率显然更高 $$ \\pi(a|s)= P(A_t = a | S_t = s) $$\r在策略 $\\pi$ 和状态s采行动后的价值 $v_\\pi(s)$ ：一般是一个期望函数，因为我们不能每次只能选择当前的reward最大的策略，而是需要考虑大局，所以我们要有一个综合的（当前和后续）的延时奖励。 $$ v_\\pi(s) = \\mathbb{E}(R_{t+1} + \\gamma R_{t+2} + \\gamma ^2 R_{t+3} + ... |S_t = s) $$\r奖励衰减因子 $\\gamma$ ：也就是上式的权重，极端值考虑贪婪和一致等同，范围在[0,1] 环境的状态转移模型：也就是环境从s经过a后转化下一个状态的状态机，也可以表示为一个概率模型 $P_{ss^‘}^a$ (s→s\u0026rsquo; , a) 探索率 $\\epsilon$ ：主要用于训练迭代中，我们一般选择当前价值最大的动作，但是为了搜索空间的完备，我们会用 $\\epsilon$ 的概率去选择非最大价值的动作，来提升训练的鲁棒性 SUMMARY：主要介绍了强化学习模型的workflow以及其中需要考虑的8个主要参数和函数架构。最主要的机制还是Policy和reward设计这一块\n","keywords":["Reinforcement learning","Machine Learning"],"articleBody":"Created by: Aiken H Detail: survey Finished?: No Tags: Paper URL1: https://www.cnblogs.com/pinard/category/1254674.html URL2: https://github.com/ljpzzz/machinelearning URL3: https://datawhalechina.github.io/easy-rl/#/ Chapter1 模型基础 强化学习（一）模型基础 强化学习是介于监督和无监督学习之间的，强化学习没有输出值，但是有reward： 同时这个reward是事后给出的，而不是及时回馈的。而无监督学习是只有数据特征，同时数据之间是独立的，没有前后依赖的关系。\nTheory理论基础 简化模型介绍：\n上面的大脑代表我们的算法执行个体，我们可以操作个体来做决策，即选择一个合适的动作（Action）At。下面的地球代表我们要研究的环境,它有自己的状态模型，我们选择了动作At后，环境的状态(State)会变，我们会发现环境状态已经变为St+1,同时我们得到了我们采取动作At的延时奖励(Reward)Rt+1。然后个体可以继续选择下一个合适的动作，然后环境的状态又会变，又有新的奖励值。。。这就是强化学习的思路。\n强化学习的模型关键要素：\n环境的状态S：t时刻环境的状态 $S_t$ 是它环境状态集中的某一个状态 个体的动作A：个体在某个时刻可能做出的动作集合 环境的奖励R：个体在某个时刻对应状态下做出的动作 $A_t$ 得到的奖励会在t+1时刻得到 个体的策略 $\\pi$ ：个体根据当前的环境选择采取动作的策略分布（函数），一般表示为一个条件概率分布的形式，概率大的动作被个体选择的概率显然更高 $$ \\pi(a|s)= P(A_t = a | S_t = s) $$\r在策略 $\\pi$ 和状态s采行动后的价值 $v_\\pi(s)$ ：一般是一个期望函数，因为我们不能每次只能选择当前的reward最大的策略，而是需要考虑大局，所以我们要有一个综合的（当前和后续）的延时奖励。 $$ v_\\pi(s) = \\mathbb{E}(R_{t+1} + \\gamma R_{t+2} + \\gamma ^2 R_{t+3} + ... |S_t = s) $$\r奖励衰减因子 $\\gamma$ ：也就是上式的权重，极端值考虑贪婪和一致等同，范围在[0,1] 环境的状态转移模型：也就是环境从s经过a后转化下一个状态的状态机，也可以表示为一个概率模型 $P_{ss^‘}^a$ (s→s’ , a) 探索率 $\\epsilon$ ：主要用于训练迭代中，我们一般选择当前价值最大的动作，但是为了搜索空间的完备，我们会用 $\\epsilon$ 的概率去选择非最大价值的动作，来提升训练的鲁棒性 SUMMARY：主要介绍了强化学习模型的workflow以及其中需要考虑的8个主要参数和函数架构。最主要的机制还是Policy和reward设计这一块\nChapter2 马尔可夫决策过程（MDP） 强化学习（二）马尔科夫决策过程(MDP) Easy-RL 在这里可能需要补充一下马尔可夫链的相关理论知识，先粗略的看完这部分再说\n马尔可夫性简化 环境的真实转化状态可能和之前的多个时刻相关，这样会导致建模困难，于是我们对环境的状态转移模型进行马尔可夫性假设。也就是：\n转化到下一个状态s’只和当前的状态s相关，与之前的状态无关\n同样的我们对Policy、价值函数也做了同样的马尔可夫性假设来简化。\n其中： $G_t$ 代表收获（return），是从某一个状态开始采样直到终止状态时所有奖励的有衰减的和。\n$$ 1.\\ P_{ss'}^a = \\mathbb{E}(S_{t+1} = s'|S_t=s,A_t=a) $$\r$$ 2. \\ \\pi(a|s) = P(A_t = a | S_t = s) $$\r$$ 3. \\ v_\\pi(s) =\\mathbb{E}_\\pi(G_t|S_t =s) = \\mathbb{E}(R_{t+1} + \\gamma R_{t+2} + \\gamma ^2 R_{t+3} + ... |S_t = s) $$\rSUMMARY：由于环境的复杂时序关系，我们需要进行相应的马尔可夫性的假设，让下一个时刻的状态或者预测值只和当前时刻有关，从而简化并假设出模型\nMDP的价值函数和贝尔曼方程 在上述价值表达式的基础上，加入考虑动作a带来的价值影响，我们就可以得到下面的动作价值函数：\n$$ q_{\\pi}(s, a)=\\mathbb{E}_{\\pi}\\left(G_{t} \\mid S_{t}=s, A_{t}=a\\right)=\\mathbb{E}_{\\pi}\\left(R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} R_{t+3}+\\ldots \\mid S_{t}=s, A_{t}=a\\right) $$\r我们可以通过价值函数的公式得到价值函数的递推关系（贝尔曼方程）：\n$$ \\begin{aligned}\rv_{\\pi}(s) \u0026=\\mathbb{E}{\\pi}\\left(R{t+1}+\\gamma R_{t+2}+\\gamma^{2} R_{t+3}+\\ldots \\mid S_{t}=s\\right) \\\\\r\u0026=\\mathbb{E}{\\pi}\\left(R{t+1}+\\gamma\\left(R_{t+2}+\\gamma R_{t+3}+\\ldots\\right) \\mid S_{t}=s\\right) \\\\\r\u0026=\\mathbb{E}{\\pi}\\left(R{t+1}+\\gamma G_{t+1} \\mid S_{t}=s\\right) \\\\\r\u0026=\\mathbb{E}{\\pi}\\left(R{t+1}+\\gamma v_{\\pi}\\left(S_{t+1}\\right) \\mid S_{t}=s\\right)\r\\end{aligned} $$\r一个状态的价值由该状态的奖励以及后续状态价值按照一定衰减比例联合而成，同样的有：\n$$ q_{\\pi}(s, a)=\\mathbb{E}_{\\pi}\\left(R_{t+1}+\\gamma q_{\\pi}\\left(S_{t+1}, A_{t+1}\\right) \\mid S_{t}=s, A_{t}=a\\right) $$\rSUMMARY：基于马尔可夫假设之后，我们可以将价值函数（动作、状态）表示一个递推的形式，这个递推的形式也被叫做贝尔曼方程。\n状态价值函数和动作价值函数的递推关系 基于状态价值函数的定义以及动作价值函数的定义，我们很容易得到两个价值函数之间的转化关系：\n状态价值函数是动作价值函数对于所有可能动作对于policy的期望。\n利用贝尔曼方程，我们也能反推得状态价值函数来表示动作价值函数：\n当前的reward和可能转移到所有后续状态的价值函数的加权和\n$$ v_\\pi(s) = \\sum_{a\\in A} \\pi({a|s}) q_\\pi(s,a) $$\r$$ q_\\pi(s,a) = R_s^a + \\gamma \\sum _ {s'\\in S} P_{ss'}^a v_\\pi(s') $$\r将上述两个式子互相结合起来，我们可以得到如下的简化（变量）算式（只包含一种价值函数）\n$$ \\begin{gathered}v_{\\pi}(s)=\\sum_{a \\in A} \\pi(a \\mid s)\\left(R_{s}^{a}+\\gamma \\sum_{J \\in S} P_{s s^{\\prime}}^{a} v_{\\pi}\\left(s^{\\prime}\\right)\\right) \\\\q_{\\pi}(s, a)=R_{s}^{a}+\\gamma \\sum_{s^{\\prime} \\in S} P_{s s^{\\prime}}^{a} \\sum_{a^{\\prime} \\in A} \\pi\\left(a^{\\prime} \\mid s^{\\prime}\\right) q_{\\pi}\\left(s^{\\prime}, a^{\\prime}\\right)\\end{gathered} $$\r最优价值函数 这一部分看原文，结合相应的例子一起看，后续可能需要看EasyRL中的markov的相关解读来进行深入的理解和计算的分析。\n解决一个强化学习的问题意味着要找一个最有的policy（策略），让Argent在和环境交互的过程中获得比其他所有策略都更多的收获，找到这个策略，也就意味着我们解决了这样一个强化学习的问题。\n求解最优策略→ 求解最优的价值函数，使得（动作、状态）价值函数获取到最大值的策略就是最优策略。\n对于最优策略我们将动作函数定义为：\n$$ \\pi_{*}(a \\mid s)=\\left\\{\\begin{array}{ll}1 \u0026 \\text { if } a=\\arg \\max _{a \\in A} q_{*}(s, a) \\\\0 \u0026 \\text { else }\\end{array}\\right. $$\r有：\n$$ v_*(s) = \\max_a q_*(s,a)\\\\q_{*}(s, a)=R_{s}^{a}+\\gamma \\sum_{s^{\\prime} \\in S} P_{s s}^{a} v_{*}\\left(s^{\\prime}\\right) $$\r这样我们就可以最终得到：\n$$ \\begin{gathered}v_{*}(s)=\\max _{a}\\left(R_{s}^{a}+\\gamma \\sum_{g^{\\prime} \\in S} P_{s s^{\\prime}}^{a} v_{*}\\left(s^{\\prime}\\right)\\right) \\\\q_{*}(s, a)=R_{s}^{a}+\\gamma \\sum_{s^{\\prime} \\in S} P_{s s^{\\prime}}^{a} \\max _{a^{\\prime}} q_{*}\\left(s^{\\prime}, a^{\\prime}\\right)\\end{gathered} $$\rChapter3 动态规划（DP）求解 强化学习（三）用动态规划（DP）求解 用动态规划来求解强化学习是自然的\n关键的两点：\n问题的最优解可以由递归的最优解来得到 子问题状态间的转移 从上面推出的贝尔曼方程，这个递推公式实际上就是DP求解的状态转移等式，然后相应的Value什么的也和DP求解过程的需求是一一对应的。\n关键的方程，通过这种递推公式，我们可以通过上一个迭代周期的状态价值去计算当前迭代周期状态S的状态价值，这也就是动态规划的一个求解的自然过程。\n基于贝克曼方程推导出来，推导过程已经在上面了\n$$ v_{\\pi}(s)=\\sum_{a \\in A} \\pi(a \\mid s)\\left(R_{s}^{a}+\\gamma \\sum_{J \\in S} P_{s s^{\\prime}}^{a} v_{\\pi}\\left(s^{\\prime}\\right)\\right) $$\r已知条件：状态集S, 动作集A, 模型状态转化概率矩阵P, 即时奖励R，衰减因子γ, 给定策略π\n策略评估求解预测问题 策略评估：求解给定策略的状态价值函数的问题，即强化学习的预测问题。\n求解思路： 从任何一个状态价值函数开始，按照给定的策略，结合关键的贝尔曼递推期望方程，状态转移，reward，更新状态价值函数，直至最终收敛。\n具体而言：\n假设第k轮我们已经计算出了所有的状态的状态价值，然后再k+1轮的时候利用k轮的值通过贝尔曼方程来进行更新。\n$$ v_{k+1}(s)=\\sum_{a \\in A} \\pi(a \\mid s)\\left(R_{s}^{a}+\\gamma \\sum_{s' \\in S} P_{s s^{\\prime}}^{a} v_{\\pi}\\left(s^{\\prime}\\right)\\right) $$\r具体案例上面的网站中去看：（很容易理解）\n策略迭代求解控制问题 控制问题：需要同时求解状态价值函数和策略\n策略迭代：从一个初始任意的策略状态，不断地迭代，调整我们的策略，从而得到一个最优的策略。\n求解思路：贪婪法\n具体而言：\n个体在某个状态下选择的行为，是其能够达到后续所有可能的状态中，状态价值最大的那个状态，\n策略迭代过程的演示：逐步的迭代策略和相应的价值函数，最终使得两者同时收敛\n价值迭代求解控制问题 和上述的策略迭代的问题一样，如果我们使用贪婪的策略去及时调整策略，而不是等到收敛了才调整策略的话，就能很快的减少迭代次数，这样我们状态价值的更新方法也会不太一样，也能更快的收敛\n$$ v_{k+1}(s)=\\max_{a \\in A} \\left(R_{s}^{a}+\\gamma \\sum_{s' \\in S} P_{s s^{\\prime}}^{a} v_{\\pi}\\left(s^{\\prime}\\right)\\right) $$\r异步动态规划算法 在前几节我们讲的都是同步动态规划算法，即每轮迭代我会计算出所有的状态价值并保存起来，在下一轮中，我们使用这些保存起来的状态价值来计算新一轮的状态价值。 另一种动态规划求解是异步动态规划算法，在这些算法里，每一次迭代并不对所有状态的价值进行更新，而是依据一定的原则有选择性的更新部分状态的价值，这类算法有自己的一些独特优势，当然有额会有一些额外的代价。 常见的异步动态规划算法有三种： 第一种是原位动态规划 (in-place dynamic programming)， 此时我们不会另外保存一份上一轮计算出的状态价值。而是即时计算即时更新。这样可以减少保存的状态价值的数量，节约内存。代价是收敛速度可能稍慢。 第二种是优先级动态规划 (prioritised sweeping)：该算法对每一个状态进行优先级分级，优先级越高的状态其状态价值优先得到更新。通常使用贝尔曼误差来评估状态的优先级，贝尔曼误差即新状态价值与前次计算得到的状态价值差的绝对值。这样可以加快收敛速度，代价是需要维护一个优先级队列。 第三种是实时动态规划 (real-time dynamic programming)：实时动态规划直接使用个体与环境交互产生的实际经历来更新状态价值，对于那些个体实际经历过的状态进行价值更新。这样个体经常访问过的状态将得到较高频次的价值更新，而与个体关系不密切、个体较少访问到的状态其价值得到更新的机会就较少。收敛速度可能稍慢。\nSUMMARY 动态规划是我们讲到的第一个系统求解强化学习预测和控制问题的方法。它的算法思路比较简单，主要就是利用贝尔曼方程来迭代更新状态价值，用贪婪法之类的方法迭代更新最优策略。\n动态规划的缺点：实际上是一种遍历的方式\n动态规划算法使用全宽度（full-width）的回溯机制来进行状态价值的更新，也就是说，无论是同步还是异步动态规划，在每一次回溯更新某一个状态的价值时，都要回溯到该状态的所有可能的后续状态，并利用贝尔曼方程更新该状态的价值。这种全宽度的价值更新方式对于状态数较少的强化学习问题还是比较有效的，但是当问题规模很大的时候，动态规划算法将会因贝尔曼维度灾难而无法使用。因此我们还需要寻找其他的针对复杂问题的强化学习问题求解方法。\nChapter 4 用蒙特卡罗法求解 强化学习（四）用蒙特卡罗法（MC）求解 ❓ 由 1. DP方法的全回溯机制（完全遍历）带来的过度的计算复杂度，对于复杂问题的求解困难 2. 很多时候对于状态转化模型P的未知\nDP中问题预测和控制问题的定义是在P已知的情况下定义的，这种称之为：基于模型的强化学习问题 而一般性预测和控制，也就是在状态转化概率矩阵P未知的情况下求解1. 状态价值函数 和2. 1+最优策略的问题 我们需要考虑其他的方法，而不能使用DP方法来求解这样的RL问题——Monto-Calo是一种可行的方法\n已知条件：状态集S, 动作集A, 即时奖励R，衰减因子γ，探索率ε\nMonto-Calo 求解 基于采样的思路：蒙特卡罗法通过采样若干经历完整的状态序列(episode)来估计状态的真实价值。\n经历完整就是这个序列必须是达到终点的。比如下棋问题分出输赢，驾车问题成功到达终点或者失败。 有了很多组这样经历完整的状态序列，我们就可以来近似的估计状态价值，进而求解预测和控制问题了。\n关键公式回顾：\n$$ v_\\pi(s) = \\mathbb{E}(R_{t+1} + \\gamma R_{t+2} + \\gamma ^2 R_{t+3} + ... |S_t = s) $$\rMC求解预测问题（策略评估） 思路：求解某个s的状态价值：对所有采样到的状态序列中，出现该状态之后的收获再取平均值来近似求解。\n$$ G_t = R_{t+1} + \\gamma R_{t+1} + ...+ \\gamma ^{T-t+1}R_T \\\\\rV_\\pi (s) \\approx average(G_t), s.t. S_t = s $$\r一个状态在一个状态序列中多次出现的处理\n主要有两种解决方式：\nFirst Visit： 只统计第一次出现的来进行均值的计算 Every Visit：每一次出现都加入均值的计算，这种方式更适合样本量少的情况，但是计算量要更大一些。 累进更新平均值（Incremental mean）\n如果我们将每个状态序列的值都记录下来在最后进行更新的话，会耗费大量的存储空间，所以我们使用累计更新均值的方法来进行不同轮次之间的迭代。\n换言之：统计当前的均值和状态遍历到的次数。\n$$ \\mu_k = \\frac{1}{k} \\sum_{j=1}^{k}x_j = \\frac{1}{k}(x_k+\\sum_{j=1}^{k-1}x_j) = \\frac{1}{k}(x_k+(k-1)\\mu_{k-1}) = \\mu_{k-1} + \\frac{1}{k}(x_k-\\mu_{k-1}) $$\r然后我们就可以将状态价值公式的更新过程修改成：\n$$ N(S_t) = N(S_t)+1\\\\\rV(S_t) = V(S_t) + \\frac{1}{N(S_t)}(G_t-V(S_t)) $$\r这种情况下的存储空间（内存消耗）就是固定的了。\n对海量数据做分布式迭代的时候 $N(S_t)$ 计算不确定的情况\n$$ V(S_t) = V(S_t) + \\alpha(G_t-V(S_t)) $$\r动作价值函数也是类似的方法。\nMC求解控制问题（策略迭代） 和策略迭代的方式也是类似的，也是先做策略评估，然后通过一定的方法（比如贪婪策略）更新策略。\n和DP相比的不同有如下几点： 策略评估的方法不同 MC优化最优动作价值函数而不是状态价值函数 DP一般使用贪婪法，MC使用 $\\epsilon$ -贪婪法 $\\epsilon$ -贪婪法：\n一般设置一个较小的值，然后用1- $\\epsilon$ 来选择最大行为价值的行为，然后剩下的就随机在m个可行行为中随机选择\n$$ \\pi(a \\mid s)=\\left\\{\\begin{array}{ll}\\epsilon / m+1-\\epsilon \u0026 \\text { if } a^{*}=\\arg \\max _{a \\in A} Q(s, a) \\\\\\epsilon / m \u0026 \\text { else }\\end{array}\\right. $$\r为了使得算法收敛； $\\epsilon$ 会逐渐减小，并趋于0。\n这样会得到一个和动态规划类似的图\n具体的算法流程：\n在这里总结下蒙特卡罗法求解强化学习控制问题的算法流程，这里的算法是在线(on-policy)版本的,相对的算法还有离线(off-policy)版本的。在线和离线的区别我们在后续的文章里面会讲。同时这里我们用的是every-visit,即个状态序列中每次出现的相同状态，都会计算对应的收获值。\n输入：状态集S, 动作集A, 即时奖励R，衰减因子γ, 探索率ϵ　输出：最优的动作价值函数q∗和最优策略π∗　初始化所有的动作价值Q(s,a)=0， 状态次数N(s,a)=0，采样次数k=0，随机初始化一个策略π　k=k+1, 基于策略π进行第k次蒙特卡罗采样，得到一个完整的状态序列:S1,A1,R2,S2,A2,…St,At,Rt+1,…RT,ST\n对于该状态序列里出现的每一状态行为对(St,At)，计算其收获Gt, 更新其计数N(s,a)和行为价值函数Q(s,a)：\n$$ G_t = R_{t+1} + \\gamma R_{t+1} + ...+ \\gamma ^{T-t+1}R_T \\\\N(S_t,A_t) = N(S_t,A_t)+1\\\\\rQ(S_t,A_t) = Q(S_t,A_t) + \\frac{1}{N(S_t,A_t)}(G_t-Q(S_t,A_t)) $$\r基于新计算出的动作价值，更新当前的ϵ−贪婪策略： $$ \\epsilon = \\frac{1}{k}\\\\\\pi(a \\mid s)=\\left\\{\\begin{array}{ll}\\epsilon / m+1-\\epsilon \u0026 \\text { if } a^{*}=\\arg \\max _{a \\in A} Q(s, a) \\\\\\epsilon / m \u0026 \\text { else }\\end{array}\\right. $$\r如果所有的Q(s,a)收敛，则对应的所有Q(s,a)即为最优的动作价值函数q∗。对应的策略π(a|s)即为最优策略π∗。否则转到第二步。 SUMMARY:实际上MC方法就是一个简单的采样渐进求平均的方法，在不断的迭代过程中找到相应的槿近似值。\nChapter5 用时序差分法（TD）求解 强化学习（五）用时序差分法（TD）求解 蒙特卡洛法虽然灵活，不需要环境转化概率模型，但是也有限制：所有的采样序列都需要是完整的状态序列，如果没有完整的状态序列，就不能使用Monto-Calo了。\n在不完整的状态序列的情况下，可以使用时序差分算法（Temporal-Difference，TD），这也是一种不基于模型的算法（也就是没有环境转移的情况下）\n关键公式回顾：\n$$ 蒙特卡洛：G_t = R_{t+1} + \\gamma R_{t+1} + ...+ \\gamma ^{T-t+1}R_T \\\\\r贝尔曼（TD）：v_{\\pi}(s) = =\\mathbb{E}{\\pi}\\left(R_{t+1}+\\gamma v_{\\pi}\\left(S_{t+1}\\right) \\mid S_{t}=s\\right) $$\n由于如果使用G的公式的话，我们需要有T时刻的R来进行计算分析， 为了简化这个过程，我们使用贝尔曼的递推式来进行时序差分的分析（实际上是同个等式）\n也就是：\n使用 $R_{t+1} + \\gamma v(S_{t+1})$ （也称为TD目标值） 来代替收获 $G_t$ ，同时令 $R_{t+1} + \\gamma v(S_{t+1}) - V(S_t)$ 称为TD误差，用TD目标值来代替收获G的过程称为引导。这样的话我们只需要两个连续的状态和对应的奖励，就可以尝试求解强化学习的问题了。\nTD预测问题求解 预测问题的求解思路大体上是类似的，但是和MC有两个主要的不同点:\n一个是 $G_t$ 收获的表达式不同\n$$ G(t) = R_{t+1} + \\gamma v(S_{t+1}) $$\r二是迭代的系数稍微有些不同，因为没有完整的序列，所以就没有对应的次数N，所以就用一个[0,1]的系数来代替\n$$ V\\left(S_{t}\\right)=V\\left(S_{t}\\right)+\\alpha\\left(G_{t}-V\\left(S_{t}\\right)\\right) $$\r具体的例子请参考相应的链接，这里写的特别的清楚！GO TO URL\n从例子中我们可以看到MC和TD主要的几点区别：\n时序差分法在知道结果之前就可以学习，也可以在没有结果时学习，还可以在持续进行的环境中学习，而蒙特卡罗法则要等到最后结果才能学习，时序差分法可以更快速灵活的更新状态的价值估计，这在某些情况下有着非常重要的实际意义。‘ 时序差分法在更新状态价值时使用的是TD 目标值，即基于即时奖励和下一状态的预估价值来替代当前状态在状态序列结束时可能得到的收获，是当前状态价值的有偏估计，而蒙特卡罗法则使用实际的收获来更新状态价值，是某一策略下状态价值的无偏估计，这一点蒙特卡罗法占优。 虽然时序差分法得到的价值是有偏估计，但是其方差却比蒙特卡罗法得到的方差要低，且对初始值敏感，通常比蒙特卡罗法更加高效。 所以后续的主流的强化学习方法都是基于时序差分的，后面的文章也会主要基于时序差分来拓展讨论。\nSUMMARY: 实际上TD和对应的DP最大的区别就在于G(t)的计算，从这里可以体现出DP主要依靠的是当前值再所有出现的序列中的状态值的平均，而TD可以依靠其他变量进行递推的这点优势。\nn步时序差分 前面我们的递推式只考虑了一步差分来进行近似，但是实际上我们可以将差分式子变形，变成二次差分项\n$$ G_t^{(2)} = R_{t+1} + \\gamma R_{t+2} + \\gamma^2 V(S_{t+1}) $$\r也可以一次类推到n步的差分项，当n趋于无穷的时候，实际上就等价于MC方法了。\nTD（ $\\lambda$ ） n步时序差分选择多少步数是一个超参数调优的过程，为了再不增加计算复杂度的时候综合考虑所有步数的预测，引入一个新的[0,1]的参数λ，定义λ-收获是n从1到∞所有步的收获*权重的和，每一步的权重带有一定的比例，如下：\n$$ G_t^\\lambda = (1-\\lambda)\\sum_{n=1}^\\infin \\lambda^{n-1}G_t^{(n)} $$\r因此我们就能得到TD（λ）的迭代公式：Q也是类似的，就不重新写一次了\n$$ V(S_t) = V(S_t)+\\alpha(G_t^\\lambda - V(S_t)) $$\r权重衰减的原因如下，随着n增大，权重成集合级数衰减，在T时刻把所有剩余的权重给最终状态，这样可以使得权重嘉禾为1，里当前越远权重越小。\n从前向来看TD(λ)， 一个状态的价值V(St)由Gt得到，而Gt又间接由所有后续状态价值计算得到，因此可以认为更新一个状态的价值需要知道所有后续状态的价值。也就是说，必须要经历完整的状态序列获得包括终止状态的每一个状态的即时奖励才能更新当前状态的价值。这和蒙特卡罗法的要求一样，因此TD(λ)有着和蒙特卡罗法一样的劣势。当λ=0 时,就是第二节讲到的普通的时序差分法，当λ=1 时,就是蒙特卡罗法。\n从反向来看TD(λ)，它可以分析我们状态对后续状态的影响。比如老鼠在依次连续接受了3 次响铃和1 次亮灯信号后遭到了电击，那么在分析遭电击的原因时，到底是响铃的因素较重要还是亮灯的因素更重要呢？如果把老鼠遭到电击的原因认为是之前接受了较多次数的响铃，则称这种归因为频率启发(frequency heuristic) 式；而把电击归因于最近少数几次状态的影响，则称为就近启发(recency heuristic) 式。\n如果给每一个状态引入一个数值：效用(eligibility, E) 来表示该状态对后续状态的影响，就可以同时利用到上述两个启发。而所有状态的效用值总称为效用迹(eligibility traces,ES)。定义为：\n$$ \\begin{gathered}E_{0}(s)=0 \\\\E_{t}(s)=\\gamma \\lambda E_{t-1}(s)+1\\left(S_{t}=s\\right)=\\left\\{\\begin{array}{ll}0 \u0026 t","wordCount":"748","inLanguage":"en","image":"https://aikenh.cn/cover/cover15.jpeg","datePublished":"2021-05-23T13:50:06Z","dateModified":"2021-05-23T13:50:06Z","author":[{"@type":"Person","name":"aikenhong"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://aikenh.cn/hugotest/posts/rl-c1/"},"publisher":{"@type":"Organization","name":"aiken's blog","logo":{"@type":"ImageObject","url":"https://aikenh.cn/favicon/ghost.ico"}}}</script></head><body id=top><script type=module src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.esm.js defer></script><script nomodule src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.js defer></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aikenh.cn/hugotest/ accesskey=h title="aiken's blog (Alt + H)">aiken's blog</a><div class=logo-switches><button id=theme-toggle-nav accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aikenh.cn/hugotest/ title=home><span>home</span></a></li><li><a href=https://aikenh.cn/hugotest/posts/ title=posts><span>posts</span></a></li><li><a href=https://aikenh.cn/hugotest/tags/ title=tags><span>tags</span></a></li><li><a href=https://aikenh.cn/hugotest/categories/ title=categories><span>categories</span></a></li><li><a href=https://aikenh.cn/hugotest/archives/ title=archives><span>archives</span></a></li><li><a href=https://aikenh.cn/hugotest/about/ title=about><span>about</span></a></li><li><a href=https://aikenh.cn/hugotest/search title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><div class=sidebar><ul><li class=logo style=--bg:#333><a href=#><div class=logo-icon><img src=/logo/logo.png></div><div class=logo-text>Aiken's Blog</div></a></li><div class=menulist><li style=--bg:#f44336><a href=https://aikenh.cn/hugotest/ title=home><div class=logo-icon><ion-icon name=home-outline></ion-icon></div><div class=logo-text>home</div></a></li><li style=--bg:#b145e9><a href=https://aikenh.cn/hugotest/posts/ title=posts><div class=logo-icon><ion-icon name=newspaper-outline></ion-icon></div><div class=logo-text>posts</div></a></li><li style=--bg:#0f93c7><a href=https://aikenh.cn/hugotest/tags/ title=tags><div class=logo-icon><ion-icon name=pricetags-outline></ion-icon></div><div class=logo-text>tags</div></a></li><li style=--bg:#ffa117><a href=https://aikenh.cn/hugotest/categories/ title=categories><div class=logo-icon><ion-icon name=grid-outline></ion-icon></div><div class=logo-text>categories</div></a></li><li style=--bg:#0fc70f><a href=https://aikenh.cn/hugotest/archives/ title=archives><div class=logo-icon><ion-icon name=folder-outline></ion-icon></div><div class=logo-text>archives</div></a></li><li style=--bg:#d16111><a href=https://aikenh.cn/hugotest/about/ title=about><div class=logo-icon><ion-icon name=person></ion-icon></div><div class=logo-text>about</div></a></li><li style=--bg:#15c095><a href=https://aikenh.cn/hugotest/search title="search (Alt + /)" accesskey=/><div class=logo-icon><ion-icon name=search></ion-icon></div><div class=logo-text>search</div></a></li></div><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt +T)"><li><div class=logo-icon id=moon><ion-icon name=moon-outline></ion-icon></div><div class=logo-icon id=sun><ion-icon name=sunny-outline></ion-icon></div></li></button></div></ul></div><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aikenh.cn/hugotest/>Home</a>&nbsp;»&nbsp;<a href=https://aikenh.cn/hugotest/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">RL Notebook 01</h1><div class=post-meta><span title='2021-05-23 13:50:06 +0000 UTC'>May 23, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;748 words&nbsp;·&nbsp;aikenhong&nbsp;·&nbsp;<a href=/tags/reinforcement-learning> Reinforcement learning</a>&nbsp;·&nbsp;<a href=/tags/machine-learning> Machine Learning</a>&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/RL-C1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://aikenh.cn/cover/cover15.jpeg alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#chapter1-%e6%a8%a1%e5%9e%8b%e5%9f%ba%e7%a1%80 aria-label="Chapter1 模型基础">Chapter1 模型基础</a><ul class=header-level-1><li><a href=#theory%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%80 aria-label=Theory理论基础>Theory理论基础</a></li></ul></li><li><a href=#chapter2-%e9%a9%ac%e5%b0%94%e5%8f%af%e5%a4%ab%e5%86%b3%e7%ad%96%e8%bf%87%e7%a8%8bmdp aria-label="Chapter2 马尔可夫决策过程（MDP）">Chapter2 马尔可夫决策过程（MDP）</a><ul class=header-level-1><li><a href=#%e9%a9%ac%e5%b0%94%e5%8f%af%e5%a4%ab%e6%80%a7%e7%ae%80%e5%8c%96 aria-label=马尔可夫性简化>马尔可夫性简化</a></li><li><a href=#mdp%e7%9a%84%e4%bb%b7%e5%80%bc%e5%87%bd%e6%95%b0%e5%92%8c%e8%b4%9d%e5%b0%94%e6%9b%bc%e6%96%b9%e7%a8%8b aria-label=MDP的价值函数和贝尔曼方程>MDP的价值函数和贝尔曼方程</a></li><li><a href=#%e7%8a%b6%e6%80%81%e4%bb%b7%e5%80%bc%e5%87%bd%e6%95%b0%e5%92%8c%e5%8a%a8%e4%bd%9c%e4%bb%b7%e5%80%bc%e5%87%bd%e6%95%b0%e7%9a%84%e9%80%92%e6%8e%a8%e5%85%b3%e7%b3%bb aria-label=状态价值函数和动作价值函数的递推关系>状态价值函数和动作价值函数的递推关系</a></li><li><a href=#%e6%9c%80%e4%bc%98%e4%bb%b7%e5%80%bc%e5%87%bd%e6%95%b0 aria-label=最优价值函数>最优价值函数</a></li></ul></li><li><a href=#chapter3-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92dp%e6%b1%82%e8%a7%a3 aria-label="Chapter3 动态规划（DP）求解">Chapter3 动态规划（DP）求解</a><ul class=header-level-1><li><a href=#%e7%ad%96%e7%95%a5%e8%af%84%e4%bc%b0%e6%b1%82%e8%a7%a3%e9%a2%84%e6%b5%8b%e9%97%ae%e9%a2%98 aria-label=策略评估求解预测问题>策略评估求解预测问题</a></li><li><a href=#%e7%ad%96%e7%95%a5%e8%bf%ad%e4%bb%a3%e6%b1%82%e8%a7%a3%e6%8e%a7%e5%88%b6%e9%97%ae%e9%a2%98 aria-label=策略迭代求解控制问题>策略迭代求解控制问题</a></li><li><a href=#%e4%bb%b7%e5%80%bc%e8%bf%ad%e4%bb%a3%e6%b1%82%e8%a7%a3%e6%8e%a7%e5%88%b6%e9%97%ae%e9%a2%98 aria-label=价值迭代求解控制问题>价值迭代求解控制问题</a></li><li><a href=#%e5%bc%82%e6%ad%a5%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e7%ae%97%e6%b3%95 aria-label=异步动态规划算法>异步动态规划算法</a></li></ul></li><li><a href=#chapter-4-%e7%94%a8%e8%92%99%e7%89%b9%e5%8d%a1%e7%bd%97%e6%b3%95%e6%b1%82%e8%a7%a3 aria-label="Chapter 4 用蒙特卡罗法求解">Chapter 4 用蒙特卡罗法求解</a><ul class=header-level-1><li><a href=#monto-calo-%e6%b1%82%e8%a7%a3 aria-label="Monto-Calo 求解">Monto-Calo 求解</a></li><li><a href=#mc%e6%b1%82%e8%a7%a3%e9%a2%84%e6%b5%8b%e9%97%ae%e9%a2%98%e7%ad%96%e7%95%a5%e8%af%84%e4%bc%b0 aria-label=MC求解预测问题（策略评估）>MC求解预测问题（策略评估）</a></li><li><a href=#mc%e6%b1%82%e8%a7%a3%e6%8e%a7%e5%88%b6%e9%97%ae%e9%a2%98%e7%ad%96%e7%95%a5%e8%bf%ad%e4%bb%a3 aria-label=MC求解控制问题（策略迭代）>MC求解控制问题（策略迭代）</a></li></ul></li><li><a href=#chapter5-%e7%94%a8%e6%97%b6%e5%ba%8f%e5%b7%ae%e5%88%86%e6%b3%95td%e6%b1%82%e8%a7%a3 aria-label="Chapter5 用时序差分法（TD）求解">Chapter5 用时序差分法（TD）求解</a><ul class=header-level-1><li><a href=#td%e9%a2%84%e6%b5%8b%e9%97%ae%e9%a2%98%e6%b1%82%e8%a7%a3 aria-label=TD预测问题求解>TD预测问题求解</a></li><li><a href=#n%e6%ad%a5%e6%97%b6%e5%ba%8f%e5%b7%ae%e5%88%86 aria-label=n步时序差分>n步时序差分</a></li><li><a href=#td-lambda- aria-label="TD（ $\lambda$ ）">TD（ $\lambda$ ）</a></li><li><a href=#td%e6%8e%a7%e5%88%b6%e9%97%ae%e9%a2%98%e6%b1%82%e8%a7%a3 aria-label=TD控制问题求解>TD控制问题求解</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase(),n=document.querySelector(`.inner ul li a[href="#${t}"]`);n.classList.remove("read")}),activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach((t)=>{const o=encodeURI(t.getAttribute("id")).toLowerCase(),s=document.querySelector(`.inner ul li a[href="#${o}"]`);if(t===activeElement){s.classList.add("active");const e=document.querySelector(".toc .inner"),t=s.offsetTop,n=e.clientHeight,o=s.clientHeight,i=t-n/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else getOffsetTop(t)<e&&s.classList.add("read"),s.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return!document.querySelector(".hugo-encryptor-prompt")&&elements.length!=0&&(elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),console.log("Elements re-queried:",elements)),0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Created by: Aiken H
Detail: survey
Finished?: No
Tags: Paper
URL1: <a href=https://www.cnblogs.com/pinard/category/1254674.html target=_blank rel=noopener>https://www.cnblogs.com/pinard/category/1254674.html</a>
URL2: <a href=https://github.com/ljpzzz/machinelearning target=_blank rel=noopener>https://github.com/ljpzzz/machinelearning</a>
URL3: <a href=https://datawhalechina.github.io/easy-rl/#/ target=_blank rel=noopener>https://datawhalechina.github.io/easy-rl/#/</a></p><h1 id=chapter1-模型基础>Chapter1 模型基础<a hidden class=anchor aria-hidden=true href=#chapter1-模型基础>#</a></h1><p><a href=https://www.cnblogs.com/pinard/p/9385570.html target=_blank rel=noopener>强化学习（一）模型基础</a></p><p>强化学习是介于监督和无监督学习之间的，强化学习没有输出值，但是有<strong>reward：</strong> 同时这个reward是事后给出的，而不是及时回馈的。而无监督学习是只有数据特征，同时数据之间是独立的，没有前后依赖的关系。</p><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911210000.png><img alt=https://images2018.cnblogs.com/blog/1042406/201807/1042406-20180729163058011-290427357.png loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911210000.png class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911210000.png style="display:block;margin:0 auto" alt=https://images2018.cnblogs.com/blog/1042406/201807/1042406-20180729163058011-290427357.png></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><h2 id=theory理论基础>Theory理论基础<a hidden class=anchor aria-hidden=true href=#theory理论基础>#</a></h2><ul><li><p>简化模型介绍：</p><p>上面的大脑代表我们的算法执行个体，我们可以操作个体来做决策，即选择一个合适的动作（Action）At。下面的地球代表我们要研究的环境,它有自己的状态模型，我们选择了动作At后，环境的状态(State)会变，我们会发现环境状态已经变为St+1,同时我们得到了我们采取动作At的延时奖励(Reward)Rt+1。然后个体可以继续选择下一个合适的动作，然后环境的状态又会变，又有新的奖励值。。。这就是强化学习的思路。</p></li></ul><p>强化学习的模型关键要素：</p><ol><li>环境的状态S：t时刻环境的状态 $S_t$ 是它环境状态集中的某一个状态</li><li>个体的动作A：个体在某个时刻可能做出的动作集合</li><li>环境的奖励R：个体在某个时刻对应状态下做出的动作 $A_t$ 得到的奖励会在t+1时刻得到</li><li>个体的策略 $\pi$ ：个体根据当前的环境选择采取动作的策略分布（函数），一般表示为一个条件概率分布的形式，概率大的动作被个体选择的概率显然更高</li></ol><div>$$ \pi(a|s)= P(A_t = a | S_t = s) $$</div><ol start=5><li>在策略 $\pi$ 和状态s采行动后的价值 $v_\pi(s)$ ：一般是一个期望函数，因为我们不能每次只能选择当前的reward最大的策略，而是需要考虑大局，所以我们要有一个综合的（当前和后续）的延时奖励。</li></ol><div>$$ v_\pi(s) = \mathbb{E}(R_{t+1} + \gamma R_{t+2} + \gamma ^2 R_{t+3} + ... |S_t = s) $$</div><ol start=6><li>奖励衰减因子 $\gamma$ ：也就是上式的权重，极端值考虑贪婪和一致等同，范围在[0,1]</li><li>环境的状态转移模型：也就是环境从s经过a后转化下一个状态的状态机，也可以表示为一个概率模型 $P_{ss^‘}^a$ (s→s&rsquo; , a)</li><li>探索率 $\epsilon$ ：主要用于训练迭代中，我们一般选择当前价值最大的动作，但是为了搜索空间的完备，我们会用 $\epsilon$ 的概率去选择非最大价值的动作，来提升训练的鲁棒性</li></ol><p><strong>SUMMARY：主要介绍了强化学习模型的workflow以及其中需要考虑的8个主要参数和函数架构。最主要的机制还是Policy和reward设计这一块</strong></p><h1 id=chapter2-马尔可夫决策过程mdp>Chapter2 马尔可夫决策过程（MDP）<a hidden class=anchor aria-hidden=true href=#chapter2-马尔可夫决策过程mdp>#</a></h1><p><a href=https://www.cnblogs.com/pinard/p/9426283.html target=_blank rel=noopener>强化学习（二）马尔科夫决策过程(MDP)</a></p><p><a href=https://datawhalechina.github.io/easy-rl/#/chapter2/chapter2 target=_blank rel=noopener>Easy-RL</a></p><p>在这里可能需要补充一下马尔可夫链的相关理论知识，先粗略的看完这部分再说</p><h2 id=马尔可夫性简化>马尔可夫性简化<a hidden class=anchor aria-hidden=true href=#马尔可夫性简化>#</a></h2><p>环境的真实转化状态可能和之前的多个时刻相关，这样会导致建模困难，于是我们对环境的状态转移模型进行马尔可夫性假设。也就是：</p><p>转化到下一个状态s&rsquo;只和当前的状态s相关，与之前的状态无关</p><p>同样的我们对Policy、价值函数也做了同样的马尔可夫性假设来简化。</p><p>其中： $G_t$ 代表收获（return），是从某一个状态开始采样直到终止状态时所有奖励的有衰减的和。</p><div>$$ 1.\ P_{ss'}^a = \mathbb{E}(S_{t+1} = s'|S_t=s,A_t=a) $$</div><div>$$ 2. \ \pi(a|s) = P(A_t = a | S_t = s) $$</div><div>$$ 3. \ v_\pi(s) =\mathbb{E}_\pi(G_t|S_t =s) = \mathbb{E}(R_{t+1} + \gamma R_{t+2} + \gamma ^2 R_{t+3} + ... |S_t = s) $$</div><p><strong>SUMMARY：由于环境的复杂时序关系，我们需要进行相应的马尔可夫性的假设，让下一个时刻的状态或者预测值只和当前时刻有关，从而简化并假设出模型</strong></p><h2 id=mdp的价值函数和贝尔曼方程>MDP的价值函数和贝尔曼方程<a hidden class=anchor aria-hidden=true href=#mdp的价值函数和贝尔曼方程>#</a></h2><p>在上述价值表达式的基础上，加入考虑动作a带来的价值影响，我们就可以得到下面的动作价值函数：</p><div>$$ q_{\pi}(s, a)=\mathbb{E}_{\pi}\left(G_{t} \mid S_{t}=s, A_{t}=a\right)=\mathbb{E}_{\pi}\left(R_{t+1}+\gamma R_{t+2}+\gamma^{2} R_{t+3}+\ldots \mid S_{t}=s, A_{t}=a\right) $$</div><p>我们可以通过价值函数的公式得到价值函数的递推关系（贝尔曼方程）：</p><div>$$ \begin{aligned}
v_{\pi}(s) &=\mathbb{E}{\pi}\left(R{t+1}+\gamma R_{t+2}+\gamma^{2} R_{t+3}+\ldots \mid S_{t}=s\right) \\
&=\mathbb{E}{\pi}\left(R{t+1}+\gamma\left(R_{t+2}+\gamma R_{t+3}+\ldots\right) \mid S_{t}=s\right) \\
&=\mathbb{E}{\pi}\left(R{t+1}+\gamma G_{t+1} \mid S_{t}=s\right) \\
&=\mathbb{E}{\pi}\left(R{t+1}+\gamma v_{\pi}\left(S_{t+1}\right) \mid S_{t}=s\right)
\end{aligned} $$</div><p>一个状态的价值由该状态的奖励以及后续状态价值按照一定衰减比例联合而成，同样的有：</p><div>$$ q_{\pi}(s, a)=\mathbb{E}_{\pi}\left(R_{t+1}+\gamma q_{\pi}\left(S_{t+1}, A_{t+1}\right) \mid S_{t}=s, A_{t}=a\right) $$</div><p>SUMMARY：基于马尔可夫假设之后，我们可以将价值函数（动作、状态）表示一个递推的形式，这个递推的形式也被叫做贝尔曼方程。</p><h2 id=状态价值函数和动作价值函数的递推关系>状态价值函数和动作价值函数的递推关系<a hidden class=anchor aria-hidden=true href=#状态价值函数和动作价值函数的递推关系>#</a></h2><p>基于状态价值函数的定义以及动作价值函数的定义，我们很容易得到两个价值函数之间的转化关系：</p><p>状态价值函数是动作价值函数对于所有可能动作对于policy的期望。</p><p>利用贝尔曼方程，我们也能反推得状态价值函数来表示动作价值函数：</p><p>当前的reward和可能转移到所有后续状态的价值函数的加权和</p><div>$$ v_\pi(s) = \sum_{a\in A} \pi({a|s}) q_\pi(s,a) $$</div><div>$$ q_\pi(s,a) = R_s^a + \gamma \sum _ {s'\in S} P_{ss'}^a v_\pi(s') $$</div><p>将上述两个式子互相结合起来，我们可以得到如下的简化（变量）算式（只包含一种价值函数）</p><div>$$ \begin{gathered}v_{\pi}(s)=\sum_{a \in A} \pi(a \mid s)\left(R_{s}^{a}+\gamma \sum_{J \in S} P_{s s^{\prime}}^{a} v_{\pi}\left(s^{\prime}\right)\right) \\q_{\pi}(s, a)=R_{s}^{a}+\gamma \sum_{s^{\prime} \in S} P_{s s^{\prime}}^{a} \sum_{a^{\prime} \in A} \pi\left(a^{\prime} \mid s^{\prime}\right) q_{\pi}\left(s^{\prime}, a^{\prime}\right)\end{gathered} $$</div><h2 id=最优价值函数>最优价值函数<a hidden class=anchor aria-hidden=true href=#最优价值函数>#</a></h2><p>这一部分看原文，结合相应的例子一起看，后续可能需要看EasyRL中的markov的相关解读来进行深入的理解和计算的分析。</p><p>解决一个强化学习的问题意味着要找一个最有的policy（策略），让Argent在和环境交互的过程中获得比其他所有策略都更多的收获，找到这个策略，也就意味着我们解决了这样一个强化学习的问题。</p><p>求解最优策略→ 求解最优的价值函数，使得（动作、状态）价值函数获取到最大值的策略就是最优策略。</p><p>对于最优策略我们将动作函数定义为：</p><div>$$ \pi_{*}(a \mid s)=\left\{\begin{array}{ll}1 & \text { if } a=\arg \max _{a \in A} q_{*}(s, a) \\0 & \text { else }\end{array}\right. $$</div><p>有：</p><div>$$ v_*(s) = \max_a q_*(s,a)\\q_{*}(s, a)=R_{s}^{a}+\gamma \sum_{s^{\prime} \in S} P_{s s}^{a} v_{*}\left(s^{\prime}\right) $$</div><p>这样我们就可以最终得到：</p><div>$$ \begin{gathered}v_{*}(s)=\max _{a}\left(R_{s}^{a}+\gamma \sum_{g^{\prime} \in S} P_{s s^{\prime}}^{a} v_{*}\left(s^{\prime}\right)\right) \\q_{*}(s, a)=R_{s}^{a}+\gamma \sum_{s^{\prime} \in S} P_{s s^{\prime}}^{a} \max _{a^{\prime}} q_{*}\left(s^{\prime}, a^{\prime}\right)\end{gathered} $$</div><h1 id=chapter3-动态规划dp求解>Chapter3 动态规划（DP）求解<a hidden class=anchor aria-hidden=true href=#chapter3-动态规划dp求解>#</a></h1><p><a href=https://www.cnblogs.com/pinard/p/9463815.html target=_blank rel=noopener>强化学习（三）用动态规划（DP）求解</a></p><ul><li><p>用动态规划来求解强化学习是自然的</p><p><strong>关键的两点</strong>：</p><ul><li>问题的最优解可以由递归的最优解来得到</li><li>子问题状态间的转移</li></ul><p>从上面推出的贝尔曼方程，这个递推公式实际上就是DP求解的状态转移等式，然后相应的Value什么的也和DP求解过程的需求是一一对应的。</p></li><li><p>关键的方程，通过这种递推公式，我们可以通过上一个迭代周期的状态价值去计算当前迭代周期状态S的状态价值，这也就是动态规划的一个求解的自然过程。</p><p>基于贝克曼方程推导出来，推导过程已经在上面了</p></li></ul><div>$$ v_{\pi}(s)=\sum_{a \in A} \pi(a \mid s)\left(R_{s}^{a}+\gamma \sum_{J \in S} P_{s s^{\prime}}^{a} v_{\pi}\left(s^{\prime}\right)\right) $$</div><hr><p>已知条件：状态集S, 动作集A, 模型状态转化概率矩阵P, 即时奖励R，衰减因子γ, 给定策略π</p><h2 id=策略评估求解预测问题>策略评估求解预测问题<a hidden class=anchor aria-hidden=true href=#策略评估求解预测问题>#</a></h2><p>策略评估：求解给定策略的状态价值函数的问题，即强化学习的预测问题。</p><p>求解思路： 从任何一个状态价值函数开始，按照给定的策略，结合关键的贝尔曼递推期望方程，状态转移，reward，更新状态价值函数，直至最终收敛。</p><ul><li><p>具体而言：</p><p>假设第k轮我们已经计算出了所有的状态的状态价值，然后再k+1轮的时候利用k轮的值通过贝尔曼方程来进行更新。</p></li></ul><div>$$ v_{k+1}(s)=\sum_{a \in A} \pi(a \mid s)\left(R_{s}^{a}+\gamma \sum_{s' \in S} P_{s s^{\prime}}^{a} v_{\pi}\left(s^{\prime}\right)\right) $$</div><p>具体案例上面的网站中去看：（很容易理解）</p><h2 id=策略迭代求解控制问题>策略迭代求解控制问题<a hidden class=anchor aria-hidden=true href=#策略迭代求解控制问题>#</a></h2><p>控制问题：需要同时求解状态价值函数和策略</p><p>策略迭代：从一个初始任意的策略状态，不断地迭代，调整我们的策略，从而得到一个最优的策略。</p><p>求解思路：贪婪法</p><ul><li><p>具体而言：</p><p>个体在某个状态下选择的行为，是其能够达到后续所有可能的状态中，状态价值最大的那个状态，</p></li></ul><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911210046.jpg><img alt=https://images2018.cnblogs.com/blog/1042406/201808/1042406-20180812191537706-1156414836.jpg loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911210046.jpg class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210911210046.jpg style="display:block;margin:0 auto" alt=https://images2018.cnblogs.com/blog/1042406/201808/1042406-20180812191537706-1156414836.jpg></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>策略迭代过程的演示：逐步的迭代策略和相应的价值函数，最终使得两者同时收敛</p><h2 id=价值迭代求解控制问题>价值迭代求解控制问题<a hidden class=anchor aria-hidden=true href=#价值迭代求解控制问题>#</a></h2><p>和上述的策略迭代的问题一样，如果我们使用贪婪的策略去及时调整策略，而不是等到收敛了才调整策略的话，就能很快的减少迭代次数，这样我们状态价值的更新方法也会不太一样，也能更快的收敛</p><div>$$ v_{k+1}(s)=\max_{a \in A} \left(R_{s}^{a}+\gamma \sum_{s' \in S} P_{s s^{\prime}}^{a} v_{\pi}\left(s^{\prime}\right)\right) $$</div><h2 id=异步动态规划算法>异步动态规划算法<a hidden class=anchor aria-hidden=true href=#异步动态规划算法>#</a></h2><blockquote><p>在前几节我们讲的都是同步动态规划算法，即每轮迭代我会计算出所有的状态价值并保存起来，在下一轮中，我们使用这些保存起来的状态价值来计算新一轮的状态价值。
另一种动态规划求解是异步动态规划算法，在这些算法里，每一次迭代并不对所有状态的价值进行更新，而是依据一定的原则有选择性的更新部分状态的价值，这类算法有自己的一些独特优势，当然有额会有一些额外的代价。
常见的异步动态规划算法有三种：
第一种是原位动态规划 (in-place dynamic programming)， 此时我们不会另外保存一份上一轮计算出的状态价值。而是即时计算即时更新。这样可以减少保存的状态价值的数量，节约内存。代价是收敛速度可能稍慢。
第二种是优先级动态规划 (prioritised sweeping)：该算法对每一个状态进行优先级分级，优先级越高的状态其状态价值优先得到更新。通常使用贝尔曼误差来评估状态的优先级，贝尔曼误差即新状态价值与前次计算得到的状态价值差的绝对值。这样可以加快收敛速度，代价是需要维护一个优先级队列。
第三种是实时动态规划 (real-time dynamic programming)：实时动态规划直接使用个体与环境交互产生的实际经历来更新状态价值，对于那些个体实际经历过的状态进行价值更新。这样个体经常访问过的状态将得到较高频次的价值更新，而与个体关系不密切、个体较少访问到的状态其价值得到更新的机会就较少。收敛速度可能稍慢。</p></blockquote><p><strong>SUMMARY 动态规划是我们讲到的第一个系统求解强化学习预测和控制问题的方法。它的算法思路比较简单，主要就是利用贝尔曼方程来迭代更新状态价值，用贪婪法之类的方法迭代更新最优策略。</strong></p><ul><li><p>动态规划的缺点：实际上是一种遍历的方式</p><p>动态规划算法使用全宽度（full-width）的回溯机制来进行状态价值的更新，也就是说，无论是同步还是异步动态规划，在每一次回溯更新某一个状态的价值时，都要回溯到该状态的所有可能的后续状态，并利用贝尔曼方程更新该状态的价值。这种全宽度的价值更新方式对于状态数较少的强化学习问题还是比较有效的，但是当问题规模很大的时候，动态规划算法将会因贝尔曼维度灾难而无法使用。因此我们还需要寻找其他的针对复杂问题的强化学习问题求解方法。</p></li></ul><h1 id=chapter-4-用蒙特卡罗法求解>Chapter 4 用蒙特卡罗法求解<a hidden class=anchor aria-hidden=true href=#chapter-4-用蒙特卡罗法求解>#</a></h1><p><a href=https://www.cnblogs.com/pinard/p/9492980.html target=_blank rel=noopener>强化学习（四）用蒙特卡罗法（MC）求解</a></p><p>❓ 由 1. DP方法的全回溯机制（完全遍历）带来的过度的计算复杂度，对于复杂问题的求解困难
2. 很多时候对于状态转化模型P的未知</p><ul><li>DP中问题预测和控制问题的定义是在P已知的情况下定义的，这种称之为：基于模型的强化学习问题</li><li>而一般性预测和控制，也就是在状态转化概率矩阵P未知的情况下求解1. 状态价值函数 和2. 1+最优策略的问题</li></ul><p>我们需要考虑其他的方法，而不能使用DP方法来求解这样的RL问题——Monto-Calo是一种可行的方法</p><p>已知条件：状态集S, 动作集A, 即时奖励R，衰减因子γ，探索率ε</p><h2 id=monto-calo-求解>Monto-Calo 求解<a hidden class=anchor aria-hidden=true href=#monto-calo-求解>#</a></h2><p>基于采样的思路：蒙特卡罗法通过采样若干经历完整的状态序列(episode)来估计状态的真实价值。</p><p>经历完整就是这个序列必须是达到终点的。比如下棋问题分出输赢，驾车问题成功到达终点或者失败。
有了很多组这样经历完整的状态序列，我们就可以来近似的估计状态价值，进而求解预测和控制问题了。</p><p>关键公式回顾：</p><div>$$ v_\pi(s) = \mathbb{E}(R_{t+1} + \gamma R_{t+2} + \gamma ^2 R_{t+3} + ... |S_t = s) $$</div><h2 id=mc求解预测问题策略评估>MC求解预测问题（策略评估）<a hidden class=anchor aria-hidden=true href=#mc求解预测问题策略评估>#</a></h2><p>思路：求解某个s的状态价值：对所有采样到的状态序列中，出现该状态之后的收获再取平均值来近似求解。</p><div>$$ G_t = R_{t+1} + \gamma R_{t+1} + ...+ \gamma ^{T-t+1}R_T \\
V_\pi (s) \approx average(G_t), s.t. S_t = s $$</div><p><strong>一个状态在一个状态序列中多次出现的处理</strong></p><p>主要有两种解决方式：</p><ol><li>First Visit： 只统计第一次出现的来进行均值的计算</li><li>Every Visit：每一次出现都加入均值的计算，这种方式更适合样本量少的情况，但是计算量要更大一些。</li></ol><p><strong>累进更新平均值（Incremental mean）</strong></p><p>如果我们将每个状态序列的值都记录下来在最后进行更新的话，会耗费大量的存储空间，所以我们使用累计更新均值的方法来进行不同轮次之间的迭代。</p><p>换言之：统计当前的均值和状态遍历到的次数。</p><div>$$ \mu_k = \frac{1}{k} \sum_{j=1}^{k}x_j = \frac{1}{k}(x_k+\sum_{j=1}^{k-1}x_j) = \frac{1}{k}(x_k+(k-1)\mu_{k-1}) = \mu_{k-1} + \frac{1}{k}(x_k-\mu_{k-1}) $$</div><p>然后我们就可以将状态价值公式的更新过程修改成：</p><div>$$ N(S_t) = N(S_t)+1\\
V(S_t) = V(S_t) + \frac{1}{N(S_t)}(G_t-V(S_t)) $$</div><p>这种情况下的存储空间（内存消耗）就是固定的了。</p><p>对海量数据做分布式迭代的时候 $N(S_t)$ 计算不确定的情况</p><div>$$ V(S_t) = V(S_t) + \alpha(G_t-V(S_t)) $$</div><p>动作价值函数也是类似的方法。</p><h2 id=mc求解控制问题策略迭代>MC求解控制问题（策略迭代）<a hidden class=anchor aria-hidden=true href=#mc求解控制问题策略迭代>#</a></h2><p>和策略迭代的方式也是类似的，也是先做策略评估，然后通过一定的方法（比如贪婪策略）更新策略。</p><ul><li>和DP相比的不同有如下几点：<ol><li>策略评估的方法不同</li><li>MC优化最优动作价值函数而不是状态价值函数</li><li>DP一般使用贪婪法，MC使用 $\epsilon$ -贪婪法</li></ol></li></ul><p>$\epsilon$ -贪婪法：</p><p>一般设置一个较小的值，然后用1- $\epsilon$ 来选择最大行为价值的行为，然后剩下的就随机在m个可行行为中随机选择</p><div>$$ \pi(a \mid s)=\left\{\begin{array}{ll}\epsilon / m+1-\epsilon & \text { if } a^{*}=\arg \max _{a \in A} Q(s, a) \\\epsilon / m & \text { else }\end{array}\right. $$</div><p>为了使得算法收敛； $\epsilon$ 会逐渐减小，并趋于0。</p><p>这样会得到一个和动态规划类似的图</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180817164828651-1814136312.jpg><img alt=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180817164828651-1814136312.jpg loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180817164828651-1814136312.jpg class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180817164828651-1814136312.jpg style="display:block;margin:0 auto" alt=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180817164828651-1814136312.jpg></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p><strong>具体的算法流程：</strong></p><p>在这里总结下蒙特卡罗法求解强化学习控制问题的算法流程，这里的算法是在线(on-policy)版本的,相对的算法还有离线(off-policy)版本的。在线和离线的区别我们在后续的文章里面会讲。同时这里我们用的是every-visit,即个状态序列中每次出现的相同状态，都会计算对应的收获值。</p><p>输入：状态集S, 动作集A, 即时奖励R，衰减因子γ, 探索率ϵ　
输出：最优的动作价值函数q∗和最优策略π∗　</p><ol><li><p>初始化所有的动作价值Q(s,a)=0， 状态次数N(s,a)=0，采样次数k=0，随机初始化一个策略π　</p></li><li><p>k=k+1, 基于策略π进行第k次蒙特卡罗采样，得到一个完整的状态序列:S1,A1,R2,S2,A2,&mldr;St,At,Rt+1,&mldr;RT,ST</p></li><li><p>对于该状态序列里出现的每一状态行为对(St,At)，计算其收获Gt, 更新其计数N(s,a)和行为价值函数Q(s,a)：</p></li></ol><div>$$ G_t = R_{t+1} + \gamma R_{t+1} + ...+ \gamma ^{T-t+1}R_T \\N(S_t,A_t) = N(S_t,A_t)+1\\
Q(S_t,A_t) = Q(S_t,A_t) + \frac{1}{N(S_t,A_t)}(G_t-Q(S_t,A_t)) $$</div><ol start=4><li>基于新计算出的动作价值，更新当前的ϵ−贪婪策略：</li></ol><div>$$ \epsilon = \frac{1}{k}\\\pi(a \mid s)=\left\{\begin{array}{ll}\epsilon / m+1-\epsilon & \text { if } a^{*}=\arg \max _{a \in A} Q(s, a) \\\epsilon / m & \text { else }\end{array}\right. $$</div><ol start=5><li>如果所有的Q(s,a)收敛，则对应的所有Q(s,a)即为最优的动作价值函数q∗。对应的策略π(a|s)即为最优策略π∗。否则转到第二步。</li></ol><p><strong>SUMMARY:实际上MC方法就是一个简单的采样渐进求平均的方法，在不断的迭代过程中找到相应的槿近似值。</strong></p><h1 id=chapter5-用时序差分法td求解>Chapter5 用时序差分法（TD）求解<a hidden class=anchor aria-hidden=true href=#chapter5-用时序差分法td求解>#</a></h1><p><a href=https://www.cnblogs.com/pinard/p/9529828.html target=_blank rel=noopener>强化学习（五）用时序差分法（TD）求解</a></p><p>蒙特卡洛法虽然灵活，不需要环境转化概率模型，但是也有限制：所有的采样序列都需要是完整的状态序列，如果没有完整的状态序列，就不能使用Monto-Calo了。</p><p>在不完整的状态序列的情况下，可以使用时序差分算法（Temporal-Difference，TD），这也是一种不基于模型的算法（也就是没有环境转移的情况下）</p><p>关键公式回顾：</p><div>$$ 蒙特卡洛：G_t = R_{t+1} + \gamma R_{t+1} + ...+ \gamma ^{T-t+1}R_T \\<p>贝尔曼（TD）：v_{\pi}(s) = =\mathbb{E}{\pi}\left(R_{t+1}+\gamma v_{\pi}\left(S_{t+1}\right) \mid S_{t}=s\right)
$$</p></div><p>由于如果使用G的公式的话，我们需要有T时刻的R来进行计算分析， 为了简化这个过程，我们使用贝尔曼的递推式来进行时序差分的分析（实际上是同个等式）</p><p>也就是：</p><p>使用 $R_{t+1} + \gamma v(S_{t+1})$ （也称为TD目标值） 来代替收获 $G_t$ ，同时令 $R_{t+1} + \gamma v(S_{t+1}) - V(S_t)$ 称为TD误差，用TD目标值来代替收获G的过程称为引导。这样的话我们只需要两个连续的状态和对应的奖励，就可以尝试求解强化学习的问题了。</p><h2 id=td预测问题求解>TD预测问题求解<a hidden class=anchor aria-hidden=true href=#td预测问题求解>#</a></h2><p>预测问题的求解思路大体上是类似的，但是和MC有两个主要的不同点:</p><p><strong>一个是 $G_t$ 收获的表达式不同</strong></p><div>$$ G(t) = R_{t+1} + \gamma v(S_{t+1}) $$</div><p><strong>二是迭代的系数稍微有些不同，因为没有完整的序列，所以就没有对应的次数N，所以就用一个[0,1]的系数来代替</strong></p><div>$$ V\left(S_{t}\right)=V\left(S_{t}\right)+\alpha\left(G_{t}-V\left(S_{t}\right)\right) $$</div><p>具体的例子请参考相应的链接，这里写的特别的清楚！GO TO URL</p><p><strong>从例子中我们可以看到MC和TD主要的几点区别：</strong></p><ol><li>时序差分法在知道结果之前就可以学习，也可以在没有结果时学习，还可以在持续进行的环境中学习，而蒙特卡罗法则要等到最后结果才能学习，时序差分法可以更快速灵活的更新状态的价值估计，这在某些情况下有着非常重要的实际意义。‘</li><li>时序差分法在更新状态价值时使用的是TD 目标值，即基于即时奖励和下一状态的预估价值来替代当前状态在状态序列结束时可能得到的收获，是当前状态价值的有偏估计，而蒙特卡罗法则使用实际的收获来更新状态价值，是某一策略下状态价值的无偏估计，这一点蒙特卡罗法占优。</li><li>虽然时序差分法得到的价值是有偏估计，但是其方差却比蒙特卡罗法得到的方差要低，且对初始值敏感，通常比蒙特卡罗法更加高效。</li></ol><p>所以后续的主流的强化学习方法都是基于时序差分的，后面的文章也会主要基于时序差分来拓展讨论。</p><p>SUMMARY: 实际上TD和对应的DP最大的区别就在于G(t)的计算，从这里可以体现出DP主要依靠的是当前值再所有出现的序列中的状态值的平均，而TD可以依靠其他变量进行递推的这点优势。</p><h2 id=n步时序差分>n步时序差分<a hidden class=anchor aria-hidden=true href=#n步时序差分>#</a></h2><p>前面我们的递推式只考虑了一步差分来进行近似，但是实际上我们可以将差分式子变形，变成二次差分项</p><div>$$ G_t^{(2)} = R_{t+1} + \gamma R_{t+2} + \gamma^2 V(S_{t+1}) $$</div><p>也可以一次类推到n步的差分项，当n趋于无穷的时候，实际上就等价于MC方法了。</p><h2 id=td-lambda->TD（ $\lambda$ ）<a hidden class=anchor aria-hidden=true href=#td-lambda->#</a></h2><p>n步时序差分选择多少步数是一个超参数调优的过程，为了再不增加计算复杂度的时候综合考虑所有步数的预测，引入一个新的[0,1]的参数λ，定义λ-收获是n从1到∞所有步的收获*权重的和，每一步的权重带有一定的比例，如下：</p><div>$$ G_t^\lambda = (1-\lambda)\sum_{n=1}^\infin \lambda^{n-1}G_t^{(n)} $$</div><p>因此我们就能得到TD（λ）的迭代公式：Q也是类似的，就不重新写一次了</p><div>$$ V(S_t) = V(S_t)+\alpha(G_t^\lambda - V(S_t)) $$</div><p>权重衰减的原因如下，随着n增大，权重成集合级数衰减，在T时刻把所有剩余的权重给最终状态，这样可以使得权重嘉禾为1，里当前越远权重越小。</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180824163740251-607605293.jpg><img alt=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180824163740251-607605293.jpg loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180824163740251-607605293.jpg class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180824163740251-607605293.jpg style="display:block;margin:0 auto" alt=https://raw.githubusercontent.com/AikenH/md-image/master/img/1042406-20180824163740251-607605293.jpg></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>从前向来看TD(λ)， 一个状态的价值V(St)由Gt得到，而Gt又间接由所有后续状态价值计算得到，因此可以认为更新一个状态的价值需要知道所有后续状态的价值。也就是说，必须要经历完整的状态序列获得包括终止状态的每一个状态的即时奖励才能更新当前状态的价值。这和蒙特卡罗法的要求一样，因此TD(λ)有着和蒙特卡罗法一样的劣势。当λ=0 时,就是第二节讲到的普通的时序差分法，当λ=1 时,就是蒙特卡罗法。</p><p>从反向来看TD(λ)，它可以分析我们状态对后续状态的影响。比如老鼠在依次连续接受了3 次响铃和1 次亮灯信号后遭到了电击，那么在分析遭电击的原因时，到底是响铃的因素较重要还是亮灯的因素更重要呢？如果把老鼠遭到电击的原因认为是之前接受了较多次数的响铃，则称这种归因为频率启发(frequency heuristic) 式；而把电击归因于最近少数几次状态的影响，则称为就近启发(recency heuristic) 式。</p><p>如果给每一个状态引入一个数值：效用(eligibility, E) 来表示该状态对后续状态的影响，就可以同时利用到上述两个启发。而所有状态的效用值总称为效用迹(eligibility traces,ES)。定义为：</p><div>$$ \begin{gathered}E_{0}(s)=0 \\E_{t}(s)=\gamma \lambda E_{t-1}(s)+1\left(S_{t}=s\right)=\left\{\begin{array}{ll}0 & t<k \\(\gamma \lambda)^{t-k} & t \geq k\end{array}, \text { s.t. } \lambda, \gamma \in[0,1], s \text { is visited once at time } k\right.\end{gathered} $$ </div><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/20200218133233516.png><img alt=https://raw.githubusercontent.com/AikenH/md-image/master/img/20200218133233516.png loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/20200218133233516.png class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/20200218133233516.png style="display:block;margin:0 auto" alt=https://raw.githubusercontent.com/AikenH/md-image/master/img/20200218133233516.png></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>可以看到一个状态要是重复出现的话都会让效用迹增加，不然的话就会一直衰减。</p><p>这样最终TD（λ）的股票公式就可以更新为：（反向公式这应该是）</p><div>$$ \begin{gathered}\delta_{t}=R_{t+1}+\gamma v\left(S_{t+1}\right)-V\left(S_{t}\right) \\V\left(S_{t}\right)=V\left(S_{t}\right)+\alpha \delta_{t} E_{t}(s)\end{gathered} $$</div><p>然后可以看出这两个公式是存在一致性的。</p><h2 id=td控制问题求解>TD控制问题求解<a hidden class=anchor aria-hidden=true href=#td控制问题求解>#</a></h2><p>实际上还是使用同样的ε-贪婪进行策略和价值迭代。</p><p>在线控制最常见的是SARSA算法</p><p>离线控制比在线控制多了一个策略，用贪婪发来更新价值函数，用一样的来进行动作选择，最常见的是Q-Learning算法。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://aikenh.cn/hugotest/tags/reinforcement-learning/>Reinforcement Learning</a></li><li><a href=https://aikenh.cn/hugotest/tags/machine-learning/>Machine Learning</a></li></ul><nav class=paginav><a class=prev href=https://aikenh.cn/hugotest/posts/rl-mobaai_tencent/><span class=title>« Prev</span><br><span>RL-MobaAI</span>
</a><a class=next href=https://aikenh.cn/hugotest/posts/intview_%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/><span class=title>Next »</span><br><span>经典深度学习与机器学习算法</span></a></nav></footer><div id=disqus_thread></div><script>function loadDisqus(){var e=document,t=e.createElement("script");t.src="https://aiken-hugo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t),window.disqus_config=function(){this.page.url=window.location.href,this.page.identifier=window.location.href.substring(18)}}var runningOnBrowser=typeof window!="undefined",isBot=runningOnBrowser&&!("onscroll"in window)||typeof navigator!="undefined"&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){if(!isBot&&supportsIntersectionObserver){var e=new IntersectionObserver(function(t){t[0].isIntersecting&&(loadDisqus(),e.disconnect())},{threshold:[0]});e.observe(document.getElementById("disqus_thread"))}else loadDisqus()},1)</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://aikenh.cn/hugotest/>aiken's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container>Visitors: <span id=busuanzi_value_site_uv></span>
Views: <span id=busuanzi_value_site_pv></span></span></footer><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),o=13863,i=16993;if(!e||!t){console.error("Busuanzi elements not found.");return}const n=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+o;break}}),s=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){s.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+i;break}});n.observe(e,{childList:!0}),s.observe(t,{childList:!0})})</script><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))}),document.getElementById("theme-toggle-nav").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("/js/pangu.js",function(){pangu.spacingPage()})</script></body></html>