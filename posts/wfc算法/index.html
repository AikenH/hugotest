<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wave Function Collapse | aiken's blog</title>
<meta name=keywords content="Game,Algorithm"><meta name=description content="@Reference: Github-Mxgmn
 | zhihu

概念简介和复习
本质上该方法的底层思想就是条件概率的启发式随机生成算法。
波函数坍塌
在介绍算法之前首先需要明确几个概念，第一个就是**“波函数坍塌”（名字的来源是量子力学中的概念），参考“薛定谔的猫”，可以理解成：在一系列的不确定像素（存在多种可能）的基础之上，通过确定的规则**、相关关系，随机的将所有的像素变成确定的状态。（可以通过给定种子来启动，也可以通过随机规则来启动），实现在一定规则或者模式下的随机生成。

熵
熵作为热力学中，表示物理状态的参量，其含义在于表示物质的混乱程度（正相关）。在当前的场景下，使用信息熵（而非热熵）来衡量变量的不确定程度（完全随机，或者有限随机，或者二选一等等）。

$$ 
H(X) = \sum_{x\in X}p(x)log p(x)
 $$

式中描述的是信息熵的计算公式，在实际应用中，可以使用任何表示状态不确定程度的度量来进行一下的计算。
算法原理-流程
动态地使可选的范围越来越小，直到最后整体都是确定的状态。而缩小范围的方法核心可以总结为（数独）：


约束规则、状态传播、回溯


从最小熵的单位开始坍缩，保证最小概率的坍缩失败，从而减少大量的回溯过程，来减少计算量。


以地图生成为例：
约束规则：（选择一个熵最小的slot开始）针对于每个slot的坍缩，是在ModuleSet（可选模块集合）中随机取一个概率最高的模块，进行合成，而这个概率受我们制定的规则，周边的Slot的状态影响。
状态传播：模块确定后就将该状态和规则传递到相邻的moduleset中，删除不匹配的模块等。
回溯：当坍缩陷入矛盾（与规则相互矛盾，坍缩失效），就对状态进行回溯（Backtrack）重新进行状态搜索和回溯。


Read the input bitmap and count NxN patterns.

(optional) Augment pattern data with rotations and reflections.


Create an array with the dimensions of the output (called &ldquo;wave&rdquo; in the source). Each element of this array represents a state of an NxN region in the output. A state of an NxN region is a superposition of NxN patterns of the input with boolean coefficients (so a state of a pixel in the output is a superposition of input colors with real coefficients). False coefficient means that the corresponding pattern is forbidden, true coefficient means that the corresponding pattern is not yet forbidden.
Initialize the wave in the completely unobserved state, i.e. with all the boolean coefficients being true.
Repeat the following steps:

Observation:

Find a wave element with the minimal nonzero entropy. If there is no such elements (if all elements have zero or undefined entropy) then break the cycle (4) and go to step (5).
Collapse this element into a definite state according to its coefficients and the distribution of NxN patterns in the input.


Propagation: propagate information gained on the previous observation step.


By now all the wave elements are either in a completely observed state (all the coefficients except one being zero) or in the contradictory state (all the coefficients being zero). In the first case return the output. In the second case finish the work without returning anything.


Code
官方仓库中有诸多样例和各种代码版本的实现，可以参考并实现部分版本。"><meta name=author content="aikenhong"><link rel=canonical href=https://hugotest-phi.vercel.app/posts/wfc%E7%AE%97%E6%B3%95/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://hugotest-phi.vercel.app/favicon/ghost.ico><link rel=icon type=image/png sizes=16x16 href=https://hugotest-phi.vercel.app/favicon/ghost-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hugotest-phi.vercel.app/favicon/ghost-32x32.png><link rel=apple-touch-icon href=https://hugotest-phi.vercel.app/favicon/ghost-apple-touch-icon.png><link rel=mask-icon href=https://hugotest-phi.vercel.app/favicon/ghost-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hugotest-phi.vercel.app/posts/wfc%E7%AE%97%E6%B3%95/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><meta property="og:url" content="https://hugotest-phi.vercel.app/posts/wfc%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="aiken's blog"><meta property="og:title" content="Wave Function Collapse"><meta property="og:description" content="@Reference: Github-Mxgmn | zhihu 概念简介和复习 本质上该方法的底层思想就是条件概率的启发式随机生成算法。
波函数坍塌 在介绍算法之前首先需要明确几个概念，第一个就是**“波函数坍塌”（名字的来源是量子力学中的概念），参考“薛定谔的猫”，可以理解成：在一系列的不确定像素（存在多种可能）的基础之上，通过确定的规则**、相关关系，随机的将所有的像素变成确定的状态。（可以通过给定种子来启动，也可以通过随机规则来启动），实现在一定规则或者模式下的随机生成。
熵 熵作为热力学中，表示物理状态的参量，其含义在于表示物质的混乱程度（正相关）。在当前的场景下，使用信息熵（而非热熵）来衡量变量的不确定程度（完全随机，或者有限随机，或者二选一等等）。
$$ H(X) = \sum_{x\in X}p(x)log p(x)$$式中描述的是信息熵的计算公式，在实际应用中，可以使用任何表示状态不确定程度的度量来进行一下的计算。
算法原理-流程 动态地使可选的范围越来越小，直到最后整体都是确定的状态。而缩小范围的方法核心可以总结为（数独）：
约束规则、状态传播、回溯
从最小熵的单位开始坍缩，保证最小概率的坍缩失败，从而减少大量的回溯过程，来减少计算量。
以地图生成为例：
约束规则：（选择一个熵最小的slot开始）针对于每个slot的坍缩，是在ModuleSet（可选模块集合）中随机取一个概率最高的模块，进行合成，而这个概率受我们制定的规则，周边的Slot的状态影响。 状态传播：模块确定后就将该状态和规则传递到相邻的moduleset中，删除不匹配的模块等。 回溯：当坍缩陷入矛盾（与规则相互矛盾，坍缩失效），就对状态进行回溯（Backtrack）重新进行状态搜索和回溯。
Read the input bitmap and count NxN patterns. (optional) Augment pattern data with rotations and reflections. Create an array with the dimensions of the output (called “wave” in the source). Each element of this array represents a state of an NxN region in the output. A state of an NxN region is a superposition of NxN patterns of the input with boolean coefficients (so a state of a pixel in the output is a superposition of input colors with real coefficients). False coefficient means that the corresponding pattern is forbidden, true coefficient means that the corresponding pattern is not yet forbidden. Initialize the wave in the completely unobserved state, i.e. with all the boolean coefficients being true. Repeat the following steps: Observation: Find a wave element with the minimal nonzero entropy. If there is no such elements (if all elements have zero or undefined entropy) then break the cycle (4) and go to step (5). Collapse this element into a definite state according to its coefficients and the distribution of NxN patterns in the input. Propagation: propagate information gained on the previous observation step. By now all the wave elements are either in a completely observed state (all the coefficients except one being zero) or in the contradictory state (all the coefficients being zero). In the first case return the output. In the second case finish the work without returning anything. Code 官方仓库中有诸多样例和各种代码版本的实现，可以参考并实现部分版本。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-10T09:42:50+00:00"><meta property="article:modified_time" content="2022-07-10T09:42:50+00:00"><meta property="article:tag" content="Game"><meta property="article:tag" content="Algorithm"><meta property="og:image" content="https://hugotest-phi.vercel.app/cover/cover1.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hugotest-phi.vercel.app/cover/cover1.jpeg"><meta name=twitter:title content="Wave Function Collapse"><meta name=twitter:description content="@Reference: Github-Mxgmn
 | zhihu

概念简介和复习
本质上该方法的底层思想就是条件概率的启发式随机生成算法。
波函数坍塌
在介绍算法之前首先需要明确几个概念，第一个就是**“波函数坍塌”（名字的来源是量子力学中的概念），参考“薛定谔的猫”，可以理解成：在一系列的不确定像素（存在多种可能）的基础之上，通过确定的规则**、相关关系，随机的将所有的像素变成确定的状态。（可以通过给定种子来启动，也可以通过随机规则来启动），实现在一定规则或者模式下的随机生成。

熵
熵作为热力学中，表示物理状态的参量，其含义在于表示物质的混乱程度（正相关）。在当前的场景下，使用信息熵（而非热熵）来衡量变量的不确定程度（完全随机，或者有限随机，或者二选一等等）。

$$ 
H(X) = \sum_{x\in X}p(x)log p(x)
 $$

式中描述的是信息熵的计算公式，在实际应用中，可以使用任何表示状态不确定程度的度量来进行一下的计算。
算法原理-流程
动态地使可选的范围越来越小，直到最后整体都是确定的状态。而缩小范围的方法核心可以总结为（数独）：


约束规则、状态传播、回溯


从最小熵的单位开始坍缩，保证最小概率的坍缩失败，从而减少大量的回溯过程，来减少计算量。


以地图生成为例：
约束规则：（选择一个熵最小的slot开始）针对于每个slot的坍缩，是在ModuleSet（可选模块集合）中随机取一个概率最高的模块，进行合成，而这个概率受我们制定的规则，周边的Slot的状态影响。
状态传播：模块确定后就将该状态和规则传递到相邻的moduleset中，删除不匹配的模块等。
回溯：当坍缩陷入矛盾（与规则相互矛盾，坍缩失效），就对状态进行回溯（Backtrack）重新进行状态搜索和回溯。


Read the input bitmap and count NxN patterns.

(optional) Augment pattern data with rotations and reflections.


Create an array with the dimensions of the output (called &ldquo;wave&rdquo; in the source). Each element of this array represents a state of an NxN region in the output. A state of an NxN region is a superposition of NxN patterns of the input with boolean coefficients (so a state of a pixel in the output is a superposition of input colors with real coefficients). False coefficient means that the corresponding pattern is forbidden, true coefficient means that the corresponding pattern is not yet forbidden.
Initialize the wave in the completely unobserved state, i.e. with all the boolean coefficients being true.
Repeat the following steps:

Observation:

Find a wave element with the minimal nonzero entropy. If there is no such elements (if all elements have zero or undefined entropy) then break the cycle (4) and go to step (5).
Collapse this element into a definite state according to its coefficients and the distribution of NxN patterns in the input.


Propagation: propagate information gained on the previous observation step.


By now all the wave elements are either in a completely observed state (all the coefficients except one being zero) or in the contradictory state (all the coefficients being zero). In the first case return the output. In the second case finish the work without returning anything.


Code
官方仓库中有诸多样例和各种代码版本的实现，可以参考并实现部分版本。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hugotest-phi.vercel.app/posts/"},{"@type":"ListItem","position":2,"name":"Wave Function Collapse","item":"https://hugotest-phi.vercel.app/posts/wfc%E7%AE%97%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Wave Function Collapse","name":"Wave Function Collapse","description":"@Reference: Github-Mxgmn | zhihu 概念简介和复习 本质上该方法的底层思想就是条件概率的启发式随机生成算法。\n波函数坍塌 在介绍算法之前首先需要明确几个概念，第一个就是**“波函数坍塌”（名字的来源是量子力学中的概念），参考“薛定谔的猫”，可以理解成：在一系列的不确定像素（存在多种可能）的基础之上，通过确定的规则**、相关关系，随机的将所有的像素变成确定的状态。（可以通过给定种子来启动，也可以通过随机规则来启动），实现在一定规则或者模式下的随机生成。\n熵 熵作为热力学中，表示物理状态的参量，其含义在于表示物质的混乱程度（正相关）。在当前的场景下，使用信息熵（而非热熵）来衡量变量的不确定程度（完全随机，或者有限随机，或者二选一等等）。\n$$ H(X) = \\sum_{x\\in X}p(x)log p(x)\r$$\r式中描述的是信息熵的计算公式，在实际应用中，可以使用任何表示状态不确定程度的度量来进行一下的计算。\n算法原理-流程 动态地使可选的范围越来越小，直到最后整体都是确定的状态。而缩小范围的方法核心可以总结为（数独）：\n约束规则、状态传播、回溯\n从最小熵的单位开始坍缩，保证最小概率的坍缩失败，从而减少大量的回溯过程，来减少计算量。\n以地图生成为例：\n约束规则：（选择一个熵最小的slot开始）针对于每个slot的坍缩，是在ModuleSet（可选模块集合）中随机取一个概率最高的模块，进行合成，而这个概率受我们制定的规则，周边的Slot的状态影响。 状态传播：模块确定后就将该状态和规则传递到相邻的moduleset中，删除不匹配的模块等。 回溯：当坍缩陷入矛盾（与规则相互矛盾，坍缩失效），就对状态进行回溯（Backtrack）重新进行状态搜索和回溯。\nRead the input bitmap and count NxN patterns. (optional) Augment pattern data with rotations and reflections. Create an array with the dimensions of the output (called \u0026ldquo;wave\u0026rdquo; in the source). Each element of this array represents a state of an NxN region in the output. A state of an NxN region is a superposition of NxN patterns of the input with boolean coefficients (so a state of a pixel in the output is a superposition of input colors with real coefficients). False coefficient means that the corresponding pattern is forbidden, true coefficient means that the corresponding pattern is not yet forbidden. Initialize the wave in the completely unobserved state, i.e. with all the boolean coefficients being true. Repeat the following steps: Observation: Find a wave element with the minimal nonzero entropy. If there is no such elements (if all elements have zero or undefined entropy) then break the cycle (4) and go to step (5). Collapse this element into a definite state according to its coefficients and the distribution of NxN patterns in the input. Propagation: propagate information gained on the previous observation step. By now all the wave elements are either in a completely observed state (all the coefficients except one being zero) or in the contradictory state (all the coefficients being zero). In the first case return the output. In the second case finish the work without returning anything. Code 官方仓库中有诸多样例和各种代码版本的实现，可以参考并实现部分版本。\n","keywords":["Game","Algorithm"],"articleBody":"@Reference: Github-Mxgmn | zhihu 概念简介和复习 本质上该方法的底层思想就是条件概率的启发式随机生成算法。\n波函数坍塌 在介绍算法之前首先需要明确几个概念，第一个就是**“波函数坍塌”（名字的来源是量子力学中的概念），参考“薛定谔的猫”，可以理解成：在一系列的不确定像素（存在多种可能）的基础之上，通过确定的规则**、相关关系，随机的将所有的像素变成确定的状态。（可以通过给定种子来启动，也可以通过随机规则来启动），实现在一定规则或者模式下的随机生成。\n熵 熵作为热力学中，表示物理状态的参量，其含义在于表示物质的混乱程度（正相关）。在当前的场景下，使用信息熵（而非热熵）来衡量变量的不确定程度（完全随机，或者有限随机，或者二选一等等）。\n$$ H(X) = \\sum_{x\\in X}p(x)log p(x)\r$$\r式中描述的是信息熵的计算公式，在实际应用中，可以使用任何表示状态不确定程度的度量来进行一下的计算。\n算法原理-流程 动态地使可选的范围越来越小，直到最后整体都是确定的状态。而缩小范围的方法核心可以总结为（数独）：\n约束规则、状态传播、回溯\n从最小熵的单位开始坍缩，保证最小概率的坍缩失败，从而减少大量的回溯过程，来减少计算量。\n以地图生成为例：\n约束规则：（选择一个熵最小的slot开始）针对于每个slot的坍缩，是在ModuleSet（可选模块集合）中随机取一个概率最高的模块，进行合成，而这个概率受我们制定的规则，周边的Slot的状态影响。 状态传播：模块确定后就将该状态和规则传递到相邻的moduleset中，删除不匹配的模块等。 回溯：当坍缩陷入矛盾（与规则相互矛盾，坍缩失效），就对状态进行回溯（Backtrack）重新进行状态搜索和回溯。\nRead the input bitmap and count NxN patterns. (optional) Augment pattern data with rotations and reflections. Create an array with the dimensions of the output (called “wave” in the source). Each element of this array represents a state of an NxN region in the output. A state of an NxN region is a superposition of NxN patterns of the input with boolean coefficients (so a state of a pixel in the output is a superposition of input colors with real coefficients). False coefficient means that the corresponding pattern is forbidden, true coefficient means that the corresponding pattern is not yet forbidden. Initialize the wave in the completely unobserved state, i.e. with all the boolean coefficients being true. Repeat the following steps: Observation: Find a wave element with the minimal nonzero entropy. If there is no such elements (if all elements have zero or undefined entropy) then break the cycle (4) and go to step (5). Collapse this element into a definite state according to its coefficients and the distribution of NxN patterns in the input. Propagation: propagate information gained on the previous observation step. By now all the wave elements are either in a completely observed state (all the coefficients except one being zero) or in the contradictory state (all the coefficients being zero). In the first case return the output. In the second case finish the work without returning anything. Code 官方仓库中有诸多样例和各种代码版本的实现，可以参考并实现部分版本。\n样例解读 样例实现 ","wordCount":"261","inLanguage":"en","image":"https://hugotest-phi.vercel.app/cover/cover1.jpeg","datePublished":"2022-07-10T09:42:50Z","dateModified":"2022-07-10T09:42:50Z","author":[{"@type":"Person","name":"aikenhong"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://hugotest-phi.vercel.app/posts/wfc%E7%AE%97%E6%B3%95/"},"publisher":{"@type":"Organization","name":"aiken's blog","logo":{"@type":"ImageObject","url":"https://hugotest-phi.vercel.app/favicon/ghost.ico"}}}</script></head><body id=top><script type=module src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.esm.js defer></script><script nomodule src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.js defer></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hugotest-phi.vercel.app/ accesskey=h title="aiken's blog (Alt + H)">aiken's blog</a><div class=logo-switches><button id=theme-toggle-nav accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hugotest-phi.vercel.app/ title=home><span>home</span></a></li><li><a href=https://hugotest-phi.vercel.app/archives/ title=archives><span>archives</span></a></li><li><a href=https://hugotest-phi.vercel.app/search title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><div class=sidebar><ul><li class=logo style=--bg:#333><a href=#><div class=logo-icon><img src=/logo/logo.png></div><div class=logo-text>Aiken's Blog</div></a></li><div class=menulist><li style=--bg:#f44336><a href=https://hugotest-phi.vercel.app/ title=home><div class=logo-icon><ion-icon name=home-outline></ion-icon></div><div class=logo-text>home</div></a></li><li style=--bg:#b145e9><a href=https://hugotest-phi.vercel.app/posts/ title=posts><div class=logo-icon><ion-icon name=newspaper-outline></ion-icon></div><div class=logo-text>posts</div></a></li><li style=--bg:#0f93c7><a href=https://hugotest-phi.vercel.app/tags/ title=tags><div class=logo-icon><ion-icon name=pricetags-outline></ion-icon></div><div class=logo-text>tags</div></a></li><li style=--bg:#ffa117><a href=https://hugotest-phi.vercel.app/categories/ title=categories><div class=logo-icon><ion-icon name=grid-outline></ion-icon></div><div class=logo-text>categories</div></a></li><li style=--bg:#0fc70f><a href=https://hugotest-phi.vercel.app/archives/ title=archives><div class=logo-icon><ion-icon name=folder-outline></ion-icon></div><div class=logo-text>archives</div></a></li><li style=--bg:#d16111><a href=https://hugotest-phi.vercel.app/about/ title=about><div class=logo-icon><ion-icon name=person></ion-icon></div><div class=logo-text>about</div></a></li><li style=--bg:#15c095><a href=https://hugotest-phi.vercel.app/search title="search (Alt + /)" accesskey=/><div class=logo-icon><ion-icon name=search></ion-icon></div><div class=logo-text>search</div></a></li></div><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt +T)"><li><div class=logo-icon id=moon><ion-icon name=moon-outline></ion-icon></div><div class=logo-icon id=sun><ion-icon name=sunny-outline></ion-icon></div></li></button></div></ul></div><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hugotest-phi.vercel.app/>Home</a>&nbsp;»&nbsp;<a href=https://hugotest-phi.vercel.app/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Wave Function Collapse</h1><div class=post-meta><span title='2022-07-10 09:42:50 +0000 UTC'>July 10, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;261 words&nbsp;·&nbsp;aikenhong&nbsp;·&nbsp;<a href=/tags/game> Game</a>&nbsp;·&nbsp;<a href=/tags/algorithm> Algorithm</a>&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/WFC%e7%ae%97%e6%b3%95.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://hugotest-phi.vercel.app/cover/cover1.jpeg alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%a6%82%e5%bf%b5%e7%ae%80%e4%bb%8b%e5%92%8c%e5%a4%8d%e4%b9%a0 aria-label=概念简介和复习>概念简介和复习</a><ul class=header-level-2><li><a href=#%e6%b3%a2%e5%87%bd%e6%95%b0%e5%9d%8d%e5%a1%8c aria-label=波函数坍塌>波函数坍塌</a></li><li><a href=#%e7%86%b5 aria-label=熵>熵</a></li></ul></li><li><a href=#%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86-%e6%b5%81%e7%a8%8b aria-label=算法原理-流程>算法原理-流程</a></li><li><a href=#code aria-label=Code>Code</a><ul class=header-level-2><li><a href=#%e6%a0%b7%e4%be%8b%e8%a7%a3%e8%af%bb aria-label=样例解读>样例解读</a></li><li><a href=#%e6%a0%b7%e4%be%8b%e5%ae%9e%e7%8e%b0 aria-label=样例实现>样例实现</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase(),n=document.querySelector(`.inner ul li a[href="#${t}"]`);n.classList.remove("read")}),activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach((t)=>{const o=encodeURI(t.getAttribute("id")).toLowerCase(),s=document.querySelector(`.inner ul li a[href="#${o}"]`);if(t===activeElement){s.classList.add("active");const e=document.querySelector(".toc .inner"),t=s.offsetTop,n=e.clientHeight,o=s.clientHeight,i=t-n/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else getOffsetTop(t)<e&&s.classList.add("read"),s.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return!document.querySelector(".hugo-encryptor-prompt")&&elements.length!=0&&(elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),console.log("Elements re-queried:",elements)),0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>@Reference: <a href=https://github.com/mxgmn/WaveFunctionCollapse target=_blank rel=noopener>Github-Mxgmn</a>
| <a href=https://zhuanlan.zhihu.com/p/66416593 target=_blank rel=noopener>zhihu</a></p><h2 id=概念简介和复习>概念简介和复习<a hidden class=anchor aria-hidden=true href=#概念简介和复习>#</a></h2><p>本质上该方法的底层思想就是条件概率的启发式随机生成算法。</p><h3 id=波函数坍塌>波函数坍塌<a hidden class=anchor aria-hidden=true href=#波函数坍塌>#</a></h3><p>在介绍算法之前首先需要明确几个概念，第一个就是**“波函数坍塌”<strong>（名字的来源是量子力学中的概念），参考</strong>“薛定谔的猫”<strong>，可以理解成：在一系列的不确定像素（存在多种可能）的基础之上，通过</strong>确定的规则**、<strong>相关关系</strong>，随机的将所有的像素变成确定的状态。（可以通过给定种子来启动，也可以通过随机规则来启动），实现在一定规则或者模式下的随机生成。</p><h3 id=熵>熵<a hidden class=anchor aria-hidden=true href=#熵>#</a></h3><p><strong>熵</strong>作为热力学中，表示物理状态的参量，其含义在于表示物质的<strong>混乱程度</strong>（正相关）。在当前的场景下，使用信息熵（而非热熵）来衡量变量的<strong>不确定程度</strong>（完全随机，或者有限随机，或者二选一等等）。</p><div>$$
H(X) = \sum_{x\in X}p(x)log p(x)
$$</div><p>式中描述的是信息熵的计算公式，在实际应用中，可以使用任何表示状态不确定程度的度量来进行一下的计算。</p><h2 id=算法原理-流程>算法原理-流程<a hidden class=anchor aria-hidden=true href=#算法原理-流程>#</a></h2><p>动态地使可选的范围越来越小，直到最后整体都是确定的状态。而缩小范围的方法核心可以总结为（数独）：</p><ul><li><p><strong>约束规则</strong>、<strong>状态传播</strong>、<strong>回溯</strong></p></li><li><p>从最小熵的单位开始坍缩，保证最小概率的坍缩失败，从而<strong>减少大量的回溯</strong>过程，来减少计算量。</p></li></ul><p>以<strong>地图生成</strong>为例：</p><p><strong>约束规则</strong>：（选择一个熵最小的slot开始）针对于每个slot的坍缩，是在ModuleSet（可选模块集合）中随机取一个概率最高的模块，进行合成，而这个概率受我们制定的<strong>规则</strong>，<strong>周边的Slot</strong>的状态影响。
<strong>状态传播</strong>：模块确定后就将该状态和规则传递到相邻的moduleset中，删除不匹配的模块等。
<strong>回溯</strong>：当坍缩陷入矛盾（与规则相互矛盾，坍缩失效），就对状态进行回溯（Backtrack）重新进行状态搜索和回溯。</p><blockquote><ol><li>Read the input bitmap and count NxN patterns.<ol><li>(optional) Augment pattern data with rotations and reflections.</li></ol></li><li>Create an array with the dimensions of the output (called &ldquo;wave&rdquo; in the source). Each element of this array represents a state of an NxN region in the output. A state of an NxN region is a superposition of NxN patterns of the input with boolean coefficients (so a state of a pixel in the output is a superposition of input colors with real coefficients). False coefficient means that the corresponding pattern is forbidden, true coefficient means that the corresponding pattern is not yet forbidden.</li><li>Initialize the wave in the completely unobserved state, i.e. with all the boolean coefficients being true.</li><li>Repeat the following steps:<ol><li>Observation:<ol><li>Find a wave element with the minimal nonzero entropy. If there is no such elements (if all elements have zero or undefined entropy) then break the cycle (4) and go to step (5).</li><li>Collapse this element into a definite state according to its coefficients and the distribution of NxN patterns in the input.</li></ol></li><li>Propagation: propagate information gained on the previous observation step.</li></ol></li><li>By now all the wave elements are either in a completely observed state (all the coefficients except one being zero) or in the contradictory state (all the coefficients being zero). In the first case return the output. In the second case finish the work without returning anything.</li></ol></blockquote><h2 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h2><p>官方仓库中有诸多样例和各种代码版本的实现，可以参考并实现部分版本。</p><h3 id=样例解读>样例解读<a hidden class=anchor aria-hidden=true href=#样例解读>#</a></h3><h3 id=样例实现>样例实现<a hidden class=anchor aria-hidden=true href=#样例实现>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://hugotest-phi.vercel.app/tags/game/>Game</a></li><li><a href=https://hugotest-phi.vercel.app/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://hugotest-phi.vercel.app/posts/markovjunior/><span class=title>« Prev</span><br><span>Markov Junior</span>
</a><a class=next href=https://hugotest-phi.vercel.app/posts/linux_cli_z/><span class=title>Next »</span><br><span>Using Z Jumper in CLI</span></a></nav></footer><div id=disqus_thread></div><script>function loadDisqus(){var e=document,t=e.createElement("script");t.src="https://aiken-hugo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t),window.disqus_config=function(){this.page.url=window.location.href,this.page.identifier=window.location.href.substring(18)}}var runningOnBrowser=typeof window!="undefined",isBot=runningOnBrowser&&!("onscroll"in window)||typeof navigator!="undefined"&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){if(!isBot&&supportsIntersectionObserver){var e=new IntersectionObserver(function(t){t[0].isIntersecting&&(loadDisqus(),e.disconnect())},{threshold:[0]});e.observe(document.getElementById("disqus_thread"))}else loadDisqus()},1)</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://hugotest-phi.vercel.app/>aiken's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container>Visitors: <span id=busuanzi_value_site_uv></span>
Views: <span id=busuanzi_value_site_pv></span></span></footer><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),o=13863,i=16993;if(!e||!t){console.error("Busuanzi elements not found.");return}const n=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+o;break}}),s=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){s.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+i;break}});n.observe(e,{childList:!0}),s.observe(t,{childList:!0})})</script><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))}),document.getElementById("theme-toggle-nav").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("/js/pangu.js",function(){pangu.spacingPage()})</script></body></html>