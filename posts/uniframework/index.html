<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>UniFramework 01 | aiken's blog</title>
<meta name=keywords content="CV,Machine Learning"><meta name=description content="
    
    







  
    
      文章的部分内容被密码保护：
    
  
  
    
    
  
  
    --- DON'T MODIFY THIS LINE ---
    @aiken 2021  Framework
Abstract
Try To make structure universal，编写一个自己的通用的架构，框架化，满足通过不同的model文件和特殊配置文件就能实现不同的模型的一个架构。
只是一个初步的框架集成，还有很多没有完善的地方，目前测试了ResNet18 跑Cifar10，没有什么问题，如果有什么可以改进的地方，或者你实现了一些Feature，*欢迎进行交流*！（私下联系我最好啦！）
感谢帮助


还有一些可以参数化或者可视化的地方，由于时间关系目前还没有修改，有兴趣的可以自己先添加一下


暂时只集成了分类的模块，后续可能会随缘扩展


本框架主要希望实现的是：易读性，可拓展性，以及简洁；
希望将重要的，可变的参数都尽量的分离出来，通过配置文件和命令行参数去定义和运行我们的网络，在这种情况下实现一个较好的工作流程。
Final Project Design
PURPOSE：新类发现和模型自主更新；同时希望能够解决长尾分布的数据情景；
**ANALYSIS：**为了实现这种模型的自主更新过程，将整体的流程分成两个部分

启动（start）：


self supervissed 等方法无监督的学习特征提取网络（这种方式是否会对Unbalance产生增益）

初始化预测模型：
基于Unbalance的数据训练一个基础的分类模型，在输出分类结果的同时需要输出对应的预测置信度，这两个其实都是一些简单的Trick，而最重要的是Backbone的分类效果需要得到保证，同时Backbone需要支撑后续的模型蒸馏更新。



  
    
  






模型的自主更新和迭代：
Online：在线运行推断模型，通过置信度输出筛选出新类样本，将样本在样本池中收集
Offline：基于样本池的规模和评估触发离线更新：伪标签生成模型；模型蒸馏和更新

创新点：自主新类发现和学习"><meta name=author content="aikenhong"><link rel=canonical href=https://aikenh.cn/hugotest/posts/uniframework/><link crossorigin=anonymous href=/hugotest/assets/css/stylesheet.2f85ca17c12c62fa86b1e474b8a51aca4856f0d645debfe4922a4d5ddc6aa978.css integrity="sha256-L4XKF8EsYvqGseR0uKUaykhW8NZF3r/kkipNXdxqqXg=" rel="preload stylesheet" as=style><link rel=icon href=https://aikenh.cn/favicon/ghost.ico><link rel=icon type=image/png sizes=16x16 href=https://aikenh.cn/favicon/ghost-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aikenh.cn/favicon/ghost-32x32.png><link rel=apple-touch-icon href=https://aikenh.cn/favicon/ghost-apple-touch-icon.png><link rel=mask-icon href=https://aikenh.cn/favicon/ghost-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aikenh.cn/hugotest/posts/uniframework/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><meta property="og:url" content="https://aikenh.cn/hugotest/posts/uniframework/"><meta property="og:site_name" content="aiken's blog"><meta property="og:title" content="UniFramework 01"><meta property="og:description" content="文章的部分内容被密码保护：
--- DON'T MODIFY THIS LINE ---@aiken 2021 Framework
Abstract Try To make structure universal，编写一个自己的通用的架构，框架化，满足通过不同的model文件和特殊配置文件就能实现不同的模型的一个架构。
只是一个初步的框架集成，还有很多没有完善的地方，目前测试了ResNet18 跑Cifar10，没有什么问题，如果有什么可以改进的地方，或者你实现了一些Feature，*欢迎进行交流*！（私下联系我最好啦！）
感谢帮助
还有一些可以参数化或者可视化的地方，由于时间关系目前还没有修改，有兴趣的可以自己先添加一下
暂时只集成了分类的模块，后续可能会随缘扩展
本框架主要希望实现的是：易读性，可拓展性，以及简洁；
希望将重要的，可变的参数都尽量的分离出来，通过配置文件和命令行参数去定义和运行我们的网络，在这种情况下实现一个较好的工作流程。
Final Project Design PURPOSE：新类发现和模型自主更新；同时希望能够解决长尾分布的数据情景；
**ANALYSIS：**为了实现这种模型的自主更新过程，将整体的流程分成两个部分
启动（start）： self supervissed 等方法无监督的学习特征提取网络（这种方式是否会对Unbalance产生增益）
初始化预测模型： 基于Unbalance的数据训练一个基础的分类模型，在输出分类结果的同时需要输出对应的预测置信度，这两个其实都是一些简单的Trick，而最重要的是Backbone的分类效果需要得到保证，同时Backbone需要支撑后续的模型蒸馏更新。 模型的自主更新和迭代： Online：在线运行推断模型，通过置信度输出筛选出新类样本，将样本在样本池中收集 Offline：基于样本池的规模和评估触发离线更新：伪标签生成模型；模型蒸馏和更新 创新点：自主新类发现和学习"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-04T01:43:30+00:00"><meta property="article:modified_time" content="2021-12-04T01:43:30+00:00"><meta property="article:tag" content="CV"><meta property="article:tag" content="Machine Learning"><meta property="og:image" content="https://aikenh.cn/cover/cover16.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aikenh.cn/cover/cover16.jpeg"><meta name=twitter:title content="UniFramework 01"><meta name=twitter:description content="
    
    







  
    
      文章的部分内容被密码保护：
    
  
  
    
    
  
  
    --- DON'T MODIFY THIS LINE ---
    @aiken 2021  Framework
Abstract
Try To make structure universal，编写一个自己的通用的架构，框架化，满足通过不同的model文件和特殊配置文件就能实现不同的模型的一个架构。
只是一个初步的框架集成，还有很多没有完善的地方，目前测试了ResNet18 跑Cifar10，没有什么问题，如果有什么可以改进的地方，或者你实现了一些Feature，*欢迎进行交流*！（私下联系我最好啦！）
感谢帮助


还有一些可以参数化或者可视化的地方，由于时间关系目前还没有修改，有兴趣的可以自己先添加一下


暂时只集成了分类的模块，后续可能会随缘扩展


本框架主要希望实现的是：易读性，可拓展性，以及简洁；
希望将重要的，可变的参数都尽量的分离出来，通过配置文件和命令行参数去定义和运行我们的网络，在这种情况下实现一个较好的工作流程。
Final Project Design
PURPOSE：新类发现和模型自主更新；同时希望能够解决长尾分布的数据情景；
**ANALYSIS：**为了实现这种模型的自主更新过程，将整体的流程分成两个部分

启动（start）：


self supervissed 等方法无监督的学习特征提取网络（这种方式是否会对Unbalance产生增益）

初始化预测模型：
基于Unbalance的数据训练一个基础的分类模型，在输出分类结果的同时需要输出对应的预测置信度，这两个其实都是一些简单的Trick，而最重要的是Backbone的分类效果需要得到保证，同时Backbone需要支撑后续的模型蒸馏更新。



  
    
  






模型的自主更新和迭代：
Online：在线运行推断模型，通过置信度输出筛选出新类样本，将样本在样本池中收集
Offline：基于样本池的规模和评估触发离线更新：伪标签生成模型；模型蒸馏和更新

创新点：自主新类发现和学习"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aikenh.cn/hugotest/posts/"},{"@type":"ListItem","position":2,"name":"UniFramework 01","item":"https://aikenh.cn/hugotest/posts/uniframework/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"UniFramework 01","name":"UniFramework 01","description":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r@aiken 2021 Framework\nAbstract Try To make structure universal，编写一个自己的通用的架构，框架化，满足通过不同的model文件和特殊配置文件就能实现不同的模型的一个架构。\n只是一个初步的框架集成，还有很多没有完善的地方，目前测试了ResNet18 跑Cifar10，没有什么问题，如果有什么可以改进的地方，或者你实现了一些Feature，*欢迎进行交流*！（私下联系我最好啦！）\n感谢帮助\n还有一些可以参数化或者可视化的地方，由于时间关系目前还没有修改，有兴趣的可以自己先添加一下\n暂时只集成了分类的模块，后续可能会随缘扩展\n本框架主要希望实现的是：易读性，可拓展性，以及简洁；\n希望将重要的，可变的参数都尽量的分离出来，通过配置文件和命令行参数去定义和运行我们的网络，在这种情况下实现一个较好的工作流程。\nFinal Project Design PURPOSE：新类发现和模型自主更新；同时希望能够解决长尾分布的数据情景；\n**ANALYSIS：**为了实现这种模型的自主更新过程，将整体的流程分成两个部分\n启动（start）： self supervissed 等方法无监督的学习特征提取网络（这种方式是否会对Unbalance产生增益）\n初始化预测模型： 基于Unbalance的数据训练一个基础的分类模型，在输出分类结果的同时需要输出对应的预测置信度，这两个其实都是一些简单的Trick，而最重要的是Backbone的分类效果需要得到保证，同时Backbone需要支撑后续的模型蒸馏更新。 模型的自主更新和迭代： Online：在线运行推断模型，通过置信度输出筛选出新类样本，将样本在样本池中收集 Offline：基于样本池的规模和评估触发离线更新：伪标签生成模型；模型蒸馏和更新 创新点：自主新类发现和学习\n","keywords":["CV","Machine Learning"],"articleBody":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r@aiken 2021 Framework\nAbstract Try To make structure universal，编写一个自己的通用的架构，框架化，满足通过不同的model文件和特殊配置文件就能实现不同的模型的一个架构。\n只是一个初步的框架集成，还有很多没有完善的地方，目前测试了ResNet18 跑Cifar10，没有什么问题，如果有什么可以改进的地方，或者你实现了一些Feature，*欢迎进行交流*！（私下联系我最好啦！）\n感谢帮助\n还有一些可以参数化或者可视化的地方，由于时间关系目前还没有修改，有兴趣的可以自己先添加一下\n暂时只集成了分类的模块，后续可能会随缘扩展\n本框架主要希望实现的是：易读性，可拓展性，以及简洁；\n希望将重要的，可变的参数都尽量的分离出来，通过配置文件和命令行参数去定义和运行我们的网络，在这种情况下实现一个较好的工作流程。\nFinal Project Design PURPOSE：新类发现和模型自主更新；同时希望能够解决长尾分布的数据情景；\n**ANALYSIS：**为了实现这种模型的自主更新过程，将整体的流程分成两个部分\n启动（start）： self supervissed 等方法无监督的学习特征提取网络（这种方式是否会对Unbalance产生增益）\n初始化预测模型： 基于Unbalance的数据训练一个基础的分类模型，在输出分类结果的同时需要输出对应的预测置信度，这两个其实都是一些简单的Trick，而最重要的是Backbone的分类效果需要得到保证，同时Backbone需要支撑后续的模型蒸馏更新。 模型的自主更新和迭代： Online：在线运行推断模型，通过置信度输出筛选出新类样本，将样本在样本池中收集 Offline：基于样本池的规模和评估触发离线更新：伪标签生成模型；模型蒸馏和更新 创新点：自主新类发现和学习\nUnbalance：\nStrategy Status Desc Two Stage Todo 可以作为一个Baseline策略 Causla Analysis Doing 基于TwoStage做出的偏差校正 Rebalance TBD 作为数据增强的辅助策略 置信度生成方法：\n置信度生成的方法可以从Active Learning等领域的文章中作为参考\nStrategy Status pros and cons Evidential Learning Doing pros：有坚实的数学基础；\ncons：增加模型复杂度和训练的难度 Least Confident Done pros：实现简单，不影响原有复杂度\ncons：原理上简单，不是特别靠谱 Entropy and… TBD\n同上，可以随时取代测试 置信度准确率评估：\n使用下面的指标去做置信度输出的准确率评估\n$$ ac = NumNew/NumLowconfi\r$$\r$$ recall = NumOld/NumLowconfi\r$$\r伪标签生成模型：\n在进行新的模型训练，之前，要将数据集混合现有的已知数据，生成的方式主要可以分成两种，网络或者聚类\n聚类：通过现有类别的聚类结果，还能判断聚类的质量 网络：切分Mini-Batch进行Meta-Like的Training，训练FSL或者Unsupervised的模型，输出伪标签预测（一致性原则） 基本思想：\n当特征以通用表征的无监督预训练进行，这种情况下不存在对应的数据瓶颈，因为我们不需要标记，我们可以将Backbone得到一个泛化性极强的高级特征，那么在这种情况下LT和FC带来的泛化性问题将集中在Classifier中，对Classifer进行校准和调整就是我们的主要方向，这样就能将问题归化到蒸馏和FC的训练一个Linear的问题 所以处理Unbalance的分类器和特征迁移方式是我们后续work的方向，可以从复杂度高的网络训练一个高级表征的分类器，或者通过Graph和Cluster的构建，来实现一个更为依赖Backbone的一种方式。 创新点：\n（Augmentation）在做伪标签生成之前，我们基于原本特征特征提取器，组合数据特征，数据混合和增强方法作为后续的数据基础 （Loss-Design）通过混合的数据集中的伪标签生成，和标签的双指标，定义损失，去更新原有的特征提取架构同时赋予新类伪标签。这是由于我们知道部分数据集的真实标签，我们就可以通过这一部分的信息去做一个对应的标准。 这样就可以通过生成的伪标签对原特征提取器进行一定的更新，这种更新应该是交替进行的，因为我们不知道哪个Coder是更为可靠的一个label generator。（除非我们使用的是有终点的聚类） 模型更新：\n参考蒸馏学习的思想，使用原有网络和pseudo generator作为Teacher 进行模型的更新，Duplicate Feature Extractor，Modify FC（num_class），考虑使用双重循环去freeze，利用不同的lr training网络的两部分。\n在这里参考其他蒸馏学习的方法，去设计这种Teacher给予Label或者Parms的机制\n考虑基于prototype的方法，是否会和聚类的方法更加的匹配，但是prototype\n的方法和我们之前设想的实验过程应该是一个区分度比较大的情况\n创新点：\n（Framework）double teacher to generate a new siamese model which train in two diff phase for feature extractor and classifier 使用孪生的机制，在两个不同的阶段来训练特征提取器和分类器，在这里我们将训练的重心转化到Projector以及Cluster，Model上 设计思路\n在模型的整体架构上还是会和awb师弟的有很多类似的地方，后续可以详细进行探讨和借鉴。\nDevLog 开发中的一些疑问和细节会放在这个地方，包括开发的RoadMap，实现中遇到的问题，FrameWork设计中的主要矛盾和问题。\n下面是一些基本的实验内容：首先将流程跑通，在设计对应的消融实验。\nFull-Data 的模型基准实验 BackBone测试 数据集 进度 结果 resnet-18 cifar10 完成（配置文件已保存） 93% cifar100 完成（配置文件已保存） 77% ImageNet conclusion 过拟合in cifar100 Efficient Net b0 cifar10 完成（非最佳）（配置文件已保存） 90% cifar100 完成（非最佳）（配置文件已保存） 73% ImageNet conclusion 过拟合in cifar Swin Transformer 实际上在训练集和测试集中，resnet18 和 efficient net呈现的都是一种训练集远高于数据集的过拟合like的情况，我认为这种情况与问题规模简单，等诸多原因导致，为了改善这种情况，我们可以考虑\n使用更多数据增强来使得问题更为复杂 使用特征学习无监督与训练的方法，同样通过数据增强来加大问题规模 增加数据，使用大规模数据集对模型进行与训练，但是也要考虑到数据的规模和模型的capability Cifar10-100的模型调优过程 后续可以考虑加入MAE的方式，实际上这种方式就是代替了EnAET中的多种复杂数据增强，还是从数据增强的角度入手对模型进行处理实现的一种自监督的机制，这种自监督的策略来学习一种图像上的通用表征，保持在识别问题上，整体的有效性。\nResNet 在对cifar10-100的图像进行分类的时候需要修改初始的入口层，因为cifar数据集中的图像太小，如果一开始使用7*7的卷积层，在精度上会损失很多特征信息。\n可以将7*7 2的卷积改成3*3 1,然后去掉maxpooling层 亦可以将图像resize到224*224 前者在cifar10中最终测试可得接近93%的准确率，在cifar100中最终测试可以取得稳定77%的准确率\n此外，对图像进行randomcrop的过程中，由于原图本来就只有32*32所以我们希望crop到32的时候，我们最好是先进行padding，不然该增强是一个无效的增强。\nEfficient Net 和对ResNet进行调整的时候一样，训练集太过简单，所以过快的收敛，影响了模型的泛化能力，这里考虑可能是dropout没有设置好，或者是任务过于简单，我们可以对其设置一些图像的增强等等的操作来对对训练过程进行调整，可以将一部分需要较多io的任务存放在本地，然后在线进行一些random transformer。\n在这里不需要对模型进行修改，只需要调整学习的参数即可。\nSwin Transformer 在new class - LT 的数据环境中的基准实验： 首先测试LT和NC的数据策略是否能进行正常的数据训练，确保数据抽取策略\n后续为了可复现和效果对比，我们在类别抽取的时候取消随机性（使用固定的随机种子），抽取固定的类别作为新类，对比未进行长尾采样以及采样之后的效果。\nmodel 数据集以及预处理 进度 LT结果 NC结果 Combine TAG … cifar10， cifar100\n分别测试LT和NC的策略 Done :heavy_check_mark: :heavy_check_mark: \\ varify resnet cifar100 NC：20 LT：0.5(step) Done \\ 75%-.5 \\ try pre-cifar100 NC20 LT0.5(STEP) Done 63% 75%-.5 63%- 0.5 basic 下面开始矫正 问题更大的实际上是LT部分 resnet-CA resnet-ReBalance resnet-MAR-iBOT Efficient Net Swin Transformer 实验结果一：置信度问题 使用Cifar100置信度划分的过程中，发现对新类的筛选效果并不好，我们考虑，这可能是由于超类和子类之间的关系造成的，为此，在初步的研究阶段，我们决定，拆分出特定的超类来作为新类，避免对于新类识别的干扰；\n后续的研究中可以考虑像安文斌的方式去做纵向的新类发现，现阶段首先考虑横向的新类发现问题，在这里可以参考安文斌师弟的两个研究 实际上新类的拆分要求的是precision，相对的recall在当前的问题上并不是很重要，所以对该算法的改进不是很迫切，但是相应的，我们需要完善recall和Precision的输出用来作为我们后续进行判断的依据\n拆分特定新类的情况下，置信度结果并没有明显的改进，说明问题更多的出自模型的特征提取和分类本身，用于分类的特征没有将类别之间的差异性体现出来，所以后续在这一方面的训练应该进行改进，改进思路如下：\n修改Loss：使用Contrastive Learning的训练策略，在分类准确率之上结合NLL对比损失，在这一部分可以结合人脸比对的相应损失进行设计\n实际上我们可以用MAE训练一个通用的预训练表征，Backbone，然后使用Contrastive训练Classifier，两种不同的策略的侧重点实际上是不一样的。那么如何结合这两种训练方式，或者将其中的一种训练和分类的训练相互结合起来，使得我们的训练步骤不会如此的冗余。\nContrastive Learn的预训练方式：得到一个类别之间更为分明的Backbone or MLP？\nMAE的预训练方式，得到一个通用的表征？\n实验结果二：LT问题 准确率下降到63%（下降了10%左右），过拟合问题愈发严重，需要更多的去分析这种下降出现的原因。\nDistill部分网络结构设计 为了使得能够进行代码复用，不做重复的造轮子，在对蒸馏部分网络进行设计的时候遇到了一些问题，以下是问题和解决方式，假如这些方式不能很好的解决对应的问题，我们就duplicate代码并重新编写Train_ditill 的设计\n这一部分其实设计的是整个框架中的数据流程，要注意在每个不同的阶段我们使用的数据是不同的。如何更有效的利用这个数据，是框架设计中的关键部分。\n损失部分对输入的要求不同 面临问题：\n需要额外的模型输出作为Loss的计算依据 损失函数的输入维度不统一 暂定解决方案，\n（Both）使用额外的args参数对损失计算的部分进行分支处理 伪标签的处理 具体问题：\n在什么阶段将标签转化为对应的伪标签 如何和真实标签进行一个对照分析，如何保存并实现验证和真实环境的匹配度 暂定解决方案：\n再labelGe中仿照人类标注，按照绝大多数类别的真是标签来确定伪标签，然后再初始化蒸馏训练中，将训练集中的数据替换为伪标签，而test数据集中仍然是真实标签，就解决了验证的问题和伪标签和真实标签之前缺乏一次映射的问题。\nRoadMap 开发路线图部分，主要分为基本的模块，和不同的训练方式两个阶段，用来集成完整的Framework.\nDeadline Settting 具体时间节点，主要是为了给自己明确当前的任务，后续可能会继续细化，时间上也会随着实验的顺利与否进行调整。\nTask Desc 部分功能重写 config，dataloader（read data and load in GPU）\nby define collate_fn function 完成 数据处理 几个部分的数据还有整体的数据：New（FS divide into phase？）-Old（LT）-Cloud（无关数据） 完成 调整运行Swin 交织在多个任务中并行，时不时的调整参数测试一下 待定 长尾模块功能实现 在cifar数据集上用resnet先进行实验和swin的实验并行\n实现对长尾的优化 进行 小样本模型和聚类模型嵌入 1. 确定数据混合策略\n2. EnAet中训练的策略集成到该函数中\n3 确定标签的输出和参与的形式 进行 蒸馏架构实现 架构编写，实现蒸馏框架的嵌入\n测试双模型之间的蒸馏的结果 完成 模型实验和测试 Data 数据集收集和初始数据的采样处理：\n分析一下数据的使用场景：\n首先我们使用Unbalance的数据进行初始模型的构建，然后我们需要在训练的过程中加入小样本的新类别。\n可以额外的构建小样本的数据集来训练小样本模型，但这不在我们的Workflow里，不作为我们的主题框架中的代码。\nFunction Stage Desc New Class（Larget version） done like mini-imagenet，mv some cls to other dir Unbalance done sampling data in differ rate Mix data done mix old knowledge and the new data，the point:\nwhether we want to use meta-learning or pnot Few Shot done testing the model only have few data 所以数据准备工作应该分为两步：\n（Script）数据集预处理，将一部分类别抽离出去，建立新的文件夹，但是对于Cifar这种数据集好像都是一次性载入的，思考一下怎么写成对应的函数进行处理。\n（Load）初始数据的Unbalance处理，通过不同的采样策略使得数据不均衡\n此外，我们在进行新类训练的时候会将旧数据和新数据进行混合，我们需要设计对应的数据混合策略，进行小样本模型的训练和聚类的训练\nModel Functional Part Stage KeyWord/Method Basic Training abjust ImageNet1k Using ImageNet to Pretrain or Self-Training Backbone todo Swin（abjust params and train on ImageNet）\nLT and Confidence done two-stage\nrebalance\ncausal analysis FSL doing Self-Supervise\nCluster Cluster todo New-Descover\nK-Means\nSelf-Supervised + linear Framework Training Process Stage KeyWord/Method Meta Training TBD / Multi-Stage Training Intergrate with Framwork / Distill Training done Incremental learning, Unsupervised todo MAE Clustering doing Projector-Head + Kmeans Swin-T 问题描述：在cifar10，或者ImageNet数据集上训练的时候，损失曲线过早收敛，识别准确率很低；\n问题分析：\nLR 过高，没有办法学到好的解 框架中学习率设置的问题，同理可以分析其他的和config中的冲突\n数据集标签的问题\n模型定义的问题\n损失函数设计，模型的体量问题\n解决方法拟定：\n直接使用官方的模型和官方的数据集进行训练后比对 加载并编写论文中提到的各种trick 对比官方的模型和自己编写的模型之间的差异 Dataset 这一部分描写使用到的dataset的具体参数，主要至少包含一下的一些信息\nName Class EachNum Resolution Useage Cifar10 10 5000+1000 32*32 Cls LT Cifar100 100 500+100 32*32 Cls NC LT TinyImageNet 200 500+50+50 64*64 Cls NC LT MiniImageNet 100 500+100 86*86 Cls NC LT ImageNet-1k 1000 700-1300 resize to (256*256)\navg:469*387 PreTrain If Need List the dataset here :\nTiny-ImageNet-200 | Tiny-ImageNet-Plus Reference Confidental\n主动学习(Active learning)算法的原理 ResNet\nPytorch.org 、官方实现解读 、ResNet详解与分析 、Pytorch手工实现 Mini ImageNet\n用Mini-ImageNet训练分类网络 Swin Transformer\n","wordCount":"526","inLanguage":"en","image":"https://aikenh.cn/cover/cover16.jpeg","datePublished":"2021-12-04T01:43:30Z","dateModified":"2021-12-04T01:43:30Z","author":[{"@type":"Person","name":"aikenhong"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://aikenh.cn/hugotest/posts/uniframework/"},"publisher":{"@type":"Organization","name":"aiken's blog","logo":{"@type":"ImageObject","url":"https://aikenh.cn/favicon/ghost.ico"}}}</script></head><body id=top><script type=module src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.esm.js defer></script><script nomodule src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.js defer></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aikenh.cn/hugotest/ accesskey=h title="aiken's blog (Alt + H)">aiken's blog</a><div class=logo-switches><button id=theme-toggle-nav accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aikenh.cn/hugotest/ title=home><span>home</span></a></li><li><a href=https://aikenh.cn/hugotest/posts/ title=posts><span>posts</span></a></li><li><a href=https://aikenh.cn/hugotest/tags/ title=tags><span>tags</span></a></li><li><a href=https://aikenh.cn/hugotest/categories/ title=categories><span>categories</span></a></li><li><a href=https://aikenh.cn/hugotest/archives/ title=archives><span>archives</span></a></li><li><a href=https://aikenh.cn/hugotest/about/ title=about><span>about</span></a></li><li><a href=https://aikenh.cn/hugotest/search title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><div class=sidebar><ul><li class=logo style=--bg:#333><a href=#><div class=logo-icon><img src=/logo/logo.png></div><div class=logo-text>Aiken's Blog</div></a></li><div class=menulist><li style=--bg:#f44336><a href=https://aikenh.cn/hugotest/ title=home><div class=logo-icon><ion-icon name=home-outline></ion-icon></div><div class=logo-text>home</div></a></li><li style=--bg:#b145e9><a href=https://aikenh.cn/hugotest/posts/ title=posts><div class=logo-icon><ion-icon name=newspaper-outline></ion-icon></div><div class=logo-text>posts</div></a></li><li style=--bg:#0f93c7><a href=https://aikenh.cn/hugotest/tags/ title=tags><div class=logo-icon><ion-icon name=pricetags-outline></ion-icon></div><div class=logo-text>tags</div></a></li><li style=--bg:#ffa117><a href=https://aikenh.cn/hugotest/categories/ title=categories><div class=logo-icon><ion-icon name=grid-outline></ion-icon></div><div class=logo-text>categories</div></a></li><li style=--bg:#0fc70f><a href=https://aikenh.cn/hugotest/archives/ title=archives><div class=logo-icon><ion-icon name=folder-outline></ion-icon></div><div class=logo-text>archives</div></a></li><li style=--bg:#d16111><a href=https://aikenh.cn/hugotest/about/ title=about><div class=logo-icon><ion-icon name=person></ion-icon></div><div class=logo-text>about</div></a></li><li style=--bg:#15c095><a href=https://aikenh.cn/hugotest/search title="search (Alt + /)" accesskey=/><div class=logo-icon><ion-icon name=search></ion-icon></div><div class=logo-text>search</div></a></li></div><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt +T)"><li><div class=logo-icon id=moon><ion-icon name=moon-outline></ion-icon></div><div class=logo-icon id=sun><ion-icon name=sunny-outline></ion-icon></div></li></button></div></ul></div><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aikenh.cn/hugotest/>Home</a>&nbsp;»&nbsp;<a href=https://aikenh.cn/hugotest/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">UniFramework 01</h1><div class=post-meta><span title='2021-12-04 01:43:30 +0000 UTC'>December 4, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;526 words&nbsp;·&nbsp;aikenhong&nbsp;·&nbsp;<a href=/tags/cv> CV</a>&nbsp;·&nbsp;<a href=/tags/machine-learning> Machine Learning</a>&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/UniFramework.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://aikenh.cn/cover/cover16.jpeg alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#abstract aria-label=Abstract>Abstract</a></li><li><a href=#final-project-design aria-label="Final Project Design">Final Project Design</a></li><li><a href=#devlog aria-label=DevLog>DevLog</a><ul class=header-level-2><li><a href=#full-data-%e7%9a%84%e6%a8%a1%e5%9e%8b%e5%9f%ba%e5%87%86%e5%ae%9e%e9%aa%8c aria-label="Full-Data 的模型基准实验">Full-Data 的模型基准实验</a></li><li><a href=#cifar10-100%e7%9a%84%e6%a8%a1%e5%9e%8b%e8%b0%83%e4%bc%98%e8%bf%87%e7%a8%8b aria-label=Cifar10-100的模型调优过程>Cifar10-100的模型调优过程</a><ul class=header-level-3><li><a href=#resnet aria-label=ResNet>ResNet</a></li><li><a href=#efficient-net aria-label="Efficient Net">Efficient Net</a></li><li><a href=#swin-transformer aria-label="Swin Transformer">Swin Transformer</a></li></ul></li><li><a href=#%e5%9c%a8new-class---lt-%e7%9a%84%e6%95%b0%e6%8d%ae%e7%8e%af%e5%a2%83%e4%b8%ad%e7%9a%84%e5%9f%ba%e5%87%86%e5%ae%9e%e9%aa%8c aria-label="在new class - LT 的数据环境中的基准实验：">在new class - LT 的数据环境中的基准实验：</a><ul class=header-level-3><li><a href=#%e5%ae%9e%e9%aa%8c%e7%bb%93%e6%9e%9c%e4%b8%80%e7%bd%ae%e4%bf%a1%e5%ba%a6%e9%97%ae%e9%a2%98 aria-label=实验结果一：置信度问题>实验结果一：置信度问题</a></li><li><a href=#%e5%ae%9e%e9%aa%8c%e7%bb%93%e6%9e%9c%e4%ba%8clt%e9%97%ae%e9%a2%98 aria-label=实验结果二：LT问题>实验结果二：LT问题</a></li></ul></li><li><a href=#distill%e9%83%a8%e5%88%86%e7%bd%91%e7%bb%9c%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1 aria-label=Distill部分网络结构设计>Distill部分网络结构设计</a><ul class=header-level-3><li><a href=#%e6%8d%9f%e5%a4%b1%e9%83%a8%e5%88%86%e5%af%b9%e8%be%93%e5%85%a5%e7%9a%84%e8%a6%81%e6%b1%82%e4%b8%8d%e5%90%8c aria-label=损失部分对输入的要求不同>损失部分对输入的要求不同</a></li><li><a href=#%e4%bc%aa%e6%a0%87%e7%ad%be%e7%9a%84%e5%a4%84%e7%90%86 aria-label=伪标签的处理>伪标签的处理</a></li></ul></li><li><a href=#roadmap aria-label=RoadMap>RoadMap</a><ul class=header-level-3><li><a href=#deadline-settting aria-label="Deadline Settting">Deadline Settting</a></li><li><a href=#data aria-label=Data>Data</a></li><li><a href=#model aria-label=Model>Model</a></li><li><a href=#framework aria-label=Framework>Framework</a></li></ul></li><li><a href=#swin-t aria-label=Swin-T>Swin-T</a></li></ul></li><li><a href=#dataset aria-label=Dataset>Dataset</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase(),n=document.querySelector(`.inner ul li a[href="#${t}"]`);n.classList.remove("read")}),activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach((t)=>{const o=encodeURI(t.getAttribute("id")).toLowerCase(),s=document.querySelector(`.inner ul li a[href="#${o}"]`);if(t===activeElement){s.classList.add("active");const e=document.querySelector(".toc .inner"),t=s.offsetTop,n=e.clientHeight,o=s.clientHeight,i=t-n/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else getOffsetTop(t)<e&&s.classList.add("read"),s.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return!document.querySelector(".hugo-encryptor-prompt")&&elements.length!=0&&(elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),console.log("Elements re-queried:",elements)),0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><head><script src=https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js></script></head><div class=hugo-encryptor-container><div class=hugo-encryptor-prompt><p>文章的部分内容被密码保护：</p></div><div class=hugo-encryptor-form><input class=hugo-encryptor-input placeholder=请输入密码>
<input class=hugo-encryptor-button type=button value=CLICK onclick=_click_handler(this)></div><div class=hugo-encryptor-cipher-text data-password=aikenhong_blog style=display:none><span style=display:none>--- DON'T MODIFY THIS LINE ---</span><p>@aiken 2021 Framework</p><h2 id=abstract>Abstract<a hidden class=anchor aria-hidden=true href=#abstract>#</a></h2><p>Try To make structure universal，编写一个自己的通用的架构，框架化，满足通过不同的model文件和特殊配置文件就能实现不同的模型的一个架构。</p><p>只是一个初步的框架集成，还有很多没有完善的地方，目前测试了ResNet18 跑Cifar10，没有什么问题，如果有什么可以改进的地方，或者你实现了一些Feature，<em><strong>*欢迎进行交流*</strong></em>！（私下联系我最好啦！）</p><p>感谢帮助</p><ol><li><p>还有一些可以参数化或者可视化的地方，由于时间关系目前还没有修改，有兴趣的可以自己先添加一下</p></li><li><p>暂时只集成了分类的模块，后续可能会随缘扩展</p></li></ol><p>本框架主要希望实现的是：易读性，可拓展性，以及简洁；</p><p>希望将重要的，可变的参数都尽量的分离出来，通过配置文件和命令行参数去定义和运行我们的网络，在这种情况下实现一个较好的工作流程。</p><h2 id=final-project-design>Final Project Design<a hidden class=anchor aria-hidden=true href=#final-project-design>#</a></h2><p><strong>PURPOSE：新类发现和模型自主更新</strong>；同时希望能够解决<strong>长尾分布</strong>的数据情景；</p><p>**ANALYSIS：**为了实现这种模型的自主更新过程，将整体的流程分成两个部分</p><ul><li>启动（start）：</li></ul><p>self supervissed 等方法无监督的学习特征提取网络（这种方式是否会对Unbalance产生增益）</p><ul><li><strong>初始化预测模型：</strong>
基于<strong>Unbalance</strong>的数据训练一个基础的分类模型，在输出分类结果的同时需要输出对应的预测<strong>置信度</strong>，这两个其实都是一些简单的Trick，而最重要的是Backbone的分类效果需要得到保证，同时<strong>Backbone需要支撑后续的模型蒸馏</strong>更新。</li></ul><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210921164616.png><img alt=image-20210921164615348 loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210921164616.png class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210921164616.png style="display:block;margin:0 auto" alt=image-20210921164615348></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><ul><li><strong>模型的自主更新和迭代：</strong>
Online：在线运行推断模型，通过<strong>置信度输出筛选</strong>出新类样本，将样本在<strong>样本池</strong>中收集
Offline：基于样本池的规模和评估触发离线更新：<strong>伪标签生成模型</strong>；<strong>模型蒸馏和更新</strong></li></ul><p>创新点：自主新类发现和学习</p><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210921165300.png><img alt=image-20210921165259383 loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210921165300.png class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/img/20210921165300.png style="display:block;margin:0 auto" alt=image-20210921165259383></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p><strong>Unbalance：</strong></p><table><thead><tr><th>Strategy</th><th>Status</th><th>Desc</th></tr></thead><tbody><tr><td><strong>Two Stage</strong></td><td>Todo</td><td>可以作为一个Baseline策略</td></tr><tr><td><strong>Causla Analysis</strong></td><td>Doing</td><td>基于TwoStage做出的偏差校正</td></tr><tr><td><strong>Rebalance</strong></td><td>TBD</td><td>作为数据增强的辅助策略</td></tr></tbody></table><p><strong>置信度生成方法：</strong></p><p>置信度生成的方法可以从<strong>Active Learning</strong>等领域的文章中作为参考</p><table><thead><tr><th>Strategy</th><th>Status</th><th>pros and cons</th></tr></thead><tbody><tr><td><strong>Evidential Learning</strong></td><td>Doing</td><td>pros：有坚实的数学基础；<br>cons：增加模型复杂度和训练的难度</td></tr><tr><td><strong>Least Confident</strong></td><td>Done</td><td>pros：实现简单，不影响原有复杂度<br>cons：原理上简单，不是特别靠谱</td></tr><tr><td><strong>Entropy and&mldr;</strong></td><td>TBD<br></td><td>同上，可以随时取代测试</td></tr></tbody></table><p><strong>置信度准确率评估：</strong></p><p>使用下面的指标去做置信度输出的准确率评估</p><div>$$
ac = NumNew/NumLowconfi
$$</div><div>$$
recall = NumOld/NumLowconfi
$$</div><p><strong>伪标签生成模型：</strong></p><p>在进行新的模型训练，之前，要将数据集混合现有的已知数据，生成的方式主要可以分成两种，<strong>网络</strong>或者<strong>聚类</strong></p><ul><li>聚类：通过现有类别的聚类结果，还能判断聚类的质量</li><li>网络：切分Mini-Batch进行Meta-Like的Training，训练FSL或者Unsupervised的模型，输出伪标签预测（一致性原则）</li></ul><p>基本思想：</p><ol><li>当特征以通用表征的无监督预训练进行，这种情况下不存在对应的数据瓶颈，因为我们不需要标记，我们可以将Backbone得到一个泛化性极强的高级特征，那么在这种情况下LT和FC带来的泛化性问题将集中在Classifier中，对Classifer进行校准和调整就是我们的主要方向，这样就能将问题归化到蒸馏和FC的训练一个Linear的问题</li><li>所以处理Unbalance的分类器和特征迁移方式是我们后续work的方向，可以从复杂度高的网络训练一个高级表征的分类器，或者通过Graph和Cluster的构建，来实现一个更为依赖Backbone的一种方式。</li></ol><p>创新点：</p><ul><li>（Augmentation）在做伪标签生成之前，我们基于原本特征特征提取器，组合数据特征，数据混合和增强方法作为后续的数据基础</li><li>（Loss-Design）通过混合的数据集中的伪标签生成，和标签的双指标，定义损失，去更新原有的特征提取架构同时赋予新类伪标签。这是由于我们知道部分数据集的真实标签，我们就可以通过这一部分的信息去做一个对应的标准。</li><li>这样就可以通过生成的伪标签对原特征提取器进行一定的更新，这种更新应该是交替进行的，因为我们不知道哪个Coder是更为可靠的一个label generator。（除非我们使用的是有终点的聚类）</li></ul><p><strong>模型更新：</strong></p><p>参考蒸馏学习的思想，使用原有网络和pseudo generator作为Teacher 进行模型的更新，Duplicate Feature Extractor，Modify FC（num_class），考虑使用双重循环去freeze，利用不同的lr training网络的两部分。</p><ul><li><p>在这里参考其他蒸馏学习的方法，去设计这种Teacher给予Label或者Parms的机制</p></li><li><p>考虑基于prototype的方法，是否会和聚类的方法更加的匹配，但是prototype</p><p>的方法和我们之前设想的实验过程应该是一个区分度比较大的情况</p></li></ul><p>创新点：</p><ul><li>（Framework）double teacher to generate a new siamese model which train in two diff phase for feature extractor and classifier
使用孪生的机制，在两个不同的阶段来训练特征提取器和分类器，在这里我们将训练的重心转化到Projector以及Cluster，Model上</li></ul><p><strong>设计思路</strong></p><p>在模型的整体架构上还是会和awb师弟的有很多类似的地方，后续可以详细进行探讨和借鉴。</p><h2 id=devlog>DevLog<a hidden class=anchor aria-hidden=true href=#devlog>#</a></h2><p>开发中的一些疑问和细节会放在这个地方，包括开发的RoadMap，实现中遇到的问题，FrameWork设计中的主要矛盾和问题。</p><p>下面是一些基本的实验内容：首先将流程跑通，在设计对应的消融实验。</p><h3 id=full-data-的模型基准实验>Full-Data 的模型基准实验<a hidden class=anchor aria-hidden=true href=#full-data-的模型基准实验>#</a></h3><table><thead><tr><th>BackBone测试</th><th>数据集</th><th>进度</th><th>结果</th></tr></thead><tbody><tr><td>resnet-18</td><td>cifar10</td><td>完成（配置文件已保存）</td><td>93%</td></tr><tr><td></td><td>cifar100</td><td>完成（配置文件已保存）</td><td>77%</td></tr><tr><td></td><td>ImageNet</td><td></td><td></td></tr><tr><td>conclusion</td><td></td><td>过拟合in cifar100</td><td></td></tr><tr><td>Efficient Net b0</td><td>cifar10</td><td>完成（非最佳）（配置文件已保存）</td><td>90%</td></tr><tr><td></td><td>cifar100</td><td>完成（非最佳）（配置文件已保存）</td><td>73%</td></tr><tr><td></td><td>ImageNet</td><td></td><td></td></tr><tr><td>conclusion</td><td></td><td>过拟合in cifar</td><td></td></tr><tr><td>Swin Transformer</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>实际上在训练集和测试集中，resnet18 和 efficient net呈现的都是一种训练集远高于数据集的过拟合like的情况，我认为这种情况与问题规模简单，等诸多原因导致，为了改善这种情况，我们可以考虑</p><ol><li>使用更多数据增强来使得问题更为复杂</li><li>使用特征学习无监督与训练的方法，同样通过数据增强来加大问题规模</li><li>增加数据，使用大规模数据集对模型进行与训练，但是也要考虑到数据的规模和模型的capability</li></ol><h3 id=cifar10-100的模型调优过程>Cifar10-100的模型调优过程<a hidden class=anchor aria-hidden=true href=#cifar10-100的模型调优过程>#</a></h3><p>后续可以考虑加入MAE的方式，实际上这种方式就是代替了EnAET中的多种复杂数据增强，还是从数据增强的角度入手对模型进行处理实现的一种自监督的机制，这种自监督的策略来学习一种图像上的通用表征，保持在识别问题上，整体的有效性。</p><h4 id=resnet>ResNet<a hidden class=anchor aria-hidden=true href=#resnet>#</a></h4><p>在对cifar10-100的图像进行分类的时候需要修改初始的入口层，因为cifar数据集中的图像太小，如果一开始使用7*7的卷积层，在精度上会损失很多特征信息。</p><ul><li>可以将7*7 2的卷积改成3*3 1,然后去掉maxpooling层</li><li>亦可以将图像resize到224*224</li></ul><p>前者在cifar10中最终测试可得接近93%的准确率，在cifar100中最终测试可以取得稳定77%的准确率</p><p>此外，对图像进行<code>randomcrop</code>的过程中，由于原图本来就只有<code>32*32</code>所以我们希望crop到32的时候，我们最好是先进行padding，不然该增强是一个无效的增强。</p><h4 id=efficient-net>Efficient Net<a hidden class=anchor aria-hidden=true href=#efficient-net>#</a></h4><p>和对ResNet进行调整的时候一样，训练集太过简单，所以过快的收敛，影响了模型的泛化能力，这里考虑可能是dropout没有设置好，或者是任务过于简单，我们可以对其设置一些图像的增强等等的操作来对对训练过程进行调整，可以将一部分需要较多io的任务存放在本地，然后在线进行一些random transformer。</p><p>在这里不需要对模型进行修改，只需要调整学习的参数即可。</p><h4 id=swin-transformer>Swin Transformer<a hidden class=anchor aria-hidden=true href=#swin-transformer>#</a></h4><hr><h3 id=在new-class---lt-的数据环境中的基准实验>在new class - LT 的数据环境中的基准实验：<a hidden class=anchor aria-hidden=true href=#在new-class---lt-的数据环境中的基准实验>#</a></h3><p>首先测试LT和NC的数据策略是否能进行正常的数据训练，确保数据抽取策略</p><p>后续为了可复现和效果对比，我们在<strong>类别抽取的时候取消随机性</strong>（使用固定的随机种子），抽取固定的类别作为新类，对比未进行长尾采样以及采样之后的效果。</p><table><thead><tr><th>model</th><th>数据集以及预处理</th><th>进度</th><th>LT结果</th><th>NC结果</th><th>Combine</th><th>TAG</th></tr></thead><tbody><tr><td>&mldr;</td><td>cifar10， cifar100<br>分别测试LT和NC的策略</td><td>Done</td><td>:heavy_check_mark:</td><td>:heavy_check_mark:</td><td>\</td><td>varify</td></tr><tr><td>resnet</td><td>cifar100 NC：20 LT：0.5(step)</td><td>Done</td><td>\</td><td>75%-.5</td><td>\</td><td>try</td></tr><tr><td></td><td>pre-cifar100 NC20 LT0.5(STEP)</td><td>Done</td><td>63%</td><td>75%-.5</td><td>63%- 0.5</td><td>basic</td></tr><tr><td>下面开始矫正</td><td>问题更大的实际上是LT部分</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>resnet-CA</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>resnet-ReBalance</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>resnet-MAR-iBOT</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Efficient Net</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Swin Transformer</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id=实验结果一置信度问题>实验结果一：置信度问题<a hidden class=anchor aria-hidden=true href=#实验结果一置信度问题>#</a></h4><p>使用Cifar100置信度划分的过程中，发现对新类的筛选效果并不好，我们考虑，这可能是由于超类和子类之间的关系造成的，为此，在初步的研究阶段，我们决定，<strong>拆分出特定的超类来作为新类</strong>，避免对于新类识别的干扰；</p><ul><li>后续的研究中可以考虑像安文斌的方式去做<strong>纵向的新类发现</strong>，现阶段首先考虑<strong>横向的新类发现问题</strong>，在这里可以参考<strong>安文斌师弟的两个研究</strong></li></ul><blockquote><ol><li><p>实际上新类的拆分要求的是<strong>precision</strong>，相对的<strong>recall</strong>在当前的问题上并不是很重要，所以对该算法的改进不是很迫切，但是相应的，我们需要完善recall和Precision的输出用来作为我们后续进行判断的依据</p></li><li><p>拆分特定新类的情况下，置信度结果并没有明显的改进，说明问题更多的出自模型的特征提取和分类本身，用于分类的特征没有将类别之间的差异性体现出来，所以后续在这一方面的训练应该进行改进，改进思路如下：</p></li></ol></blockquote><p>修改Loss：使用Contrastive Learning的训练策略，在分类准确率之上结合NLL对比损失，在这一部分可以结合人脸比对的相应损失进行设计</p><p>实际上我们可以用MAE训练一个通用的预训练表征，Backbone，然后使用Contrastive训练Classifier，两种不同的策略的侧重点实际上是不一样的。那么如何结合这两种训练方式，或者将其中的一种训练和分类的训练相互结合起来，使得我们的训练步骤不会如此的冗余。</p><blockquote><p>Contrastive Learn的预训练方式：得到一个类别之间更为分明的Backbone or MLP？</p><p>MAE的预训练方式，得到一个通用的表征？</p></blockquote><h4 id=实验结果二lt问题>实验结果二：LT问题<a hidden class=anchor aria-hidden=true href=#实验结果二lt问题>#</a></h4><p>准确率下降到63%（下降了10%左右），过拟合问题愈发严重，需要更多的去分析这种下降出现的原因。</p><h3 id=distill部分网络结构设计>Distill部分网络结构设计<a hidden class=anchor aria-hidden=true href=#distill部分网络结构设计>#</a></h3><p>为了使得能够进行代码复用，不做重复的造轮子，在对蒸馏部分网络进行设计的时候遇到了一些问题，以下是问题和解决方式，假如这些方式不能很好的解决对应的问题，我们就duplicate代码并重新编写Train_ditill 的设计</p><p>这一部分其实设计的是整个框架中的数据流程，要注意在每个不同的阶段我们使用的数据是不同的。如何更有效的利用这个数据，是框架设计中的关键部分。</p><h4 id=损失部分对输入的要求不同>损失部分对输入的要求不同<a hidden class=anchor aria-hidden=true href=#损失部分对输入的要求不同>#</a></h4><p>面临<strong>问题</strong>：</p><ol><li>需要额外的模型输出作为Loss的计算依据</li><li>损失函数的输入维度不统一</li></ol><p>暂定<strong>解决方案</strong>，</p><ul><li>（Both）使用额外的args参数对损失计算的部分进行分支处理</li></ul><h4 id=伪标签的处理>伪标签的处理<a hidden class=anchor aria-hidden=true href=#伪标签的处理>#</a></h4><p>具体<strong>问题</strong>：</p><ol><li>在什么阶段将标签转化为对应的伪标签</li><li>如何和真实标签进行一个对照分析，如何保存并实现验证和真实环境的匹配度</li></ol><p>暂定<strong>解决方案</strong>：</p><p>再labelGe中仿照人类标注，按照绝大多数类别的真是标签来确定伪标签，然后再初始化蒸馏训练中，将训练集中的数据替换为伪标签，而test数据集中仍然是真实标签，就解决了验证的问题和伪标签和真实标签之前缺乏一次映射的问题。</p><p><div class=post-img-view><a data-fancybox=gallery href=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/dbf13e29e9692b46da06f1dfde735e2.jpg><img alt="align mcanism" loading=lazy src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/dbf13e29e9692b46da06f1dfde735e2.jpg class=responsive-image src=https://picture-bed-001-1310572365.cos.ap-guangzhou.myqcloud.com/imgs/labimg/dbf13e29e9692b46da06f1dfde735e2.jpg style="display:block;margin:0 auto" alt="align mcanism"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><h3 id=roadmap>RoadMap<a hidden class=anchor aria-hidden=true href=#roadmap>#</a></h3><p>开发路线图部分，主要分为基本的模块，和不同的训练方式两个阶段，用来集成完整的Framework.</p><h4 id=deadline-settting>Deadline Settting<a hidden class=anchor aria-hidden=true href=#deadline-settting>#</a></h4><p>具体时间节点，主要是为了给自己明确当前的任务，后续可能会继续细化，时间上也会随着实验的顺利与否进行调整。</p><table><thead><tr><th>Task</th><th>Desc</th><th></th></tr></thead><tbody><tr><td>部分功能重写</td><td>config，dataloader（read data and load in GPU）<br>by define collate_fn function</td><td>完成</td></tr><tr><td>数据处理</td><td>几个部分的数据还有整体的数据：New（FS divide into phase？）-Old（LT）-Cloud（无关数据）</td><td>完成</td></tr><tr><td>调整运行Swin</td><td>交织在多个任务中并行，时不时的调整参数测试一下</td><td>待定</td></tr><tr><td>长尾模块功能实现</td><td>在cifar数据集上用resnet先进行实验和swin的实验并行<br>实现对长尾的优化</td><td>进行</td></tr><tr><td>小样本模型和聚类模型嵌入</td><td>1. 确定数据混合策略<br>2. EnAet中训练的策略集成到该函数中<br>3 确定标签的输出和参与的形式</td><td>进行</td></tr><tr><td>蒸馏架构实现</td><td>架构编写，实现蒸馏框架的嵌入<br>测试双模型之间的蒸馏的结果</td><td>完成</td></tr><tr><td>模型实验和测试</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id=data>Data<a hidden class=anchor aria-hidden=true href=#data>#</a></h4><p>数据集收集和初始数据的采样处理：</p><p>分析一下数据的使用场景：</p><p>首先我们使用Unbalance的数据进行初始模型的构建，然后我们需要在训练的过程中加入小样本的新类别。</p><p><em>可以额外的构建小样本的数据集来训练小样本模型，但这不在我们的Workflow里，不作为我们的主题框架中的代码。</em></p><table><thead><tr><th>Function</th><th>Stage</th><th>Desc</th></tr></thead><tbody><tr><td>New Class（Larget version）</td><td><strong>done</strong></td><td>like mini-imagenet，<code>mv</code> some cls to other dir</td></tr><tr><td>Unbalance</td><td><strong>done</strong></td><td>sampling data in differ rate</td></tr><tr><td>Mix data</td><td><strong>done</strong></td><td>mix old knowledge and the new data，the point:<br>whether we want to use meta-learning or pnot</td></tr><tr><td>Few Shot</td><td><strong>done</strong></td><td>testing the model only have few data</td></tr></tbody></table><p>所以数据准备工作应该分为两步：</p><p>（Script）数据集预处理，将一部分类别抽离出去，建立新的文件夹，但是对于Cifar这种数据集好像都是一次性载入的，思考一下怎么写成对应的函数进行处理。</p><p>（Load）初始数据的Unbalance处理，通过不同的采样策略使得数据不均衡</p><p>此外，我们在进行新类训练的时候会将旧数据和新数据进行混合，我们需要设计对应的数据混合策略，进行小样本模型的训练和聚类的训练</p><h4 id=model>Model<a hidden class=anchor aria-hidden=true href=#model>#</a></h4><table><thead><tr><th>Functional Part</th><th>Stage</th><th>KeyWord/Method</th></tr></thead><tbody><tr><td><strong>Basic Training</strong></td><td>abjust</td><td>ImageNet1k Using ImageNet to Pretrain or Self-Training</td></tr><tr><td><strong>Backbone</strong></td><td>todo</td><td>Swin（abjust params and train on ImageNet）<br></td></tr><tr><td><strong>LT and Confidence</strong></td><td>done</td><td>two-stage<br>rebalance<br>causal analysis</td></tr><tr><td><strong>FSL</strong></td><td>doing</td><td>Self-Supervise<br>Cluster</td></tr><tr><td><strong>Cluster</strong></td><td>todo</td><td>New-Descover<br>K-Means<br>Self-Supervised + linear</td></tr></tbody></table><h4 id=framework>Framework<a hidden class=anchor aria-hidden=true href=#framework>#</a></h4><table><thead><tr><th>Training Process</th><th>Stage</th><th>KeyWord/Method</th></tr></thead><tbody><tr><td><strong>Meta Training</strong></td><td>TBD</td><td>/</td></tr><tr><td><strong>Multi-Stage Training</strong></td><td>Intergrate with Framwork</td><td>/</td></tr><tr><td><strong>Distill Training</strong></td><td>done</td><td>Incremental learning,</td></tr><tr><td><strong>Unsupervised</strong></td><td>todo</td><td>MAE</td></tr><tr><td><strong>Clustering</strong></td><td>doing</td><td>Projector-Head + Kmeans</td></tr></tbody></table><h3 id=swin-t>Swin-T<a hidden class=anchor aria-hidden=true href=#swin-t>#</a></h3><p>问题描述：在cifar10，或者ImageNet数据集上训练的时候，损失曲线过早收敛，识别准确率很低；</p><p>问题分析：</p><ol><li>LR 过高，没有办法学到好的解</li></ol><p>框架中学习率设置的问题，同理可以分析其他的和config中的冲突</p><ol start=2><li><p>数据集标签的问题</p></li><li><p>模型定义的问题</p></li><li><p>损失函数设计，模型的体量问题</p></li></ol><p>解决方法拟定：</p><ul><li>直接使用官方的模型和官方的数据集进行训练后比对</li><li>加载并编写论文中提到的各种trick</li><li>对比官方的模型和自己编写的模型之间的差异</li></ul><h2 id=dataset>Dataset<a hidden class=anchor aria-hidden=true href=#dataset>#</a></h2><p>这一部分描写使用到的dataset的具体参数，主要至少包含一下的一些信息</p><table><thead><tr><th>Name</th><th>Class</th><th>EachNum</th><th>Resolution</th><th>Useage</th></tr></thead><tbody><tr><td>Cifar10</td><td>10</td><td>5000+1000</td><td>32*32</td><td>Cls LT</td></tr><tr><td>Cifar100</td><td>100</td><td>500+100</td><td>32*32</td><td>Cls NC LT</td></tr><tr><td>TinyImageNet</td><td>200</td><td>500+50+50</td><td>64*64</td><td>Cls NC LT</td></tr><tr><td>MiniImageNet</td><td>100</td><td>500+100</td><td>86*86</td><td>Cls NC LT</td></tr><tr><td>ImageNet-1k</td><td>1000</td><td>700-1300</td><td>resize to (256*256)<br>avg:469*387</td><td>PreTrain</td></tr></tbody></table><p>If Need List the dataset here :</p><p><a href=https://github.com/rmccorm4/Tiny-Imagenet-200 target=_blank rel=noopener>Tiny-ImageNet-200</a>
| Tiny-ImageNet-<a href=https://www.cnblogs.com/liuyangcode/p/14689893.html target=_blank rel=noopener>Plus</a></p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p><strong>Confidental</strong></p><p><a href=https://www.zhihu.com/question/265479171/answer/1474978784 target=_blank rel=noopener>主动学习(Active learning)算法的原理</a></p><p><strong>ResNet</strong></p><p><a href=https://pytorch.org/vision/stable/_modules/torchvision/models/resnet.html#resnet18 target=_blank rel=noopener>Pytorch.org</a>
、<a href=https://www.cnblogs.com/wzyuan/p/9880342.html target=_blank rel=noopener>官方实现解读</a>
、<a href=https://www.cnblogs.com/shine-lee/p/12363488.html target=_blank rel=noopener>ResNet详解与分析</a>
、<a href=https://zhuanlan.zhihu.com/p/149387262 target=_blank rel=noopener>Pytorch手工实现</a></p><p><strong>Mini ImageNet</strong></p><p><a href=https://blog.csdn.net/qq_37541097/article/details/113027489 target=_blank rel=noopener>用Mini-ImageNet训练分类网络</a></p><p><strong>Swin Transformer</strong></p></div></div><script>function sanitizeContent(e){return e.replace(/[\x00-\x1F\x7F]/g,"").trim()}function encryptContent(e,t){const n=CryptoJS.MD5(e).toString(),s=n.substring(16),o=padContent(t),i=CryptoJS.AES.encrypt(o,CryptoJS.enc.Utf8.parse(n),{iv:CryptoJS.enc.Utf8.parse(s),mode:CryptoJS.mode.CBC,padding:CryptoJS.pad.Pkcs7});return CryptoJS.enc.Base64.stringify(i.ciphertext)}function padContent(e){const t=32,n=t-e.length%t;return e}function processEncryptedBlocks(){const t=document.querySelectorAll(".hugo-encryptor-cipher-text");t.forEach(e=>{const t=e.getAttribute("data-password"),n=e.innerHTML.trim(),s=sanitizeContent(n),o=encryptContent(t,s);e.innerHTML=o,e.removeAttribute("data-password")});const e=document.createElement("script");e.src="/js/decrypt.js",document.body.appendChild(e)}document.addEventListener("DOMContentLoaded",processEncryptedBlocks)</script></div><footer class=post-footer><ul class=post-tags><li><a href=https://aikenh.cn/hugotest/tags/cv/>CV</a></li><li><a href=https://aikenh.cn/hugotest/tags/machine-learning/>Machine Learning</a></li></ul><nav class=paginav><a class=prev href=https://aikenh.cn/hugotest/posts/sorttrick/><span class=title>« Prev</span><br><span>Algorithm Sort</span>
</a><a class=next href=https://aikenh.cn/hugotest/posts/hungarian/><span class=title>Next »</span><br><span>Hungarian</span></a></nav></footer><div id=disqus_thread></div><script>function loadDisqus(){var e=document,t=e.createElement("script");t.src="https://aiken-hugo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t),window.disqus_config=function(){this.page.url=window.location.href,this.page.identifier=window.location.href.substring(18)}}var runningOnBrowser=typeof window!="undefined",isBot=runningOnBrowser&&!("onscroll"in window)||typeof navigator!="undefined"&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){if(!isBot&&supportsIntersectionObserver){var e=new IntersectionObserver(function(t){t[0].isIntersecting&&(loadDisqus(),e.disconnect())},{threshold:[0]});e.observe(document.getElementById("disqus_thread"))}else loadDisqus()},1)</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://aikenh.cn/hugotest/>aiken's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container>Visitors: <span id=busuanzi_value_site_uv></span>
Views: <span id=busuanzi_value_site_pv></span></span></footer><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),o=13863,i=16993;if(!e||!t){console.error("Busuanzi elements not found.");return}const n=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+o;break}}),s=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){s.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+i;break}});n.observe(e,{childList:!0}),s.observe(t,{childList:!0})})</script><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))}),document.getElementById("theme-toggle-nav").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("/js/pangu.js",function(){pangu.spacingPage()})</script></body></html>