<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>经典深度学习与机器学习算法 | aiken's blog</title>
<meta name=keywords content="Job,Machine Learning"><meta name=description content="
    
    







  
    
      文章的部分内容被密码保护：
    
  
  
    
    
  
  
    --- DON'T MODIFY THIS LINE ---
    LINK1

深度学习部分
DenseNet
任意的两层之间都存在直接的链接，每一层的输入都是前面的所有层的输出的并集，而该层学习的特征图也会是后面所有层的输入，DenseBlock中需要Feature_map保持一致；
Block与Block之间的降采样则使用transition layer，使用BN，1*1的 conv，Pooling来降维
优缺点：

省参数，省计算
抗过拟合，泛化能力强
需要保存Feature占显存


EfficientNet
针对卷积神经网络的模型拓展，可以通过：1

增加网络规模可以、 增加模型宽度，增加模型深度，增加输入图像的分辨率，但是如何去人工调整这个比例和参数，比较麻烦，
实验发现ConvNet缩放过程中平衡网络宽度、深度、和分辨率的维度是很重要的
EfficientNet就是对这些的合理组合，复合型的模型扩展技术集合神经结构搜索技术获得



  
    
  





关键技术复合扩张技术
所以本文提出了复合扩张方法，这也是文章核心的地方，

$$ \alpha,\beta,\gamma $$

 是我们需要求解的一组参数，如下图公式，带约束的最优参数求解。 

$$ \alpha,\beta,\gamma $$

 分别衡量着depth, width和 resolution的比重，其中 

$$ \beta,\gamma $$

 在约束上会有平方，是因为如果增加宽度或分辨率两倍，其计算量是增加四倍，但是增加深度两倍，其计算量只会增加两倍。


  
    
  




"><meta name=author content="aikenhong"><link rel=canonical href=https://aikenh.cn/hugotest/posts/intview_%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/><link crossorigin=anonymous href=/hugotest/assets/css/stylesheet.2f85ca17c12c62fa86b1e474b8a51aca4856f0d645debfe4922a4d5ddc6aa978.css integrity="sha256-L4XKF8EsYvqGseR0uKUaykhW8NZF3r/kkipNXdxqqXg=" rel="preload stylesheet" as=style><link rel=icon href=https://aikenh.cn/favicon/ghost.ico><link rel=icon type=image/png sizes=16x16 href=https://aikenh.cn/favicon/ghost-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aikenh.cn/favicon/ghost-32x32.png><link rel=apple-touch-icon href=https://aikenh.cn/favicon/ghost-apple-touch-icon.png><link rel=mask-icon href=https://aikenh.cn/favicon/ghost-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aikenh.cn/hugotest/posts/intview_%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdmirror.com/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdmirror.com/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><meta property="og:url" content="https://aikenh.cn/hugotest/posts/intview_%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/"><meta property="og:site_name" content="aiken's blog"><meta property="og:title" content="经典深度学习与机器学习算法"><meta property="og:description" content="文章的部分内容被密码保护：
--- DON'T MODIFY THIS LINE ---LINK1 深度学习部分 DenseNet 任意的两层之间都存在直接的链接，每一层的输入都是前面的所有层的输出的并集，而该层学习的特征图也会是后面所有层的输入，DenseBlock中需要Feature_map保持一致；
Block与Block之间的降采样则使用transition layer，使用BN，1*1的 conv，Pooling来降维
优缺点：
省参数，省计算 抗过拟合，泛化能力强 需要保存Feature占显存 EfficientNet 针对卷积神经网络的模型拓展，可以通过：1
增加网络规模可以、 增加模型宽度，增加模型深度，增加输入图像的分辨率，但是如何去人工调整这个比例和参数，比较麻烦， 实验发现ConvNet缩放过程中平衡网络宽度、深度、和分辨率的维度是很重要的 EfficientNet就是对这些的合理组合，复合型的模型扩展技术集合神经结构搜索技术获得 关键技术复合扩张技术
所以本文提出了复合扩张方法，这也是文章核心的地方，
$$ \alpha,\beta,\gamma $$是我们需要求解的一组参数，如下图公式，带约束的最优参数求解。 $$ \alpha,\beta,\gamma $$分别衡量着depth, width和 resolution的比重，其中 $$ \beta,\gamma $$在约束上会有平方，是因为如果增加宽度或分辨率两倍，其计算量是增加四倍，但是增加深度两倍，其计算量只会增加两倍。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-23T01:43:43+00:00"><meta property="article:modified_time" content="2021-04-23T01:43:43+00:00"><meta property="article:tag" content="Job"><meta property="article:tag" content="Machine Learning"><meta property="og:image" content="https://aikenh.cn/cover/cover23.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aikenh.cn/cover/cover23.jpeg"><meta name=twitter:title content="经典深度学习与机器学习算法"><meta name=twitter:description content="
    
    







  
    
      文章的部分内容被密码保护：
    
  
  
    
    
  
  
    --- DON'T MODIFY THIS LINE ---
    LINK1

深度学习部分
DenseNet
任意的两层之间都存在直接的链接，每一层的输入都是前面的所有层的输出的并集，而该层学习的特征图也会是后面所有层的输入，DenseBlock中需要Feature_map保持一致；
Block与Block之间的降采样则使用transition layer，使用BN，1*1的 conv，Pooling来降维
优缺点：

省参数，省计算
抗过拟合，泛化能力强
需要保存Feature占显存


EfficientNet
针对卷积神经网络的模型拓展，可以通过：1

增加网络规模可以、 增加模型宽度，增加模型深度，增加输入图像的分辨率，但是如何去人工调整这个比例和参数，比较麻烦，
实验发现ConvNet缩放过程中平衡网络宽度、深度、和分辨率的维度是很重要的
EfficientNet就是对这些的合理组合，复合型的模型扩展技术集合神经结构搜索技术获得



  
    
  





关键技术复合扩张技术
所以本文提出了复合扩张方法，这也是文章核心的地方，

$$ \alpha,\beta,\gamma $$

 是我们需要求解的一组参数，如下图公式，带约束的最优参数求解。 

$$ \alpha,\beta,\gamma $$

 分别衡量着depth, width和 resolution的比重，其中 

$$ \beta,\gamma $$

 在约束上会有平方，是因为如果增加宽度或分辨率两倍，其计算量是增加四倍，但是增加深度两倍，其计算量只会增加两倍。


  
    
  




"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aikenh.cn/hugotest/posts/"},{"@type":"ListItem","position":2,"name":"经典深度学习与机器学习算法","item":"https://aikenh.cn/hugotest/posts/intview_%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"经典深度学习与机器学习算法","name":"经典深度学习与机器学习算法","description":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\rLINK1 深度学习部分 DenseNet 任意的两层之间都存在直接的链接，每一层的输入都是前面的所有层的输出的并集，而该层学习的特征图也会是后面所有层的输入，DenseBlock中需要Feature_map保持一致；\nBlock与Block之间的降采样则使用transition layer，使用BN，1*1的 conv，Pooling来降维\n优缺点：\n省参数，省计算 抗过拟合，泛化能力强 需要保存Feature占显存 EfficientNet 针对卷积神经网络的模型拓展，可以通过：1\n增加网络规模可以、 增加模型宽度，增加模型深度，增加输入图像的分辨率，但是如何去人工调整这个比例和参数，比较麻烦， 实验发现ConvNet缩放过程中平衡网络宽度、深度、和分辨率的维度是很重要的 EfficientNet就是对这些的合理组合，复合型的模型扩展技术集合神经结构搜索技术获得 关键技术复合扩张技术\n所以本文提出了复合扩张方法，这也是文章核心的地方，\n$$ \\alpha,\\beta,\\gamma $$\r是我们需要求解的一组参数，如下图公式，带约束的最优参数求解。 $$ \\alpha,\\beta,\\gamma $$\r分别衡量着depth, width和 resolution的比重，其中 $$ \\beta,\\gamma $$\r在约束上会有平方，是因为如果增加宽度或分辨率两倍，其计算量是增加四倍，但是增加深度两倍，其计算量只会增加两倍。\r","keywords":["Job","Machine Learning"],"articleBody":"\r文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\rLINK1 深度学习部分 DenseNet 任意的两层之间都存在直接的链接，每一层的输入都是前面的所有层的输出的并集，而该层学习的特征图也会是后面所有层的输入，DenseBlock中需要Feature_map保持一致；\nBlock与Block之间的降采样则使用transition layer，使用BN，1*1的 conv，Pooling来降维\n优缺点：\n省参数，省计算 抗过拟合，泛化能力强 需要保存Feature占显存 EfficientNet 针对卷积神经网络的模型拓展，可以通过：1\n增加网络规模可以、 增加模型宽度，增加模型深度，增加输入图像的分辨率，但是如何去人工调整这个比例和参数，比较麻烦， 实验发现ConvNet缩放过程中平衡网络宽度、深度、和分辨率的维度是很重要的 EfficientNet就是对这些的合理组合，复合型的模型扩展技术集合神经结构搜索技术获得 关键技术复合扩张技术\n所以本文提出了复合扩张方法，这也是文章核心的地方，\n$$ \\alpha,\\beta,\\gamma $$\r是我们需要求解的一组参数，如下图公式，带约束的最优参数求解。 $$ \\alpha,\\beta,\\gamma $$\r分别衡量着depth, width和 resolution的比重，其中 $$ \\beta,\\gamma $$\r在约束上会有平方，是因为如果增加宽度或分辨率两倍，其计算量是增加四倍，但是增加深度两倍，其计算量只会增加两倍。\r固定公式中的φ=1，然后通过网格搜索（grid search）得出最优的α、β、γ，得出最基本的模型EfficientNet-B0. 固定α、β、γ的值，使用不同的φ，得到EfficientNet-B1, …, EfficientNet-B7 φ的大小对应着消耗资源的大小，相当于：\n当φ=1时，得出了一个最小的最优基础模型； 增大φ时，相当于对基模型三个维度同时扩展，模型变大，性能也会提升，资源消耗也变大。 bottleneck Bottleneck layer又称之为瓶颈层，使用的是1*1的卷积神经网络。之所以称之为瓶颈层，是因为长得比较像一个瓶颈。\n中间比较细，像一个瓶颈\n如上图所示，经过 $11 conv$ ，中间那个看起来比较细。像一个瓶颈一样。使用 $11$ 网络的一大好处就是可以大幅减少计算量。深度可分离卷积中，也有这样的设计考虑。如果想具体了解如何大幅减少计算量的话，可以参考参考资料[2]\nXavier参数初始化方法 已经写在笔记上了，但是还要补充的，或者说是理清楚的是怎么推导的或者为什么这么干的，还有其他的初始化方法之间的区别什么的\n模型压缩 为了研究小而快的机器学习模型：1. 对复杂模型进行压缩 2. 直接设计小模型得到训练\n轻量网络：MobileNet 主要的网络架构：是使用depthwise separable convolution也就是xception中提到的这种，双分离的卷积\n然后使用：ReLU6激活函数（限制最大输出为6）\n过程中不使用pooling直接使用stride=2进行下采样\n基本的组件如图所示： 最后用avg pooling从 $771024 $ 到 $111024$\n对其进行瘦身：\n按比例缩放特征图的大小 按比例缩放通道数 核心的计算量实际上在 $1*1 conv$ 这个全通道密集卷积的操作上\nV2：\n引入了shortcut（残差结构）\n在进行depthwise之前先用 $1*1$ 扩张feature_map的通道数\n是为了提升效果，参数量比1还是稍微增加了，\n这里的1*1和resnet中的是完全相反的：\n残差模块：11降维 33卷积 11升维 反残差模块：11升维，33卷积，11降维\n原因：因为depthwise卷积不能改变通道数，因此特征提取受限于输入的通道数，所以将通道数先提升上去。文中的扩展因子为6。\npointwise之后的relu改成了Linear激活函数，防止relu破坏特征\n原因：relu造成的低维度数据塌陷\nhttps://www.sohu.com/a/307566264_100024677 就是当低维信息映射到高维，经过ReLU后再映射回低维时，若映射到的维度相对较高，则信息变换回去的损失较小；若映射到的维度相对较低，则信息变换回去后损失很大。因此，认为对低维度做ReLU运算，很容易造成信息的丢失。而在高维度进行ReLU运算的话，信息的丢失则会很少。\n因为relu函数小于0时候，值为0，是有信息损耗的，而线性激活函数没有信息损耗\n轻量网络：Shufflenet V1 带Pytorch ShuffleNet的核心是采用了两种操作：pointwise group convolution和channel shuffle，这在保持精度的同时大大降低了模型的计算量。\n缓解 $1*1 conv$ 的计算量，也使用channel sparse connection，但是这种group convolution 也有弊端：特征图之间不通信，所以我们就channel shuffle（均匀打乱）\n图3.(a)是一个普通的带有残差结构的深度可分离卷积，例如，MobileNet [5], Xception [6]。ShuffleNet v1的结构如图3.(b)，3.(c)。其中3.(b)不需要降采样，3.(c)是需要降采样的情况。\nV2:\nG1). 使用输入通道和输出通道相同的卷积操作； G2). 谨慎使用分组卷积； G3). 减少网络分支数； G4). 减少element-wise操作。 通道分割在每个单元开始前将通道的输入分成两个，不再使用group卷积，然后concat两个channel并channel shuffle\n轻量网络：squeezeNET 利用Fire module 来实现了：Link Knowledge Distiall 实际上很简单，就是用小模型逼近大模型的输出，用大模型来做小模型的监督，也就是让小模型尽量去适应大模型的输出分布（原本应该只是一个类别标签），这其实已经偏向于一个无监督的驯良过程了，或者说是自监督。\n训练大模型 计算大模型的soft output 训练小模型，在类别的监督信息以外再加上soft target的loss，用lambda来调节传中 使用小模型进行预测。 超参数搜索的方法 网格搜索，随机搜索，贝叶斯优化方法（这种方法实际上还不是太清楚，后面可能还需要看看），AutoML\n激活函数的稀疏性 适应性强，针对不同的情况有不同的激活单元 简洁的模型，计算更快 更好的预测能力和更不容易过拟合 更可分 梯度消失与爆炸 消失：sigmoid ，tanh，\n误差的反向传播造作，我们可以看出这种连乘的形式涉及到了很多的参数和导数，这种时候无论是放大还是缩小的效应都很容易累加起来产生梯度的消失或者膨胀，\n当对当前层的w进行求导的时候，我们需要先对上一层的x求导，就会得到wt+1 与梯度连乘这样的式子，这也是导致梯度爆炸的原因\nsigmoid的最大输出只有1/4所以sigmoid中梯度消失实际上是更常见的时候\n再RNN中BPTT这种反向传播的时候也是类似的思路，但是它是以一个n维矩阵的方式向后传播的，这样当雅可比矩阵的特征值小于1的时候，这样的梯度传播会呈现指数级的变化，要么梯度消失要么梯度爆炸\nResNet 缓解深层网络中梯度消失的问题，实际并不是真正的解决这样的问题，只是给出了一个传播的shortcut，所以掩盖了梯度消失的情况出现，实际上ResNet解决更多的是模型退化的问题，也就是\n梯度爆炸也可以使用梯度裁剪的方法进行解决：当梯度的范数大于阈值的时候，我们对梯度进行等比的搜索，\n损失函数的反向推导 常见的几个损失函数和误差之间的关系（推一下grad的公式）\nSoftmax CE 过拟合欠拟合的判断和处理方式 过拟合的训练方法：\n获取更多数据\n降低模型的复杂度\n正则化方法：实际上这就是权重衰减的方法这里药剂的L1（直接减少有效参数的数量），L2正则化结构风险（减少权值过大带来的过拟合的风险）的那些具体定义；dropout等等。\ndrop可以理解成bagging的办法的继承实现\n集成学习方法，通过多个模型的集成来降低单一模型的过拟合风险\nearly-stop\nDROPOUT rescale\n使用 pretraining 方法也可以帮助 dropout 训练参数，在使用 dropout 时，要将所有参数都乘以 $ 1/p$\n开始时随机删除，一半P的神经元 在剩下的一般中更新， recycle，然后，最后学出来的参数的存在概率只有（1-P)所以要*概率。 欠拟合降低的方法：\n添加新特征：特征与标签之间的相关性太差，我们可能需要挖掘新的特征； 增加模型的复杂度：简单模型的学习能力可能太差了，比如在线性模型中添加高次项，增加网络的深度或者神经元个数 减少正则化参数 有监督学习中涉及到的损失函数 LINKLINE 0，1损失函数： $max{0,1-fy}$ ,标签，二分类问题 hinge损失（0，1的进化）：max{0,1-fy} 卷积 卷积的矩阵加速：https://www.mobibrw.com/2019/17787\n转置卷积：LInk1 ；LInk2 转置卷积上采样带来的棋盘效应：https://www.cnblogs.com/hellcat/p/9707204.html\n空洞卷积也会带来棋盘效应，也就是采样不均匀，有些点被重复采样，有些点没有被采样到，这样就会像棋盘一样，两种颜色分离的这种情况。\n上采样 下采样：\nSVD：https://www.cnblogs.com/endlesscoding/p/10033527.html\n正则化的具体函数和内在含义 KEYPOINT：https://www.cnblogs.com/alexanderkun/p/6922428.html\n实际上我们可以发现这也是一个权重衰减的操作，如果从导数去分析的话，或者我们数形结合，我们会发现这样的w和我们的函数曲线的交点实际上是偏向\nRegularization：在目标函数中添加惩罚项，对复杂度高的模型进行惩罚，于是考虑从W的向量出发，\n0范数：非零元素的个数，在机器学习中是个NP完全问题，很难求\n1范数：绝对值之和\n2范数，通常意义上的模，实际上从分布上来看\nL2范数是指向量各元素的平方和然后求平方根。我们让L2范数的正则项||W||2最小，可以使得W的每个元素都很小，都接近于0，但与L1范数不同，它不会让它等于0，而是接近于0，这里是有很大的区别的哦；所以大家比起1范数，更钟爱2范数。\nNormalization 重要参考资料 ；参考资料2向东的回答 权重伸缩不变性，可以有效的提高反向传播的效率，也有参数正则化的效果；\n数据伸缩不变性；减少梯度弥散，简化对学习率的选择\ncovariate shift 协方差偏移，实际上是训练集和测试集中，变量的分布的不同带来的问题，这样就会导致模型的效果收到影响，也会印象网络的迭代速度，通过BN就可以将每个mini-batch的数据都拉回到标准正态分布，把带有偏差的数据拉回标准分布，拉回模型擅长的领域中，使得梯度变大，避免梯度小时的问题出现，也能加快收敛的速度。\n帮助理解covariate shift ，更确切的来说，实际上是source domain和Target domain的数据分布不一致，他们的条件概率相同，但是边缘概率不同：\n这样会导致不再是独立同分布：\n需要不断适应输入的分布，降低学习速度\n下端的变化可能趋向于变大或者变小，容易使得上层落入饱和区，学习过早的停止\n会相互影响。\nBN，IN，LN，WN Normalization的基本框架就是 $h=f(g·\\frac{x-\\mu}{\\sigma} + b)$\n再次进行平移和缩放是为了模型的表达能力不因规范化而下降；这两个缩放因子是可以学习的，用来对底层的学习结果有所价值，这也会将数据变换到基本在非饱和区中（线性区），然后通过再次的缩放和偏移，提供了非线性。\nBNnormalization纵向\n是对同一个batch的所有图的逐channel进行的\n使用mini-batch来计算相关的均值和方差，element-wised；但是BN是独立的对每个维度（channel）进行统计的，这样的话，如果原始分布差距很大的话，会导致不同的数据训练，这样可能会增加模型的训练难度。\n适用场景：每个mini-batch比较大，数据分布比较接近，所以我们需要进行充分的shuffle，不然效果会差很多。再运行中需要统计一阶和二阶统计量，所以不适用动态的网络架构和RNN，；相应的改造就不说了\n适用于判别模型中，\nInstance Normalization\n是对单张图片的单个通道单独进行的Normalization，适用于生成模型中，比如风格迁移，主要依赖的是单张图片的实例，所以不适宜对整个batch进行归一化，这样可以加速模型收敛和保证实例之间的独立性\nGroup Normalization\n实际上就是一个normalization的变体：\nLayer Normalization 横向\n是指对同一张图片的同一层的所有通道进行的normalization，所以和公式不一样的就是不需要求M的均值了，是对同一张图片的所有channel进行的\nWegiht Normalization参数规范化\nCosineNormalization\n解释一下attention 在某种程度上，注意力是由我么如何关注视觉图像的不同区域或者我们如何关联同一个句子中的不同单词所启发的：针对于问题的不同，我们会对图像的某些具体的区域重视（某些区域在视觉中呈现高分辨率，而另一些则是低分辨率的情况），或者句子中的某些词重视的情况。\n比如我们看到eating就对food有更高的attention，与此同时color的权重就会比较低。\n因为传统的RNN架构，固定的context vector可能会导致序列信息的缺失，可能无法记住长句子和时序对齐的信息，所以诞生了attention.\ncontent vector和 attention weight加权，然后和上一个时刻的target和y，生成现在的y。\nself-attention：https://zhuanlan.zhihu.com/p/47282410；\n内部注意力，也就是内部的自我关联的获取，QKV的关系\nTransformer 的基本架构 Transformer 的 Multi-Head 实际上就是有不同的QKV表示，然后我们将其表示起来。\nmask屏蔽未来的信息\nPooling的反向传播： Pooling层的主要作用\n1、特征不变性，使模型更加关注是否存在某些特征而不是特征具体的位置，对于一些旋转和平移具有不变性 2、特征降维，使模型可以抽取更广泛围的特征，减小了下一层输入大小，进而减小计算量和参数个数\n3、在一定程度防止过拟合，更方便优化\n4、扩大感受野\navg pooling：均分后回传\nMaxPooling：只传给最大的一项，其他项的反向传播值为0\nAnchor-based和 Anchor-free的理解和辨析 实际上就是把五百问的内容再巩固一下，然后整理过来，这里还有两个比较相关的链接，到时候还不清楚就可以看下。\nhttps://www.zhihu.com/question/356551927/answer/926659692 https://zhuanlan.zhihu.com/p/62372897 Anchor-based方法：在选练之前在训练集熵使用K-Means等聚类方法聚类出一组矩形框，代表主要的长宽，然后在推理时用这些Anchor滑动提取proposal之后在对这些Anchor进行回归和分类，比如扩张和中心点预测\nAnchor-free:就是没有预先定义这样的BoundingBox，直接通过网络来预测相应的边框，比如左上角右下角，中心点这样的预测；中心点+长宽\n机器学习部分 回归任务为什么难以训练 目标更难，需要适应所有的点 损失函数的角度，MSE之类的，下降与Value相关，对Outline敏感 Selective Search HOG SIFT HOG: 手机知乎\nSelective Search：https://zhuanlan.zhihu.com/p/27467369\nSIFT：概览 ； 开贴细说 LR怎么处理低维线性不可分问题 特征工程或者使用多项式核和高斯核，将样本映射到可分的空间去进行逻辑回归；\n线性回归和逻辑回归的异同点\n实际上都是一个函数映射的问题，就是离散化和连续化的区别而已，还有其中的损失函数的设计等等\n线性回归和逻辑回归实际上都是线性模型，但是最终一个映射到连续域做拟合，另一个映射到离散域做分类，最主要的区别就在于目的，输出值域，以及损失函数的设计上。\n本质上都是一个一个线性映射函数的选择。\nLR对连续值特征是怎么处理的 离散化的作用和优势：https://notes.001.io/lian-xu-te-zheng-li-san-hua/\nLR本质上属于广义线性模型，通过进行值域的划分，相当于引入了非线性，从而提升了模型的表达能力；\n进行离散化后对异常值不敏感，能对轻微的扰动有一定的鲁棒性，但是这还是比较考验特征划分技术的\n可以对离散的特征值进行组合，进一步引入非线性\n相当于简化了逻辑回归的模型，引入模型复杂度的正则化，这样能够减少过拟合的风险。\nLR为什么要归一化 LR的求解过程不就是是梯度下降的方式，那么就是归一化的作用了没什么好说的\n集成学习方法 Boosting 基学习器，做错的样本受到更多的关注，然后调整后的样本分布进行下一个基学习器的训练（AdaBoost）\n对特定的数据分布进行学习，实际上就像是re-weighting的这样的操作；如果不能使用这种方法的模型我们就使用re-sampling的操作来处理。\n过程中如果不满足比随机猜测好，这种模型就直接停止 可以看出这种方法主要关注降低偏差，可以对弱学习器构建出很强的集成 Bagging与随机森林 又放回的随机抽取样本构建包含m个的数据集，采样出T个这样的数据集，然后对这些基学习器进行结合，（简单投票做分类，简单平均做回归）\n随机森林是在以决策树为基础构建的基学习器，在bagging的基础上，引入了随机的属性选择（原本是选择最优的），也就是先选择一个随机的子集，然后在子集中选择最优的用来划分。\nGBDT和XGBoost GBDT实际上就是BOOSTing的一种方法\n都是通过损失函数相对于模型的负梯度方向来对当前的模型进行更新，但是在梯度下降里，我们的模型是通过参数表示的，而在梯度提升，是在函数空间中直接表示的。\n通俗一点的说的话，实际上就是梯度下降是在更新梯度来进行梯度下降，梯度提升通过累加弱学习器来梯度下降。\n关键：实际上在梯度提升中，梯度最终会被计算为（当作）残差，也就是用损失函数的负梯度去模拟残差\n参考链接，里面也有提到区别 ；简单的实例分析 GBDT：Gradient Boosting Descend Tree\nGBDT分类和回归时的基学习器都是CART分类回归LINK 树，每轮迭代在上一个基学习器结果的残差至上进行训练，（弱分类器）；\n这里的残差可以更改为损失函数，然后最后还是会变成对残差的一个拟合，模型的残差实际上也不是这么好弄的，用损失函数的负梯度，来拟合本轮损失的近似值。然后就是从上到下一个个基学习器过去\n不同的损失函数针对的是不同的问题（分类回归）\n分类问题：指数损失函数和对数损失函数 回归问题：均方差损失函数，绝对值损失函数 GBDT的正则化：\n给每个模型乘上一个弱化系数，降低每个模型对拟合损失的贡献 通过按比例来随机抽取样本训练模型，bagging，减少方差但是会增加偏差，可以使用交叉验证 控制CART的复杂度，可以使用剪枝正则化 优缺点：\n灵活，准确率高，使用健壮的损失函数可以处理异常值 难以并行化处理，受限于基学习器之间的依赖关系 XGBoost\n详细讲解XGBoost ；\n和残差然后用CART拟合不同，我们是通过SCORE来确定结构，然后通过梯度的值来计算结构中应该有的值， 所以在我们计算完二阶梯度的时候，我们能同步的进行划分和复制，这样，但是还有为为什么要排序后去做，我有点没搞明白\n两种方法的区别：\n正则化防止过拟合，提升泛化能力 L1+L2 还可以使用线性分类器 使用了二阶导数信息来进行对代价函数的优化 采用和随机森林类似的策略，能对数据进行采样，降低过拟合和减少计算 有缩减项，类似weight decay 能计算出缺失值的分裂方向 可并行计算 划分的方式改成了一个Score（根据两阶段梯度数据） SVM细节 在SVM推导部分的后面添加最终的形式以及整理一下KKT条件，通过这些特性对一些问题进行分析\n为什么将原问题转化成对偶问题 对偶问题将原始问题中的不等式约束转为了对偶问题中的等式约束 方便核函数的引入,输入最终会转化从恒一种内积的形式 改变了问题的复杂度。由求特征向量w转化为求比例系数a，在原始问题下，求解的复杂度与样本的维度有关，即w的维度。在对偶问题下，只与样本数量有关。 怎么转化到多分类的场景 不是逐个二分吗？\nhinge损失的多分类形式：https://www.turingtopia.com/article/details/e2492b497a144bf6b3cd1fc62df60bbd\nLagrange乘数法，对偶问题 二次型函数 A是实对称矩阵\n$$ f(x)=x^TAx\r$$\r在 $R^N$ 上是凸函数和A是半正定矩阵是充要的关系；\n凸规划：目标函数是凸函数，约束空间是凸集\nMP是凸规划的条件：满足。。。\n为什么凸规划是重要的，因为凸规划的任意局部最优值都是他的整体最优解\n凸优化问题Lagrange：\n引入松弛变量/kkt乘子，将不等式约束转化为等式约束， 引入拉格朗日乘子将等式约束转为无约束优化 KKT条件：MP（非线性规划）问题，可微可行点 $x^*$ 是整体最有解的条件 实际上是在凸规划的最优值求解过程中，使用拉格朗日乘数法，其中的不等式约束（\u003c=0）需要满足的条件，其中：\n求解Largrange，KT条件的时候我们通常使用互补松紧条件入手来求解（分情况讨论，但是这种时候要考虑分类的完备性来进行求解。）\n对偶条件的引出 在线性规划的过程中可以使用对偶问题来进行转化，将求最大转化为求最小值；如果LP问题又最优解，则对偶问题也有最优解，且解相同\nSVM的具体推导以及核函数 再生希尔伯特空间，\n于是我们可以选择多项式核，高斯核，拉普拉斯核之类的来做这个核函数映射\n核函数的记忆\n相关的面试问题 SVM和LR的联系与区别：\n他们都是分类算法，都是监督学习的模型\n都是判别模型，如果不考虑核函数的话，都是线性分类算法\nLR采用log损失，SVM采用合页（hinge）损失\nLR基于概率理论，使用sigmoid和MLE来估计出参数的值；SVM基于几何的边界最大化原理\nLR对异常值敏感，SVM不\n对海量数据来说LR效率高，在低纬度的时候LR的准确率高，但是维度上升就被反超\n处理线性不可分：LR靠特征构造（组合交叉特征，特征离散化），SVM 还可以核函数\nLR是经验风险最小化，SVM自带结构风险最小化（自带了L2正则项所以）\n将数据向SVM求得的超平面进行投影后，是否仍然线性可分？（数学推导，这里的推导我放弃）\n显然不，从支持向量的角度分析，最优的结论必然是两点的中垂线，那么这种情况本身并不是线性可分的，但是如果超平面不是这个中出现的话，那么就不满足SVM求解条件中的最优分界面了。\n70页开始，但是我决定先推导SVM，这一部分的内容再说吧\n是否一定存在一组参数使得SVM的训练误差为0？\n训练误差为0的SVM分类器一定存在吗？\n加入松弛变量的SVM训练误差可以为0吗？\n决策树 3种分支计算的方法：信息增益，增益率，gini指数\n预剪枝，后剪枝\n是否会重复利用连续值或者离散值特征来分树？\n离散特征不行，比如用西瓜的纹理来说：就是有没有了\n连续特征可以，阈值切割，我们可以不断的往下细分，比如\u003c100 \u003c50这样。\nPCA与LDA 优化的目标：最大化投影方差， 在主轴上的投影方差最大，包含更多的信息量（信噪比的概念）。\n通过这个思想去设计一个求解过程：中心化（为了使得投影后均值为0），然后求方差，然后推导出最大化问题，然后通过largrange乘数法，推出实际上就是特征值。\nLDA投影到的是便于分类的，PCA是方差最大信息量最大的去除冗余的信息维度；无监督有监督\nBoosting与Bagging bagging 解决的是过拟合，boosting解决的是欠拟合的方法\n这里需要重新再去温习一下基本的定义\nMAP、MLE、Bayesian https://blog.csdn.net/u011508640/article/details/72815981/ https://zhuanlan.zhihu.com/p/61593112 从数学意义上和模型上区分 显然基于bayesian公式我们可以区分后验和先验，以及使用贝叶斯公式去获得估计的基本依据是啥。（要看清楚似然的主体是啥，也就是求解的参数是那个）\n$$ P(\\theta | D)(后验概率 ) = \\frac{P(D|\\theta)(似然函数)P(\\theta)(先验)}{\\sum P(D|\\theta)P(\\theta)}\r$$\r这里的P实际上可以看成一个概率分布模型，一个推断模型（其中的D和θ一个是模型的数据一个是模型的参数）\n前两者将\n那么MLE（极大似然）：（频率学派，假设为定制）\n我们把模型参数设置成θ（变量）然后，我们计算当θ等于多少的时候出现D这个数据的概率最大，（这样的话也就会引出我们对大量数据的需求，实际上是一个概率估计模型）\n而MAP（最大后验概率）（和👇一样是贝叶斯学派，θ是随机数）\n是贝叶斯估计的一种近似\n也就是我们考虑了参数发生或者出现的先验概率以后再进行计算，由于上式的分母P(D)是个确定的值，所以不影响最大化的过程，我们通常再计算的时候将其忽略，然后最大化分子，就是MAP了，在这里这一步的prior是非常重要的，和我们之后的模型估计息息相关。\n最后Bayesian估计\n其中MAP估计的是后验的最大值，而贝叶斯估计是去近似这个后验函数，基于贝叶斯公式去做这个估计。（去看看数据挖掘中的这部分的题目来帮助理解）\n朴素贝叶斯问题 看看数据挖掘中的那个讲稿，就很清楚，实际上就是类关系条件独立假设；\n可以使用laplace校准来避免0概率对决策造成影响\n那什么是朴素贝叶斯学习呢？\n交叉熵 KL散度 信息熵 https://blog.csdn.net/b1055077005/article/details/100152102 无监督方法 K均值聚类的有优缺点：\n受离群值影响，通常是局部最优解，类别量级和密度的问题没法解决 需要人工确定k 样本只能被划分到单一的类中 如何调优：\n数据归一化，离群点处理 合理选择K值 核函数 证明K means 收敛：和EM算法实际上是一个框架，这里看一下关系\nGMM：高斯混合模型 假定不同簇种的样本各自符合不同的高斯分布，这种得到的聚类算法就是高斯混合模型；\n$$ P(x) = \\sum_{i=1}{K}\\pi_iN(x|\\mu_i,)\r$$\r核心思想是：每个单独的分模型都是标准高斯模型，我们需要估计高斯分布的双参数，还有一个额外参数（权重或者生成数据的概率），实际上和K均值聚类是一样的操作过程，这里要记得EM。\n使用极大似然（很难求解）去寻找均值方差和权重，所以最后使用EM去做\n随机初始化参数， E：根据当前参数，计算每个点由某个分模型生成的概率 M：根据概率，来改进每个分模型的均值方差和权重 SOM：自组织映射神经网络 nah\n聚类算法的评估：\n轮廓系数；霍普金斯统计量；R方\n数据清洗 没用到就不说了，在数据挖掘中主要是：缺失数据，错误数据，和噪声数据\n错误数据：分析更改删除和忽略\n缺失数据：忽略，手工，填充（全局常量，属性或者中位数，基于贝叶斯等等方法（这个不提））\n噪声数据：分箱（均值平滑，中值平滑，边界平滑），聚类，回归，人工检查\n图像增强策略 torchvision.transformers的库里面有很多，还有unbalance_image中有一些经典的unbalance_image的一些策略\n还有PIL中的Image.Enhance(这里可能要注意图像维度的转换)\n1、对比度：白色画面(最亮时)下的亮度除以黑色画面(最暗时)下的亮度；\n2、色彩饱和度：：彩度除以明度，指色彩的鲜艳程度，也称色彩的纯度；\n3、色调：向负方向调节会显现红色，正方向调节则增加黄色。适合对肤色对象进行微调；\n4、锐度：是反映图像平面清晰度和图像边缘锐利程度的一个指标。\nMixUp的操作实际上就不要在赘述了，而Sharpen的操作实际上就是对分子分母都做一个1/T的乘方的这样一个锐化的操作，突出显著的样例，这样能够使得：？（需要加强记忆）\n评估模块 ROC、PR、F1 PR曲线就比较清楚是根据Precision和recall区划分的，然后根据判定为正负样本的阈值去区分这个曲线的情况。\nROC曲线是根据 TPR和FPR真阳性率（正样本中有多少被判定为真）和伪阳性率（负样本中有多少被判定为真），依据score的阈值来绘制曲线\nAUC越大，说明分类器越可能把真正的正样本放在前面\n还有F1，是综合反应一个排序模型的性能(调和平均值)：\n$$ F1 = \\frac {2*precision * recall}{precision + recall}\r$$\rROC比起PR来说，对于正负样本数据量的分布比较不敏感，所以在这种数据不均衡的大数据场景，ROC更合适，更广泛。如果是针对特定数据集上的表现的话实际上PR曲线的话能更直观的反应性能\nRMSE 离群点可能导致效果一直很差，可以用归一化的百分比来看\n余弦相似度 实际上就是将问题从距离转换到了角度上，用1-cos(A,B)表示余弦距离，实际上这种距离比起欧氏距离来说，能够适应更高的维度，比较相对差异的时候我们可以考虑用余弦相似度来衡量\n不满足三角不等式：等腰直角三角形\n在机器学习领域，还有kl距离，相对熵，也能衡量两个分布之间的距离，但是也不满足对称性和三角不等式\n训练集和测试集的划分机制 K次交叉验证法；\n首先描述一下什么是k次交叉验证，k次交叉验证的作用是：评估模型的预测性能，训练好的模型再新数据上的表现，在一定程度上减少过拟合，从有限数据中获取尽可能多的有效信息，使得模型对于数据的划分不那么敏感\nHandout检验：实际上就是7：3的随机划分的方式；其中还有留一划分的策略；\n自助法（bootstrap）：有放回的随机抽样，总数为n的集合，抽样n次作为训练集，剩下的没有被抽样出来的数据作为测试集，这就是自助法的验证过程\n当抽样次数趋向于无穷的时候，有多少数据没有被选择过， $(1-\\frac{1}{n})^n$ 取极限，根据重要极限 $(1+\\frac{1}{n})^n$ 的极限是e，可以推得大概是1/e的概率没被选中，也就是大概百分之36%， （59页） 语言部分 Python部分 深拷贝浅拷贝 概念上是一致的，但是具体实现深拷贝上，是不一样的，python 应该是自带的.copy函数\nhttps://www.jianshu.com/p/a71c09798123 )\n修饰符的作用 修饰符的作用python函数修饰符@的作用是为现有函数增加额外的功能，常用于插入日志、性能测试、事务处理等等。\n实际上就是讲函数作为作为输入参数，然后对函数进行包装，在执行函数之前或者之后增加一些操作，通常用来指示函数执行进程，也可以用来添加数据预处理等等\nLINK REFERENCE 1 2 3 4 5 6 7 8 9 10 11 12 def log(func): def wrapper(): print('log开始 ...') func() print('log结束 ...') return wrapper @log def test(): print('test ..') test() 多线程处理 一些基本的概念： 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。\n指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。\n线程可以被抢占（中断）。 在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） – 这就是线程的退让。 使用threading作为线程处理模块： run start join([timr])：等待至线程终止；isAlive() getName() setName()\nappend():添加到线程列表，使用for i in threads: i.join() 来等待所有线程完成。\n首先通过继承threading.thread创建子类，实现run操作； 实例化之后使用start启动进程； 线程同步（Lock） Lock和Rlock 都有相应acquire和release，\n防止多个线程同时对某个数据进行修改，就需要对多个线程进行同步；\nPython 中多线程和多进程的区别 这一点还是需要补充，好像是使用什么来着\n主要从进程和线程本身的区别来谈，然后Python中的多线程是收到了Cpython的GIL约束的，所以稍微有点鸡肋，可能还是要用多进程去了解\n[参考链接](\n文件IO部分 文件处理： 读取键盘输入：a = input('请输入：')；\n打开和关闭文件：open()，一般需要按照指定的格式打开一个文件才能对其进行修改或者读取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 fo = open(\"foo.ext\",\"w\") fo.close() # 相应的文件的读写实际上应该是 fo.write(\"dadsad\") res = fo.read(10) # 使用tell 和seek输出和定位当前的文件位置， # 实际上经常和with命令一起使用 with open(path,\"w\",encoding='utf-8') as f : # record the dir name (depth=1) f.writelines(authorres) # record all the video for element in result: f.write(element) 补充说明： 这里with语句的解析 OS命令 chmod，chdir，chown，mkdir，path（一系列常用操作，exist之类的），getcwd（返回当前工作区），listdir（返回文件夹包含的文件或者文件夹的列表）\nC++部分 实际上c++对于编写的顺序是有上下关系的，如果我们定义的时候遇到了一些上面和下面的差别的时候，我们可以考虑在上面先进行declaration，在后面在具体的进行definition。\n文件操作： 基本读写 写文件步骤如下：\n包含头文件 #include 创建流对象 ofstream ofs;\n打开文件ofs.open(\"文件路径\",打开方式);\n写数据ofs \u003c\u003c \"写入的数据\";\n关闭文件ofs.close();\n读文件的操作步骤如下\n包含头文件 #include 创建流对象 ifstream ifs;\n打开文件并判断文件是否打开成功 ifs.open(“文件路径”,打开方式);\n读数据 四种方式读取\n关闭文件 ifs.close();\n处理二进制文件 二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream\u0026 write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n打开方式要指定为 ios::binary；\n二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream\u0026 read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n预编译头 首先介绍的是如何防止在重复的include的时候,不会导致重复的定义和include的方式，以及其中的区别\n#pragma once：自定义包含了这种情况的时候，依赖于不会将同一个文件多次编译，这个方式没办法保证内容相同的不同名文件被重复的编译，针对的是文件。\n#ifndef ：依赖于宏名称不能冲突，这个能保证内容相同的不同文件不小心被同时包含，实际上是一个预编译的条件语句\n首先介绍一下写法：\n1 2 3 4 5 基本的逻辑也就是当我们第一次执行的时候，就会预先定义到这一块，这样到时候就不会导致相应部分的代码被重复的执行或者定义 #ifndef _code_block #define _code_block // code here #endif 在自己编写的时候需要注意不能重复使用宏名（_code_block），不然可能会出现以外的其他地方的代码没有被执行。\n多线程 mutex互斥锁\n内存分区模型 主要将内存分为四个区域:\n代码区：存放函数的二进制代码，由操作系统进行管理\n程序运行前进行分配\n存放CPU执行的机器指令，具体而言代码区是共享的和只读的\n全局区：存放全局变量、静态变量和常量\n这部分空间应该是在预编译的时候事先分配的\n该部分的数据再程序结束后由操作系统释放\n栈区：由编译器制动分配和释放，存放函数的参数值，局部变量等\n堆区：由程序员分配和释放，如果程序员不释放，程序结束后由操作系统回收；\n（类内的存储特点）：\n在c++中，类内的成员变量和成员函数分开存储，只有非静态的成员变量才属于类的对象上的存储。（函数也是不占对象空间的，所有的函数共享一个函数实例）\n（static）静态成员函数在编译阶段分配内存，类内声明类外初始化，所有的对象共享同一份数据；\n类： THIS指针 指向的是，当前调用的这个 对象；\n友元friend： 通过friend关键词告诉编译器其他的可以访问类中私有内容的东西；\n友元可以是：\n函数 类 其他类别的成员函数 继承 构造函数顺序\n继承的时候首先调用父类的构造函数，在构造子类的构造函数，析构是反向的。\n几种继承方式\n注意区分继承方式面临的主体，也就是说：\n派生类能访问的元素实际上都是除了私有类都能访问 区别在于我们是否能通过派生类的实例对基类的变量进行访问，这里的继承方式就代表着这些变量在被继承之后的状态，是私有的保护的，还是公共的 父子的成员同名\n无论是不是静态，都是：\n访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 多态 多态是C++面向对象三大特性之一\n多态分为两类\n静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别：\n静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n3. 拥有纯虚析构函数的类也属于抽象类\r常用STL函数 for_each：遍历容器 transform：搬运容器中的数据到另一个容器中 accumulate：计算容器的元素综合 fill：向容器中添加元素 replace_if find_if set_union：求两个容器的并集 set_intersection：求两个容器的交集 通用部分： 深拷贝和浅拷贝的概念： 浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n同步与异步 ","wordCount":"826","inLanguage":"en","image":"https://aikenh.cn/cover/cover23.jpeg","datePublished":"2021-04-23T01:43:43Z","dateModified":"2021-04-23T01:43:43Z","author":[{"@type":"Person","name":"aikenhong"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://aikenh.cn/hugotest/posts/intview_%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/"},"publisher":{"@type":"Organization","name":"aiken's blog","logo":{"@type":"ImageObject","url":"https://aikenh.cn/favicon/ghost.ico"}}}</script></head><body id=top><script type=module src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.esm.js defer></script><script nomodule src=https://cdn.jsdmirror.com/npm/ionicons@7.1.0/dist/ionicons/ionicons.js defer></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aikenh.cn/hugotest/ accesskey=h title="aiken's blog (Alt + H)">aiken's blog</a><div class=logo-switches><button id=theme-toggle-nav accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aikenh.cn/hugotest/ title=home><span>home</span></a></li><li><a href=https://aikenh.cn/hugotest/posts/ title=posts><span>posts</span></a></li><li><a href=https://aikenh.cn/hugotest/tags/ title=tags><span>tags</span></a></li><li><a href=https://aikenh.cn/hugotest/categories/ title=categories><span>categories</span></a></li><li><a href=https://aikenh.cn/hugotest/archives/ title=archives><span>archives</span></a></li><li><a href=https://aikenh.cn/hugotest/about/ title=about><span>about</span></a></li><li><a href=https://aikenh.cn/hugotest/search title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><div class=sidebar><ul><li class=logo style=--bg:#333><a href=#><div class=logo-icon><img src=/logo/logo.png></div><div class=logo-text>Aiken's Blog</div></a></li><div class=menulist><li style=--bg:#f44336><a href=https://aikenh.cn/hugotest/ title=home><div class=logo-icon><ion-icon name=home-outline></ion-icon></div><div class=logo-text>home</div></a></li><li style=--bg:#b145e9><a href=https://aikenh.cn/hugotest/posts/ title=posts><div class=logo-icon><ion-icon name=newspaper-outline></ion-icon></div><div class=logo-text>posts</div></a></li><li style=--bg:#0f93c7><a href=https://aikenh.cn/hugotest/tags/ title=tags><div class=logo-icon><ion-icon name=pricetags-outline></ion-icon></div><div class=logo-text>tags</div></a></li><li style=--bg:#ffa117><a href=https://aikenh.cn/hugotest/categories/ title=categories><div class=logo-icon><ion-icon name=grid-outline></ion-icon></div><div class=logo-text>categories</div></a></li><li style=--bg:#0fc70f><a href=https://aikenh.cn/hugotest/archives/ title=archives><div class=logo-icon><ion-icon name=folder-outline></ion-icon></div><div class=logo-text>archives</div></a></li><li style=--bg:#d16111><a href=https://aikenh.cn/hugotest/about/ title=about><div class=logo-icon><ion-icon name=person></ion-icon></div><div class=logo-text>about</div></a></li><li style=--bg:#15c095><a href=https://aikenh.cn/hugotest/search title="search (Alt + /)" accesskey=/><div class=logo-icon><ion-icon name=search></ion-icon></div><div class=logo-text>search</div></a></li></div><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt +T)"><li><div class=logo-icon id=moon><ion-icon name=moon-outline></ion-icon></div><div class=logo-icon id=sun><ion-icon name=sunny-outline></ion-icon></div></li></button></div></ul></div><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aikenh.cn/hugotest/>Home</a>&nbsp;»&nbsp;<a href=https://aikenh.cn/hugotest/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">经典深度学习与机器学习算法</h1><div class=post-meta><span title='2021-04-23 01:43:43 +0000 UTC'>April 23, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;826 words&nbsp;·&nbsp;aikenhong&nbsp;·&nbsp;<a href=/tags/job> Job</a>&nbsp;·&nbsp;<a href=/tags/machine-learning> Machine Learning</a>&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/IntView_%e9%9d%a2%e8%af%95%e8%a1%a5%e5%85%85.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://aikenh.cn/cover/cover23.jpeg alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e9%83%a8%e5%88%86 aria-label=深度学习部分>深度学习部分</a><ul class=header-level-2><li><a href=#densenet aria-label=DenseNet>DenseNet</a></li><li><a href=#efficientnet aria-label=EfficientNet>EfficientNet</a></li><li><a href=#bottleneck aria-label=bottleneck>bottleneck</a></li><li><a href=#xavier%e5%8f%82%e6%95%b0%e5%88%9d%e5%a7%8b%e5%8c%96%e6%96%b9%e6%b3%95 aria-label=Xavier参数初始化方法>Xavier参数初始化方法</a></li><li><a href=#%e6%a8%a1%e5%9e%8b%e5%8e%8b%e7%bc%a9 aria-label=模型压缩>模型压缩</a><ul class=header-level-3><li><a href=#%e8%bd%bb%e9%87%8f%e7%bd%91%e7%bb%9cmobilenet aria-label=轻量网络：MobileNet>轻量网络：MobileNet</a></li><li><a href=#%e8%bd%bb%e9%87%8f%e7%bd%91%e7%bb%9cshufflenet aria-label=轻量网络：Shufflenet>轻量网络：Shufflenet</a></li><li><a href=#%e8%bd%bb%e9%87%8f%e7%bd%91%e7%bb%9csqueezenet aria-label=轻量网络：squeezeNET>轻量网络：squeezeNET</a></li><li><a href=#knowledge-distiall aria-label="Knowledge Distiall">Knowledge Distiall</a></li></ul></li><li><a href=#%e8%b6%85%e5%8f%82%e6%95%b0%e6%90%9c%e7%b4%a2%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=超参数搜索的方法>超参数搜索的方法</a></li><li><a href=#%e6%bf%80%e6%b4%bb%e5%87%bd%e6%95%b0%e7%9a%84%e7%a8%80%e7%96%8f%e6%80%a7 aria-label=激活函数的稀疏性>激活函数的稀疏性</a></li><li><a href=#%e6%a2%af%e5%ba%a6%e6%b6%88%e5%a4%b1%e4%b8%8e%e7%88%86%e7%82%b8 aria-label=梯度消失与爆炸>梯度消失与爆炸</a></li><li><a href=#%e6%8d%9f%e5%a4%b1%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%8d%e5%90%91%e6%8e%a8%e5%af%bc aria-label=损失函数的反向推导>损失函数的反向推导</a></li><li><a href=#%e8%bf%87%e6%8b%9f%e5%90%88%e6%ac%a0%e6%8b%9f%e5%90%88%e7%9a%84%e5%88%a4%e6%96%ad%e5%92%8c%e5%a4%84%e7%90%86%e6%96%b9%e5%bc%8f aria-label=过拟合欠拟合的判断和处理方式>过拟合欠拟合的判断和处理方式</a></li><li><a href=#%e6%9c%89%e7%9b%91%e7%9d%a3%e5%ad%a6%e4%b9%a0%e4%b8%ad%e6%b6%89%e5%8f%8a%e5%88%b0%e7%9a%84%e6%8d%9f%e5%a4%b1%e5%87%bd%e6%95%b0 aria-label=有监督学习中涉及到的损失函数>有监督学习中涉及到的损失函数</a></li><li><a href=#%e5%8d%b7%e7%a7%af aria-label=卷积>卷积</a></li><li><a href=#%e6%ad%a3%e5%88%99%e5%8c%96%e7%9a%84%e5%85%b7%e4%bd%93%e5%87%bd%e6%95%b0%e5%92%8c%e5%86%85%e5%9c%a8%e5%90%ab%e4%b9%89 aria-label=正则化的具体函数和内在含义>正则化的具体函数和内在含义</a></li><li><a href=#normalization aria-label=Normalization>Normalization</a><ul class=header-level-3><li><a href=#covariate-shift aria-label="covariate shift">covariate shift</a></li><li><a href=#bninlnwn aria-label=BN，IN，LN，WN>BN，IN，LN，WN</a></li></ul></li><li><a href=#%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8battention aria-label=解释一下attention>解释一下attention</a><ul class=header-level-3><li><a href=#transformer-%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%9e%b6%e6%9e%84 aria-label="Transformer 的基本架构">Transformer 的基本架构</a></li></ul></li><li><a href=#pooling%e7%9a%84%e5%8f%8d%e5%90%91%e4%bc%a0%e6%92%ad aria-label=Pooling的反向传播：>Pooling的反向传播：</a></li><li><a href=#anchor-based%e5%92%8c-anchor-free%e7%9a%84%e7%90%86%e8%a7%a3%e5%92%8c%e8%be%a8%e6%9e%90 aria-label="Anchor-based和 Anchor-free的理解和辨析">Anchor-based和 Anchor-free的理解和辨析</a></li></ul></li><li><a href=#%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e9%83%a8%e5%88%86 aria-label=机器学习部分>机器学习部分</a><ul class=header-level-2><li><a href=#%e5%9b%9e%e5%bd%92%e4%bb%bb%e5%8a%a1%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9a%be%e4%bb%a5%e8%ae%ad%e7%bb%83 aria-label=回归任务为什么难以训练>回归任务为什么难以训练</a></li><li><a href=#selective-search-hog-sift aria-label="Selective Search HOG SIFT">Selective Search HOG SIFT</a></li><li><a href=#lr%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86%e4%bd%8e%e7%bb%b4%e7%ba%bf%e6%80%a7%e4%b8%8d%e5%8f%af%e5%88%86%e9%97%ae%e9%a2%98 aria-label=LR怎么处理低维线性不可分问题>LR怎么处理低维线性不可分问题</a><ul class=header-level-3><li><a href=#lr%e5%af%b9%e8%bf%9e%e7%bb%ad%e5%80%bc%e7%89%b9%e5%be%81%e6%98%af%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86%e7%9a%84 aria-label=LR对连续值特征是怎么处理的>LR对连续值特征是怎么处理的</a></li><li><a href=#lr%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%bd%92%e4%b8%80%e5%8c%96 aria-label=LR为什么要归一化>LR为什么要归一化</a></li></ul></li><li><a href=#%e9%9b%86%e6%88%90%e5%ad%a6%e4%b9%a0%e6%96%b9%e6%b3%95 aria-label=集成学习方法>集成学习方法</a><ul class=header-level-3><li><a href=#boosting aria-label=Boosting>Boosting</a></li><li><a href=#bagging%e4%b8%8e%e9%9a%8f%e6%9c%ba%e6%a3%ae%e6%9e%97 aria-label=Bagging与随机森林>Bagging与随机森林</a></li><li><a href=#gbdt%e5%92%8cxgboost aria-label=GBDT和XGBoost>GBDT和XGBoost</a></li></ul></li><li><a href=#svm%e7%bb%86%e8%8a%82 aria-label=SVM细节>SVM细节</a><ul class=header-level-3><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%b0%86%e5%8e%9f%e9%97%ae%e9%a2%98%e8%bd%ac%e5%8c%96%e6%88%90%e5%af%b9%e5%81%b6%e9%97%ae%e9%a2%98 aria-label=为什么将原问题转化成对偶问题>为什么将原问题转化成对偶问题</a></li><li><a href=#%e6%80%8e%e4%b9%88%e8%bd%ac%e5%8c%96%e5%88%b0%e5%a4%9a%e5%88%86%e7%b1%bb%e7%9a%84%e5%9c%ba%e6%99%af aria-label=怎么转化到多分类的场景>怎么转化到多分类的场景</a></li><li><a href=#lagrange%e4%b9%98%e6%95%b0%e6%b3%95%e5%af%b9%e5%81%b6%e9%97%ae%e9%a2%98 aria-label=Lagrange乘数法，对偶问题>Lagrange乘数法，对偶问题</a></li><li><a href=#%e5%af%b9%e5%81%b6%e6%9d%a1%e4%bb%b6%e7%9a%84%e5%bc%95%e5%87%ba aria-label=对偶条件的引出>对偶条件的引出</a></li><li><a href=#svm%e7%9a%84%e5%85%b7%e4%bd%93%e6%8e%a8%e5%af%bc%e4%bb%a5%e5%8f%8a%e6%a0%b8%e5%87%bd%e6%95%b0 aria-label=SVM的具体推导以及核函数>SVM的具体推导以及核函数</a></li><li><a href=#%e7%9b%b8%e5%85%b3%e7%9a%84%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98 aria-label=相关的面试问题>相关的面试问题</a></li></ul></li><li><a href=#%e5%86%b3%e7%ad%96%e6%a0%91 aria-label=决策树>决策树</a></li><li><a href=#pca%e4%b8%8elda aria-label=PCA与LDA>PCA与LDA</a></li><li><a href=#boosting%e4%b8%8ebagging aria-label=Boosting与Bagging>Boosting与Bagging</a></li><li><a href=#mapmlebayesian aria-label=MAP、MLE、Bayesian>MAP、MLE、Bayesian</a><ul class=header-level-3><li><a href=#%e4%bb%8e%e6%95%b0%e5%ad%a6%e6%84%8f%e4%b9%89%e4%b8%8a%e5%92%8c%e6%a8%a1%e5%9e%8b%e4%b8%8a%e5%8c%ba%e5%88%86 aria-label=从数学意义上和模型上区分>从数学意义上和模型上区分</a></li><li><a href=#%e6%9c%b4%e7%b4%a0%e8%b4%9d%e5%8f%b6%e6%96%af%e9%97%ae%e9%a2%98 aria-label=朴素贝叶斯问题>朴素贝叶斯问题</a></li></ul></li><li><a href=#%e4%ba%a4%e5%8f%89%e7%86%b5-kl%e6%95%a3%e5%ba%a6-%e4%bf%a1%e6%81%af%e7%86%b5 aria-label="交叉熵 KL散度 信息熵">交叉熵 KL散度 信息熵</a></li><li><a href=#%e6%97%a0%e7%9b%91%e7%9d%a3%e6%96%b9%e6%b3%95 aria-label=无监督方法>无监督方法</a><ul class=header-level-3><li><a href=#gmm%e9%ab%98%e6%96%af%e6%b7%b7%e5%90%88%e6%a8%a1%e5%9e%8b aria-label=GMM：高斯混合模型>GMM：高斯混合模型</a></li><li><a href=#som%e8%87%aa%e7%bb%84%e7%bb%87%e6%98%a0%e5%b0%84%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c aria-label=SOM：自组织映射神经网络>SOM：自组织映射神经网络</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e6%b8%85%e6%b4%97 aria-label=数据清洗>数据清洗</a></li><li><a href=#%e5%9b%be%e5%83%8f%e5%a2%9e%e5%bc%ba%e7%ad%96%e7%95%a5 aria-label=图像增强策略>图像增强策略</a></li><li><a href=#%e8%af%84%e4%bc%b0%e6%a8%a1%e5%9d%97 aria-label=评估模块>评估模块</a><ul class=header-level-3><li><a href=#rocprf1 aria-label=ROC、PR、F1>ROC、PR、F1</a></li><li><a href=#rmse aria-label=RMSE>RMSE</a></li><li><a href=#%e4%bd%99%e5%bc%a6%e7%9b%b8%e4%bc%bc%e5%ba%a6 aria-label=余弦相似度>余弦相似度</a></li></ul></li><li><a href=#%e8%ae%ad%e7%bb%83%e9%9b%86%e5%92%8c%e6%b5%8b%e8%af%95%e9%9b%86%e7%9a%84%e5%88%92%e5%88%86%e6%9c%ba%e5%88%b6 aria-label=训练集和测试集的划分机制>训练集和测试集的划分机制</a></li></ul></li><li><a href=#%e8%af%ad%e8%a8%80%e9%83%a8%e5%88%86 aria-label=语言部分>语言部分</a><ul class=header-level-2><li><a href=#python%e9%83%a8%e5%88%86 aria-label=Python部分>Python部分</a><ul class=header-level-3><li><a href=#%e6%b7%b1%e6%8b%b7%e8%b4%9d%e6%b5%85%e6%8b%b7%e8%b4%9d aria-label=深拷贝浅拷贝>深拷贝浅拷贝</a></li><li><a href=#%e4%bf%ae%e9%a5%b0%e7%ac%a6%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=修饰符的作用>修饰符的作用</a></li><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%a4%84%e7%90%86 aria-label=多线程处理>多线程处理</a><ul class=header-level-4><li><a href=#%e4%b8%80%e4%ba%9b%e5%9f%ba%e6%9c%ac%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=一些基本的概念：>一些基本的概念：</a></li><li><a href=#%e4%bd%bf%e7%94%a8threading%e4%bd%9c%e4%b8%ba%e7%ba%bf%e7%a8%8b%e5%a4%84%e7%90%86%e6%a8%a1%e5%9d%97 aria-label=使用threading作为线程处理模块：><strong>使用threading作为线程处理模块：</strong></a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5lock aria-label=线程同步（Lock）>线程同步（Lock）</a></li><li><a href=#python-%e4%b8%ad%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%92%8c%e5%a4%9a%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="Python 中多线程和多进程的区别">Python 中多线程和多进程的区别</a></li></ul></li><li><a href=#%e6%96%87%e4%bb%b6io%e9%83%a8%e5%88%86 aria-label=文件IO部分>文件IO部分</a><ul class=header-level-4><li><a href=#%e6%96%87%e4%bb%b6%e5%a4%84%e7%90%86 aria-label=文件处理：>文件处理：</a></li><li><a href=#os%e5%91%bd%e4%bb%a4 aria-label=OS命令>OS命令</a></li></ul></li></ul></li><li><a href=#c%e9%83%a8%e5%88%86 aria-label=C++部分>C++部分</a><ul class=header-level-3><li><a href=#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c aria-label=文件操作：>文件操作：</a><ul class=header-level-4><li><a href=#%e5%9f%ba%e6%9c%ac%e8%af%bb%e5%86%99 aria-label=基本读写>基本读写</a></li><li><a href=#%e5%a4%84%e7%90%86%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6 aria-label=处理二进制文件>处理二进制文件</a></li></ul></li><li><a href=#%e9%a2%84%e7%bc%96%e8%af%91%e5%a4%b4 aria-label=预编译头>预编译头</a></li><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=多线程>多线程</a></li><li><a href=#%e5%86%85%e5%ad%98%e5%88%86%e5%8c%ba%e6%a8%a1%e5%9e%8b aria-label=内存分区模型>内存分区模型</a></li><li><a href=#%e7%b1%bb aria-label=类：>类：</a><ul class=header-level-4><li><a href=#this%e6%8c%87%e9%92%88 aria-label=THIS指针>THIS指针</a></li><li><a href=#%e5%8f%8b%e5%85%83friend aria-label=友元friend：>友元friend：</a></li><li><a href=#%e7%bb%a7%e6%89%bf aria-label=继承>继承</a></li></ul></li><li><a href=#%e5%a4%9a%e6%80%81 aria-label=多态>多态</a></li><li><a href=#%e5%b8%b8%e7%94%a8stl%e5%87%bd%e6%95%b0 aria-label=常用STL函数>常用STL函数</a></li></ul></li><li><a href=#%e9%80%9a%e7%94%a8%e9%83%a8%e5%88%86 aria-label=通用部分：>通用部分：</a><ul class=header-level-3><li><a href=#%e6%b7%b1%e6%8b%b7%e8%b4%9d%e5%92%8c%e6%b5%85%e6%8b%b7%e8%b4%9d%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=深拷贝和浅拷贝的概念：>深拷贝和浅拷贝的概念：</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e4%b8%8e%e5%bc%82%e6%ad%a5 aria-label=同步与异步>同步与异步</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase(),n=document.querySelector(`.inner ul li a[href="#${t}"]`);n.classList.remove("read")}),activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach((t)=>{const o=encodeURI(t.getAttribute("id")).toLowerCase(),s=document.querySelector(`.inner ul li a[href="#${o}"]`);if(t===activeElement){s.classList.add("active");const e=document.querySelector(".toc .inner"),t=s.offsetTop,n=e.clientHeight,o=s.clientHeight,i=t-n/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else getOffsetTop(t)<e&&s.classList.add("read"),s.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return!document.querySelector(".hugo-encryptor-prompt")&&elements.length!=0&&(elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),console.log("Elements re-queried:",elements)),0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><head><script src=https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/crypto-js/3.1.9-1/crypto-js.js></script></head><div class=hugo-encryptor-container><div class=hugo-encryptor-prompt><p>文章的部分内容被密码保护：</p></div><div class=hugo-encryptor-form><input class=hugo-encryptor-input placeholder=请输入密码>
<input class=hugo-encryptor-button type=button value=CLICK onclick=_click_handler(this)></div><div class=hugo-encryptor-cipher-text data-password=aikenhong_blog style=display:none><span style=display:none>--- DON'T MODIFY THIS LINE ---</span><p><a href=https://blog.csdn.net/cppjava_/article/details/68921869 target=_blank rel=noopener>LINK1</a></p><h2 id=深度学习部分>深度学习部分<a hidden class=anchor aria-hidden=true href=#深度学习部分>#</a></h2><h3 id=densenet>DenseNet<a hidden class=anchor aria-hidden=true href=#densenet>#</a></h3><p>任意的两层之间都存在直接的链接，每一层的输入都是前面的所有层的输出的并集，而该层学习的特征图也会是后面所有层的输入，DenseBlock中需要Feature_map保持一致；</p><p>Block与Block之间的降采样则使用transition layer，使用BN，1*1的 conv，Pooling来降维</p><p>优缺点：</p><ol><li>省参数，省计算</li><li>抗过拟合，泛化能力强</li><li>需要保存Feature占显存</li></ol><h3 id=efficientnet>EfficientNet<a hidden class=anchor aria-hidden=true href=#efficientnet>#</a></h3><p>针对卷积神经网络的模型拓展，可以通过：1</p><ol><li>增加网络规模可以、 增加<strong>模型宽度</strong>，增加<strong>模型深度</strong>，增加<strong>输入图像的分辨率</strong>，但是如何去人工调整这个比例和参数，比较麻烦，</li><li>实验发现ConvNet缩放过程中平衡网络宽度、深度、和分辨率的维度是很重要的</li><li>EfficientNet就是对这些的合理组合，复合型的模型扩展技术集合神经结构搜索技术获得</li></ol><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-fcbff6e21eb9e7f9cce94c3bd935b84a_720w2.jpg><img alt=img loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-fcbff6e21eb9e7f9cce94c3bd935b84a_720w2.jpg class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-fcbff6e21eb9e7f9cce94c3bd935b84a_720w2.jpg style="display:block;margin:0 auto" alt=img></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p><strong>关键技术</strong>复合扩张技术</p><p>所以本文提出了<strong>复合扩张方法</strong>，这也是文章核心的地方，</p><div>$$ \alpha,\beta,\gamma $$</div>是我们需要求解的一组参数，如下图公式，带约束的最优参数求解。<div>$$ \alpha,\beta,\gamma $$</div>分别衡量着depth, width和 resolution的比重，其中<div>$$ \beta,\gamma $$</div>在约束上会有平方，是因为如果增加宽度或分辨率两倍，其计算量是增加四倍，但是增加深度两倍，其计算量只会增加两倍。<p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-d158f21d6bae78f05fbcf40fd81255d3_720w.jpg><img alt=img loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-d158f21d6bae78f05fbcf40fd81255d3_720w.jpg class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-d158f21d6bae78f05fbcf40fd81255d3_720w.jpg style="display:block;margin:0 auto" alt=img></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><ol><li>固定公式中的φ=1，然后通过网格搜索（grid search）得出最优的α、β、γ，得出最基本的模型EfficientNet-B0.</li><li>固定α、β、γ的值，使用不同的φ，得到EfficientNet-B1, &mldr;, EfficientNet-B7</li></ol><p>φ的大小对应着消耗资源的大小，相当于：</p><ol><li>当φ=1时，得出了一个最小的最优基础模型；</li><li>增大φ时，相当于对基模型三个维度同时扩展，模型变大，性能也会提升，资源消耗也变大。</li></ol><h3 id=bottleneck>bottleneck<a hidden class=anchor aria-hidden=true href=#bottleneck>#</a></h3><p>Bottleneck layer又称之为瓶颈层，使用的是1*1的卷积神经网络。之所以称之为瓶颈层，是因为长得比较像一个瓶颈。</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-a78418d8f2dc346cd284a22f20e66af7_720w.jpg><img alt=img loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-a78418d8f2dc346cd284a22f20e66af7_720w.jpg class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-a78418d8f2dc346cd284a22f20e66af7_720w.jpg style="display:block;margin:0 auto" alt=img></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script>中间比较细，像一个瓶颈</p><p>如上图所示，经过 $1<em>1 conv$ ，中间那个看起来比较细。像一个瓶颈一样。使用 $1</em>1$ 网络的一大好处就是可以大幅减少计算量。深度可分离卷积中，也有这样的设计考虑。如果想具体了解如何大幅减少计算量的话，可以参考参考资料[2]</p><h3 id=xavier参数初始化方法>Xavier参数初始化方法<a hidden class=anchor aria-hidden=true href=#xavier参数初始化方法>#</a></h3><p>已经写在笔记上了，但是还要补充的，或者说是理清楚的是怎么推导的或者为什么这么干的，还有其他的初始化方法之间的区别什么的</p><h3 id=模型压缩>模型压缩<a hidden class=anchor aria-hidden=true href=#模型压缩>#</a></h3><p>为了研究小而快的机器学习模型：1. 对复杂模型进行压缩 2. 直接设计小模型得到训练</p><h4 id=轻量网络mobilenet>轻量网络：MobileNet<a hidden class=anchor aria-hidden=true href=#轻量网络mobilenet>#</a></h4><p>主要的网络架构：是使用<strong>depthwise separable convolution</strong>也就是xception中提到的这种，双分离的卷积</p><p>然后使用：<strong>ReLU6</strong>激活函数（限制最大输出为6）</p><p>过程中<strong>不使用pooling直接使用stride=2</strong>进行下采样</p><p>基本的组件如图所示： 最后用avg pooling从 $7<em>7</em>1024 $ 到 $1<em>1</em>1024$</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/20180615124806760><img alt=img loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/20180615124806760 class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/20180615124806760 style="display:block;margin:0 auto" alt=img></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>对其进行瘦身：</p><ul><li>按比例缩放特征图的大小</li><li>按比例缩放通道数</li></ul><p>核心的计算量实际上在 $1*1 conv$ 这个全通道密集卷积的操作上</p><p><strong>V2：</strong></p><ul><li><p>引入了shortcut（残差结构）</p></li><li><p>在进行depthwise之前先用 $1*1$ 扩张feature_map的通道数</p><blockquote><p>是为了提升效果，参数量比1还是稍微增加了，</p><p>这里的1*1和resnet中的是完全相反的：</p><p>残差模块：1<em>1降维 3</em>3卷积 1<em>1升维
反残差模块：1</em>1升维，3<em>3卷积，1</em>1降维</p><p>原因：因为depthwise卷积不能改变通道数，因此特征提取受限于输入的通道数，所以将通道数先提升上去。文中的扩展因子为6。</p></blockquote></li><li><p>pointwise之后的relu改成了Linear激活函数，防止relu破坏特征</p><blockquote><p>原因：relu造成的低维度数据塌陷<br></p><p><a href=https://www.sohu.com/a/307566264_100024677 target=_blank rel=noopener>https://www.sohu.com/a/307566264_100024677</a></p><p>就是当低维信息映射到高维，经过ReLU后再映射回低维时，若映射到的维度相对较高，则信息变换回去的损失较小；若映射到的维度相对较低，则信息变换回去后损失很大。因此，认为对低维度做ReLU运算，很容易造成信息的丢失。而在高维度进行ReLU运算的话，信息的丢失则会很少。<br>因为relu函数小于0时候，值为0，是有信息损耗的，而线性激活函数没有信息损耗</p></blockquote></li></ul><h4 id=轻量网络shufflenet>轻量网络：Shufflenet<a hidden class=anchor aria-hidden=true href=#轻量网络shufflenet>#</a></h4><p><a href="https://www.zhihu.com/search?q=shufflenet&amp;utm_content=search_suggestion&amp;type=content" target=_blank rel=noopener>V1 带Pytorch</a></p><p>ShuffleNet的核心是采用了两种操作：<strong>pointwise group convolution</strong>和<strong>channel shuffle</strong>，这在保持精度的同时大大降低了模型的计算量。</p><p>缓解 $1*1 conv$ 的计算量，也使用channel sparse connection，但是这种group convolution 也有弊端：特征图之间不通信，所以我们就channel shuffle（均匀打乱）</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-f8ddc33fb1f578bf7f51a4b6e5407426_r.jpg><img alt=preview loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-f8ddc33fb1f578bf7f51a4b6e5407426_r.jpg class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-f8ddc33fb1f578bf7f51a4b6e5407426_r.jpg style="display:block;margin:0 auto" alt=preview></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>图3.(a)是一个普通的带有残差结构的深度可分离卷积，例如，<a href=https://zhuanlan.zhihu.com/p/50045821 target=_blank rel=noopener>MobileNet</a>
[5], <a href=https://zhuanlan.zhihu.com/p/50897945 target=_blank rel=noopener>Xception</a>
[6]。ShuffleNet v1的结构如图3.(b)，3.(c)。其中3.(b)不需要降采样，3.(c)是需要降采样的情况。</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-fdf77861cd24ab65be0c81934e7e3af2_r.jpg><img alt=preview loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-fdf77861cd24ab65be0c81934e7e3af2_r.jpg class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-fdf77861cd24ab65be0c81934e7e3af2_r.jpg style="display:block;margin:0 auto" alt=preview></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p><strong>V2:</strong></p><ol><li>G1). 使用输入通道和输出通道相同的卷积操作；</li><li>G2). 谨慎使用分组卷积；</li><li>G3). 减少网络分支数；</li><li>G4). 减少element-wise操作。</li></ol><p>通道分割在每个单元开始前将通道的输入分成两个，不再使用group卷积，然后concat两个channel并channel shuffle</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-eee995e9167bde760a6aab6c4b30c794_720w.jpg><img alt=img loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-eee995e9167bde760a6aab6c4b30c794_720w.jpg class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-eee995e9167bde760a6aab6c4b30c794_720w.jpg style="display:block;margin:0 auto" alt=img></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><h4 id=轻量网络squeezenet>轻量网络：squeezeNET<a hidden class=anchor aria-hidden=true href=#轻量网络squeezenet>#</a></h4><p>利用Fire module 来实现了：<a href=https://zhuanlan.zhihu.com/p/49465950 target=_blank rel=noopener>Link</a></p><h4 id=knowledge-distiall>Knowledge Distiall<a hidden class=anchor aria-hidden=true href=#knowledge-distiall>#</a></h4><p>实际上很简单，就是用小模型逼近大模型的输出，用大模型来做小模型的监督，也就是让小模型尽量去适应大模型的输出分布（原本应该只是一个类别标签），这其实已经偏向于一个无监督的驯良过程了，或者说是自监督。</p><ul><li>训练大模型</li><li>计算大模型的soft output</li><li>训练小模型，在类别的监督信息以外再加上soft target的loss，用lambda来调节传中</li><li>使用小模型进行预测。</li></ul><h3 id=超参数搜索的方法>超参数搜索的方法<a hidden class=anchor aria-hidden=true href=#超参数搜索的方法>#</a></h3><p>网格搜索，随机搜索，贝叶斯优化方法（这种方法实际上还不是太清楚，后面可能还需要看看），AutoML</p><h3 id=激活函数的稀疏性>激活函数的稀疏性<a hidden class=anchor aria-hidden=true href=#激活函数的稀疏性>#</a></h3><ol><li>适应性强，针对不同的情况有不同的激活单元</li><li>简洁的模型，计算更快</li><li>更好的预测能力和更不容易过拟合</li><li>更可分</li></ol><h3 id=梯度消失与爆炸>梯度消失与爆炸<a hidden class=anchor aria-hidden=true href=#梯度消失与爆炸>#</a></h3><p>消失：sigmoid ，tanh，</p><p>误差的反向传播造作，我们可以看出这种连乘的形式涉及到了很多的参数和导数，这种时候无论是放大还是缩小的效应都很容易累加起来产生梯度的消失或者膨胀，</p><blockquote><p>当对当前层的w进行求导的时候，我们需要先对上一层的x求导，就会得到wt+1 与梯度连乘这样的式子，这也是导致梯度爆炸的原因</p><p>sigmoid的最大输出只有1/4所以sigmoid中梯度消失实际上是更常见的时候</p></blockquote><p>再RNN中BPTT这种反向传播的时候也是类似的思路，但是它是以一个n维矩阵的方式向后传播的，这样当雅可比矩阵的特征值小于1的时候，这样的梯度传播会呈现指数级的变化，要么梯度消失要么梯度爆炸</p><p>ResNet 缓解深层网络中梯度消失的问题，实际并不是真正的解决这样的问题，只是给出了一个传播的shortcut，所以掩盖了梯度消失的情况出现，实际上ResNet解决更多的是模型退化的问题，也就是</p><p>梯度爆炸也可以使用梯度裁剪的方法进行解决：当梯度的范数大于阈值的时候，我们对梯度进行等比的搜索，</p><h3 id=损失函数的反向推导>损失函数的反向推导<a hidden class=anchor aria-hidden=true href=#损失函数的反向推导>#</a></h3><p>常见的几个损失函数和误差之间的关系（推一下grad的公式）</p><ul><li>Softmax</li><li>CE</li></ul><h3 id=过拟合欠拟合的判断和处理方式>过拟合欠拟合的判断和处理方式<a hidden class=anchor aria-hidden=true href=#过拟合欠拟合的判断和处理方式>#</a></h3><p><strong>过拟合</strong>的训练方法：</p><ul><li><p>获取更多数据</p></li><li><p>降低模型的复杂度</p></li><li><p>正则化方法：实际上这就是权重衰减的方法这里药剂的L1（直接减少有效参数的数量），L2正则化结构风险（减少权值过大带来的过拟合的风险）的那些具体定义；dropout等等。</p><blockquote><p>drop可以理解成bagging的办法的继承实现</p></blockquote></li><li><p>集成学习方法，通过多个模型的集成来降低单一模型的过拟合风险</p></li><li><p>early-stop</p></li></ul><p><strong>DROPOUT rescale</strong></p><p>使用 pretraining 方法也可以帮助 dropout 训练参数，在使用 dropout 时，要将所有参数都乘以 $ 1/p$</p><ul><li>开始时随机删除，一半P的神经元</li><li>在剩下的一般中更新，</li><li>recycle，然后，最后学出来的参数的存在概率只有（1-P)所以要*概率。</li></ul><p><strong>欠拟合降低的方法</strong>：</p><ul><li>添加新特征：特征与标签之间的相关性太差，我们可能需要挖掘新的特征；</li><li>增加模型的复杂度：简单模型的学习能力可能太差了，比如在线性模型中添加高次项，增加网络的深度或者神经元个数</li><li>减少正则化参数</li></ul><h3 id=有监督学习中涉及到的损失函数>有监督学习中涉及到的损失函数<a hidden class=anchor aria-hidden=true href=#有监督学习中涉及到的损失函数>#</a></h3><p><a href="https://zhuanlan.zhihu.com/p/77686118?utm_source=qq" target=_blank rel=noopener>LINKLINE</a></p><ul><li>0，1损失函数： $max{0,1-fy}$ ,标签，二分类问题</li><li>hinge损失（0，1的进化）：max{0,1-fy}</li></ul><h3 id=卷积>卷积<a hidden class=anchor aria-hidden=true href=#卷积>#</a></h3><p>卷积的矩阵加速：https://www.mobibrw.com/2019/17787</p><p>转置卷积：<a href=https://blog.csdn.net/lanadeus/article/details/82534425 target=_blank rel=noopener>LInk1</a>
；<a href=https://blog.csdn.net/tsyccnh/article/details/87357447 target=_blank rel=noopener>LInk2</a></p><p>转置卷积上采样带来的棋盘效应：https://www.cnblogs.com/hellcat/p/9707204.html</p><p>空洞卷积也会带来棋盘效应，也就是采样不均匀，有些点被重复采样，有些点没有被采样到，这样就会像棋盘一样，两种颜色分离的这种情况。</p><p>上采样 下采样：</p><p>SVD：https://www.cnblogs.com/endlesscoding/p/10033527.html</p><h3 id=正则化的具体函数和内在含义>正则化的具体函数和内在含义<a hidden class=anchor aria-hidden=true href=#正则化的具体函数和内在含义>#</a></h3><p>KEYPOINT：https://www.cnblogs.com/alexanderkun/p/6922428.html</p><p>实际上我们可以发现这也是一个权重衰减的操作，如果从导数去分析的话，或者我们数形结合，我们会发现这样的w和我们的函数曲线的交点实际上是偏向</p><p>Regularization：在目标函数中添加惩罚项，对复杂度高的模型进行惩罚，于是考虑从W的向量出发，</p><ul><li><p>0范数：非零元素的个数，在机器学习中是个NP完全问题，很难求</p></li><li><p>1范数：绝对值之和</p></li><li><p>2范数，通常意义上的模，实际上从分布上来看</p><blockquote><p><strong>L2范数是指向量各元素的平方和然后求平方根。我们让L2范数的正则项||W||2最小，可以使得W的每个元素都很小，都接近于0，但与L1范数不同，它不会让它等于0，而是接近于0，这里是有很大的区别的哦；所以大家比起1范数，更钟爱2范数。</strong></p></blockquote></li></ul><h3 id=normalization>Normalization<a hidden class=anchor aria-hidden=true href=#normalization>#</a></h3><p><a href=https://zhuanlan.zhihu.com/p/33173246 target=_blank rel=noopener>重要参考资料</a>
；<a href=https://www.zhihu.com/question/68730628/answer/277339783 target=_blank rel=noopener>参考资料2向东的回答</a></p><p>权重伸缩不变性，可以有效的提高反向传播的效率，也有参数正则化的效果；</p><p>数据伸缩不变性；减少梯度弥散，简化对学习率的选择</p><h4 id=covariate-shift>covariate shift<a hidden class=anchor aria-hidden=true href=#covariate-shift>#</a></h4><p>协方差偏移，实际上是训练集和测试集中，变量的分布的不同带来的问题，这样就会导致模型的效果收到影响，也会印象网络的迭代速度，通过BN就可以将每个mini-batch的数据都拉回到标准正态分布，把带有偏差的数据拉回标准分布，拉回模型擅长的领域中，使得梯度变大，避免梯度小时的问题出现，也能加快收敛的速度。</p><p><a href=https://blog.csdn.net/mao_xiao_feng/article/details/54317852 target=_blank rel=noopener>帮助理解covariate shift</a>
，更确切的来说，实际上是source domain和Target domain的数据分布不一致，他们的条件概率相同，但是边缘概率不同：</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210313144706811.png><img alt=image-20210313144706811 loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210313144706811.png class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210313144706811.png style="display:block;margin:0 auto" alt=image-20210313144706811></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><ul><li><p>这样会导致不再是独立同分布：</p></li><li><p>需要不断适应输入的分布，降低学习速度</p></li><li><p>下端的变化可能趋向于变大或者变小，容易使得上层落入饱和区，学习过早的停止</p></li><li><p>会相互影响。</p></li></ul><h4 id=bninlnwn>BN，IN，LN，WN<a hidden class=anchor aria-hidden=true href=#bninlnwn>#</a></h4><p>Normalization的基本框架就是 $h=f(g·\frac{x-\mu}{\sigma} + b)$</p><p>再次进行平移和缩放是为了模型的表达能力不因规范化而下降；这两个缩放因子是可以学习的，用来对底层的学习结果有所价值，这也会将数据变换到基本在非饱和区中（线性区），然后通过再次的缩放和偏移，提供了非线性。</p><p><strong>BNnormalization纵向</strong></p><p>是对同一个batch的所有图的逐channel进行的</p><img src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-ee8f2d5e3a002fd0ecf47cc094d935a5_720w.jpg alt=img style=zoom:50%><p>使用mini-batch来计算相关的均值和方差，element-wised；但是BN是独立的对每个维度（channel）进行统计的，这样的话，如果原始分布差距很大的话，会导致不同的数据训练，这样可能会增加模型的训练难度。</p><p>适用场景：每个mini-batch比较大，数据分布比较接近，所以我们需要进行充分的shuffle，不然效果会差很多。再运行中需要统计一阶和二阶统计量，所以不适用动态的网络架构和RNN，；相应的改造就不说了</p><p>适用于判别模型中，</p><p><strong>Instance Normalization</strong></p><img src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-7092a1ff8c48cbd1a79044cbb3346856_720w.jpg alt=img style=zoom:50%><p>是对单张图片的单个通道单独进行的Normalization，适用于生成模型中，比如风格迁移，主要依赖的是单张图片的实例，所以不适宜对整个batch进行归一化，这样可以加速模型收敛和保证实例之间的独立性</p><p><strong>Group Normalization</strong></p><p>实际上就是一个normalization的变体：</p><img src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-4d4320b6e285c108f8e11bea650a3d32_720w.jpg alt=img style=zoom:50%><p><strong>Layer Normalization 横向</strong></p><p>是指对同一张图片的同一层的所有通道进行的normalization，所以和公式不一样的就是不需要求M的均值了，是对同一张图片的所有channel进行的</p><img src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-f8df6b9a4c8b4d39a3521f3738a9dff4_r.jpg alt=preview style=zoom:50%><p><strong>Wegiht Normalization参数规范化</strong></p><p><strong>CosineNormalization</strong></p><h3 id=解释一下attention>解释一下attention<a hidden class=anchor aria-hidden=true href=#解释一下attention>#</a></h3><blockquote><p>在某种程度上，注意力是由我么如何关注视觉图像的不同区域或者我们如何关联同一个句子中的不同单词所启发的：针对于问题的不同，我们会对图像的某些具体的区域重视（某些区域在视觉中呈现高分辨率，而另一些则是低分辨率的情况），或者句子中的某些词重视的情况。</p></blockquote><p>比如我们看到eating就对food有更高的attention，与此同时color的权重就会比较低。</p><p><strong>因为传统的RNN架构，固定的context vector可能会导致序列信息的缺失，可能无法记住长句子和时序对齐的信息，所以诞生了attention.</strong></p><p>content vector和 attention weight加权，然后和上一个时刻的target和y，生成现在的y。</p><p>self-attention：https://zhuanlan.zhihu.com/p/47282410；</p><p>内部注意力，也就是内部的自我关联的获取，QKV的关系</p><h4 id=transformer-的基本架构>Transformer 的基本架构<a hidden class=anchor aria-hidden=true href=#transformer-的基本架构>#</a></h4><p>Transformer 的 Multi-Head 实际上就是有不同的QKV表示，然后我们将其表示起来。</p><p>mask屏蔽未来的信息</p><h3 id=pooling的反向传播>Pooling的反向传播：<a hidden class=anchor aria-hidden=true href=#pooling的反向传播>#</a></h3><p>Pooling层的主要作用</p><p>1、特征不变性，使模型更加关注是否存在某些特征而不是特征具体的位置，对于一些旋转和平移具有不变性<br>2、特征降维，使模型可以抽取更广泛围的特征，减小了下一层输入大小，进而减小计算量和参数个数</p><p>3、在一定程度防止过拟合，更方便优化</p><p>4、扩大感受野</p><p>avg pooling：均分后回传</p><p>MaxPooling：只传给最大的一项，其他项的反向传播值为0</p><h3 id=anchor-based和-anchor-free的理解和辨析>Anchor-based和 Anchor-free的理解和辨析<a hidden class=anchor aria-hidden=true href=#anchor-based和-anchor-free的理解和辨析>#</a></h3><p>实际上就是把五百问的内容再巩固一下，然后整理过来，这里还有两个比较相关的链接，到时候还不清楚就可以看下。</p><p><a href=https://www.zhihu.com/question/356551927/answer/926659692 target=_blank rel=noopener>https://www.zhihu.com/question/356551927/answer/926659692</a></p><p><a href=https://zhuanlan.zhihu.com/p/62372897 target=_blank rel=noopener>https://zhuanlan.zhihu.com/p/62372897</a></p><p>Anchor-based方法：在选练之前在训练集熵使用K-Means等聚类方法聚类出一组矩形框，代表主要的长宽，然后在推理时用这些Anchor滑动提取proposal之后在对这些Anchor进行回归和分类，比如扩张和中心点预测</p><p>Anchor-free:就是没有预先定义这样的BoundingBox，直接通过网络来预测相应的边框，比如左上角右下角，中心点这样的预测；中心点+长宽</p><h2 id=机器学习部分>机器学习部分<a hidden class=anchor aria-hidden=true href=#机器学习部分>#</a></h2><h3 id=回归任务为什么难以训练>回归任务为什么难以训练<a hidden class=anchor aria-hidden=true href=#回归任务为什么难以训练>#</a></h3><ul><li>目标更难，需要适应所有的点</li><li>损失函数的角度，MSE之类的，下降与Value相关，对Outline敏感</li></ul><h3 id=selective-search-hog-sift>Selective Search HOG SIFT<a hidden class=anchor aria-hidden=true href=#selective-search-hog-sift>#</a></h3><p>HOG: 手机知乎</p><p>Selective Search：https://zhuanlan.zhihu.com/p/27467369</p><p>SIFT：<a href=https://zhuanlan.zhihu.com/p/70385018 target=_blank rel=noopener>概览</a>
； <a href=https://zhuanlan.zhihu.com/p/261697473 target=_blank rel=noopener>开贴细说</a></p><h3 id=lr怎么处理低维线性不可分问题>LR怎么处理低维线性不可分问题<a hidden class=anchor aria-hidden=true href=#lr怎么处理低维线性不可分问题>#</a></h3><p>特征工程或者使用多项式核和高斯核，将样本映射到可分的空间去进行逻辑回归；</p><p><strong>线性回归和逻辑回归的异同点</strong></p><p>实际上都是一个函数映射的问题，就是离散化和连续化的区别而已，还有其中的损失函数的设计等等</p><p>线性回归和逻辑回归实际上都是线性模型，但是最终一个映射到连续域做拟合，另一个映射到离散域做分类，最主要的区别就在于目的，输出值域，以及损失函数的设计上。</p><p>本质上都是一个一个线性映射函数的选择。</p><h4 id=lr对连续值特征是怎么处理的>LR对连续值特征是怎么处理的<a hidden class=anchor aria-hidden=true href=#lr对连续值特征是怎么处理的>#</a></h4><p>离散化的作用和优势：https://notes.001.io/lian-xu-te-zheng-li-san-hua/</p><p>LR本质上属于广义线性模型，通过进行值域的划分，相当于引入了非线性，从而提升了模型的表达能力；</p><p>进行离散化后对异常值不敏感，能对轻微的扰动有一定的鲁棒性，但是这还是比较考验特征划分技术的</p><p>可以对离散的特征值进行组合，进一步引入非线性</p><p>相当于简化了逻辑回归的模型，引入模型复杂度的正则化，这样能够减少过拟合的风险。</p><h4 id=lr为什么要归一化>LR为什么要归一化<a hidden class=anchor aria-hidden=true href=#lr为什么要归一化>#</a></h4><p>LR的求解过程不就是是梯度下降的方式，那么就是归一化的作用了没什么好说的</p><h3 id=集成学习方法>集成学习方法<a hidden class=anchor aria-hidden=true href=#集成学习方法>#</a></h3><h4 id=boosting>Boosting<a hidden class=anchor aria-hidden=true href=#boosting>#</a></h4><p>基学习器，做错的样本受到更多的关注，然后调整后的样本分布进行下一个基学习器的训练（AdaBoost）</p><p>对特定的数据分布进行学习，实际上就像是re-weighting的这样的操作；如果不能使用这种方法的模型我们就使用re-sampling的操作来处理。</p><ul><li>过程中如果不满足比随机猜测好，这种模型就直接停止</li><li>可以看出这种方法主要关注降低偏差，可以对弱学习器构建出很强的集成</li></ul><h4 id=bagging与随机森林>Bagging与随机森林<a hidden class=anchor aria-hidden=true href=#bagging与随机森林>#</a></h4><p>又放回的随机抽取样本构建包含m个的数据集，采样出T个这样的数据集，然后对这些基学习器进行结合，（简单投票做分类，简单平均做回归）</p><p>随机森林是在以决策树为基础构建的基学习器，在bagging的基础上，引入了随机的属性选择（原本是选择最优的），也就是先选择一个随机的子集，然后在子集中选择最优的用来划分。</p><h4 id=gbdt和xgboost>GBDT和XGBoost<a hidden class=anchor aria-hidden=true href=#gbdt和xgboost>#</a></h4><p>GBDT实际上就是BOOSTing的一种方法</p><p>都是通过损失函数相对于模型的负梯度方向来对当前的模型进行更新，但是在<strong>梯度下降</strong>里，我们的模型是通过参数表示的，而在<strong>梯度提升</strong>，是在函数空间中直接表示的。</p><p>通俗一点的说的话，实际上就是梯度下降是在更新梯度来进行梯度下降，梯度提升通过累加弱学习器来梯度下降。</p><p>关键：<strong>实际上在梯度提升中，梯度最终会被计算为（当作）残差</strong>，也就是用损失函数的负梯度去模拟残差</p><p><a href=https://www.cnblogs.com/jiangxinyang/p/9248154.html target=_blank rel=noopener>参考链接，里面也有提到区别</a>
；<a href=https://blog.csdn.net/zpalyq110/article/details/79527653 target=_blank rel=noopener>简单的实例分析</a></p><p><strong>GBDT：Gradient Boosting Descend Tree</strong></p><p>GBDT分类和回归时的基学习器都是<strong>CART分类回归</strong><a href=https://www.jianshu.com/p/b90a9ce05b28 target=_blank rel=noopener>LINK</a>
树，每轮迭代在上一个基学习器结果的残差至上进行训练，（弱分类器）；</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/20181221075421316.png><img alt=img loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/20181221075421316.png class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/20181221075421316.png style="display:block;margin:0 auto" alt=img></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><p>这里的残差可以更改为损失函数，然后最后还是会变成对残差的一个拟合，模型的残差实际上也不是这么好弄的，用损失函数的负梯度，来拟合本轮损失的近似值。然后就是从上到下一个个基学习器过去</p><p>不同的损失函数针对的是不同的问题（分类回归）</p><ul><li>分类问题：指数损失函数和对数损失函数</li><li>回归问题：均方差损失函数，绝对值损失函数</li></ul><p>GBDT的正则化：</p><ul><li>给每个模型乘上一个弱化系数，降低每个模型对拟合损失的贡献</li><li>通过按比例来随机抽取样本训练模型，bagging，减少方差但是会增加偏差，可以使用交叉验证</li><li>控制CART的复杂度，可以使用剪枝正则化</li></ul><p>优缺点：</p><ul><li>灵活，准确率高，使用健壮的损失函数可以处理异常值</li><li>难以并行化处理，受限于基学习器之间的依赖关系</li></ul><p><strong>XGBoost</strong></p><p><a href=https://www.jianshu.com/p/b0e147de75e6 target=_blank rel=noopener>详细讲解XGBoost</a>
；</p><p>和残差然后用CART拟合不同，我们是通过SCORE来确定结构，然后通过梯度的值来计算结构中应该有的值， 所以在我们计算完二阶梯度的时候，我们能同步的进行划分和复制，这样，但是还有为为什么要排序后去做，我有点没搞明白</p><p>两种方法的区别：</p><ul><li>正则化防止过拟合，提升泛化能力 L1+L2</li><li>还可以使用线性分类器</li><li>使用了二阶导数信息来进行对代价函数的优化</li><li>采用和随机森林类似的策略，能对数据进行采样，降低过拟合和减少计算</li><li>有缩减项，类似weight decay</li><li>能计算出缺失值的分裂方向</li><li>可并行计算</li><li>划分的方式改成了一个Score（根据两阶段梯度数据）</li></ul><h3 id=svm细节>SVM细节<a hidden class=anchor aria-hidden=true href=#svm细节>#</a></h3><p>在SVM推导部分的后面添加最终的形式以及整理一下KKT条件，通过这些特性对一些问题进行分析</p><h4 id=为什么将原问题转化成对偶问题>为什么将原问题转化成对偶问题<a hidden class=anchor aria-hidden=true href=#为什么将原问题转化成对偶问题>#</a></h4><ol><li>对偶问题将原始问题中的不等式约束转为了对偶问题中的等式约束</li><li>方便核函数的引入,输入最终会转化从恒一种内积的形式</li><li>改变了问题的复杂度。由求特征向量w转化为求比例系数a，在原始问题下，求解的复杂度与样本的维度有关，即w的维度。在对偶问题下，只与样本数量有关。</li></ol><h4 id=怎么转化到多分类的场景>怎么转化到多分类的场景<a hidden class=anchor aria-hidden=true href=#怎么转化到多分类的场景>#</a></h4><p>不是逐个二分吗？</p><p>hinge损失的多分类形式：https://www.turingtopia.com/article/details/e2492b497a144bf6b3cd1fc62df60bbd</p><h4 id=lagrange乘数法对偶问题>Lagrange乘数法，对偶问题<a hidden class=anchor aria-hidden=true href=#lagrange乘数法对偶问题>#</a></h4><p>二次型函数 A是实对称矩阵</p><div>$$
f(x)=x^TAx
$$</div><p>在 $R^N$ 上是凸函数和A是半正定矩阵是充要的关系；</p><p>凸规划：目标函数是凸函数，约束空间是凸集</p><p>MP是凸规划的条件：满足。。。</p><p>为什么凸规划是重要的，因为凸规划的任意局部最优值都是他的整体最优解</p><p>凸优化问题Lagrange：</p><ul><li>引入松弛变量/kkt乘子，将不等式约束转化为等式约束，</li><li>引入拉格朗日乘子将等式约束转为无约束优化</li></ul><p>KKT条件：MP（非线性规划）问题，可微可行点 $x^*$ 是整体最有解的条件
实际上是在凸规划的最优值求解过程中，使用拉格朗日乘数法，其中的不等式约束（&lt;=0）需要满足的条件，其中：</p><p>求解Largrange，KT条件的时候我们通常使用互补松紧条件入手来求解（分情况讨论，但是这种时候要考虑分类的完备性来进行求解。）</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210310010553947.png><img alt=image-20210310010553947 loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210310010553947.png class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210310010553947.png style="display:block;margin:0 auto" alt=image-20210310010553947></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><h4 id=对偶条件的引出>对偶条件的引出<a hidden class=anchor aria-hidden=true href=#对偶条件的引出>#</a></h4><p>在线性规划的过程中可以使用对偶问题来进行转化，将求最大转化为求最小值；如果LP问题又最优解，则对偶问题也有最优解，且解相同</p><h4 id=svm的具体推导以及核函数>SVM的具体推导以及核函数<a hidden class=anchor aria-hidden=true href=#svm的具体推导以及核函数>#</a></h4><p>再生希尔伯特空间，</p><p>于是我们可以选择多项式核，高斯核，拉普拉斯核之类的来做这个核函数映射</p><p><strong>核函数的记忆</strong></p><h4 id=相关的面试问题>相关的面试问题<a hidden class=anchor aria-hidden=true href=#相关的面试问题>#</a></h4><p><strong>SVM和LR的联系与区别：</strong></p><ul><li><p>他们都是分类算法，都是监督学习的模型</p></li><li><p>都是判别模型，如果不考虑核函数的话，都是线性分类算法</p></li><li><p>LR采用log损失，SVM采用合页（hinge）损失</p></li><li><p>LR基于概率理论，使用sigmoid和MLE来估计出参数的值；SVM基于几何的边界最大化原理</p></li><li><p>LR对异常值敏感，SVM不</p></li><li><p>对海量数据来说LR效率高，在低纬度的时候LR的准确率高，但是维度上升就被反超</p></li><li><p>处理线性不可分：LR靠特征构造（组合交叉特征，特征离散化），SVM 还可以核函数</p></li><li><p>LR是经验风险最小化，SVM自带结构风险最小化（自带了L2正则项所以）</p></li></ul><p><strong>将数据向SVM求得的超平面进行投影后，是否仍然线性可分？（数学推导，这里的推导我放弃）</strong></p><blockquote><p>显然不，从支持向量的角度分析，最优的结论必然是两点的中垂线，那么这种情况本身并不是线性可分的，但是如果超平面不是这个中出现的话，那么就不满足SVM求解条件中的最优分界面了。</p></blockquote><p>70页开始，但是我决定先推导SVM，这一部分的内容再说吧</p><p>是否一定存在一组参数使得SVM的训练误差为0？</p><p>训练误差为0的SVM分类器一定存在吗？</p><p>加入松弛变量的SVM训练误差可以为0吗？</p><h3 id=决策树>决策树<a hidden class=anchor aria-hidden=true href=#决策树>#</a></h3><ul><li><p>3种分支计算的方法：信息增益，增益率，gini指数</p></li><li><p>预剪枝，后剪枝</p></li><li><p>是否会重复利用连续值或者离散值特征来分树？</p><blockquote><p>离散特征不行，比如用西瓜的纹理来说：就是有没有了</p><p>连续特征可以，阈值切割，我们可以不断的往下细分，比如&lt;100 &lt;50这样。</p></blockquote></li></ul><h3 id=pca与lda>PCA与LDA<a hidden class=anchor aria-hidden=true href=#pca与lda>#</a></h3><p>优化的目标：最大化投影方差， 在主轴上的投影方差最大，包含更多的信息量（信噪比的概念）。</p><p>通过这个思想去设计一个求解过程：中心化（为了使得投影后均值为0），然后求方差，然后推导出最大化问题，然后通过largrange乘数法，推出实际上就是特征值。</p><p>LDA投影到的是便于分类的，PCA是方差最大信息量最大的去除冗余的信息维度；无监督有监督</p><h3 id=boosting与bagging>Boosting与Bagging<a hidden class=anchor aria-hidden=true href=#boosting与bagging>#</a></h3><p>bagging 解决的是过拟合，boosting解决的是欠拟合的方法</p><p>这里需要重新再去温习一下基本的定义</p><h3 id=mapmlebayesian>MAP、MLE、Bayesian<a hidden class=anchor aria-hidden=true href=#mapmlebayesian>#</a></h3><p><a href=https://blog.csdn.net/u011508640/article/details/72815981/ target=_blank rel=noopener>https://blog.csdn.net/u011508640/article/details/72815981/</a></p><p><a href=https://zhuanlan.zhihu.com/p/61593112 target=_blank rel=noopener>https://zhuanlan.zhihu.com/p/61593112</a></p><h4 id=从数学意义上和模型上区分>从数学意义上和模型上区分<a hidden class=anchor aria-hidden=true href=#从数学意义上和模型上区分>#</a></h4><p>显然基于bayesian公式我们可以区分后验和先验，以及使用贝叶斯公式去获得估计的基本依据是啥。（<strong>要看清楚似然的主体是啥，也就是求解的参数是那个</strong>）</p><div>$$
P(\theta | D)(后验概率 ) = \frac{P(D|\theta)(似然函数)P(\theta)(先验)}{\sum P(D|\theta)P(\theta)}
$$</div><p>这里的P实际上可以看成一个概率分布模型，一个推断模型（其中的D和θ一个是模型的数据一个是模型的参数）</p><p>前两者将</p><p><strong>那么MLE（极大似然）：</strong>（频率学派，假设为定制）</p><p>我们把模型参数设置成θ（变量）然后，我们计算当θ等于多少的时候出现D这个数据的概率最大，（这样的话也就会引出我们对大量数据的需求，实际上是一个概率估计模型）</p><p><strong>而MAP（最大后验概率）</strong>（和👇一样是贝叶斯学派，θ是随机数）</p><p>是贝叶斯估计的一种近似</p><p>也就是我们考虑了参数发生或者出现的先验概率以后再进行计算，由于上式的分母P(D)是个确定的值，所以不影响最大化的过程，我们通常再计算的时候将其忽略，然后最大化分子，就是MAP了，在这里这一步的prior是非常重要的，和我们之后的模型估计息息相关。</p><p><strong>最后Bayesian估计</strong></p><p>其中MAP估计的是后验的最大值，而贝叶斯估计是去近似这个后验函数，基于贝叶斯公式去做这个估计。（去看看数据挖掘中的这部分的题目来帮助理解）</p><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-321e2cb34e3fcde5c375a1fe24dffc64_r.jpg><img alt=preview loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-321e2cb34e3fcde5c375a1fe24dffc64_r.jpg class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/v2-321e2cb34e3fcde5c375a1fe24dffc64_r.jpg style="display:block;margin:0 auto" alt=preview></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p><h4 id=朴素贝叶斯问题>朴素贝叶斯问题<a hidden class=anchor aria-hidden=true href=#朴素贝叶斯问题>#</a></h4><p>看看数据挖掘中的那个讲稿，就很清楚，实际上就是类关系条件独立假设；</p><p>可以使用laplace校准来避免0概率对决策造成影响</p><p><strong>那什么是朴素贝叶斯学习呢？</strong></p><h3 id=交叉熵-kl散度-信息熵>交叉熵 KL散度 信息熵<a hidden class=anchor aria-hidden=true href=#交叉熵-kl散度-信息熵>#</a></h3><p><a href=https://blog.csdn.net/b1055077005/article/details/100152102 target=_blank rel=noopener>https://blog.csdn.net/b1055077005/article/details/100152102</a></p><h3 id=无监督方法>无监督方法<a hidden class=anchor aria-hidden=true href=#无监督方法>#</a></h3><p><strong>K均值聚类</strong>的有优缺点：</p><ul><li>受离群值影响，通常是局部最优解，类别量级和密度的问题没法解决</li><li>需要人工确定k</li><li>样本只能被划分到单一的类中</li></ul><p>如何调优：</p><ul><li>数据归一化，离群点处理</li><li>合理选择K值</li><li>核函数</li></ul><p>证明K means 收敛：和EM算法实际上是一个框架，这里看一下关系</p><h4 id=gmm高斯混合模型>GMM：高斯混合模型<a hidden class=anchor aria-hidden=true href=#gmm高斯混合模型>#</a></h4><p>假定不同簇种的样本各自符合不同的高斯分布，这种得到的聚类算法就是高斯混合模型；</p><div>$$
P(x) = \sum_{i=1}{K}\pi_iN(x|\mu_i,)
$$</div><p>核心思想是：每个单独的分模型都是标准高斯模型，我们需要估计高斯分布的双参数，还有一个额外参数（权重或者生成数据的概率），实际上和K均值聚类是一样的操作过程，这里要记得EM。</p><p>使用极大似然（很难求解）去寻找均值方差和权重，所以最后使用EM去做</p><ul><li>随机初始化参数，</li><li>E：根据当前参数，计算每个点由某个分模型生成的概率</li><li>M：根据概率，来改进每个分模型的均值方差和权重</li></ul><h4 id=som自组织映射神经网络>SOM：自组织映射神经网络<a hidden class=anchor aria-hidden=true href=#som自组织映射神经网络>#</a></h4><p>nah</p><p><strong>聚类算法的评估：</strong></p><p>轮廓系数；霍普金斯统计量；R方</p><h3 id=数据清洗>数据清洗<a hidden class=anchor aria-hidden=true href=#数据清洗>#</a></h3><p>没用到就不说了，在数据挖掘中主要是：缺失数据，错误数据，和噪声数据</p><p><strong>错误数据</strong>：分析更改删除和忽略</p><p><strong>缺失数据</strong>：忽略，手工，填充（全局常量，属性或者中位数，基于贝叶斯等等方法（这个不提））</p><p><strong>噪声数据</strong>：分箱（均值平滑，中值平滑，边界平滑），聚类，回归，人工检查</p><h3 id=图像增强策略>图像增强策略<a hidden class=anchor aria-hidden=true href=#图像增强策略>#</a></h3><p>torchvision.transformers的库里面有很多，还有unbalance_image中有一些经典的unbalance_image的一些策略</p><p>还有PIL中的Image.Enhance(这里可能要注意图像维度的转换)</p><p>1、对比度：白色画面(最亮时)下的亮度除以黑色画面(最暗时)下的亮度；</p><p>2、色彩饱和度：：彩度除以明度，指色彩的鲜艳程度，也称色彩的纯度；</p><p>3、色调：向负方向调节会显现红色，正方向调节则增加黄色。适合对肤色对象进行微调；</p><p>4、锐度：是反映图像平面清晰度和图像边缘锐利程度的一个指标。</p><p>MixUp的操作实际上就不要在赘述了，而Sharpen的操作实际上就是对分子分母都做一个1/T的乘方的这样一个锐化的操作，突出显著的样例，这样能够使得：？（需要加强记忆）</p><h3 id=评估模块>评估模块<a hidden class=anchor aria-hidden=true href=#评估模块>#</a></h3><h4 id=rocprf1>ROC、PR、F1<a hidden class=anchor aria-hidden=true href=#rocprf1>#</a></h4><p>PR曲线就比较清楚是根据Precision和recall区划分的，然后根据判定为正负样本的阈值去区分这个曲线的情况。</p><p>ROC曲线是根据 TPR和FPR真阳性率（正样本中有多少被判定为真）和伪阳性率（负样本中有多少被判定为真），依据score的阈值来绘制曲线</p><blockquote><p>AUC越大，说明分类器越可能把真正的正样本放在前面</p></blockquote><p>还有F1，是综合反应一个排序模型的性能(调和平均值)：</p><div>$$
F1 = \frac {2*precision * recall}{precision + recall}
$$</div><p>ROC比起PR来说，对于正负样本数据量的分布比较不敏感，所以在这种数据不均衡的大数据场景，ROC更合适，更广泛。如果是针对特定数据集上的表现的话实际上PR曲线的话能更直观的反应性能</p><h4 id=rmse>RMSE<a hidden class=anchor aria-hidden=true href=#rmse>#</a></h4><p>离群点可能导致效果一直很差，可以用归一化的百分比来看</p><h4 id=余弦相似度>余弦相似度<a hidden class=anchor aria-hidden=true href=#余弦相似度>#</a></h4><p>实际上就是将问题从距离转换到了角度上，用1-cos(A,B)表示余弦距离，实际上这种距离比起欧氏距离来说，能够适应更高的维度，比较相对差异的时候我们可以考虑用余弦相似度来衡量</p><p>不满足三角不等式：等腰直角三角形</p><p>在机器学习领域，还有kl距离，相对熵，也能衡量两个分布之间的距离，但是也不满足对称性和三角不等式</p><h3 id=训练集和测试集的划分机制>训练集和测试集的划分机制<a hidden class=anchor aria-hidden=true href=#训练集和测试集的划分机制>#</a></h3><ul><li><p>K次交叉验证法；</p><blockquote><p>首先描述一下什么是k次交叉验证，k次交叉验证的作用是：评估模型的预测性能，训练好的模型再新数据上的表现，在一定程度上减少过拟合，从有限数据中获取尽可能多的有效信息，使得模型对于数据的划分不那么敏感</p></blockquote></li><li><p>Handout检验：实际上就是7：3的随机划分的方式；其中还有留一划分的策略；</p></li><li><p>自助法（bootstrap）：有放回的随机抽样，总数为n的集合，抽样n次作为训练集，剩下的没有被抽样出来的数据作为测试集，这就是自助法的验证过程</p><ul><li>当抽样次数趋向于无穷的时候，有多少数据没有被选择过， $(1-\frac{1}{n})^n$ 取极限，根据重要极限 $(1+\frac{1}{n})^n$ 的极限是e，可以推得大概是1/e的概率没被选中，也就是大概百分之36%， （59页）</li></ul></li></ul><h2 id=语言部分>语言部分<a hidden class=anchor aria-hidden=true href=#语言部分>#</a></h2><h3 id=python部分>Python部分<a hidden class=anchor aria-hidden=true href=#python部分>#</a></h3><h4 id=深拷贝浅拷贝>深拷贝浅拷贝<a hidden class=anchor aria-hidden=true href=#深拷贝浅拷贝>#</a></h4><p>概念上是一致的，但是具体实现深拷贝上，是不一样的，python 应该是自带的.copy函数</p><p><a href=https://www.jianshu.com/p/a71c09798123 target=_blank rel=noopener>https://www.jianshu.com/p/a71c09798123</a>
)</p><h4 id=修饰符的作用>修饰符的作用<a hidden class=anchor aria-hidden=true href=#修饰符的作用>#</a></h4><p>修饰符的作用python函数修饰符@的作用是为现有函数增加额外的功能，常用于插入日志、性能测试、事务处理等等。</p><p>实际上就是讲函数作为作为输入参数，然后对函数进行包装，在执行函数之前或者之后增加一些操作，通常用来指示函数执行进程，也可以用来添加数据预处理等等</p><p><a href=https://www.cnblogs.com/gdjlc/p/11182441.html target=_blank rel=noopener>LINK REFERENCE</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>log</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;log开始 ...&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;log结束 ...&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>wrapper</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=nd>@log</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>test</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;test ..&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>test</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=多线程处理>多线程处理<a hidden class=anchor aria-hidden=true href=#多线程处理>#</a></h4><h5 id=一些基本的概念>一些基本的概念：<a hidden class=anchor aria-hidden=true href=#一些基本的概念>#</a></h5><blockquote><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</p><p>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。</p><ul><li>线程可以被抢占（中断）。</li><li>在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） &ndash; 这就是线程的退让。</li></ul></blockquote><h5 id=使用threading作为线程处理模块><strong>使用threading作为线程处理模块：</strong><a hidden class=anchor aria-hidden=true href=#使用threading作为线程处理模块>#</a></h5><p><code>run</code> <code>start</code> <code>join([timr])</code>：等待至线程终止；<code>isAlive()</code> <code>getName()</code> <code>setName()</code></p><p><code>append()</code>:添加到线程列表，使用for i in threads: i.join() 来等待所有线程完成。</p><ol><li>首先通过继承threading.thread创建子类，实现run操作；</li><li>实例化之后使用start启动进程；</li></ol><h5 id=线程同步lock>线程同步（Lock）<a hidden class=anchor aria-hidden=true href=#线程同步lock>#</a></h5><p><code>Lock</code>和<code>Rlock</code> 都有相应<code>acquire</code>和<code>release</code>，</p><p>防止多个线程同时对某个数据进行修改，就需要对多个线程进行同步；</p><h5 id=python-中多线程和多进程的区别>Python 中多线程和多进程的区别<a hidden class=anchor aria-hidden=true href=#python-中多线程和多进程的区别>#</a></h5><p>这一点还是需要补充，好像是使用什么来着</p><p>主要从进程和线程本身的区别来谈，然后Python中的多线程是收到了Cpython的GIL约束的，所以稍微有点鸡肋，可能还是要用多进程去了解</p><p>[参考链接](</p><h4 id=文件io部分>文件IO部分<a hidden class=anchor aria-hidden=true href=#文件io部分>#</a></h4><h5 id=文件处理>文件处理：<a hidden class=anchor aria-hidden=true href=#文件处理>#</a></h5><p>读取键盘输入：<code>a = input('请输入：')</code>；</p><p>打开和关闭文件：<code>open()</code>，一般需要按照指定的格式打开一个文件才能对其进行修改或者读取。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fo</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;foo.ext&#34;</span><span class=p>,</span><span class=s2>&#34;w&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fo</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># 相应的文件的读写实际上应该是</span>
</span></span><span class=line><span class=cl><span class=n>fo</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s2>&#34;dadsad&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>res</span> <span class=o>=</span> <span class=n>fo</span><span class=o>.</span><span class=n>read</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 使用tell 和seek输出和定位当前的文件位置，</span>
</span></span><span class=line><span class=cl><span class=c1># 实际上经常和with命令一起使用</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>path</span><span class=p>,</span><span class=s2>&#34;w&#34;</span><span class=p>,</span><span class=n>encoding</span><span class=o>=</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># record the dir name (depth=1) </span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>.</span><span class=n>writelines</span><span class=p>(</span><span class=n>authorres</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># record all the video</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>element</span> <span class=ow>in</span> <span class=n>result</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>element</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>补充说明： 这里<a href=http://www.coolpython.net/python_senior/senior_feature/with.html target=_blank rel=noopener>with语句的解析</a></p><h5 id=os命令>OS命令<a hidden class=anchor aria-hidden=true href=#os命令>#</a></h5><p>chmod，chdir，chown，mkdir，path（一系列常用操作，exist之类的），getcwd（返回当前工作区），listdir（返回文件夹包含的文件或者文件夹的列表）</p><h3 id=c部分>C++部分<a hidden class=anchor aria-hidden=true href=#c部分>#</a></h3><p>实际上c++对于编写的顺序是有上下关系的，如果我们定义的时候遇到了一些上面和下面的差别的时候，我们可以考虑在上面先进行declaration，在后面在具体的进行definition。</p><h4 id=文件操作>文件操作：<a hidden class=anchor aria-hidden=true href=#文件操作>#</a></h4><h5 id=基本读写>基本读写<a hidden class=anchor aria-hidden=true href=#基本读写>#</a></h5><p>写文件步骤如下：</p><ol><li><p>包含头文件 <code>#include &lt;fstream\></code></p></li><li><p>创建流对象 <code>ofstream ofs;</code></p></li><li><p>打开文件<code>ofs.open("文件路径",打开方式);</code></p></li><li><p>写数据<code>ofs &lt;&lt; "写入的数据"</code>;</p></li><li><p>关闭文件<code>ofs.close()</code>;</p></li></ol><p>读文件的操作步骤如下</p><ol><li><p>包含头文件 #include &lt;fstream></p></li><li><p>创建流对象 ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功 ifs.open(&ldquo;文件路径&rdquo;,打开方式);</p></li><li><p>读数据 四种方式读取</p></li><li><p>关闭文件 ifs.close();</p></li></ol><h5 id=处理二进制文件>处理二进制文件<a hidden class=anchor aria-hidden=true href=#处理二进制文件>#</a></h5><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream& write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>打开方式要指定为 ios::binary；</p><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream& read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><h4 id=预编译头>预编译头<a hidden class=anchor aria-hidden=true href=#预编译头>#</a></h4><p>首先介绍的是如何防止在重复的include&lt;head.h>的时候,不会导致重复的定义和include的方式，以及其中的区别</p><p>#pragma once：自定义包含了这种情况的时候，依赖于不会将同一个文件多次编译，这个方式<strong>没办法保证内容相同的不同名文件</strong>被重复的编译，针对的是文件。</p><p><code>#ifndef ：依赖于宏名称不能冲突，这个能保证内容相同的不同文件不小心被同时包含，实际上是一个预编译的条件语句</code></p><p>首先介绍一下写法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=err>基本的逻辑也就是当我们第一次执行的时候，就会预先定义到这一块，这样到时候就不会导致相应部分的代码被重复的执行或者定义</span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef _code_block
</span></span></span><span class=line><span class=cl><span class=cp>#define _code_block
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// code here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><p>在自己编写的时候需要注意不能重复使用宏名（<code>_code_block</code>），不然可能会出现以外的其他地方的代码没有被执行。</p><h4 id=多线程>多线程<a hidden class=anchor aria-hidden=true href=#多线程>#</a></h4><p>mutex互斥锁</p><h4 id=内存分区模型>内存分区模型<a hidden class=anchor aria-hidden=true href=#内存分区模型>#</a></h4><p>主要将内存分为四个区域:</p><ul><li><p>代码区：存放函数的二进制代码，由操作系统进行管理</p><blockquote><p>程序运行前进行分配</p><p>存放CPU执行的机器指令，具体而言代码区是共享的和只读的</p></blockquote></li><li><p>全局区：存放全局变量、静态变量和常量</p><blockquote><p>这部分空间应该是在预编译的时候事先分配的</p><p>该部分的数据再程序结束后由操作系统释放</p></blockquote></li><li><p>栈区：由编译器制动分配和释放，存放函数的参数值，局部变量等</p></li><li><p>堆区：由程序员分配和释放，如果程序员不释放，程序结束后由操作系统回收；</p></li></ul><p>（类内的存储特点）：</p><p>在c++中，类内的成员变量和成员函数分开存储，只有非静态的成员变量才属于类的对象上的存储。（函数也是不占对象空间的，所有的函数共享一个函数实例）</p><p>（static）静态成员函数在编译阶段分配内存，类内声明类外初始化，所有的对象共享同一份数据；</p><h4 id=类>类：<a hidden class=anchor aria-hidden=true href=#类>#</a></h4><h5 id=this指针>THIS指针<a hidden class=anchor aria-hidden=true href=#this指针>#</a></h5><p>指向的是，当前调用的这个 <strong>对象</strong>；</p><h5 id=友元friend>友元friend：<a hidden class=anchor aria-hidden=true href=#友元friend>#</a></h5><p>通过friend关键词告诉编译器其他的可以访问类中私有内容的东西；</p><p>友元可以是：</p><ul><li>函数</li><li>类</li><li>其他类别的成员函数</li></ul><h5 id=继承>继承<a hidden class=anchor aria-hidden=true href=#继承>#</a></h5><p><strong>构造函数顺序</strong></p><p>继承的时候首先调用父类的构造函数，在构造子类的构造函数，析构是反向的。</p><p><strong>几种继承方式</strong></p><p>注意区分继承方式面临的主体，也就是说：</p><ul><li>派生类能访问的元素实际上都是除了私有类都能访问</li><li>区别在于我们是否能通过派生类的实例对基类的变量进行访问，这里的继承方式就代表着这些变量在被继承之后的状态，是私有的保护的，还是公共的</li></ul><p><strong>父子的成员同名</strong></p><p>无论是不是静态，都是：</p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><h4 id=多态>多态<a hidden class=anchor aria-hidden=true href=#多态>#</a></h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><pre><code>3. 拥有纯虚析构函数的类也属于抽象类
</code></pre><h4 id=常用stl函数>常用STL函数<a hidden class=anchor aria-hidden=true href=#常用stl函数>#</a></h4><ul><li>for_each：遍历容器</li><li>transform：搬运容器中的数据到另一个容器中</li><li>accumulate：计算容器的元素综合</li><li>fill：向容器中添加元素</li><li>replace_if</li><li>find_if</li><li>set_union：求两个容器的并集</li><li>set_intersection：求两个容器的交集</li></ul><h3 id=通用部分>通用部分：<a hidden class=anchor aria-hidden=true href=#通用部分>#</a></h3><h4 id=深拷贝和浅拷贝的概念>深拷贝和浅拷贝的概念：<a hidden class=anchor aria-hidden=true href=#深拷贝和浅拷贝的概念>#</a></h4><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><h4 id=同步与异步>同步与异步<a hidden class=anchor aria-hidden=true href=#同步与异步>#</a></h4><p><div class=post-img-view><a data-fancybox=gallery href=https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210319155434936.png><img alt=image-20210319155434936 loading=lazy src=https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210319155434936.png class=responsive-image src=https://raw.githubusercontent.com/AikenH/md-image/master/img/image-20210319155434936.png style="display:block;margin:0 auto" alt=image-20210319155434936></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/2.5;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></p></div></div><script>function sanitizeContent(e){return e.replace(/[\x00-\x1F\x7F]/g,"").trim()}function encryptContent(e,t){const n=CryptoJS.MD5(e).toString(),s=n.substring(16),o=padContent(t),i=CryptoJS.AES.encrypt(o,CryptoJS.enc.Utf8.parse(n),{iv:CryptoJS.enc.Utf8.parse(s),mode:CryptoJS.mode.CBC,padding:CryptoJS.pad.Pkcs7});return CryptoJS.enc.Base64.stringify(i.ciphertext)}function padContent(e){const t=32,n=t-e.length%t;return e}function processEncryptedBlocks(){const t=document.querySelectorAll(".hugo-encryptor-cipher-text");t.forEach(e=>{const t=e.getAttribute("data-password"),n=e.innerHTML.trim(),s=sanitizeContent(n),o=encryptContent(t,s);e.innerHTML=o,e.removeAttribute("data-password")});const e=document.createElement("script");e.src="/js/decrypt.js",document.body.appendChild(e)}document.addEventListener("DOMContentLoaded",processEncryptedBlocks)</script></div><footer class=post-footer><ul class=post-tags><li><a href=https://aikenh.cn/hugotest/tags/job/>Job</a></li><li><a href=https://aikenh.cn/hugotest/tags/machine-learning/>Machine Learning</a></li></ul><nav class=paginav><a class=prev href=https://aikenh.cn/hugotest/posts/rl-c1/><span class=title>« Prev</span><br><span>RL Notebook 01</span>
</a><a class=next href=https://aikenh.cn/hugotest/posts/involution/><span class=title>Next »</span><br><span>Involution</span></a></nav></footer><div id=disqus_thread></div><script>function loadDisqus(){var e=document,t=e.createElement("script");t.src="https://aiken-hugo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t),window.disqus_config=function(){this.page.url=window.location.href,this.page.identifier=window.location.href.substring(18)}}var runningOnBrowser=typeof window!="undefined",isBot=runningOnBrowser&&!("onscroll"in window)||typeof navigator!="undefined"&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){if(!isBot&&supportsIntersectionObserver){var e=new IntersectionObserver(function(t){t[0].isIntersecting&&(loadDisqus(),e.disconnect())},{threshold:[0]});e.observe(document.getElementById("disqus_thread"))}else loadDisqus()},1)</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://aikenh.cn/hugotest/>aiken's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container>Visitors: <span id=busuanzi_value_site_uv></span>
Views: <span id=busuanzi_value_site_pv></span></span></footer><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("busuanzi_value_site_uv"),t=document.getElementById("busuanzi_value_site_pv"),o=13863,i=16993;if(!e||!t){console.error("Busuanzi elements not found.");return}const n=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+o;break}}),s=new MutationObserver(e=>{for(let t of e)if(t.type==="childList"){s.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML||0)+i;break}});n.observe(e,{childList:!0}),s.observe(t,{childList:!0})})</script><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))}),document.getElementById("theme-toggle-nav").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("/js/pangu.js",function(){pangu.spacingPage()})</script></body></html>